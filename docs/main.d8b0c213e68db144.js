(self.webpackChunkostoo = self.webpackChunkostoo || []).push([
  [179],
  {
    93: (Af, au, lu) => {
      "use strict";
      function di(n) {
        return "function" == typeof n;
      }
      function op(n) {
        const t = n((s) => {
          Error.call(s), (s.stack = new Error().stack);
        });
        return (
          (t.prototype = Object.create(Error.prototype)),
          (t.prototype.constructor = t),
          t
        );
      }
      const Pf = op(
        (n) =>
          function (t) {
            n(this),
              (this.message = t
                ? `${t.length} errors occurred during unsubscription:\n${t
                    .map((s, c) => `${c + 1}) ${s.toString()}`)
                    .join("\n  ")}`
                : ""),
              (this.name = "UnsubscriptionError"),
              (this.errors = t);
          }
      );
      function d(n, e) {
        if (n) {
          const t = n.indexOf(e);
          0 <= t && n.splice(t, 1);
        }
      }
      class Be {
        constructor(e) {
          (this.initialTeardown = e),
            (this.closed = !1),
            (this._parentage = null),
            (this._finalizers = null);
        }
        unsubscribe() {
          let e;
          if (!this.closed) {
            this.closed = !0;
            const { _parentage: t } = this;
            if (t)
              if (((this._parentage = null), Array.isArray(t)))
                for (const p of t) p.remove(this);
              else t.remove(this);
            const { initialTeardown: s } = this;
            if (di(s))
              try {
                s();
              } catch (p) {
                e = p instanceof Pf ? p.errors : [p];
              }
            const { _finalizers: c } = this;
            if (c) {
              this._finalizers = null;
              for (const p of c)
                try {
                  jt(p);
                } catch (y) {
                  (e = e ?? []),
                    y instanceof Pf ? (e = [...e, ...y.errors]) : e.push(y);
                }
            }
            if (e) throw new Pf(e);
          }
        }
        add(e) {
          var t;
          if (e && e !== this)
            if (this.closed) jt(e);
            else {
              if (e instanceof Be) {
                if (e.closed || e._hasParent(this)) return;
                e._addParent(this);
              }
              (this._finalizers =
                null !== (t = this._finalizers) && void 0 !== t ? t : []).push(
                e
              );
            }
        }
        _hasParent(e) {
          const { _parentage: t } = this;
          return t === e || (Array.isArray(t) && t.includes(e));
        }
        _addParent(e) {
          const { _parentage: t } = this;
          this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
        }
        _removeParent(e) {
          const { _parentage: t } = this;
          t === e ? (this._parentage = null) : Array.isArray(t) && d(t, e);
        }
        remove(e) {
          const { _finalizers: t } = this;
          t && d(t, e), e instanceof Be && e._removeParent(this);
        }
      }
      Be.EMPTY = (() => {
        const n = new Be();
        return (n.closed = !0), n;
      })();
      const Oo = Be.EMPTY;
      function eo(n) {
        return (
          n instanceof Be ||
          (n && "closed" in n && di(n.remove) && di(n.add) && di(n.unsubscribe))
        );
      }
      function jt(n) {
        di(n) ? n() : n.unsubscribe();
      }
      const zt = {
          onUnhandledError: null,
          onStoppedNotification: null,
          Promise: void 0,
          useDeprecatedSynchronousErrorHandling: !1,
          useDeprecatedNextContext: !1,
        },
        Mi = {
          setTimeout(n, e, ...t) {
            const { delegate: s } = Mi;
            return s?.setTimeout
              ? s.setTimeout(n, e, ...t)
              : setTimeout(n, e, ...t);
          },
          clearTimeout(n) {
            const { delegate: e } = Mi;
            return (e?.clearTimeout || clearTimeout)(n);
          },
          delegate: void 0,
        };
      function mr(n) {
        Mi.setTimeout(() => {
          const { onUnhandledError: e } = zt;
          if (!e) throw n;
          e(n);
        });
      }
      function Fo() {}
      const ns = Ur("C", void 0, void 0);
      function Ur(n, e, t) {
        return { kind: n, value: e, error: t };
      }
      let to = null;
      function Mr(n) {
        if (zt.useDeprecatedSynchronousErrorHandling) {
          const e = !to;
          if ((e && (to = { errorThrown: !1, error: null }), n(), e)) {
            const { errorThrown: t, error: s } = to;
            if (((to = null), t)) throw s;
          }
        } else n();
      }
      class is extends Be {
        constructor(e) {
          super(),
            (this.isStopped = !1),
            e
              ? ((this.destination = e), eo(e) && e.add(this))
              : (this.destination = cu);
        }
        static create(e, t, s) {
          return new Sa(e, t, s);
        }
        next(e) {
          this.isStopped
            ? sc(
                (function vl(n) {
                  return Ur("N", n, void 0);
                })(e),
                this
              )
            : this._next(e);
        }
        error(e) {
          this.isStopped
            ? sc(
                (function oc(n) {
                  return Ur("E", void 0, n);
                })(e),
                this
              )
            : ((this.isStopped = !0), this._error(e));
        }
        complete() {
          this.isStopped
            ? sc(ns, this)
            : ((this.isStopped = !0), this._complete());
        }
        unsubscribe() {
          this.closed ||
            ((this.isStopped = !0),
            super.unsubscribe(),
            (this.destination = null));
        }
        _next(e) {
          this.destination.next(e);
        }
        _error(e) {
          try {
            this.destination.error(e);
          } finally {
            this.unsubscribe();
          }
        }
        _complete() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }
      }
      const go = Function.prototype.bind;
      function nt(n, e) {
        return go.call(n, e);
      }
      class Dh {
        constructor(e) {
          this.partialObserver = e;
        }
        next(e) {
          const { partialObserver: t } = this;
          if (t.next)
            try {
              t.next(e);
            } catch (s) {
              Qt(s);
            }
        }
        error(e) {
          const { partialObserver: t } = this;
          if (t.error)
            try {
              t.error(e);
            } catch (s) {
              Qt(s);
            }
          else Qt(e);
        }
        complete() {
          const { partialObserver: e } = this;
          if (e.complete)
            try {
              e.complete();
            } catch (t) {
              Qt(t);
            }
        }
      }
      class Sa extends is {
        constructor(e, t, s) {
          let c;
          if ((super(), di(e) || !e))
            c = {
              next: e ?? void 0,
              error: t ?? void 0,
              complete: s ?? void 0,
            };
          else {
            let p;
            this && zt.useDeprecatedNextContext
              ? ((p = Object.create(e)),
                (p.unsubscribe = () => this.unsubscribe()),
                (c = {
                  next: e.next && nt(e.next, p),
                  error: e.error && nt(e.error, p),
                  complete: e.complete && nt(e.complete, p),
                }))
              : (c = e);
          }
          this.destination = new Dh(c);
        }
      }
      function Qt(n) {
        zt.useDeprecatedSynchronousErrorHandling
          ? (function Ca(n) {
              zt.useDeprecatedSynchronousErrorHandling &&
                to &&
                ((to.errorThrown = !0), (to.error = n));
            })(n)
          : mr(n);
      }
      function sc(n, e) {
        const { onStoppedNotification: t } = zt;
        t && Mi.setTimeout(() => t(n, e));
      }
      const cu = {
          closed: !0,
          next: Fo,
          error: function zi(n) {
            throw n;
          },
          complete: Fo,
        },
        Ia =
          ("function" == typeof Symbol && Symbol.observable) || "@@observable";
      function ac(n) {
        return n;
      }
      let Tn = (() => {
        class n {
          constructor(t) {
            t && (this._subscribe = t);
          }
          lift(t) {
            const s = new n();
            return (s.source = this), (s.operator = t), s;
          }
          subscribe(t, s, c) {
            const p = (function pi(n) {
              return (
                (n && n instanceof is) ||
                ((function Rs(n) {
                  return n && di(n.next) && di(n.error) && di(n.complete);
                })(n) &&
                  eo(n))
              );
            })(t)
              ? t
              : new Sa(t, s, c);
            return (
              Mr(() => {
                const { operator: y, source: w } = this;
                p.add(
                  y
                    ? y.call(p, w)
                    : w
                    ? this._subscribe(p)
                    : this._trySubscribe(p)
                );
              }),
              p
            );
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t);
            } catch (s) {
              t.error(s);
            }
          }
          forEach(t, s) {
            return new (s = Ai(s))((c, p) => {
              const y = new Sa({
                next: (w) => {
                  try {
                    t(w);
                  } catch (C) {
                    p(C), y.unsubscribe();
                  }
                },
                error: p,
                complete: c,
              });
              this.subscribe(y);
            });
          }
          _subscribe(t) {
            var s;
            return null === (s = this.source) || void 0 === s
              ? void 0
              : s.subscribe(t);
          }
          [Ia]() {
            return this;
          }
          pipe(...t) {
            return (function Ma(n) {
              return 0 === n.length
                ? ac
                : 1 === n.length
                ? n[0]
                : function (t) {
                    return n.reduce((s, c) => c(s), t);
                  };
            })(t)(this);
          }
          toPromise(t) {
            return new (t = Ai(t))((s, c) => {
              let p;
              this.subscribe(
                (y) => (p = y),
                (y) => c(y),
                () => s(p)
              );
            });
          }
        }
        return (n.create = (e) => new n(e)), n;
      })();
      function Ai(n) {
        var e;
        return null !== (e = n ?? zt.Promise) && void 0 !== e ? e : Promise;
      }
      const Os = op(
        (n) =>
          function () {
            n(this),
              (this.name = "ObjectUnsubscribedError"),
              (this.message = "object unsubscribed");
          }
      );
      let rs = (() => {
        class n extends Tn {
          constructor() {
            super(),
              (this.closed = !1),
              (this.currentObservers = null),
              (this.observers = []),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null);
          }
          lift(t) {
            const s = new os(this, this);
            return (s.operator = t), s;
          }
          _throwIfClosed() {
            if (this.closed) throw new Os();
          }
          next(t) {
            Mr(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.currentObservers ||
                  (this.currentObservers = Array.from(this.observers));
                for (const s of this.currentObservers) s.next(t);
              }
            });
          }
          error(t) {
            Mr(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                (this.hasError = this.isStopped = !0), (this.thrownError = t);
                const { observers: s } = this;
                for (; s.length; ) s.shift().error(t);
              }
            });
          }
          complete() {
            Mr(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.isStopped = !0;
                const { observers: t } = this;
                for (; t.length; ) t.shift().complete();
              }
            });
          }
          unsubscribe() {
            (this.isStopped = this.closed = !0),
              (this.observers = this.currentObservers = null);
          }
          get observed() {
            var t;
            return (
              (null === (t = this.observers) || void 0 === t
                ? void 0
                : t.length) > 0
            );
          }
          _trySubscribe(t) {
            return this._throwIfClosed(), super._trySubscribe(t);
          }
          _subscribe(t) {
            return (
              this._throwIfClosed(),
              this._checkFinalizedStatuses(t),
              this._innerSubscribe(t)
            );
          }
          _innerSubscribe(t) {
            const { hasError: s, isStopped: c, observers: p } = this;
            return s || c
              ? Oo
              : ((this.currentObservers = null),
                p.push(t),
                new Be(() => {
                  (this.currentObservers = null), d(p, t);
                }));
          }
          _checkFinalizedStatuses(t) {
            const { hasError: s, thrownError: c, isStopped: p } = this;
            s ? t.error(c) : p && t.complete();
          }
          asObservable() {
            const t = new Tn();
            return (t.source = this), t;
          }
        }
        return (n.create = (e, t) => new os(e, t)), n;
      })();
      class os extends rs {
        constructor(e, t) {
          super(), (this.destination = e), (this.source = t);
        }
        next(e) {
          var t, s;
          null ===
            (s =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.next) ||
            void 0 === s ||
            s.call(t, e);
        }
        error(e) {
          var t, s;
          null ===
            (s =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.error) ||
            void 0 === s ||
            s.call(t, e);
        }
        complete() {
          var e, t;
          null ===
            (t =
              null === (e = this.destination) || void 0 === e
                ? void 0
                : e.complete) ||
            void 0 === t ||
            t.call(e);
        }
        _subscribe(e) {
          var t, s;
          return null !==
            (s =
              null === (t = this.source) || void 0 === t
                ? void 0
                : t.subscribe(e)) && void 0 !== s
            ? s
            : Oo;
        }
      }
      function Fs(n) {
        return (e) => {
          if (
            (function ss(n) {
              return di(n?.lift);
            })(e)
          )
            return e.lift(function (t) {
              try {
                return n(t, this);
              } catch (s) {
                this.error(s);
              }
            });
          throw new TypeError("Unable to lift unknown Observable type");
        };
      }
      function No(n, e, t, s, c) {
        return new xl(n, e, t, s, c);
      }
      class xl extends is {
        constructor(e, t, s, c, p, y) {
          super(e),
            (this.onFinalize = p),
            (this.shouldUnsubscribe = y),
            (this._next = t
              ? function (w) {
                  try {
                    t(w);
                  } catch (C) {
                    e.error(C);
                  }
                }
              : super._next),
            (this._error = c
              ? function (w) {
                  try {
                    c(w);
                  } catch (C) {
                    e.error(C);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._error),
            (this._complete = s
              ? function () {
                  try {
                    s();
                  } catch (w) {
                    e.error(w);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._complete);
        }
        unsubscribe() {
          var e;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            const { closed: t } = this;
            super.unsubscribe(),
              !t &&
                (null === (e = this.onFinalize) ||
                  void 0 === e ||
                  e.call(this));
          }
        }
      }
      function ro(n) {
        return this instanceof ro ? ((this.v = n), this) : new ro(n);
      }
      function Bs(n, e, t) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var c,
          s = t.apply(n, e || []),
          p = [];
        return (
          (c = {}),
          y("next"),
          y("throw"),
          y("return"),
          (c[Symbol.asyncIterator] = function () {
            return this;
          }),
          c
        );
        function y(Q) {
          s[Q] &&
            (c[Q] = function (ie) {
              return new Promise(function (pe, Ee) {
                p.push([Q, ie, pe, Ee]) > 1 || w(Q, ie);
              });
            });
        }
        function w(Q, ie) {
          try {
            !(function C(Q) {
              Q.value instanceof ro
                ? Promise.resolve(Q.value.v).then(P, N)
                : j(p[0][2], Q);
            })(s[Q](ie));
          } catch (pe) {
            j(p[0][3], pe);
          }
        }
        function P(Q) {
          w("next", Q);
        }
        function N(Q) {
          w("throw", Q);
        }
        function j(Q, ie) {
          Q(ie), p.shift(), p.length && w(p[0][0], p[0][1]);
        }
      }
      function js(n) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t,
          e = n[Symbol.asyncIterator];
        return e
          ? e.call(n)
          : ((n = (function Ar(n) {
              var e = "function" == typeof Symbol && Symbol.iterator,
                t = e && n[e],
                s = 0;
              if (t) return t.call(n);
              if (n && "number" == typeof n.length)
                return {
                  next: function () {
                    return (
                      n && s >= n.length && (n = void 0),
                      { value: n && n[s++], done: !n }
                    );
                  },
                };
              throw new TypeError(
                e
                  ? "Object is not iterable."
                  : "Symbol.iterator is not defined."
              );
            })(n)),
            (t = {}),
            s("next"),
            s("throw"),
            s("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function s(p) {
          t[p] =
            n[p] &&
            function (y) {
              return new Promise(function (w, C) {
                !(function c(p, y, w, C) {
                  Promise.resolve(C).then(function (P) {
                    p({ value: P, done: w });
                  }, y);
                })(w, C, (y = n[p](y)).done, y.value);
              });
            };
        }
      }
      const me = (n) =>
        n && "number" == typeof n.length && "function" != typeof n;
      function ve(n) {
        return di(n?.then);
      }
      function ye(n) {
        return di(n[Ia]);
      }
      function fe(n) {
        return Symbol.asyncIterator && di(n?.[Symbol.asyncIterator]);
      }
      function Ce(n) {
        return new TypeError(
          `You provided ${
            null !== n && "object" == typeof n ? "an invalid object" : `'${n}'`
          } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`
        );
      }
      const et = (function Qe() {
        return "function" == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : "@@iterator";
      })();
      function We(n) {
        return di(n?.[et]);
      }
      function Rt(n) {
        return Bs(this, arguments, function* () {
          const t = n.getReader();
          try {
            for (;;) {
              const { value: s, done: c } = yield ro(t.read());
              if (c) return yield ro(void 0);
              yield yield ro(s);
            }
          } finally {
            t.releaseLock();
          }
        });
      }
      function Ut(n) {
        return di(n?.getReader);
      }
      function Ct(n) {
        if (n instanceof Tn) return n;
        if (null != n) {
          if (ye(n))
            return (function Zt(n) {
              return new Tn((e) => {
                const t = n[Ia]();
                if (di(t.subscribe)) return t.subscribe(e);
                throw new TypeError(
                  "Provided object does not correctly implement Symbol.observable"
                );
              });
            })(n);
          if (me(n))
            return (function on(n) {
              return new Tn((e) => {
                for (let t = 0; t < n.length && !e.closed; t++) e.next(n[t]);
                e.complete();
              });
            })(n);
          if (ve(n))
            return (function Zn(n) {
              return new Tn((e) => {
                n.then(
                  (t) => {
                    e.closed || (e.next(t), e.complete());
                  },
                  (t) => e.error(t)
                ).then(null, mr);
              });
            })(n);
          if (fe(n)) return Ki(n);
          if (We(n))
            return (function fi(n) {
              return new Tn((e) => {
                for (const t of n) if ((e.next(t), e.closed)) return;
                e.complete();
              });
            })(n);
          if (Ut(n))
            return (function Di(n) {
              return Ki(Rt(n));
            })(n);
        }
        throw Ce(n);
      }
      function Ki(n) {
        return new Tn((e) => {
          (function zo(n, e) {
            var t, s, c, p;
            return (function as(n, e, t, s) {
              return new (t || (t = Promise))(function (p, y) {
                function w(N) {
                  try {
                    P(s.next(N));
                  } catch (j) {
                    y(j);
                  }
                }
                function C(N) {
                  try {
                    P(s.throw(N));
                  } catch (j) {
                    y(j);
                  }
                }
                function P(N) {
                  N.done
                    ? p(N.value)
                    : (function c(p) {
                        return p instanceof t
                          ? p
                          : new t(function (y) {
                              y(p);
                            });
                      })(N.value).then(w, C);
                }
                P((s = s.apply(n, e || [])).next());
              });
            })(this, void 0, void 0, function* () {
              try {
                for (t = js(n); !(s = yield t.next()).done; )
                  if ((e.next(s.value), e.closed)) return;
              } catch (y) {
                c = { error: y };
              } finally {
                try {
                  s && !s.done && (p = t.return) && (yield p.call(t));
                } finally {
                  if (c) throw c.error;
                }
              }
              e.complete();
            });
          })(n, e).catch((t) => e.error(t));
        });
      }
      function Xn(n, e, t, s = 0, c = !1) {
        const p = e.schedule(function () {
          t(), c ? n.add(this.schedule(null, s)) : this.unsubscribe();
        }, s);
        if ((n.add(p), !c)) return p;
      }
      function ka(n, e, t = 1 / 0) {
        return di(e)
          ? ka(
              (s, c) =>
                (function rn(n, e) {
                  return Fs((t, s) => {
                    let c = 0;
                    t.subscribe(
                      No(s, (p) => {
                        s.next(n.call(e, p, c++));
                      })
                    );
                  });
                })((p, y) => e(s, p, c, y))(Ct(n(s, c))),
              t
            )
          : ("number" == typeof e && (t = e),
            Fs((s, c) =>
              (function gr(n, e, t, s, c, p, y, w) {
                const C = [];
                let P = 0,
                  N = 0,
                  j = !1;
                const Q = () => {
                    j && !C.length && !P && e.complete();
                  },
                  ie = (Ee) => (P < s ? pe(Ee) : C.push(Ee)),
                  pe = (Ee) => {
                    p && e.next(Ee), P++;
                    let Oe = !1;
                    Ct(t(Ee, N++)).subscribe(
                      No(
                        e,
                        (Ue) => {
                          c?.(Ue), p ? ie(Ue) : e.next(Ue);
                        },
                        () => {
                          Oe = !0;
                        },
                        void 0,
                        () => {
                          if (Oe)
                            try {
                              for (P--; C.length && P < s; ) {
                                const Ue = C.shift();
                                y ? Xn(e, y, () => pe(Ue)) : pe(Ue);
                              }
                              Q();
                            } catch (Ue) {
                              e.error(Ue);
                            }
                        }
                      )
                    );
                  };
                return (
                  n.subscribe(
                    No(e, ie, () => {
                      (j = !0), Q();
                    })
                  ),
                  () => {
                    w?.();
                  }
                );
              })(s, c, n, t)
            ));
      }
      const Ch = new Tn((n) => n.complete());
      function dc(n) {
        return n[n.length - 1];
      }
      function fu(n, e = 0) {
        return Fs((t, s) => {
          t.subscribe(
            No(
              s,
              (c) => Xn(s, n, () => s.next(c), e),
              () => Xn(s, n, () => s.complete(), e),
              (c) => Xn(s, n, () => s.error(c), e)
            )
          );
        });
      }
      function mu(n, e = 0) {
        return Fs((t, s) => {
          s.add(n.schedule(() => t.subscribe(s), e));
        });
      }
      function Vo(n, e) {
        if (!n) throw new Error("Iterable cannot be null");
        return new Tn((t) => {
          Xn(t, e, () => {
            const s = n[Symbol.asyncIterator]();
            Xn(
              t,
              e,
              () => {
                s.next().then((c) => {
                  c.done ? t.complete() : t.next(c.value);
                });
              },
              0,
              !0
            );
          });
        });
      }
      function jo(...n) {
        const e = (function Bo(n) {
            return (function hc(n) {
              return n && di(n.schedule);
            })(dc(n))
              ? n.pop()
              : void 0;
          })(n),
          t = (function cs(n, e) {
            return "number" == typeof dc(n) ? n.pop() : e;
          })(n, 1 / 0),
          s = n;
        return s.length
          ? 1 === s.length
            ? Ct(s[0])
            : (function Lf(n = 1 / 0) {
                return ka(ac, n);
              })(t)(
                (function sp(n, e) {
                  return e
                    ? (function Bi(n, e) {
                        if (null != n) {
                          if (ye(n))
                            return (function Ra(n, e) {
                              return Ct(n).pipe(mu(e), fu(e));
                            })(n, e);
                          if (me(n))
                            return (function pc(n, e) {
                              return new Tn((t) => {
                                let s = 0;
                                return e.schedule(function () {
                                  s === n.length
                                    ? t.complete()
                                    : (t.next(n[s++]),
                                      t.closed || this.schedule());
                                });
                              });
                            })(n, e);
                          if (ve(n))
                            return (function us(n, e) {
                              return Ct(n).pipe(mu(e), fu(e));
                            })(n, e);
                          if (fe(n)) return Vo(n, e);
                          if (We(n))
                            return (function Ae(n, e) {
                              return new Tn((t) => {
                                let s;
                                return (
                                  Xn(t, e, () => {
                                    (s = n[et]()),
                                      Xn(
                                        t,
                                        e,
                                        () => {
                                          let c, p;
                                          try {
                                            ({ value: c, done: p } = s.next());
                                          } catch (y) {
                                            return void t.error(y);
                                          }
                                          p ? t.complete() : t.next(c);
                                        },
                                        0,
                                        !0
                                      );
                                  }),
                                  () => di(s?.return) && s.return()
                                );
                              });
                            })(n, e);
                          if (Ut(n))
                            return (function mi(n, e) {
                              return Vo(Rt(n), e);
                            })(n, e);
                        }
                        throw Ce(n);
                      })(n, e)
                    : Ct(n);
                })(s, e)
              )
          : Ch;
      }
      function gu(n, e, ...t) {
        if (!0 === e) return void n();
        if (!1 === e) return;
        const s = new Sa({
          next: () => {
            s.unsubscribe(), n();
          },
        });
        return e(...t).subscribe(s);
      }
      function Dn(n) {
        for (let e in n) if (n[e] === Dn) return e;
        throw Error("Could not find renamed property on target object.");
      }
      function xt(n) {
        if ("string" == typeof n) return n;
        if (Array.isArray(n)) return "[" + n.map(xt).join(", ") + "]";
        if (null == n) return "" + n;
        if (n.overriddenName) return `${n.overriddenName}`;
        if (n.name) return `${n.name}`;
        const e = n.toString();
        if (null == e) return "" + e;
        const t = e.indexOf("\n");
        return -1 === t ? e : e.substring(0, t);
      }
      function $t(n, e) {
        return null == n || "" === n
          ? null === e
            ? ""
            : e
          : null == e || "" === e
          ? n
          : n + " " + e;
      }
      const Hr = Dn({ __forward_ref__: Dn });
      function Pr(n) {
        return (
          (n.__forward_ref__ = Pr),
          (n.toString = function () {
            return xt(this());
          }),
          n
        );
      }
      function it(n) {
        return (function _r(n) {
          return (
            "function" == typeof n &&
            n.hasOwnProperty(Hr) &&
            n.__forward_ref__ === Pr
          );
        })(n)
          ? n()
          : n;
      }
      class st extends Error {
        constructor(e, t) {
          super(
            (function yr(n, e) {
              return `NG0${Math.abs(n)}${e ? ": " + e.trim() : ""}`;
            })(e, t)
          ),
            (this.code = e);
        }
      }
      function gt(n) {
        return "string" == typeof n ? n : null == n ? "" : String(n);
      }
      function Dl(n, e) {
        throw new st(-201, !1);
      }
      function pn(n, e) {
        null == n &&
          (function gn(n, e, t, s) {
            throw new Error(
              `ASSERTION ERROR: ${n}` +
                (null == s ? "" : ` [Expected=> ${t} ${s} ${e} <=Actual]`)
            );
          })(e, n, null, "!=");
      }
      function Mn(n) {
        return {
          token: n.token,
          providedIn: n.providedIn || null,
          factory: n.factory,
          value: void 0,
        };
      }
      function ii(n) {
        return { providers: n.providers || [], imports: n.imports || [] };
      }
      function yo(n) {
        return dp(n, Il) || dp(n, Uo);
      }
      function dp(n, e) {
        return n.hasOwnProperty(e) ? n[e] : null;
      }
      function vo(n) {
        return n && (n.hasOwnProperty(ds) || n.hasOwnProperty(gc))
          ? n[ds]
          : null;
      }
      const Il = Dn({ ɵprov: Dn }),
        ds = Dn({ ɵinj: Dn }),
        Uo = Dn({ ngInjectableDef: Dn }),
        gc = Dn({ ngInjectorDef: Dn });
      var St = (() => (
        ((St = St || {})[(St.Default = 0)] = "Default"),
        (St[(St.Host = 1)] = "Host"),
        (St[(St.Self = 2)] = "Self"),
        (St[(St.SkipSelf = 4)] = "SkipSelf"),
        (St[(St.Optional = 8)] = "Optional"),
        St
      ))();
      let Ml;
      function sr(n) {
        const e = Ml;
        return (Ml = n), e;
      }
      function kh(n, e, t) {
        const s = yo(n);
        return s && "root" == s.providedIn
          ? void 0 === s.value
            ? (s.value = s.factory())
            : s.value
          : t & St.Optional
          ? null
          : void 0 !== e
          ? e
          : void Dl(xt(n));
      }
      function $o(n) {
        return { toString: n }.toString();
      }
      var qr = (() => (
          ((qr = qr || {})[(qr.OnPush = 0)] = "OnPush"),
          (qr[(qr.Default = 1)] = "Default"),
          qr
        ))(),
        xo = (() => {
          return (
            ((n = xo || (xo = {}))[(n.Emulated = 0)] = "Emulated"),
            (n[(n.None = 2)] = "None"),
            (n[(n.ShadowDom = 3)] = "ShadowDom"),
            xo
          );
          var n;
        })();
      const $n = (() =>
          (typeof globalThis < "u" && globalThis) ||
          (typeof global < "u" && global) ||
          (typeof window < "u" && window) ||
          (typeof self < "u" &&
            typeof WorkerGlobalScope < "u" &&
            self instanceof WorkerGlobalScope &&
            self))(),
        Oa = {},
        wn = [],
        ps = Dn({ ɵcmp: Dn }),
        Pl = Dn({ ɵdir: Dn }),
        Us = Dn({ ɵpipe: Dn }),
        Ho = Dn({ ɵmod: Dn }),
        vr = Dn({ ɵfac: Dn }),
        $s = Dn({ __NG_ELEMENT_ID__: Dn });
      let fp = 0;
      function Yi(n) {
        return $o(() => {
          const t = !0 === n.standalone,
            s = {},
            c = {
              type: n.type,
              providersResolver: null,
              decls: n.decls,
              vars: n.vars,
              factory: null,
              template: n.template || null,
              consts: n.consts || null,
              ngContentSelectors: n.ngContentSelectors,
              hostBindings: n.hostBindings || null,
              hostVars: n.hostVars || 0,
              hostAttrs: n.hostAttrs || null,
              contentQueries: n.contentQueries || null,
              declaredInputs: s,
              inputs: null,
              outputs: null,
              exportAs: n.exportAs || null,
              onPush: n.changeDetection === qr.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              standalone: t,
              dependencies: (t && n.dependencies) || null,
              getStandaloneInjector: null,
              selectors: n.selectors || wn,
              viewQuery: n.viewQuery || null,
              features: n.features || null,
              data: n.data || {},
              encapsulation: n.encapsulation || xo.Emulated,
              id: "c" + fp++,
              styles: n.styles || wn,
              _: null,
              setInput: null,
              schemas: n.schemas || null,
              tView: null,
            },
            p = n.dependencies,
            y = n.features;
          return (
            (c.inputs = ln(n.inputs, s)),
            (c.outputs = ln(n.outputs)),
            y && y.forEach((w) => w(c)),
            (c.directiveDefs = p
              ? () => ("function" == typeof p ? p() : p).map(bu).filter(yc)
              : null),
            (c.pipeDefs = p
              ? () => ("function" == typeof p ? p() : p).map(_i).filter(yc)
              : null),
            c
          );
        });
      }
      function bu(n) {
        return An(n) || lr(n);
      }
      function yc(n) {
        return null !== n;
      }
      function ar(n) {
        return $o(() => ({
          type: n.type,
          bootstrap: n.bootstrap || wn,
          declarations: n.declarations || wn,
          imports: n.imports || wn,
          exports: n.exports || wn,
          transitiveCompileScopes: null,
          schemas: n.schemas || null,
          id: n.id || null,
        }));
      }
      function ln(n, e) {
        if (null == n) return Oa;
        const t = {};
        for (const s in n)
          if (n.hasOwnProperty(s)) {
            let c = n[s],
              p = c;
            Array.isArray(c) && ((p = c[1]), (c = c[0])),
              (t[c] = s),
              e && (e[c] = p);
          }
        return t;
      }
      const Pi = Yi;
      function An(n) {
        return n[ps] || null;
      }
      function lr(n) {
        return n[Pl] || null;
      }
      function _i(n) {
        return n[Us] || null;
      }
      function wr(n) {
        return Array.isArray(n) && "object" == typeof n[1];
      }
      function cr(n) {
        return Array.isArray(n) && !0 === n[1];
      }
      function zh(n) {
        return 0 != (8 & n.flags);
      }
      function Tu(n) {
        return 2 == (2 & n.flags);
      }
      function Du(n) {
        return 1 == (1 & n.flags);
      }
      function wo(n) {
        return null !== n.template;
      }
      function Rf(n) {
        return 0 != (256 & n[2]);
      }
      function Ys(n, e) {
        return n.hasOwnProperty(vr) ? n[vr] : null;
      }
      class Mu {
        constructor(e, t, s) {
          (this.previousValue = e),
            (this.currentValue = t),
            (this.firstChange = s);
        }
        isFirstChange() {
          return this.firstChange;
        }
      }
      function Zo() {
        return Ba;
      }
      function Ba(n) {
        return n.type.prototype.ngOnChanges && (n.setInput = Ec), $h;
      }
      function $h() {
        const n = Tc(this),
          e = n?.current;
        if (e) {
          const t = n.previous;
          if (t === Oa) n.previous = e;
          else for (let s in e) t[s] = e[s];
          (n.current = null), this.ngOnChanges(e);
        }
      }
      function Ec(n, e, t, s) {
        const c =
            Tc(n) ||
            (function Au(n, e) {
              return (n[Fl] = e);
            })(n, { previous: Oa, current: null }),
          p = c.current || (c.current = {}),
          y = c.previous,
          w = this.declaredInputs[t],
          C = y[w];
        (p[w] = new Mu(C && C.currentValue, e, y === Oa)), (n[s] = e);
      }
      Zo.ngInherit = !0;
      const Fl = "__ngSimpleChanges__";
      function Tc(n) {
        return n[Fl] || null;
      }
      function oi(n) {
        for (; Array.isArray(n); ) n = n[0];
        return n;
      }
      function ja(n, e) {
        return oi(e[n]);
      }
      function ji(n, e) {
        return oi(e[n.index]);
      }
      function qh(n, e) {
        return n.data[e];
      }
      function Ui(n, e) {
        const t = e[n];
        return wr(t) ? t : t[0];
      }
      function Nl(n) {
        return 64 == (64 & n[2]);
      }
      function Do(n, e) {
        return null == e ? null : n[e];
      }
      function zl(n) {
        n[18] = 0;
      }
      function $a(n, e) {
        n[5] += e;
        let t = n,
          s = n[3];
        for (
          ;
          null !== s && ((1 === e && 1 === t[5]) || (-1 === e && 0 === t[5]));

        )
          (s[5] += e), (t = s), (s = s[3]);
      }
      const Bt = { lFrame: Nu(null), bindingsEnabled: !0 };
      function Kh() {
        return Bt.bindingsEnabled;
      }
      function Ze() {
        return Bt.lFrame.lView;
      }
      function mn() {
        return Bt.lFrame.tView;
      }
      function Ha(n) {
        return (Bt.lFrame.contextLView = n), n[8];
      }
      function yi(n) {
        return (Bt.lFrame.contextLView = null), n;
      }
      function ki() {
        let n = Yh();
        for (; null !== n && 64 === n.type; ) n = n.parent;
        return n;
      }
      function Yh() {
        return Bt.lFrame.currentTNode;
      }
      function Xo(n, e) {
        const t = Bt.lFrame;
        (t.currentTNode = n), (t.isParent = e);
      }
      function Or() {
        return Bt.lFrame.isParent;
      }
      function Lu() {
        Bt.lFrame.isParent = !1;
      }
      function $i() {
        const n = Bt.lFrame;
        let e = n.bindingRootIndex;
        return (
          -1 === e && (e = n.bindingRootIndex = n.tView.bindingStartIndex), e
        );
      }
      function ea() {
        return Bt.lFrame.bindingIndex++;
      }
      function Qh(n, e) {
        const t = Bt.lFrame;
        (t.bindingIndex = t.bindingRootIndex = n), Ru(e);
      }
      function Ru(n) {
        Bt.lFrame.currentDirectiveIndex = n;
      }
      function Jh() {
        return Bt.lFrame.currentQueryIndex;
      }
      function Ou(n) {
        Bt.lFrame.currentQueryIndex = n;
      }
      function Hf(n) {
        const e = n[1];
        return 2 === e.type ? e.declTNode : 1 === e.type ? n[6] : null;
      }
      function xp(n, e, t) {
        if (t & St.SkipSelf) {
          let c = e,
            p = n;
          for (
            ;
            !((c = c.parent),
            null !== c ||
              t & St.Host ||
              ((c = Hf(p)), null === c || ((p = p[15]), 10 & c.type)));

          );
          if (null === c) return !1;
          (e = c), (n = p);
        }
        const s = (Bt.lFrame = Fu());
        return (s.currentTNode = e), (s.lView = n), !0;
      }
      function Mc(n) {
        const e = Fu(),
          t = n[1];
        (Bt.lFrame = e),
          (e.currentTNode = t.firstChild),
          (e.lView = n),
          (e.tView = t),
          (e.contextLView = n),
          (e.bindingIndex = t.bindingStartIndex),
          (e.inI18n = !1);
      }
      function Fu() {
        const n = Bt.lFrame,
          e = null === n ? null : n.child;
        return null === e ? Nu(n) : e;
      }
      function Nu(n) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: n,
          child: null,
          inI18n: !1,
        };
        return null !== n && (n.child = e), e;
      }
      function qa() {
        const n = Bt.lFrame;
        return (
          (Bt.lFrame = n.parent), (n.currentTNode = null), (n.lView = null), n
        );
      }
      const f = qa;
      function a() {
        const n = qa();
        (n.isParent = !0),
          (n.tView = null),
          (n.selectedIndex = -1),
          (n.contextLView = null),
          (n.elementDepthCount = 0),
          (n.currentDirectiveIndex = -1),
          (n.currentNamespace = null),
          (n.bindingRootIndex = -1),
          (n.bindingIndex = -1),
          (n.currentQueryIndex = 0);
      }
      function v() {
        return Bt.lFrame.selectedIndex;
      }
      function b(n) {
        Bt.lFrame.selectedIndex = n;
      }
      function D() {
        const n = Bt.lFrame;
        return qh(n.tView, n.selectedIndex);
      }
      function q(n, e) {
        for (let t = e.directiveStart, s = e.directiveEnd; t < s; t++) {
          const p = n.data[t].type.prototype,
            {
              ngAfterContentInit: y,
              ngAfterContentChecked: w,
              ngAfterViewInit: C,
              ngAfterViewChecked: P,
              ngOnDestroy: N,
            } = p;
          y && (n.contentHooks || (n.contentHooks = [])).push(-t, y),
            w &&
              ((n.contentHooks || (n.contentHooks = [])).push(t, w),
              (n.contentCheckHooks || (n.contentCheckHooks = [])).push(t, w)),
            C && (n.viewHooks || (n.viewHooks = [])).push(-t, C),
            P &&
              ((n.viewHooks || (n.viewHooks = [])).push(t, P),
              (n.viewCheckHooks || (n.viewCheckHooks = [])).push(t, P)),
            null != N && (n.destroyHooks || (n.destroyHooks = [])).push(t, N);
        }
      }
      function X(n, e, t) {
        B(n, e, 3, t);
      }
      function Z(n, e, t, s) {
        (3 & n[2]) === t && B(n, e, t, s);
      }
      function Y(n, e) {
        let t = n[2];
        (3 & t) === e && ((t &= 2047), (t += 1), (n[2] = t));
      }
      function B(n, e, t, s) {
        const p = s ?? -1,
          y = e.length - 1;
        let w = 0;
        for (let C = void 0 !== s ? 65535 & n[18] : 0; C < y; C++)
          if ("number" == typeof e[C + 1]) {
            if (((w = e[C]), null != s && w >= s)) break;
          } else
            e[C] < 0 && (n[18] += 65536),
              (w < p || -1 == p) &&
                (W(n, t, e, C), (n[18] = (4294901760 & n[18]) + C + 2)),
              C++;
      }
      function W(n, e, t, s) {
        const c = t[s] < 0,
          p = t[s + 1],
          w = n[c ? -t[s] : t[s]];
        if (c) {
          if (n[2] >> 11 < n[18] >> 16 && (3 & n[2]) === e) {
            n[2] += 2048;
            try {
              p.call(w);
            } finally {
            }
          }
        } else
          try {
            p.call(w);
          } finally {
          }
      }
      class te {
        constructor(e, t, s) {
          (this.factory = e),
            (this.resolving = !1),
            (this.canSeeViewProviders = t),
            (this.injectImpl = s);
        }
      }
      function Le(n, e, t) {
        let s = 0;
        for (; s < t.length; ) {
          const c = t[s];
          if ("number" == typeof c) {
            if (0 !== c) break;
            s++;
            const p = t[s++],
              y = t[s++],
              w = t[s++];
            n.setAttribute(e, y, w, p);
          } else {
            const p = c,
              y = t[++s];
            je(p) ? n.setProperty(e, p, y) : n.setAttribute(e, p, y), s++;
          }
        }
        return s;
      }
      function Se(n) {
        return 3 === n || 4 === n || 6 === n;
      }
      function je(n) {
        return 64 === n.charCodeAt(0);
      }
      function we(n, e) {
        if (null !== e && 0 !== e.length)
          if (null === n || 0 === n.length) n = e.slice();
          else {
            let t = -1;
            for (let s = 0; s < e.length; s++) {
              const c = e[s];
              "number" == typeof c
                ? (t = c)
                : 0 === t ||
                  ke(n, t, c, null, -1 === t || 2 === t ? e[++s] : null);
            }
          }
        return n;
      }
      function ke(n, e, t, s, c) {
        let p = 0,
          y = n.length;
        if (-1 === e) y = -1;
        else
          for (; p < n.length; ) {
            const w = n[p++];
            if ("number" == typeof w) {
              if (w === e) {
                y = -1;
                break;
              }
              if (w > e) {
                y = p - 1;
                break;
              }
            }
          }
        for (; p < n.length; ) {
          const w = n[p];
          if ("number" == typeof w) break;
          if (w === t) {
            if (null === s) return void (null !== c && (n[p + 1] = c));
            if (s === n[p + 1]) return void (n[p + 2] = c);
          }
          p++, null !== s && p++, null !== c && p++;
        }
        -1 !== y && (n.splice(y, 0, e), (p = y + 1)),
          n.splice(p++, 0, t),
          null !== s && n.splice(p++, 0, s),
          null !== c && n.splice(p++, 0, c);
      }
      function He(n) {
        return -1 !== n;
      }
      function Ne(n) {
        return 32767 & n;
      }
      function mt(n, e) {
        let t = (function Xe(n) {
            return n >> 16;
          })(n),
          s = e;
        for (; t > 0; ) (s = s[15]), t--;
        return s;
      }
      let It = !0;
      function dt(n) {
        const e = It;
        return (It = n), e;
      }
      let _t = 0;
      const en = {};
      function _n(n, e) {
        const t = Hi(n, e);
        if (-1 !== t) return t;
        const s = e[1];
        s.firstCreatePass &&
          ((n.injectorIndex = e.length),
          Sn(s.data, n),
          Sn(e, null),
          Sn(s.blueprint, null));
        const c = vi(n, e),
          p = n.injectorIndex;
        if (He(c)) {
          const y = Ne(c),
            w = mt(c, e),
            C = w[1].data;
          for (let P = 0; P < 8; P++) e[p + P] = w[y + P] | C[y + P];
        }
        return (e[p + 8] = c), p;
      }
      function Sn(n, e) {
        n.push(0, 0, 0, 0, 0, 0, 0, 0, e);
      }
      function Hi(n, e) {
        return -1 === n.injectorIndex ||
          (n.parent && n.parent.injectorIndex === n.injectorIndex) ||
          null === e[n.injectorIndex + 8]
          ? -1
          : n.injectorIndex;
      }
      function vi(n, e) {
        if (n.parent && -1 !== n.parent.injectorIndex)
          return n.parent.injectorIndex;
        let t = 0,
          s = null,
          c = e;
        for (; null !== c; ) {
          if (((s = Bu(c)), null === s)) return -1;
          if ((t++, (c = c[15]), -1 !== s.injectorIndex))
            return s.injectorIndex | (t << 16);
        }
        return -1;
      }
      function Er(n, e, t) {
        !(function On(n, e, t) {
          let s;
          "string" == typeof t
            ? (s = t.charCodeAt(0) || 0)
            : t.hasOwnProperty($s) && (s = t[$s]),
            null == s && (s = t[$s] = _t++);
          const c = 255 & s;
          e.data[n + (c >> 5)] |= 1 << c;
        })(n, e, t);
      }
      function Hn(n, e, t) {
        if (t & St.Optional || void 0 !== n) return n;
        Dl();
      }
      function Pn(n, e, t, s) {
        if (
          (t & St.Optional && void 0 === s && (s = null),
          0 == (t & (St.Self | St.Host)))
        ) {
          const c = n[9],
            p = sr(void 0);
          try {
            return c ? c.get(e, s, t & St.Optional) : kh(e, s, t & St.Optional);
          } finally {
            sr(p);
          }
        }
        return Hn(s, 0, t);
      }
      function hn(n, e, t, s = St.Default, c) {
        if (null !== n) {
          if (1024 & e[2]) {
            const y = (function Ac(n, e, t, s, c) {
              let p = n,
                y = e;
              for (
                ;
                null !== p && null !== y && 1024 & y[2] && !(256 & y[2]);

              ) {
                const w = si(p, y, t, s | St.Self, en);
                if (w !== en) return w;
                let C = p.parent;
                if (!C) {
                  const P = y[21];
                  if (P) {
                    const N = P.get(t, en, s);
                    if (N !== en) return N;
                  }
                  (C = Bu(y)), (y = y[15]);
                }
                p = C;
              }
              return c;
            })(n, e, t, s, en);
            if (y !== en) return y;
          }
          const p = si(n, e, t, s, en);
          if (p !== en) return p;
        }
        return Pn(e, t, s, c);
      }
      function si(n, e, t, s, c) {
        const p = (function zu(n) {
          if ("string" == typeof n) return n.charCodeAt(0) || 0;
          const e = n.hasOwnProperty($s) ? n[$s] : void 0;
          return "number" == typeof e ? (e >= 0 ? 255 & e : na) : e;
        })(t);
        if ("function" == typeof p) {
          if (!xp(e, n, s)) return s & St.Host ? Hn(c, 0, s) : Pn(e, t, s, c);
          try {
            const y = p(s);
            if (null != y || s & St.Optional) return y;
            Dl();
          } finally {
            f();
          }
        } else if ("number" == typeof p) {
          let y = null,
            w = Hi(n, e),
            C = -1,
            P = s & St.Host ? e[16][6] : null;
          for (
            (-1 === w || s & St.SkipSelf) &&
            ((C = -1 === w ? vi(n, e) : e[w + 8]),
            -1 !== C && Bl(s, !1)
              ? ((y = e[1]), (w = Ne(C)), (e = mt(C, e)))
              : (w = -1));
            -1 !== w;

          ) {
            const N = e[1];
            if (ta(p, w, N.data)) {
              const j = Tr(w, e, t, y, s, P);
              if (j !== en) return j;
            }
            (C = e[w + 8]),
              -1 !== C && Bl(s, e[1].data[w + 8] === P) && ta(p, w, e)
                ? ((y = N), (w = Ne(C)), (e = mt(C, e)))
                : (w = -1);
          }
        }
        return c;
      }
      function Tr(n, e, t, s, c, p) {
        const y = e[1],
          w = y.data[n + 8],
          N = Fn(
            w,
            y,
            t,
            null == s ? Tu(w) && It : s != y && 0 != (3 & w.type),
            c & St.Host && p === w
          );
        return null !== N ? Gi(e, y, N, w) : en;
      }
      function Fn(n, e, t, s, c) {
        const p = n.providerIndexes,
          y = e.data,
          w = 1048575 & p,
          C = n.directiveStart,
          N = p >> 20,
          Q = c ? w + N : n.directiveEnd;
        for (let ie = s ? w : w + N; ie < Q; ie++) {
          const pe = y[ie];
          if ((ie < C && t === pe) || (ie >= C && pe.type === t)) return ie;
        }
        if (c) {
          const ie = y[C];
          if (ie && wo(ie) && ie.type === t) return C;
        }
        return null;
      }
      function Gi(n, e, t, s) {
        let c = n[t];
        const p = e.data;
        if (
          (function he(n) {
            return n instanceof te;
          })(c)
        ) {
          const y = c;
          y.resolving &&
            (function hs(n, e) {
              const t = e ? `. Dependency path: ${e.join(" > ")} > ${n}` : "";
              throw new st(
                -200,
                `Circular dependency in DI detected for ${n}${t}`
              );
            })(
              (function Cn(n) {
                return "function" == typeof n
                  ? n.name || n.toString()
                  : "object" == typeof n &&
                    null != n &&
                    "function" == typeof n.type
                  ? n.type.name || n.type.toString()
                  : gt(n);
              })(p[t])
            );
          const w = dt(y.canSeeViewProviders);
          y.resolving = !0;
          const C = y.injectImpl ? sr(y.injectImpl) : null;
          xp(n, s, St.Default);
          try {
            (c = n[t] = y.factory(void 0, p, n, s)),
              e.firstCreatePass &&
                t >= s.directiveStart &&
                (function H(n, e, t) {
                  const {
                    ngOnChanges: s,
                    ngOnInit: c,
                    ngDoCheck: p,
                  } = e.type.prototype;
                  if (s) {
                    const y = Ba(e);
                    (t.preOrderHooks || (t.preOrderHooks = [])).push(n, y),
                      (
                        t.preOrderCheckHooks || (t.preOrderCheckHooks = [])
                      ).push(n, y);
                  }
                  c &&
                    (t.preOrderHooks || (t.preOrderHooks = [])).push(0 - n, c),
                    p &&
                      ((t.preOrderHooks || (t.preOrderHooks = [])).push(n, p),
                      (
                        t.preOrderCheckHooks || (t.preOrderCheckHooks = [])
                      ).push(n, p));
                })(t, p[t], e);
          } finally {
            null !== C && sr(C), dt(w), (y.resolving = !1), f();
          }
        }
        return c;
      }
      function ta(n, e, t) {
        return !!(t[e + (n >> 5)] & (1 << n));
      }
      function Bl(n, e) {
        return !(n & St.Self || (n & St.Host && e));
      }
      class Nr {
        constructor(e, t) {
          (this._tNode = e), (this._lView = t);
        }
        get(e, t, s) {
          return hn(this._tNode, this._lView, e, s, t);
        }
      }
      function na() {
        return new Nr(ki(), Ze());
      }
      function Bu(n) {
        const e = n[1],
          t = e.type;
        return 2 === t ? e.declTNode : 1 === t ? n[6] : null;
      }
      const Vu = "__parameters__";
      function Ul(n, e, t) {
        return $o(() => {
          const s = (function wp(n) {
            return function (...t) {
              if (n) {
                const s = n(...t);
                for (const c in s) this[c] = s[c];
              }
            };
          })(e);
          function c(...p) {
            if (this instanceof c) return s.apply(this, p), this;
            const y = new c(...p);
            return (w.annotation = y), w;
            function w(C, P, N) {
              const j = C.hasOwnProperty(Vu)
                ? C[Vu]
                : Object.defineProperty(C, Vu, { value: [] })[Vu];
              for (; j.length <= N; ) j.push(null);
              return (j[N] = j[N] || []).push(y), C;
            }
          }
          return (
            t && (c.prototype = Object.create(t.prototype)),
            (c.prototype.ngMetadataName = n),
            (c.annotationCls = c),
            c
          );
        });
      }
      class sn {
        constructor(e, t) {
          (this._desc = e),
            (this.ngMetadataName = "InjectionToken"),
            (this.ɵprov = void 0),
            "number" == typeof t
              ? (this.__NG_ELEMENT_ID__ = t)
              : void 0 !== t &&
                (this.ɵprov = Mn({
                  token: this,
                  providedIn: t.providedIn || "root",
                  factory: t.factory,
                }));
        }
        get multi() {
          return this;
        }
        toString() {
          return `InjectionToken ${this._desc}`;
        }
      }
      function So(n, e) {
        void 0 === e && (e = n);
        for (let t = 0; t < n.length; t++) {
          let s = n[t];
          Array.isArray(s)
            ? (e === n && (e = n.slice(0, t)), So(s, e))
            : e !== n && e.push(s);
        }
        return e;
      }
      function Xa(n, e) {
        n.forEach((t) => (Array.isArray(t) ? Xa(t, e) : e(t)));
      }
      function qf(n, e, t) {
        e >= n.length ? n.push(t) : n.splice(e, 0, t);
      }
      function td(n, e) {
        return e >= n.length - 1 ? n.pop() : n.splice(e, 1)[0];
      }
      function Kr(n, e) {
        const t = [];
        for (let s = 0; s < n; s++) t.push(e);
        return t;
      }
      function Qn(n, e, t) {
        let s = kc(n, e);
        return (
          s >= 0
            ? (n[1 | s] = t)
            : ((s = ~s),
              (function xi(n, e, t, s) {
                let c = n.length;
                if (c == e) n.push(t, s);
                else if (1 === c) n.push(s, n[0]), (n[0] = t);
                else {
                  for (c--, n.push(n[c - 1], n[c]); c > e; )
                    (n[c] = n[c - 2]), c--;
                  (n[e] = t), (n[e + 1] = s);
                }
              })(n, s, e, t)),
          s
        );
      }
      function Tp(n, e) {
        const t = kc(n, e);
        if (t >= 0) return n[1 | t];
      }
      function kc(n, e) {
        return (function Dp(n, e, t) {
          let s = 0,
            c = n.length >> t;
          for (; c !== s; ) {
            const p = s + ((c - s) >> 1),
              y = n[p << t];
            if (e === y) return p << t;
            y > e ? (c = p) : (s = p + 1);
          }
          return ~(c << t);
        })(n, e, 1);
      }
      const ju = {},
        Fc = "__NG_DI_FLAG__",
        Ka = "ngTempTokenPath",
        Zf = /\n/gm,
        Uu = "__source";
      let Qa;
      function ur(n) {
        const e = Qa;
        return (Qa = n), e;
      }
      function rd(n, e = St.Default) {
        if (void 0 === Qa) throw new st(-203, !1);
        return null === Qa
          ? kh(n, void 0, e)
          : Qa.get(n, e & St.Optional ? null : void 0, e);
      }
      function Mt(n, e = St.Default) {
        return (
          (function Al() {
            return Ml;
          })() || rd
        )(it(n), e);
      }
      function Jn(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) {
          const s = it(n[t]);
          if (Array.isArray(s)) {
            if (0 === s.length) throw new st(900, !1);
            let c,
              p = St.Default;
            for (let y = 0; y < s.length; y++) {
              const w = s[y],
                C = od(w);
              "number" == typeof C
                ? -1 === C
                  ? (c = w.token)
                  : (p |= C)
                : (c = w);
            }
            e.push(Mt(c, p));
          } else e.push(Mt(s));
        }
        return e;
      }
      function $u(n, e) {
        return (n[Fc] = e), (n.prototype[Fc] = e), n;
      }
      function od(n) {
        return n[Fc];
      }
      const sd = $u(Ul("Optional"), 8),
        aa = $u(Ul("SkipSelf"), 4);
      var Ji = (() => (
        ((Ji = Ji || {})[(Ji.Important = 1)] = "Important"),
        (Ji[(Ji.DashCase = 2)] = "DashCase"),
        Ji
      ))();
      const rm = new Map();
      let pd = 0;
      const qi = "__ngContext__";
      function Dr(n, e) {
        wr(e)
          ? ((n[qi] = e[20]),
            (function Hl(n) {
              rm.set(n[20], n);
            })(e))
          : (n[qi] = e);
      }
      function Xu(n, e) {
        return undefined(n, e);
      }
      function fd(n) {
        const e = n[3];
        return cr(e) ? e[3] : e;
      }
      function md(n) {
        return Op(n[13]);
      }
      function dm(n) {
        return Op(n[4]);
      }
      function Op(n) {
        for (; null !== n && !cr(n); ) n = n[4];
        return n;
      }
      function zc(n, e, t, s, c) {
        if (null != s) {
          let p,
            y = !1;
          cr(s) ? (p = s) : wr(s) && ((y = !0), (s = s[0]));
          const w = oi(s);
          0 === n && null !== t
            ? null == c
              ? Qr(e, t, w)
              : Yr(e, t, w, c || null, !0)
            : 1 === n && null !== t
            ? Yr(e, t, w, c || null, !0)
            : 2 === n
            ? (function vm(n, e, t) {
                const s = Bp(n, e);
                s &&
                  (function gm(n, e, t, s) {
                    n.removeChild(e, t, s);
                  })(n, s, e, t);
              })(e, w, y)
            : 3 === n && e.destroyNode(w),
            null != p &&
              (function Yu(n, e, t, s, c) {
                const p = t[7];
                p !== oi(t) && zc(e, n, s, p, c);
                for (let w = 10; w < t.length; w++) {
                  const C = t[w];
                  _d(C[1], C, n, e, s, p);
                }
              })(e, n, p, t, c);
        }
      }
      function Gl(n, e, t) {
        return n.createElement(e, t);
      }
      function s_(n, e) {
        const t = n[9],
          s = t.indexOf(e),
          c = e[3];
        512 & e[2] && ((e[2] &= -513), $a(c, -1)), t.splice(s, 1);
      }
      function Np(n, e) {
        if (n.length <= 10) return;
        const t = 10 + e,
          s = n[t];
        if (s) {
          const c = s[17];
          null !== c && c !== n && s_(c, s), e > 0 && (n[t - 1][4] = s[4]);
          const p = td(n, 10 + e);
          !(function Fp(n, e) {
            _d(n, e, e[11], 2, null, null), (e[0] = null), (e[6] = null);
          })(s[1], s);
          const y = p[19];
          null !== y && y.detachView(p[1]),
            (s[3] = null),
            (s[4] = null),
            (s[2] &= -65);
        }
        return s;
      }
      function a_(n, e) {
        if (!(128 & e[2])) {
          const t = e[11];
          t.destroyNode && _d(n, e, t, 3, null, null),
            (function Iv(n) {
              let e = n[13];
              if (!e) return fm(n[1], n);
              for (; e; ) {
                let t = null;
                if (wr(e)) t = e[13];
                else {
                  const s = e[10];
                  s && (t = s);
                }
                if (!t) {
                  for (; e && !e[4] && e !== n; )
                    wr(e) && fm(e[1], e), (e = e[3]);
                  null === e && (e = n), wr(e) && fm(e[1], e), (t = e && e[4]);
                }
                e = t;
              }
            })(e);
        }
      }
      function fm(n, e) {
        if (!(128 & e[2])) {
          (e[2] &= -65),
            (e[2] |= 128),
            (function c_(n, e) {
              let t;
              if (null != n && null != (t = n.destroyHooks))
                for (let s = 0; s < t.length; s += 2) {
                  const c = e[t[s]];
                  if (!(c instanceof te)) {
                    const p = t[s + 1];
                    if (Array.isArray(p))
                      for (let y = 0; y < p.length; y += 2) {
                        const w = c[p[y]],
                          C = p[y + 1];
                        try {
                          C.call(w);
                        } finally {
                        }
                      }
                    else
                      try {
                        p.call(c);
                      } finally {
                      }
                  }
                }
            })(n, e),
            (function l_(n, e) {
              const t = n.cleanup,
                s = e[7];
              let c = -1;
              if (null !== t)
                for (let p = 0; p < t.length - 1; p += 2)
                  if ("string" == typeof t[p]) {
                    const y = t[p + 1],
                      w = "function" == typeof y ? y(e) : oi(e[y]),
                      C = s[(c = t[p + 2])],
                      P = t[p + 3];
                    "boolean" == typeof P
                      ? w.removeEventListener(t[p], C, P)
                      : P >= 0
                      ? s[(c = P)]()
                      : s[(c = -P)].unsubscribe(),
                      (p += 2);
                  } else {
                    const y = s[(c = t[p + 1])];
                    t[p].call(y);
                  }
              if (null !== s) {
                for (let p = c + 1; p < s.length; p++) (0, s[p])();
                e[7] = null;
              }
            })(n, e),
            1 === e[1].type && e[11].destroy();
          const t = e[17];
          if (null !== t && cr(e[3])) {
            t !== e[3] && s_(t, e);
            const s = e[19];
            null !== s && s.detachView(n);
          }
          !(function om(n) {
            rm.delete(n[20]);
          })(e);
        }
      }
      function mm(n, e, t) {
        return (function zp(n, e, t) {
          let s = e;
          for (; null !== s && 40 & s.type; ) s = (e = s).parent;
          if (null === s) return t[0];
          if (2 & s.flags) {
            const c = n.data[s.directiveStart].encapsulation;
            if (c === xo.None || c === xo.Emulated) return null;
          }
          return ji(s, t);
        })(n, e.parent, t);
      }
      function Yr(n, e, t, s, c) {
        n.insertBefore(e, t, s, c);
      }
      function Qr(n, e, t) {
        n.appendChild(e, t);
      }
      function u_(n, e, t, s, c) {
        null !== s ? Yr(n, e, t, s, c) : Qr(n, e, t);
      }
      function Bp(n, e) {
        return n.parentNode(e);
      }
      function Vp(n, e, t) {
        return _m(n, e, t);
      }
      let bd,
        _m = function gd(n, e, t) {
          return 40 & n.type ? ji(n, t) : null;
        };
      function jp(n, e, t, s) {
        const c = mm(n, s, e),
          p = e[11],
          w = Vp(s.parent || e[6], s, e);
        if (null != c)
          if (Array.isArray(t))
            for (let C = 0; C < t.length; C++) u_(p, c, t[C], w, !1);
          else u_(p, c, t, w, !1);
      }
      function Up(n, e) {
        if (null !== e) {
          const t = e.type;
          if (3 & t) return ji(e, n);
          if (4 & t) return ym(-1, n[e.index]);
          if (8 & t) {
            const s = e.child;
            if (null !== s) return Up(n, s);
            {
              const c = n[e.index];
              return cr(c) ? ym(-1, c) : oi(c);
            }
          }
          if (32 & t) return Xu(e, n)() || oi(n[e.index]);
          {
            const s = h_(n, e);
            return null !== s
              ? Array.isArray(s)
                ? s[0]
                : Up(fd(n[16]), s)
              : Up(n, e.next);
          }
        }
        return null;
      }
      function h_(n, e) {
        return null !== e ? n[16][6].projection[e.projection] : null;
      }
      function ym(n, e) {
        const t = 10 + n + 1;
        if (t < e.length) {
          const s = e[t],
            c = s[1].firstChild;
          if (null !== c) return Up(s, c);
        }
        return e[7];
      }
      function xm(n, e, t, s, c, p, y) {
        for (; null != t; ) {
          const w = s[t.index],
            C = t.type;
          if (
            (y && 0 === e && (w && Dr(oi(w), s), (t.flags |= 4)),
            64 != (64 & t.flags))
          )
            if (8 & C) xm(n, e, t.child, s, c, p, !1), zc(e, n, c, w, p);
            else if (32 & C) {
              const P = Xu(t, s);
              let N;
              for (; (N = P()); ) zc(e, n, c, N, p);
              zc(e, n, c, w, p);
            } else 16 & C ? d_(n, e, s, t, c, p) : zc(e, n, c, w, p);
          t = y ? t.projectionNext : t.next;
        }
      }
      function _d(n, e, t, s, c, p) {
        xm(t, s, n.firstChild, e, c, p, !1);
      }
      function d_(n, e, t, s, c, p) {
        const y = t[16],
          C = y[6].projection[s.projection];
        if (Array.isArray(C))
          for (let P = 0; P < C.length; P++) zc(e, n, c, C[P], p);
        else xm(n, e, C, y[3], c, p, !0);
      }
      function li(n, e, t) {
        n.setAttribute(e, "style", t);
      }
      function Qu(n, e, t) {
        "" === t
          ? n.removeAttribute(e, "class")
          : n.setAttribute(e, "class", t);
      }
      const I_ = new sn("ENVIRONMENT_INITIALIZER"),
        Ad = new sn("INJECTOR", -1),
        M_ = new sn("INJECTOR_DEF_TYPES");
      class Mm {
        get(e, t = ju) {
          if (t === ju) {
            const s = new Error(`NullInjectorError: No provider for ${xt(e)}!`);
            throw ((s.name = "NullInjectorError"), s);
          }
          return t;
        }
      }
      function A_(...n) {
        return { ɵproviders: Am(0, n) };
      }
      function Am(n, ...e) {
        const t = [],
          s = new Set();
        let c;
        return (
          Xa(e, (p) => {
            const y = p;
            Pm(y, t, [], s) && (c || (c = []), c.push(y));
          }),
          void 0 !== c && P_(c, t),
          t
        );
      }
      function P_(n, e) {
        for (let t = 0; t < n.length; t++) {
          const { providers: c } = n[t];
          Xa(c, (p) => {
            e.push(p);
          });
        }
      }
      function Pm(n, e, t, s) {
        if (!(n = it(n))) return !1;
        let c = null,
          p = vo(n);
        const y = !p && An(n);
        if (p || y) {
          if (y && !y.standalone) return !1;
          c = n;
        } else {
          const C = n.ngModule;
          if (((p = vo(C)), !p)) return !1;
          c = C;
        }
        const w = s.has(c);
        if (y) {
          if (w) return !1;
          if ((s.add(c), y.dependencies)) {
            const C =
              "function" == typeof y.dependencies
                ? y.dependencies()
                : y.dependencies;
            for (const P of C) Pm(P, e, t, s);
          }
        } else {
          if (!p) return !1;
          {
            if (null != p.imports && !w) {
              let P;
              s.add(c);
              try {
                Xa(p.imports, (N) => {
                  Pm(N, e, t, s) && (P || (P = []), P.push(N));
                });
              } finally {
              }
              void 0 !== P && P_(P, e);
            }
            if (!w) {
              const P = Ys(c) || (() => new c());
              e.push(
                { provide: c, useFactory: P, deps: wn },
                { provide: M_, useValue: c, multi: !0 },
                { provide: I_, useValue: () => Mt(c), multi: !0 }
              );
            }
            const C = p.providers;
            null == C ||
              w ||
              Xa(C, (N) => {
                e.push(N);
              });
          }
        }
        return c !== n && void 0 !== n.providers;
      }
      const $v = Dn({ provide: String, useValue: Dn });
      function Lm(n) {
        return null !== n && "object" == typeof n && $v in n;
      }
      function ni(n) {
        return "function" == typeof n;
      }
      const Pd = new sn("Set Injector scope."),
        jc = {},
        nh = {};
      let Rm;
      function Qp() {
        return void 0 === Rm && (Rm = new Mm()), Rm;
      }
      class da {}
      class k_ extends da {
        constructor(e, t, s, c) {
          super(),
            (this.parent = t),
            (this.source = s),
            (this.scopes = c),
            (this.records = new Map()),
            (this._ngOnDestroyHooks = new Set()),
            (this._onDestroyHooks = []),
            (this._destroyed = !1),
            Wl(e, (y) => this.processProvider(y)),
            this.records.set(Ad, yn(void 0, this)),
            c.has("environment") && this.records.set(da, yn(void 0, this));
          const p = this.records.get(Pd);
          null != p && "string" == typeof p.value && this.scopes.add(p.value),
            (this.injectorDefTypes = new Set(this.get(M_.multi, wn, St.Self)));
        }
        get destroyed() {
          return this._destroyed;
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0);
          try {
            for (const e of this._ngOnDestroyHooks) e.ngOnDestroy();
            for (const e of this._onDestroyHooks) e();
          } finally {
            this.records.clear(),
              this._ngOnDestroyHooks.clear(),
              this.injectorDefTypes.clear(),
              (this._onDestroyHooks.length = 0);
          }
        }
        onDestroy(e) {
          this._onDestroyHooks.push(e);
        }
        runInContext(e) {
          this.assertNotDestroyed();
          const t = ur(this),
            s = sr(void 0);
          try {
            return e();
          } finally {
            ur(t), sr(s);
          }
        }
        get(e, t = ju, s = St.Default) {
          this.assertNotDestroyed();
          const c = ur(this),
            p = sr(void 0);
          try {
            if (!(s & St.SkipSelf)) {
              let w = this.records.get(e);
              if (void 0 === w) {
                const C =
                  (function N_(n) {
                    return (
                      "function" == typeof n ||
                      ("object" == typeof n && n instanceof sn)
                    );
                  })(e) && yo(e);
                (w = C && this.injectableDefInScope(C) ? yn(Om(e), jc) : null),
                  this.records.set(e, w);
              }
              if (null != w) return this.hydrate(e, w);
            }
            return (s & St.Self ? Qp() : this.parent).get(
              e,
              (t = s & St.Optional && t === ju ? null : t)
            );
          } catch (y) {
            if ("NullInjectorError" === y.name) {
              if (((y[Ka] = y[Ka] || []).unshift(xt(e)), c)) throw y;
              return (function _s(n, e, t, s) {
                const c = n[Ka];
                throw (
                  (e[Uu] && c.unshift(e[Uu]),
                  (n.message = (function yv(n, e, t, s = null) {
                    n =
                      n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1)
                        ? n.slice(2)
                        : n;
                    let c = xt(e);
                    if (Array.isArray(e)) c = e.map(xt).join(" -> ");
                    else if ("object" == typeof e) {
                      let p = [];
                      for (let y in e)
                        if (e.hasOwnProperty(y)) {
                          let w = e[y];
                          p.push(
                            y +
                              ":" +
                              ("string" == typeof w ? JSON.stringify(w) : xt(w))
                          );
                        }
                      c = `{${p.join(", ")}}`;
                    }
                    return `${t}${s ? "(" + s + ")" : ""}[${c}]: ${n.replace(
                      Zf,
                      "\n  "
                    )}`;
                  })("\n" + n.message, c, t, s)),
                  (n.ngTokenPath = c),
                  (n[Ka] = null),
                  n)
                );
              })(y, e, "R3InjectorError", this.source);
            }
            throw y;
          } finally {
            sr(p), ur(c);
          }
        }
        resolveInjectorInitializers() {
          const e = ur(this),
            t = sr(void 0);
          try {
            const s = this.get(I_.multi, wn, St.Self);
            for (const c of s) c();
          } finally {
            ur(e), sr(t);
          }
        }
        toString() {
          const e = [],
            t = this.records;
          for (const s of t.keys()) e.push(xt(s));
          return `R3Injector[${e.join(", ")}]`;
        }
        assertNotDestroyed() {
          if (this._destroyed) throw new st(205, !1);
        }
        processProvider(e) {
          let t = ni((e = it(e))) ? e : it(e && e.provide);
          const s = (function O_(n) {
            return Lm(n)
              ? yn(void 0, n.useValue)
              : yn(
                  (function Fm(n, e, t) {
                    let s;
                    if (ni(n)) {
                      const c = it(n);
                      return Ys(c) || Om(c);
                    }
                    if (Lm(n)) s = () => it(n.useValue);
                    else if (
                      (function L_(n) {
                        return !(!n || !n.useFactory);
                      })(n)
                    )
                      s = () => n.useFactory(...Jn(n.deps || []));
                    else if (
                      (function km(n) {
                        return !(!n || !n.useExisting);
                      })(n)
                    )
                      s = () => Mt(it(n.useExisting));
                    else {
                      const c = it(n && (n.useClass || n.provide));
                      if (
                        !(function Nm(n) {
                          return !!n.deps;
                        })(n)
                      )
                        return Ys(c) || Om(c);
                      s = () => new c(...Jn(n.deps));
                    }
                    return s;
                  })(n),
                  jc
                );
          })(e);
          if (ni(e) || !0 !== e.multi) this.records.get(t);
          else {
            let c = this.records.get(t);
            c ||
              ((c = yn(void 0, jc, !0)),
              (c.factory = () => Jn(c.multi)),
              this.records.set(t, c)),
              (t = e),
              c.multi.push(e);
          }
          this.records.set(t, s);
        }
        hydrate(e, t) {
          return (
            t.value === jc && ((t.value = nh), (t.value = t.factory())),
            "object" == typeof t.value &&
              t.value &&
              (function F_(n) {
                return (
                  null !== n &&
                  "object" == typeof n &&
                  "function" == typeof n.ngOnDestroy
                );
              })(t.value) &&
              this._ngOnDestroyHooks.add(t.value),
            t.value
          );
        }
        injectableDefInScope(e) {
          if (!e.providedIn) return !1;
          const t = it(e.providedIn);
          return "string" == typeof t
            ? "any" === t || this.scopes.has(t)
            : this.injectorDefTypes.has(t);
        }
      }
      function Om(n) {
        const e = yo(n),
          t = null !== e ? e.factory : Ys(n);
        if (null !== t) return t;
        if (n instanceof sn) throw new st(204, !1);
        if (n instanceof Function)
          return (function R_(n) {
            const e = n.length;
            if (e > 0) throw (Kr(e, "?"), new st(204, !1));
            const t = (function Lh(n) {
              const e = n && (n[Il] || n[Uo]);
              if (e) {
                const t = (function Sl(n) {
                  if (n.hasOwnProperty("name")) return n.name;
                  const e = ("" + n).match(/^function\s*([^\s(]+)/);
                  return null === e ? "" : e[1];
                })(n);
                return (
                  console.warn(
                    `DEPRECATED: DI is instantiating a token "${t}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${t}" class.`
                  ),
                  e
                );
              }
              return null;
            })(n);
            return null !== t ? () => t.factory(n) : () => new n();
          })(n);
        throw new st(204, !1);
      }
      function yn(n, e, t = !1) {
        return { factory: n, value: e, multi: t ? [] : void 0 };
      }
      function ol(n) {
        return !!n.ɵproviders;
      }
      function Wl(n, e) {
        for (const t of n)
          Array.isArray(t) ? Wl(t, e) : ol(t) ? Wl(t.ɵproviders, e) : e(t);
      }
      class B_ {}
      class Gv {
        resolveComponentFactory(e) {
          throw (function Hv(n) {
            const e = Error(
              `No component factory found for ${xt(
                n
              )}. Did you add it to @NgModule.entryComponents?`
            );
            return (e.ngComponent = n), e;
          })(e);
        }
      }
      let Jp = (() => {
        class n {}
        return (n.NULL = new Gv()), n;
      })();
      function qv() {
        return ih(ki(), Ze());
      }
      function ih(n, e) {
        return new sl(ji(n, e));
      }
      let sl = (() => {
        class n {
          constructor(t) {
            this.nativeElement = t;
          }
        }
        return (n.__NG_ELEMENT_ID__ = qv), n;
      })();
      function ef(n) {
        return n instanceof sl ? n.nativeElement : n;
      }
      class rh {}
      let kd = (() => {
          class n {}
          return (
            (n.__NG_ELEMENT_ID__ = () =>
              (function zm() {
                const n = Ze(),
                  t = Ui(ki().index, n);
                return (wr(t) ? t : n)[11];
              })()),
            n
          );
        })(),
        Wv = (() => {
          class n {}
          return (
            (n.ɵprov = Mn({
              token: n,
              providedIn: "root",
              factory: () => null,
            })),
            n
          );
        })();
      class Bm {
        constructor(e) {
          (this.full = e),
            (this.major = e.split(".")[0]),
            (this.minor = e.split(".")[1]),
            (this.patch = e.split(".").slice(2).join("."));
        }
      }
      const Zv = new Bm("14.3.0"),
        tf = {};
      function Od(n) {
        return n.ngOriginalError;
      }
      class Uc {
        constructor() {
          this._console = console;
        }
        handleError(e) {
          const t = this._findOriginalError(e);
          this._console.error("ERROR", e),
            t && this._console.error("ORIGINAL ERROR", t);
        }
        _findOriginalError(e) {
          let t = e && Od(e);
          for (; t && Od(t); ) t = Od(t);
          return t || null;
        }
      }
      function Um(n, e, t) {
        let s = n.length;
        for (;;) {
          const c = n.indexOf(e, t);
          if (-1 === c) return c;
          if (0 === c || n.charCodeAt(c - 1) <= 32) {
            const p = e.length;
            if (c + p === s || n.charCodeAt(c + p) <= 32) return c;
          }
          t = c + 1;
        }
      }
      const $m = "ng-template";
      function H_(n, e, t) {
        let s = 0;
        for (; s < n.length; ) {
          let c = n[s++];
          if (t && "class" === c) {
            if (((c = n[s]), -1 !== Um(c.toLowerCase(), e, 0))) return !0;
          } else if (1 === c) {
            for (; s < n.length && "string" == typeof (c = n[s++]); )
              if (c.toLowerCase() === e) return !0;
            return !1;
          }
        }
        return !1;
      }
      function Hm(n) {
        return 4 === n.type && n.value !== $m;
      }
      function G_(n, e, t) {
        return e === (4 !== n.type || t ? n.value : $m);
      }
      function Qv(n, e, t) {
        let s = 4;
        const c = n.attrs || [],
          p = (function W_(n) {
            for (let e = 0; e < n.length; e++) if (Se(n[e])) return e;
            return n.length;
          })(c);
        let y = !1;
        for (let w = 0; w < e.length; w++) {
          const C = e[w];
          if ("number" != typeof C) {
            if (!y)
              if (4 & s) {
                if (
                  ((s = 2 | (1 & s)),
                  ("" !== C && !G_(n, C, t)) || ("" === C && 1 === e.length))
                ) {
                  if (vs(s)) return !1;
                  y = !0;
                }
              } else {
                const P = 8 & s ? C : e[++w];
                if (8 & s && null !== n.attrs) {
                  if (!H_(n.attrs, P, t)) {
                    if (vs(s)) return !1;
                    y = !0;
                  }
                  continue;
                }
                const j = q_(8 & s ? "class" : C, c, Hm(n), t);
                if (-1 === j) {
                  if (vs(s)) return !1;
                  y = !0;
                  continue;
                }
                if ("" !== P) {
                  let Q;
                  Q = j > p ? "" : c[j + 1].toLowerCase();
                  const ie = 8 & s ? Q : null;
                  if ((ie && -1 !== Um(ie, P, 0)) || (2 & s && P !== Q)) {
                    if (vs(s)) return !1;
                    y = !0;
                  }
                }
              }
          } else {
            if (!y && !vs(s) && !vs(C)) return !1;
            if (y && vs(C)) continue;
            (y = !1), (s = C | (1 & s));
          }
        }
        return vs(s) || y;
      }
      function vs(n) {
        return 0 == (1 & n);
      }
      function q_(n, e, t, s) {
        if (null === e) return -1;
        let c = 0;
        if (s || !t) {
          let p = !1;
          for (; c < e.length; ) {
            const y = e[c];
            if (y === n) return c;
            if (3 === y || 6 === y) p = !0;
            else {
              if (1 === y || 2 === y) {
                let w = e[++c];
                for (; "string" == typeof w; ) w = e[++c];
                continue;
              }
              if (4 === y) break;
              if (0 === y) {
                c += 4;
                continue;
              }
            }
            c += p ? 1 : 2;
          }
          return -1;
        }
        return (function Z_(n, e) {
          let t = n.indexOf(4);
          if (t > -1)
            for (t++; t < n.length; ) {
              const s = n[t];
              if ("number" == typeof s) return -1;
              if (s === e) return t;
              t++;
            }
          return -1;
        })(e, n);
      }
      function Gm(n, e, t = !1) {
        for (let s = 0; s < e.length; s++) if (Qv(n, e[s], t)) return !0;
        return !1;
      }
      function xs(n, e) {
        e: for (let t = 0; t < e.length; t++) {
          const s = e[t];
          if (n.length === s.length) {
            for (let c = 0; c < n.length; c++) if (n[c] !== s[c]) continue e;
            return !0;
          }
        }
        return !1;
      }
      function rf(n, e) {
        return n ? ":not(" + e.trim() + ")" : e;
      }
      function sh(n) {
        let e = n[0],
          t = 1,
          s = 2,
          c = "",
          p = !1;
        for (; t < n.length; ) {
          let y = n[t];
          if ("string" == typeof y)
            if (2 & s) {
              const w = n[++t];
              c += "[" + y + (w.length > 0 ? '="' + w + '"' : "") + "]";
            } else 8 & s ? (c += "." + y) : 4 & s && (c += " " + y);
          else
            "" !== c && !vs(y) && ((e += rf(p, c)), (c = "")),
              (s = y),
              (p = p || !vs(s));
          t++;
        }
        return "" !== c && (e += rf(p, c)), e;
      }
      const Gt = {};
      function ei(n) {
        zd(mn(), Ze(), v() + n, !1);
      }
      function zd(n, e, t, s) {
        if (!s)
          if (3 == (3 & e[2])) {
            const p = n.preOrderCheckHooks;
            null !== p && X(e, p, t);
          } else {
            const p = n.preOrderHooks;
            null !== p && Z(e, p, 0, t);
          }
        b(t);
      }
      function J_(n, e = null, t = null, s) {
        const c = qm(n, e, t, s);
        return c.resolveInjectorInitializers(), c;
      }
      function qm(n, e = null, t = null, s, c = new Set()) {
        const p = [t || wn, A_(n)];
        return (
          (s = s || ("object" == typeof n ? void 0 : xt(n))),
          new k_(p, e || Qp(), s || null, c)
        );
      }
      let Hc = (() => {
        class n {
          static create(t, s) {
            if (Array.isArray(t)) return J_({ name: "" }, s, t, "");
            {
              const c = t.name ?? "";
              return J_({ name: c }, t.parent, t.providers, c);
            }
          }
        }
        return (
          (n.THROW_IF_NOT_FOUND = ju),
          (n.NULL = new Mm()),
          (n.ɵprov = Mn({
            token: n,
            providedIn: "any",
            factory: () => Mt(Ad),
          })),
          (n.__NG_ELEMENT_ID__ = -1),
          n
        );
      })();
      function Ot(n, e = St.Default) {
        const t = Ze();
        return null === t ? Mt(n, e) : hn(ki(), t, it(n), e);
      }
      function Wc(n, e) {
        return (n << 17) | (e << 2);
      }
      function lo(n) {
        return (n >> 17) & 32767;
      }
      function Hd(n) {
        return 2 | n;
      }
      function bs(n) {
        return (131068 & n) >> 2;
      }
      function fa(n, e) {
        return (-131069 & n) | (e << 2);
      }
      function Gd(n) {
        return 1 | n;
      }
      function df(n, e) {
        const t = n.contentQueries;
        if (null !== t)
          for (let s = 0; s < t.length; s += 2) {
            const c = t[s],
              p = t[s + 1];
            if (-1 !== p) {
              const y = n.data[p];
              Ou(c), y.contentQueries(2, e[p], p);
            }
          }
      }
      function Xd(n, e, t, s, c, p, y, w, C, P, N) {
        const j = e.blueprint.slice();
        return (
          (j[0] = c),
          (j[2] = 76 | s),
          (null !== N || (n && 1024 & n[2])) && (j[2] |= 1024),
          zl(j),
          (j[3] = j[15] = n),
          (j[8] = t),
          (j[10] = y || (n && n[10])),
          (j[11] = w || (n && n[11])),
          (j[12] = C || (n && n[12]) || null),
          (j[9] = P || (n && n[9]) || null),
          (j[6] = p),
          (j[20] = (function Jg() {
            return pd++;
          })()),
          (j[21] = N),
          (j[16] = 2 == e.type ? n[16] : j),
          j
        );
      }
      function Kc(n, e, t, s, c) {
        let p = n.data[e];
        if (null === p)
          (p = (function Yc(n, e, t, s, c) {
            const p = Yh(),
              y = Or(),
              C = (n.data[e] = (function lg(n, e, t, s, c, p) {
                return {
                  type: t,
                  index: s,
                  insertBeforeIndex: null,
                  injectorIndex: e ? e.injectorIndex : -1,
                  directiveStart: -1,
                  directiveEnd: -1,
                  directiveStylingLast: -1,
                  propertyBindings: null,
                  flags: 0,
                  providerIndexes: 0,
                  value: c,
                  attrs: p,
                  mergedAttrs: null,
                  localNames: null,
                  initialInputs: void 0,
                  inputs: null,
                  outputs: null,
                  tViews: null,
                  next: null,
                  projectionNext: null,
                  child: null,
                  parent: e,
                  projection: null,
                  styles: null,
                  stylesWithoutHost: null,
                  residualStyles: void 0,
                  classes: null,
                  classesWithoutHost: null,
                  residualClasses: void 0,
                  classBindings: 0,
                  styleBindings: 0,
                };
              })(0, y ? p : p && p.parent, t, e, s, c));
            return (
              null === n.firstChild && (n.firstChild = C),
              null !== p &&
                (y
                  ? null == p.child && null !== C.parent && (p.child = C)
                  : null === p.next && (p.next = C)),
              C
            );
          })(n, e, t, s, c)),
            (function Ga() {
              return Bt.lFrame.inI18n;
            })() && (p.flags |= 64);
        else if (64 & p.type) {
          (p.type = t), (p.value = s), (p.attrs = c);
          const y = (function Sc() {
            const n = Bt.lFrame,
              e = n.currentTNode;
            return n.isParent ? e : e.parent;
          })();
          p.injectorIndex = null === y ? -1 : y.injectorIndex;
        }
        return Xo(p, !0), p;
      }
      function cl(n, e, t, s) {
        if (0 === t) return -1;
        const c = e.length;
        for (let p = 0; p < t; p++)
          e.push(s), n.blueprint.push(s), n.data.push(null);
        return c;
      }
      function pf(n, e, t) {
        Mc(e);
        try {
          const s = n.viewQuery;
          null !== s && tt(1, s, t);
          const c = n.template;
          null !== c && cy(n, e, c, 1, t),
            n.firstCreatePass && (n.firstCreatePass = !1),
            n.staticContentQueries && df(n, e),
            n.staticViewQueries && tt(2, n.viewQuery, t);
          const p = n.components;
          null !== p &&
            (function Xc(n, e) {
              for (let t = 0; t < e.length; t++) Ie(n, e[t]);
            })(e, p);
        } catch (s) {
          throw (
            (n.firstCreatePass &&
              ((n.incompleteFirstPass = !0), (n.firstCreatePass = !1)),
            s)
          );
        } finally {
          (e[2] &= -5), a();
        }
      }
      function Kd(n, e, t, s) {
        const c = e[2];
        if (128 != (128 & c)) {
          Mc(e);
          try {
            zl(e),
              (function ku(n) {
                return (Bt.lFrame.bindingIndex = n);
              })(n.bindingStartIndex),
              null !== t && cy(n, e, t, 2, s);
            const y = 3 == (3 & c);
            if (y) {
              const P = n.preOrderCheckHooks;
              null !== P && X(e, P, null);
            } else {
              const P = n.preOrderHooks;
              null !== P && Z(e, P, 0, null), Y(e, 0);
            }
            if (
              ((function xe(n) {
                for (let e = md(n); null !== e; e = dm(e)) {
                  if (!e[2]) continue;
                  const t = e[9];
                  for (let s = 0; s < t.length; s++) {
                    const c = t[s],
                      p = c[3];
                    0 == (512 & c[2]) && $a(p, 1), (c[2] |= 512);
                  }
                }
              })(e),
              (function De(n) {
                for (let e = md(n); null !== e; e = dm(e))
                  for (let t = 10; t < e.length; t++) {
                    const s = e[t],
                      c = s[1];
                    Nl(s) && Kd(c, s, c.template, s[8]);
                  }
              })(e),
              null !== n.contentQueries && df(n, e),
              y)
            ) {
              const P = n.contentCheckHooks;
              null !== P && X(e, P);
            } else {
              const P = n.contentHooks;
              null !== P && Z(e, P, 1), Y(e, 1);
            }
            !(function sg(n, e) {
              const t = n.hostBindingOpCodes;
              if (null !== t)
                try {
                  for (let s = 0; s < t.length; s++) {
                    const c = t[s];
                    if (c < 0) b(~c);
                    else {
                      const p = c,
                        y = t[++s],
                        w = t[++s];
                      Qh(y, p), w(2, e[p]);
                    }
                  }
                } finally {
                  b(-1);
                }
            })(n, e);
            const w = n.components;
            null !== w &&
              (function Ts(n, e) {
                for (let t = 0; t < e.length; t++) Pe(n, e[t]);
              })(e, w);
            const C = n.viewQuery;
            if ((null !== C && tt(2, C, s), y)) {
              const P = n.viewCheckHooks;
              null !== P && X(e, P);
            } else {
              const P = n.viewHooks;
              null !== P && Z(e, P, 2), Y(e, 2);
            }
            !0 === n.firstUpdatePass && (n.firstUpdatePass = !1),
              (e[2] &= -41),
              512 & e[2] && ((e[2] &= -513), $a(e[3], -1));
          } finally {
            a();
          }
        }
      }
      function cy(n, e, t, s, c) {
        const p = v(),
          y = 2 & s;
        try {
          b(-1), y && e.length > 22 && zd(n, e, 22, !1), t(s, c);
        } finally {
          b(p);
        }
      }
      function ag(n, e, t) {
        if (zh(e)) {
          const c = e.directiveEnd;
          for (let p = e.directiveStart; p < c; p++) {
            const y = n.data[p];
            y.contentQueries && y.contentQueries(1, t[p], p);
          }
        }
      }
      function ff(n, e, t) {
        !Kh() ||
          ((function x(n, e, t, s) {
            const c = t.directiveStart,
              p = t.directiveEnd;
            n.firstCreatePass || _n(t, e), Dr(s, e);
            const y = t.initialInputs;
            for (let w = c; w < p; w++) {
              const C = n.data[w],
                P = wo(C);
              P && G(e, t, C);
              const N = Gi(e, n, w, t);
              Dr(N, e),
                null !== y && J(0, w - c, N, C, 0, y),
                P && (Ui(t.index, e)[8] = N);
            }
          })(n, e, t, ji(t, e)),
          128 == (128 & t.flags) &&
            (function E(n, e, t) {
              const s = t.directiveStart,
                c = t.directiveEnd,
                p = t.index,
                y = (function $f() {
                  return Bt.lFrame.currentDirectiveIndex;
                })();
              try {
                b(p);
                for (let w = s; w < c; w++) {
                  const C = n.data[w],
                    P = e[w];
                  Ru(w),
                    (null !== C.hostBindings ||
                      0 !== C.hostVars ||
                      null !== C.hostAttrs) &&
                      T(C, P);
                }
              } finally {
                b(-1), Ru(y);
              }
            })(n, e, t));
      }
      function mf(n, e, t = ji) {
        const s = e.localNames;
        if (null !== s) {
          let c = e.index + 1;
          for (let p = 0; p < s.length; p += 2) {
            const y = s[p + 1],
              w = -1 === y ? t(e, n) : n[y];
            n[c++] = w;
          }
        }
      }
      function uy(n) {
        const e = n.tView;
        return null === e || e.incompleteFirstPass
          ? (n.tView = Yd(
              1,
              null,
              n.template,
              n.decls,
              n.vars,
              n.directiveDefs,
              n.pipeDefs,
              n.viewQuery,
              n.schemas,
              n.consts
            ))
          : e;
      }
      function Yd(n, e, t, s, c, p, y, w, C, P) {
        const N = 22 + s,
          j = N + c,
          Q = (function hy(n, e) {
            const t = [];
            for (let s = 0; s < e; s++) t.push(s < n ? null : Gt);
            return t;
          })(N, j),
          ie = "function" == typeof P ? P() : P;
        return (Q[1] = {
          type: n,
          blueprint: Q,
          template: t,
          queries: null,
          viewQuery: w,
          declTNode: e,
          data: Q.slice().fill(null, N),
          bindingStartIndex: N,
          expandoStartIndex: j,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: "function" == typeof p ? p() : p,
          pipeRegistry: "function" == typeof y ? y() : y,
          firstChild: null,
          schemas: C,
          consts: ie,
          incompleteFirstPass: !1,
        });
      }
      function gf(n, e, t, s) {
        const c = rt(e);
        null === t
          ? c.push(s)
          : (c.push(t), n.firstCreatePass && Lt(n).push(s, c.length - 1));
      }
      function cg(n, e, t) {
        for (let s in n)
          if (n.hasOwnProperty(s)) {
            const c = n[s];
            (t = null === t ? {} : t).hasOwnProperty(s)
              ? t[s].push(e, c)
              : (t[s] = [e, c]);
          }
        return t;
      }
      function fh(n, e) {
        const s = e.directiveEnd,
          c = n.data,
          p = e.attrs,
          y = [];
        let w = null,
          C = null;
        for (let P = e.directiveStart; P < s; P++) {
          const N = c[P],
            j = N.inputs,
            Q = null === p || Hm(e) ? null : re(j, p);
          y.push(Q), (w = cg(j, P, w)), (C = cg(N.outputs, P, C));
        }
        null !== w &&
          (w.hasOwnProperty("class") && (e.flags |= 16),
          w.hasOwnProperty("style") && (e.flags |= 32)),
          (e.initialInputs = y),
          (e.inputs = w),
          (e.outputs = C);
      }
      function r(n, e) {
        const t = Ui(e, n);
        16 & t[2] || (t[2] |= 32);
      }
      function h(n, e, t, s) {
        let c = !1;
        if (Kh()) {
          const p = (function I(n, e, t) {
              const s = n.directiveRegistry;
              let c = null;
              if (s)
                for (let p = 0; p < s.length; p++) {
                  const y = s[p];
                  Gm(t, y.selectors, !1) &&
                    (c || (c = []),
                    Er(_n(t, e), n, y.type),
                    wo(y) ? (A(n, t), c.unshift(y)) : c.push(y));
                }
              return c;
            })(n, e, t),
            y = null === s ? null : { "": -1 };
          if (null !== p) {
            (c = !0), F(t, n.data.length, p.length);
            for (let N = 0; N < p.length; N++) {
              const j = p[N];
              j.providersResolver && j.providersResolver(j);
            }
            let w = !1,
              C = !1,
              P = cl(n, e, p.length, null);
            for (let N = 0; N < p.length; N++) {
              const j = p[N];
              (t.mergedAttrs = we(t.mergedAttrs, j.hostAttrs)),
                V(n, t, e, P, j),
                O(P, j, y),
                null !== j.contentQueries && (t.flags |= 8),
                (null !== j.hostBindings ||
                  null !== j.hostAttrs ||
                  0 !== j.hostVars) &&
                  (t.flags |= 128);
              const Q = j.type.prototype;
              !w &&
                (Q.ngOnChanges || Q.ngOnInit || Q.ngDoCheck) &&
                ((n.preOrderHooks || (n.preOrderHooks = [])).push(t.index),
                (w = !0)),
                !C &&
                  (Q.ngOnChanges || Q.ngDoCheck) &&
                  ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(
                    t.index
                  ),
                  (C = !0)),
                P++;
            }
            fh(n, t);
          }
          y &&
            (function L(n, e, t) {
              if (e) {
                const s = (n.localNames = []);
                for (let c = 0; c < e.length; c += 2) {
                  const p = t[e[c + 1]];
                  if (null == p) throw new st(-301, !1);
                  s.push(e[c], p);
                }
              }
            })(t, s, y);
        }
        return (t.mergedAttrs = we(t.mergedAttrs, t.attrs)), c;
      }
      function m(n, e, t, s, c, p) {
        const y = p.hostBindings;
        if (y) {
          let w = n.hostBindingOpCodes;
          null === w && (w = n.hostBindingOpCodes = []);
          const C = ~e.index;
          (function _(n) {
            let e = n.length;
            for (; e > 0; ) {
              const t = n[--e];
              if ("number" == typeof t && t < 0) return t;
            }
            return 0;
          })(w) != C && w.push(C),
            w.push(s, c, y);
        }
      }
      function T(n, e) {
        null !== n.hostBindings && n.hostBindings(1, e);
      }
      function A(n, e) {
        (e.flags |= 2), (n.components || (n.components = [])).push(e.index);
      }
      function O(n, e, t) {
        if (t) {
          if (e.exportAs)
            for (let s = 0; s < e.exportAs.length; s++) t[e.exportAs[s]] = n;
          wo(e) && (t[""] = n);
        }
      }
      function F(n, e, t) {
        (n.flags |= 1),
          (n.directiveStart = e),
          (n.directiveEnd = e + t),
          (n.providerIndexes = e);
      }
      function V(n, e, t, s, c) {
        n.data[s] = c;
        const p = c.factory || (c.factory = Ys(c.type)),
          y = new te(p, wo(c), Ot);
        (n.blueprint[s] = y),
          (t[s] = y),
          m(n, e, 0, s, cl(n, t, c.hostVars, Gt), c);
      }
      function G(n, e, t) {
        const s = ji(e, n),
          c = uy(t),
          p = n[10],
          y = Re(
            n,
            Xd(
              n,
              c,
              null,
              t.onPush ? 32 : 16,
              s,
              e,
              p,
              p.createRenderer(s, t),
              null,
              null,
              null
            )
          );
        n[e.index] = y;
      }
      function K(n, e, t, s, c, p) {
        const y = ji(n, e);
        !(function oe(n, e, t, s, c, p, y) {
          if (null == p) n.removeAttribute(e, c, t);
          else {
            const w = null == y ? gt(p) : y(p, s || "", c);
            n.setAttribute(e, c, w, t);
          }
        })(e[11], y, p, n.value, t, s, c);
      }
      function J(n, e, t, s, c, p) {
        const y = p[e];
        if (null !== y) {
          const w = s.setInput;
          for (let C = 0; C < y.length; ) {
            const P = y[C++],
              N = y[C++],
              j = y[C++];
            null !== w ? s.setInput(t, j, P, N) : (t[N] = j);
          }
        }
      }
      function re(n, e) {
        let t = null,
          s = 0;
        for (; s < e.length; ) {
          const c = e[s];
          if (0 !== c)
            if (5 !== c) {
              if ("number" == typeof c) break;
              n.hasOwnProperty(c) &&
                (null === t && (t = []), t.push(c, n[c], e[s + 1])),
                (s += 2);
            } else s += 2;
          else s += 4;
        }
        return t;
      }
      function ae(n, e, t, s) {
        return new Array(n, !0, !1, e, null, 0, s, t, null, null);
      }
      function Pe(n, e) {
        const t = Ui(e, n);
        if (Nl(t)) {
          const s = t[1];
          48 & t[2] ? Kd(s, t, s.template, t[8]) : t[5] > 0 && $e(t);
        }
      }
      function $e(n) {
        for (let s = md(n); null !== s; s = dm(s))
          for (let c = 10; c < s.length; c++) {
            const p = s[c];
            if (Nl(p))
              if (512 & p[2]) {
                const y = p[1];
                Kd(y, p, y.template, p[8]);
              } else p[5] > 0 && $e(p);
          }
        const t = n[1].components;
        if (null !== t)
          for (let s = 0; s < t.length; s++) {
            const c = Ui(t[s], n);
            Nl(c) && c[5] > 0 && $e(c);
          }
      }
      function Ie(n, e) {
        const t = Ui(e, n),
          s = t[1];
        (function Fe(n, e) {
          for (let t = e.length; t < n.blueprint.length; t++)
            e.push(n.blueprint[t]);
        })(s, t),
          pf(s, t, t[8]);
      }
      function Re(n, e) {
        return n[13] ? (n[14][4] = e) : (n[13] = e), (n[14] = e), e;
      }
      function Ve(n) {
        for (; n; ) {
          n[2] |= 32;
          const e = fd(n);
          if (Rf(n) && !e) return n;
          n = e;
        }
        return null;
      }
      function qe(n, e, t, s = !0) {
        const c = e[10];
        c.begin && c.begin();
        try {
          Kd(n, e, n.template, t);
        } catch (y) {
          throw (s && bt(e, y), y);
        } finally {
          c.end && c.end();
        }
      }
      function tt(n, e, t) {
        Ou(0), e(n, t);
      }
      function rt(n) {
        return n[7] || (n[7] = []);
      }
      function Lt(n) {
        return n.cleanup || (n.cleanup = []);
      }
      function bt(n, e) {
        const t = n[9],
          s = t ? t.get(Uc, null) : null;
        s && s.handleError(e);
      }
      function Pt(n, e, t, s, c) {
        for (let p = 0; p < t.length; ) {
          const y = t[p++],
            w = t[p++],
            C = e[y],
            P = n.data[y];
          null !== P.setInput ? P.setInput(C, c, s, w) : (C[w] = c);
        }
      }
      function At(n, e, t) {
        let s = t ? n.styles : null,
          c = t ? n.classes : null,
          p = 0;
        if (null !== e)
          for (let y = 0; y < e.length; y++) {
            const w = e[y];
            "number" == typeof w
              ? (p = w)
              : 1 == p
              ? (c = $t(c, w))
              : 2 == p && (s = $t(s, w + ": " + e[++y] + ";"));
          }
        t ? (n.styles = s) : (n.stylesWithoutHost = s),
          t ? (n.classes = c) : (n.classesWithoutHost = c);
      }
      function Et(n, e, t, s, c = !1) {
        for (; null !== t; ) {
          const p = e[t.index];
          if ((null !== p && s.push(oi(p)), cr(p)))
            for (let w = 10; w < p.length; w++) {
              const C = p[w],
                P = C[1].firstChild;
              null !== P && Et(C[1], C, P, s);
            }
          const y = t.type;
          if (8 & y) Et(n, e, t.child, s);
          else if (32 & y) {
            const w = Xu(t, e);
            let C;
            for (; (C = w()); ) s.push(C);
          } else if (16 & y) {
            const w = h_(e, t);
            if (Array.isArray(w)) s.push(...w);
            else {
              const C = fd(e[16]);
              Et(C[1], C, w, s, !0);
            }
          }
          t = c ? t.projectionNext : t.next;
        }
        return s;
      }
      class In {
        constructor(e, t) {
          (this._lView = e),
            (this._cdRefInjectingView = t),
            (this._appRef = null),
            (this._attachedToViewContainer = !1);
        }
        get rootNodes() {
          const e = this._lView,
            t = e[1];
          return Et(t, e, t.firstChild, []);
        }
        get context() {
          return this._lView[8];
        }
        set context(e) {
          this._lView[8] = e;
        }
        get destroyed() {
          return 128 == (128 & this._lView[2]);
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this);
          else if (this._attachedToViewContainer) {
            const e = this._lView[3];
            if (cr(e)) {
              const t = e[8],
                s = t ? t.indexOf(this) : -1;
              s > -1 && (Np(e, s), td(t, s));
            }
            this._attachedToViewContainer = !1;
          }
          a_(this._lView[1], this._lView);
        }
        onDestroy(e) {
          gf(this._lView[1], this._lView, null, e);
        }
        markForCheck() {
          Ve(this._cdRefInjectingView || this._lView);
        }
        detach() {
          this._lView[2] &= -65;
        }
        reattach() {
          this._lView[2] |= 64;
        }
        detectChanges() {
          qe(this._lView[1], this._lView, this.context);
        }
        checkNoChanges() {}
        attachToViewContainerRef() {
          if (this._appRef) throw new st(902, !1);
          this._attachedToViewContainer = !0;
        }
        detachFromAppRef() {
          (this._appRef = null),
            (function r_(n, e) {
              _d(n, e, e[11], 2, null, null);
            })(this._lView[1], this._lView);
        }
        attachToAppRef(e) {
          if (this._attachedToViewContainer) throw new st(902, !1);
          this._appRef = e;
        }
      }
      class Nt extends In {
        constructor(e) {
          super(e), (this._view = e);
        }
        detectChanges() {
          const e = this._view;
          qe(e[1], e, e[8], !1);
        }
        checkNoChanges() {}
        get context() {
          return null;
        }
      }
      class kt extends Jp {
        constructor(e) {
          super(), (this.ngModule = e);
        }
        resolveComponentFactory(e) {
          const t = An(e);
          return new vn(t, this.ngModule);
        }
      }
      function kn(n) {
        const e = [];
        for (let t in n)
          n.hasOwnProperty(t) && e.push({ propName: n[t], templateName: t });
        return e;
      }
      class Bn {
        constructor(e, t) {
          (this.injector = e), (this.parentInjector = t);
        }
        get(e, t, s) {
          const c = this.injector.get(e, tf, s);
          return c !== tf || t === tf ? c : this.parentInjector.get(e, t, s);
        }
      }
      class vn extends B_ {
        constructor(e, t) {
          super(),
            (this.componentDef = e),
            (this.ngModule = t),
            (this.componentType = e.type),
            (this.selector = (function ah(n) {
              return n.map(sh).join(",");
            })(e.selectors)),
            (this.ngContentSelectors = e.ngContentSelectors
              ? e.ngContentSelectors
              : []),
            (this.isBoundToModule = !!t);
        }
        get inputs() {
          return kn(this.componentDef.inputs);
        }
        get outputs() {
          return kn(this.componentDef.outputs);
        }
        create(e, t, s, c) {
          let p = (c = c || this.ngModule) instanceof da ? c : c?.injector;
          p &&
            null !== this.componentDef.getStandaloneInjector &&
            (p = this.componentDef.getStandaloneInjector(p) || p);
          const y = p ? new Bn(e, p) : e,
            w = y.get(rh, null);
          if (null === w) throw new st(407, !1);
          const C = y.get(Wv, null),
            P = w.createRenderer(null, this.componentDef),
            N = this.componentDef.selectors[0][0] || "div",
            j = s
              ? (function dy(n, e, t) {
                  return n.selectRootElement(e, t === xo.ShadowDom);
                })(P, s, this.componentDef.encapsulation)
              : Gl(
                  P,
                  N,
                  (function zn(n) {
                    const e = n.toLowerCase();
                    return "svg" === e ? "svg" : "math" === e ? "math" : null;
                  })(N)
                ),
            Q = this.componentDef.onPush ? 288 : 272,
            ie = Yd(0, null, null, 1, 0, null, null, null, null, null),
            pe = Xd(null, ie, null, Q, null, null, w, P, C, y, null);
          let Ee, Oe;
          Mc(pe);
          try {
            const Ue = (function Ii(n, e, t, s, c, p) {
              const y = t[1];
              t[22] = n;
              const C = Kc(y, 22, 2, "#host", null),
                P = (C.mergedAttrs = e.hostAttrs);
              null !== P &&
                (At(C, P, !0),
                null !== n &&
                  (Le(c, n, P),
                  null !== C.classes && Qu(c, n, C.classes),
                  null !== C.styles && li(c, n, C.styles)));
              const N = s.createRenderer(n, e),
                j = Xd(
                  t,
                  uy(e),
                  null,
                  e.onPush ? 32 : 16,
                  t[22],
                  C,
                  s,
                  N,
                  p || null,
                  null,
                  null
                );
              return (
                y.firstCreatePass &&
                  (Er(_n(C, t), y, e.type), A(y, C), F(C, t.length, 1)),
                Re(t, j),
                (t[22] = j)
              );
            })(j, this.componentDef, pe, w, P);
            if (j)
              if (s) Le(P, j, ["ng-version", Zv.full]);
              else {
                const { attrs: ht, classes: ze } = (function X_(n) {
                  const e = [],
                    t = [];
                  let s = 1,
                    c = 2;
                  for (; s < n.length; ) {
                    let p = n[s];
                    if ("string" == typeof p)
                      2 === c
                        ? "" !== p && e.push(p, n[++s])
                        : 8 === c && t.push(p);
                    else {
                      if (!vs(c)) break;
                      c = p;
                    }
                    s++;
                  }
                  return { attrs: e, classes: t };
                })(this.componentDef.selectors[0]);
                ht && Le(P, j, ht),
                  ze && ze.length > 0 && Qu(P, j, ze.join(" "));
              }
            if (((Oe = qh(ie, 22)), void 0 !== t)) {
              const ht = (Oe.projection = []);
              for (let ze = 0; ze < this.ngContentSelectors.length; ze++) {
                const vt = t[ze];
                ht.push(null != vt ? Array.from(vt) : null);
              }
            }
            (Ee = (function Ei(n, e, t, s) {
              const c = t[1],
                p = (function l(n, e, t) {
                  const s = ki();
                  n.firstCreatePass &&
                    (t.providersResolver && t.providersResolver(t),
                    V(n, s, e, cl(n, e, 1, null), t),
                    fh(n, s));
                  const c = Gi(e, n, s.directiveStart, s);
                  Dr(c, e);
                  const p = ji(s, e);
                  return p && Dr(p, e), c;
                })(c, t, e);
              if (((n[8] = t[8] = p), null !== s)) for (const w of s) w(p, e);
              if (e.contentQueries) {
                const w = ki();
                e.contentQueries(1, p, w.directiveStart);
              }
              const y = ki();
              return (
                !c.firstCreatePass ||
                  (null === e.hostBindings && null === e.hostAttrs) ||
                  (b(y.index),
                  m(t[1], y, 0, y.directiveStart, y.directiveEnd, e),
                  T(e, p)),
                p
              );
            })(Ue, this.componentDef, pe, [ti])),
              pf(ie, pe, null);
          } finally {
            a();
          }
          return new wi(this.componentType, Ee, ih(Oe, pe), pe, Oe);
        }
      }
      class wi extends class z_ {} {
        constructor(e, t, s, c, p) {
          super(),
            (this.location = s),
            (this._rootLView = c),
            (this._tNode = p),
            (this.instance = t),
            (this.hostView = this.changeDetectorRef = new Nt(c)),
            (this.componentType = e);
        }
        setInput(e, t) {
          const s = this._tNode.inputs;
          let c;
          if (null !== s && (c = s[e])) {
            const p = this._rootLView;
            Pt(p[1], p, c, e, t), r(p, this._tNode.index);
          }
        }
        get injector() {
          return new Nr(this._tNode, this._rootLView);
        }
        destroy() {
          this.hostView.destroy();
        }
        onDestroy(e) {
          this.hostView.onDestroy(e);
        }
      }
      function ti() {
        const n = ki();
        q(Ze()[1], n);
      }
      let ul = null;
      function Cs() {
        if (!ul) {
          const n = $n.Symbol;
          if (n && n.iterator) ul = n.iterator;
          else {
            const e = Object.getOwnPropertyNames(Map.prototype);
            for (let t = 0; t < e.length; ++t) {
              const s = e[t];
              "entries" !== s &&
                "size" !== s &&
                Map.prototype[s] === Map.prototype.entries &&
                (ul = s);
            }
          }
        }
        return ul;
      }
      function mh(n) {
        return (
          !!yf(n) && (Array.isArray(n) || (!(n instanceof Map) && Cs() in n))
        );
      }
      function yf(n) {
        return null !== n && ("function" == typeof n || "object" == typeof n);
      }
      function Jo(n, e, t) {
        return (n[e] = t);
      }
      function Cr(n, e, t) {
        return !Object.is(n[e], t) && ((n[e] = t), !0);
      }
      function Ss(n, e, t, s) {
        const c = Ze();
        return Cr(c, ea(), e) && (mn(), K(D(), c, n, e, t, s)), Ss;
      }
      function _h(n, e, t, s) {
        return Cr(n, ea(), t) ? e + gt(t) + s : Gt;
      }
      function Ri(n, e, t, s, c, p, y, w) {
        const C = Ze(),
          P = mn(),
          N = n + 22,
          j = P.firstCreatePass
            ? (function yD(n, e, t, s, c, p, y, w, C) {
                const P = e.consts,
                  N = Kc(e, n, 4, y || null, Do(P, w));
                h(e, t, N, Do(P, C)), q(e, N);
                const j = (N.tViews = Yd(
                  2,
                  N,
                  s,
                  c,
                  p,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  P
                ));
                return (
                  null !== e.queries &&
                    (e.queries.template(e, N),
                    (j.queries = e.queries.embeddedTView(N))),
                  N
                );
              })(N, P, C, e, t, s, c, p, y)
            : P.data[N];
        Xo(j, !1);
        const Q = C[11].createComment("");
        jp(P, C, Q, j),
          Dr(Q, C),
          Re(C, (C[N] = ae(Q, C, Q, j))),
          Du(j) && ff(P, C, j),
          null != y && mf(C, j, w);
      }
      function Gn(n, e, t) {
        const s = Ze();
        return (
          Cr(s, ea(), e) &&
            (function co(n, e, t, s, c, p, y, w) {
              const C = ji(e, t);
              let N,
                P = e.inputs;
              !w && null != P && (N = P[s])
                ? (Pt(n, t, N, s, c), Tu(e) && r(t, e.index))
                : 3 & e.type &&
                  ((s = (function ug(n) {
                    return "class" === n
                      ? "className"
                      : "for" === n
                      ? "htmlFor"
                      : "formaction" === n
                      ? "formAction"
                      : "innerHtml" === n
                      ? "innerHTML"
                      : "readonly" === n
                      ? "readOnly"
                      : "tabindex" === n
                      ? "tabIndex"
                      : n;
                  })(s)),
                  (c = null != y ? y(c, e.value || "", s) : c),
                  p.setProperty(C, s, c));
            })(mn(), D(), s, n, e, s[11], t, !1),
          Gn
        );
      }
      function D0(n, e, t, s, c) {
        const y = c ? "class" : "style";
        Pt(n, t, e.inputs[y], y, s);
      }
      function Ye(n, e, t, s) {
        const c = Ze(),
          p = mn(),
          y = 22 + n,
          w = c[11],
          C = (c[y] = Gl(
            w,
            e,
            (function z() {
              return Bt.lFrame.currentNamespace;
            })()
          )),
          P = p.firstCreatePass
            ? (function bD(n, e, t, s, c, p, y) {
                const w = e.consts,
                  P = Kc(e, n, 2, c, Do(w, p));
                return (
                  h(e, t, P, Do(w, y)),
                  null !== P.attrs && At(P, P.attrs, !1),
                  null !== P.mergedAttrs && At(P, P.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, P),
                  P
                );
              })(y, p, c, 0, e, t, s)
            : p.data[y];
        Xo(P, !0);
        const N = P.mergedAttrs;
        null !== N && Le(w, C, N);
        const j = P.classes;
        null !== j && Qu(w, C, j);
        const Q = P.styles;
        return (
          null !== Q && li(w, C, Q),
          64 != (64 & P.flags) && jp(p, c, C, P),
          0 ===
            (function _p() {
              return Bt.lFrame.elementDepthCount;
            })() && Dr(C, c),
          (function Qs() {
            Bt.lFrame.elementDepthCount++;
          })(),
          Du(P) && (ff(p, c, P), ag(p, P, c)),
          null !== s && mf(c, P),
          Ye
        );
      }
      function Je() {
        let n = ki();
        Or() ? Lu() : ((n = n.parent), Xo(n, !1));
        const e = n;
        !(function yp() {
          Bt.lFrame.elementDepthCount--;
        })();
        const t = mn();
        return (
          t.firstCreatePass && (q(t, n), zh(n) && t.queries.elementEnd(n)),
          null != e.classesWithoutHost &&
            (function ge(n) {
              return 0 != (16 & n.flags);
            })(e) &&
            D0(t, e, Ze(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function Te(n) {
              return 0 != (32 & n.flags);
            })(e) &&
            D0(t, e, Ze(), e.stylesWithoutHost, !1),
          Je
        );
      }
      function an(n, e, t, s) {
        return Ye(n, e, t, s), Je(), an;
      }
      function dg(n, e, t) {
        const s = Ze(),
          c = mn(),
          p = n + 22,
          y = c.firstCreatePass
            ? (function wD(n, e, t, s, c) {
                const p = e.consts,
                  y = Do(p, s),
                  w = Kc(e, n, 8, "ng-container", y);
                return (
                  null !== y && At(w, y, !0),
                  h(e, t, w, Do(p, c)),
                  null !== e.queries && e.queries.elementStart(e, w),
                  w
                );
              })(p, c, s, e, t)
            : c.data[p];
        Xo(y, !0);
        const w = (s[p] = s[11].createComment(""));
        return (
          jp(c, s, w, y),
          Dr(w, s),
          Du(y) && (ff(c, s, y), ag(c, y, s)),
          null != t && mf(s, y),
          dg
        );
      }
      function pg() {
        let n = ki();
        const e = mn();
        return (
          Or() ? Lu() : ((n = n.parent), Xo(n, !1)),
          e.firstCreatePass && (q(e, n), zh(n) && e.queries.elementEnd(n)),
          pg
        );
      }
      function my(n, e, t) {
        return dg(n, e, t), pg(), my;
      }
      function fg() {
        return Ze();
      }
      function C0(n) {
        return !!n && "function" == typeof n.then;
      }
      const ED = function $b(n) {
        return !!n && "function" == typeof n.subscribe;
      };
      function yh(n, e, t, s) {
        const c = Ze(),
          p = mn(),
          y = ki();
        return (
          (function Gb(n, e, t, s, c, p, y, w) {
            const C = Du(s),
              N = n.firstCreatePass && Lt(n),
              j = e[8],
              Q = rt(e);
            let ie = !0;
            if (3 & s.type || w) {
              const Oe = ji(s, e),
                Ue = w ? w(Oe) : Oe,
                ht = Q.length,
                ze = w ? (un) => w(oi(un[s.index])) : s.index;
              let vt = null;
              if (
                (!w &&
                  C &&
                  (vt = (function TD(n, e, t, s) {
                    const c = n.cleanup;
                    if (null != c)
                      for (let p = 0; p < c.length - 1; p += 2) {
                        const y = c[p];
                        if (y === t && c[p + 1] === s) {
                          const w = e[7],
                            C = c[p + 2];
                          return w.length > C ? w[C] : null;
                        }
                        "string" == typeof y && (p += 2);
                      }
                    return null;
                  })(n, e, c, s.index)),
                null !== vt)
              )
                ((vt.__ngLastListenerFn__ || vt).__ngNextListenerFn__ = p),
                  (vt.__ngLastListenerFn__ = p),
                  (ie = !1);
              else {
                p = Wb(s, e, j, p, !1);
                const un = t.listen(Ue, c, p);
                Q.push(p, un), N && N.push(c, ze, ht, ht + 1);
              }
            } else p = Wb(s, e, j, p, !1);
            const pe = s.outputs;
            let Ee;
            if (ie && null !== pe && (Ee = pe[c])) {
              const Oe = Ee.length;
              if (Oe)
                for (let Ue = 0; Ue < Oe; Ue += 2) {
                  const Rn = e[Ee[Ue]][Ee[Ue + 1]].subscribe(p),
                    Fi = Q.length;
                  Q.push(p, Rn), N && N.push(c, s.index, Fi, -(Fi + 1));
                }
            }
          })(p, c, c[11], y, n, e, 0, s),
          yh
        );
      }
      function qb(n, e, t, s) {
        try {
          return !1 !== t(s);
        } catch (c) {
          return bt(n, c), !1;
        }
      }
      function Wb(n, e, t, s, c) {
        return function p(y) {
          if (y === Function) return s;
          Ve(2 & n.flags ? Ui(n.index, e) : e);
          let C = qb(e, 0, s, y),
            P = p.__ngNextListenerFn__;
          for (; P; ) (C = qb(e, 0, P, y) && C), (P = P.__ngNextListenerFn__);
          return c && !1 === C && (y.preventDefault(), (y.returnValue = !1)), C;
        };
      }
      function po(n = 1) {
        return (function u(n) {
          return (Bt.lFrame.contextLView = (function g(n, e) {
            for (; n > 0; ) (e = e[15]), n--;
            return e;
          })(n, Bt.lFrame.contextLView))[8];
        })(n);
      }
      function DD(n, e) {
        let t = null;
        const s = (function Nd(n) {
          const e = n.attrs;
          if (null != e) {
            const t = e.indexOf(5);
            if (0 == (1 & t)) return e[t + 1];
          }
          return null;
        })(n);
        for (let c = 0; c < e.length; c++) {
          const p = e[c];
          if ("*" !== p) {
            if (null === s ? Gm(n, p, !0) : xs(s, p)) return c;
          } else t = c;
        }
        return t;
      }
      function S0(n) {
        const e = Ze()[16][6];
        if (!e.projection) {
          const s = (e.projection = Kr(n ? n.length : 1, null)),
            c = s.slice();
          let p = e.child;
          for (; null !== p; ) {
            const y = n ? DD(p, n) : 0;
            null !== y &&
              (c[y] ? (c[y].projectionNext = p) : (s[y] = p), (c[y] = p)),
              (p = p.next);
          }
        }
      }
      function I0(n, e = 0, t) {
        const s = Ze(),
          c = mn(),
          p = Kc(c, 22 + n, 16, null, t || null);
        null === p.projection && (p.projection = e),
          Lu(),
          64 != (64 & p.flags) &&
            (function bm(n, e, t) {
              d_(e[11], 0, e, t, mm(n, t, e), Vp(t.parent || e[6], t, e));
            })(c, s, p);
      }
      function r1(n, e, t, s, c) {
        const p = n[t + 1],
          y = null === e;
        let w = s ? lo(p) : bs(p),
          C = !1;
        for (; 0 !== w && (!1 === C || y); ) {
          const N = n[w + 1];
          ID(n[w], e) && ((C = !0), (n[w + 1] = s ? Gd(N) : Hd(N))),
            (w = s ? lo(N) : bs(N));
        }
        C && (n[t + 1] = s ? Hd(p) : Gd(p));
      }
      function ID(n, e) {
        return (
          null === n ||
          null == e ||
          (Array.isArray(n) ? n[1] : n) === e ||
          (!(!Array.isArray(n) || "string" != typeof e) && kc(n, e) >= 0)
        );
      }
      const Sr = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };
      function o1(n) {
        return n.substring(Sr.key, Sr.keyEnd);
      }
      function s1(n, e) {
        const t = Sr.textEnd;
        return t === e
          ? -1
          : ((e = Sr.keyEnd =
              (function LD(n, e, t) {
                for (; e < t && n.charCodeAt(e) > 32; ) e++;
                return e;
              })(n, (Sr.key = e), t)),
            xf(n, e, t));
      }
      function xf(n, e, t) {
        for (; e < t && n.charCodeAt(e) <= 32; ) e++;
        return e;
      }
      function A0(n) {
        dl(Qn, tc, n, !0);
      }
      function tc(n, e) {
        for (
          let t = (function AD(n) {
            return (
              (function l1(n) {
                (Sr.key = 0),
                  (Sr.keyEnd = 0),
                  (Sr.value = 0),
                  (Sr.valueEnd = 0),
                  (Sr.textEnd = n.length);
              })(n),
              s1(n, xf(n, 0, Sr.textEnd))
            );
          })(e);
          t >= 0;
          t = s1(e, t)
        )
          Qn(n, o1(e), !0);
      }
      function dl(n, e, t, s) {
        const c = mn(),
          p = (function Fr(n) {
            const e = Bt.lFrame,
              t = e.bindingIndex;
            return (e.bindingIndex = e.bindingIndex + n), t;
          })(2);
        c.firstUpdatePass &&
          (function f1(n, e, t, s) {
            const c = n.data;
            if (null === c[t + 1]) {
              const p = c[v()],
                y = p1(n, t);
              y1(p, s) && null === e && !y && (e = !1),
                (e = (function FD(n, e, t, s) {
                  const c = (function Ic(n) {
                    const e = Bt.lFrame.currentDirectiveIndex;
                    return -1 === e ? null : n[e];
                  })(n);
                  let p = s ? e.residualClasses : e.residualStyles;
                  if (null === c)
                    0 === (s ? e.classBindings : e.styleBindings) &&
                      ((t = mg((t = P0(null, n, e, t, s)), e.attrs, s)),
                      (p = null));
                  else {
                    const y = e.directiveStylingLast;
                    if (-1 === y || n[y] !== c)
                      if (((t = P0(c, n, e, t, s)), null === p)) {
                        let C = (function ND(n, e, t) {
                          const s = t ? e.classBindings : e.styleBindings;
                          if (0 !== bs(s)) return n[lo(s)];
                        })(n, e, s);
                        void 0 !== C &&
                          Array.isArray(C) &&
                          ((C = P0(null, n, e, C[1], s)),
                          (C = mg(C, e.attrs, s)),
                          (function zD(n, e, t, s) {
                            n[lo(t ? e.classBindings : e.styleBindings)] = s;
                          })(n, e, s, C));
                      } else
                        p = (function BD(n, e, t) {
                          let s;
                          const c = e.directiveEnd;
                          for (let p = 1 + e.directiveStylingLast; p < c; p++)
                            s = mg(s, n[p].hostAttrs, t);
                          return mg(s, e.attrs, t);
                        })(n, e, s);
                  }
                  return (
                    void 0 !== p &&
                      (s ? (e.residualClasses = p) : (e.residualStyles = p)),
                    t
                  );
                })(c, p, e, s)),
                (function CD(n, e, t, s, c, p) {
                  let y = p ? e.classBindings : e.styleBindings,
                    w = lo(y),
                    C = bs(y);
                  n[s] = t;
                  let N,
                    P = !1;
                  if (Array.isArray(t)) {
                    const j = t;
                    (N = j[1]), (null === N || kc(j, N) > 0) && (P = !0);
                  } else N = t;
                  if (c)
                    if (0 !== C) {
                      const Q = lo(n[w + 1]);
                      (n[s + 1] = Wc(Q, w)),
                        0 !== Q && (n[Q + 1] = fa(n[Q + 1], s)),
                        (n[w + 1] = (function h0(n, e) {
                          return (131071 & n) | (e << 17);
                        })(n[w + 1], s));
                    } else
                      (n[s + 1] = Wc(w, 0)),
                        0 !== w && (n[w + 1] = fa(n[w + 1], s)),
                        (w = s);
                  else
                    (n[s + 1] = Wc(C, 0)),
                      0 === w ? (w = s) : (n[C + 1] = fa(n[C + 1], s)),
                      (C = s);
                  P && (n[s + 1] = Hd(n[s + 1])),
                    r1(n, N, s, !0),
                    r1(n, N, s, !1),
                    (function SD(n, e, t, s, c) {
                      const p = c ? n.residualClasses : n.residualStyles;
                      null != p &&
                        "string" == typeof e &&
                        kc(p, e) >= 0 &&
                        (t[s + 1] = Gd(t[s + 1]));
                    })(e, N, n, s, p),
                    (y = Wc(w, C)),
                    p ? (e.classBindings = y) : (e.styleBindings = y);
                })(c, p, e, t, y, s);
            }
          })(c, null, p, s);
        const y = Ze();
        if (t !== Gt && Cr(y, p, t)) {
          const w = c.data[v()];
          if (y1(w, s) && !p1(c, p)) {
            let C = s ? w.classesWithoutHost : w.stylesWithoutHost;
            null !== C && (t = $t(C, t || "")), D0(c, w, y, t, s);
          } else
            !(function jD(n, e, t, s, c, p, y, w) {
              c === Gt && (c = wn);
              let C = 0,
                P = 0,
                N = 0 < c.length ? c[0] : null,
                j = 0 < p.length ? p[0] : null;
              for (; null !== N || null !== j; ) {
                const Q = C < c.length ? c[C + 1] : void 0,
                  ie = P < p.length ? p[P + 1] : void 0;
                let Ee,
                  pe = null;
                N === j
                  ? ((C += 2), (P += 2), Q !== ie && ((pe = j), (Ee = ie)))
                  : null === j || (null !== N && N < j)
                  ? ((C += 2), (pe = N))
                  : ((P += 2), (pe = j), (Ee = ie)),
                  null !== pe && g1(n, e, t, s, pe, Ee, y, w),
                  (N = C < c.length ? c[C] : null),
                  (j = P < p.length ? p[P] : null);
              }
            })(
              c,
              w,
              y,
              y[11],
              y[p + 1],
              (y[p + 1] = (function VD(n, e, t) {
                if (null == t || "" === t) return wn;
                const s = [],
                  c = (function ql(n) {
                    return n instanceof
                      class m_ {
                        constructor(e) {
                          this.changingThisBreaksApplicationSecurity = e;
                        }
                        toString() {
                          return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
                        }
                      }
                      ? n.changingThisBreaksApplicationSecurity
                      : n;
                  })(t);
                if (Array.isArray(c))
                  for (let p = 0; p < c.length; p++) n(s, c[p], !0);
                else if ("object" == typeof c)
                  for (const p in c) c.hasOwnProperty(p) && n(s, p, c[p]);
                else "string" == typeof c && e(s, c);
                return s;
              })(n, e, t)),
              s,
              p
            );
        }
      }
      function p1(n, e) {
        return e >= n.expandoStartIndex;
      }
      function P0(n, e, t, s, c) {
        let p = null;
        const y = t.directiveEnd;
        let w = t.directiveStylingLast;
        for (
          -1 === w ? (w = t.directiveStart) : w++;
          w < y && ((p = e[w]), (s = mg(s, p.hostAttrs, c)), p !== n);

        )
          w++;
        return null !== n && (t.directiveStylingLast = w), s;
      }
      function mg(n, e, t) {
        const s = t ? 1 : 2;
        let c = -1;
        if (null !== e)
          for (let p = 0; p < e.length; p++) {
            const y = e[p];
            "number" == typeof y
              ? (c = y)
              : c === s &&
                (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]),
                Qn(n, y, !!t || e[++p]));
          }
        return void 0 === n ? null : n;
      }
      function g1(n, e, t, s, c, p, y, w) {
        if (!(3 & e.type)) return;
        const C = n.data,
          P = C[w + 1];
        gy(
          (function ry(n) {
            return 1 == (1 & n);
          })(P)
            ? _1(C, e, t, c, bs(P), y)
            : void 0
        ) ||
          (gy(p) ||
            ((function $d(n) {
              return 2 == (2 & n);
            })(P) &&
              (p = _1(C, null, t, c, w, y))),
          (function Pv(n, e, t, s, c) {
            if (e) c ? n.addClass(t, s) : n.removeClass(t, s);
            else {
              let p = -1 === s.indexOf("-") ? void 0 : Ji.DashCase;
              null == c
                ? n.removeStyle(t, s, p)
                : ("string" == typeof c &&
                    c.endsWith("!important") &&
                    ((c = c.slice(0, -10)), (p |= Ji.Important)),
                  n.setStyle(t, s, c, p));
            }
          })(s, y, ja(v(), t), c, p));
      }
      function _1(n, e, t, s, c, p) {
        const y = null === e;
        let w;
        for (; c > 0; ) {
          const C = n[c],
            P = Array.isArray(C),
            N = P ? C[1] : C,
            j = null === N;
          let Q = t[c + 1];
          Q === Gt && (Q = j ? wn : void 0);
          let ie = j ? Tp(Q, s) : N === s ? Q : void 0;
          if ((P && !gy(ie) && (ie = Tp(C, s)), gy(ie) && ((w = ie), y)))
            return w;
          const pe = n[c + 1];
          c = y ? lo(pe) : bs(pe);
        }
        if (null !== e) {
          let C = p ? e.residualClasses : e.residualStyles;
          null != C && (w = Tp(C, s));
        }
        return w;
      }
      function gy(n) {
        return void 0 !== n;
      }
      function y1(n, e) {
        return 0 != (n.flags & (e ? 16 : 32));
      }
      function ut(n, e = "") {
        const t = Ze(),
          s = mn(),
          c = n + 22,
          p = s.firstCreatePass ? Kc(s, c, 1, e, null) : s.data[c],
          y = (t[c] = (function nl(n, e) {
            return n.createText(e);
          })(t[11], e));
        jp(s, t, y, p), Xo(p, !1);
      }
      function _y(n) {
        return L0("", n, ""), _y;
      }
      function L0(n, e, t) {
        const s = Ze(),
          c = _h(s, n, e, t);
        return (
          c !== Gt &&
            (function Yt(n, e, t) {
              const s = ja(e, n);
              !(function pm(n, e, t) {
                n.setValue(e, t);
              })(n[11], s, t);
            })(s, v(), c),
          L0
        );
      }
      const wf = "en-US";
      let j1 = wf;
      class Ef {}
      class pw extends Ef {
        constructor(e, t) {
          super(),
            (this._parent = t),
            (this._bootstrapComponents = []),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new kt(this));
          const s = (function Wr(n, e) {
            const t = n[Ho] || null;
            if (!t && !0 === e)
              throw new Error(
                `Type ${xt(n)} does not have '\u0275mod' property.`
              );
            return t;
          })(e);
          (this._bootstrapComponents = (function pa(n) {
            return n instanceof Function ? n() : n;
          })(s.bootstrap)),
            (this._r3Injector = qm(
              e,
              t,
              [
                { provide: Ef, useValue: this },
                { provide: Jp, useValue: this.componentFactoryResolver },
              ],
              xt(e),
              new Set(["environment"])
            )),
            this._r3Injector.resolveInjectorInitializers(),
            (this.instance = this._r3Injector.get(e));
        }
        get injector() {
          return this._r3Injector;
        }
        destroy() {
          const e = this._r3Injector;
          !e.destroyed && e.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null);
        }
        onDestroy(e) {
          this.destroyCbs.push(e);
        }
      }
      class B0 extends class aS {} {
        constructor(e) {
          super(), (this.moduleType = e);
        }
        create(e) {
          return new pw(this.moduleType, e);
        }
      }
      function bw(n, e, t, s) {
        return (function Ew(n, e, t, s, c, p) {
          const y = e + t;
          return Cr(n, y, c)
            ? Jo(n, y + 1, p ? s.call(p, c) : s(c))
            : bg(n, y + 1);
        })(Ze(), $i(), n, e, t, s);
      }
      function ww(n, e, t, s, c) {
        return (function Tw(n, e, t, s, c, p, y) {
          const w = e + t;
          return (function Lo(n, e, t, s) {
            const c = Cr(n, e, t);
            return Cr(n, e + 1, s) || c;
          })(n, w, c, p)
            ? Jo(n, w + 2, y ? s.call(y, c, p) : s(c, p))
            : bg(n, w + 2);
        })(Ze(), $i(), n, e, t, s, c);
      }
      function bg(n, e) {
        const t = n[e];
        return t === Gt ? void 0 : t;
      }
      function j0(n) {
        return (e) => {
          setTimeout(n, void 0, e);
        };
      }
      const xa = class OS extends rs {
        constructor(e = !1) {
          super(), (this.__isAsync = e);
        }
        emit(e) {
          super.next(e);
        }
        subscribe(e, t, s) {
          let c = e,
            p = t || (() => null),
            y = s;
          if (e && "object" == typeof e) {
            const C = e;
            (c = C.next?.bind(C)),
              (p = C.error?.bind(C)),
              (y = C.complete?.bind(C));
          }
          this.__isAsync && ((p = j0(p)), c && (c = j0(c)), y && (y = j0(y)));
          const w = super.subscribe({ next: c, error: p, complete: y });
          return e instanceof Be && e.add(w), w;
        }
      };
      function FS() {
        return this._results[Cs()]();
      }
      class U0 {
        constructor(e = !1) {
          (this._emitDistinctChangesOnly = e),
            (this.dirty = !0),
            (this._results = []),
            (this._changesDetected = !1),
            (this._changes = null),
            (this.length = 0),
            (this.first = void 0),
            (this.last = void 0);
          const t = Cs(),
            s = U0.prototype;
          s[t] || (s[t] = FS);
        }
        get changes() {
          return this._changes || (this._changes = new xa());
        }
        get(e) {
          return this._results[e];
        }
        map(e) {
          return this._results.map(e);
        }
        filter(e) {
          return this._results.filter(e);
        }
        find(e) {
          return this._results.find(e);
        }
        reduce(e, t) {
          return this._results.reduce(e, t);
        }
        forEach(e) {
          this._results.forEach(e);
        }
        some(e) {
          return this._results.some(e);
        }
        toArray() {
          return this._results.slice();
        }
        toString() {
          return this._results.toString();
        }
        reset(e, t) {
          const s = this;
          s.dirty = !1;
          const c = So(e);
          (this._changesDetected = !(function gv(n, e, t) {
            if (n.length !== e.length) return !1;
            for (let s = 0; s < n.length; s++) {
              let c = n[s],
                p = e[s];
              if ((t && ((c = t(c)), (p = t(p))), p !== c)) return !1;
            }
            return !0;
          })(s._results, c, t)) &&
            ((s._results = c),
            (s.length = c.length),
            (s.last = c[this.length - 1]),
            (s.first = c[0]));
        }
        notifyOnChanges() {
          this._changes &&
            (this._changesDetected || !this._emitDistinctChangesOnly) &&
            this._changes.emit(this);
        }
        setDirty() {
          this.dirty = !0;
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe();
        }
      }
      let nc = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = BS), n;
      })();
      const NS = nc,
        zS = class extends NS {
          constructor(e, t, s) {
            super(),
              (this._declarationLView = e),
              (this._declarationTContainer = t),
              (this.elementRef = s);
          }
          createEmbeddedView(e, t) {
            const s = this._declarationTContainer.tViews,
              c = Xd(
                this._declarationLView,
                s,
                e,
                16,
                null,
                s.declTNode,
                null,
                null,
                null,
                null,
                t || null
              );
            c[17] = this._declarationLView[this._declarationTContainer.index];
            const y = this._declarationLView[19];
            return (
              null !== y && (c[19] = y.createEmbeddedView(s)),
              pf(s, c, e),
              new In(c)
            );
          }
        };
      function BS() {
        return wy(ki(), Ze());
      }
      function wy(n, e) {
        return 4 & n.type ? new zS(e, n, ih(n, e)) : null;
      }
      let pl = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = VS), n;
      })();
      function VS() {
        return Aw(ki(), Ze());
      }
      const jS = pl,
        Iw = class extends jS {
          constructor(e, t, s) {
            super(),
              (this._lContainer = e),
              (this._hostTNode = t),
              (this._hostLView = s);
          }
          get element() {
            return ih(this._hostTNode, this._hostLView);
          }
          get injector() {
            return new Nr(this._hostTNode, this._hostLView);
          }
          get parentInjector() {
            const e = vi(this._hostTNode, this._hostLView);
            if (He(e)) {
              const t = mt(e, this._hostLView),
                s = Ne(e);
              return new Nr(t[1].data[s + 8], t);
            }
            return new Nr(null, this._hostLView);
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1);
          }
          get(e) {
            const t = Mw(this._lContainer);
            return (null !== t && t[e]) || null;
          }
          get length() {
            return this._lContainer.length - 10;
          }
          createEmbeddedView(e, t, s) {
            let c, p;
            "number" == typeof s
              ? (c = s)
              : null != s && ((c = s.index), (p = s.injector));
            const y = e.createEmbeddedView(t || {}, p);
            return this.insert(y, c), y;
          }
          createComponent(e, t, s, c, p) {
            const y =
              e &&
              !(function gs(n) {
                return "function" == typeof n;
              })(e);
            let w;
            if (y) w = t;
            else {
              const j = t || {};
              (w = j.index),
                (s = j.injector),
                (c = j.projectableNodes),
                (p = j.environmentInjector || j.ngModuleRef);
            }
            const C = y ? e : new vn(An(e)),
              P = s || this.parentInjector;
            if (!p && null == C.ngModule) {
              const Q = (y ? P : this.parentInjector).get(da, null);
              Q && (p = Q);
            }
            const N = C.create(P, c, void 0, p);
            return this.insert(N.hostView, w), N;
          }
          insert(e, t) {
            const s = e._lView,
              c = s[1];
            if (
              (function Zh(n) {
                return cr(n[3]);
              })(s)
            ) {
              const N = this.indexOf(e);
              if (-1 !== N) this.detach(N);
              else {
                const j = s[3],
                  Q = new Iw(j, j[6], j[3]);
                Q.detach(Q.indexOf(e));
              }
            }
            const p = this._adjustIndex(t),
              y = this._lContainer;
            !(function Mv(n, e, t, s) {
              const c = 10 + s,
                p = t.length;
              s > 0 && (t[c - 1][4] = e),
                s < p - 10
                  ? ((e[4] = t[c]), qf(t, 10 + s, e))
                  : (t.push(e), (e[4] = null)),
                (e[3] = t);
              const y = e[17];
              null !== y &&
                t !== y &&
                (function o_(n, e) {
                  const t = n[9];
                  e[16] !== e[3][3][16] && (n[2] = !0),
                    null === t ? (n[9] = [e]) : t.push(e);
                })(y, e);
              const w = e[19];
              null !== w && w.insertView(n), (e[2] |= 64);
            })(c, s, y, p);
            const w = ym(p, y),
              C = s[11],
              P = Bp(C, y[7]);
            return (
              null !== P &&
                (function i_(n, e, t, s, c, p) {
                  (s[0] = c), (s[6] = e), _d(n, s, t, 1, c, p);
                })(c, y[6], C, s, P, w),
              e.attachToViewContainerRef(),
              qf($0(y), p, e),
              e
            );
          }
          move(e, t) {
            return this.insert(e, t);
          }
          indexOf(e) {
            const t = Mw(this._lContainer);
            return null !== t ? t.indexOf(e) : -1;
          }
          remove(e) {
            const t = this._adjustIndex(e, -1),
              s = Np(this._lContainer, t);
            s && (td($0(this._lContainer), t), a_(s[1], s));
          }
          detach(e) {
            const t = this._adjustIndex(e, -1),
              s = Np(this._lContainer, t);
            return s && null != td($0(this._lContainer), t) ? new In(s) : null;
          }
          _adjustIndex(e, t = 0) {
            return e ?? this.length + t;
          }
        };
      function Mw(n) {
        return n[8];
      }
      function $0(n) {
        return n[8] || (n[8] = []);
      }
      function Aw(n, e) {
        let t;
        const s = e[n.index];
        if (cr(s)) t = s;
        else {
          let c;
          if (8 & n.type) c = oi(s);
          else {
            const p = e[11];
            c = p.createComment("");
            const y = ji(n, e);
            Yr(
              p,
              Bp(p, y),
              c,
              (function Av(n, e) {
                return n.nextSibling(e);
              })(p, y),
              !1
            );
          }
          (e[n.index] = t = ae(s, e, c, n)), Re(e, t);
        }
        return new Iw(t, n, e);
      }
      class H0 {
        constructor(e) {
          (this.queryList = e), (this.matches = null);
        }
        clone() {
          return new H0(this.queryList);
        }
        setDirty() {
          this.queryList.setDirty();
        }
      }
      class G0 {
        constructor(e = []) {
          this.queries = e;
        }
        createEmbeddedView(e) {
          const t = e.queries;
          if (null !== t) {
            const s =
                null !== e.contentQueries ? e.contentQueries[0] : t.length,
              c = [];
            for (let p = 0; p < s; p++) {
              const y = t.getByIndex(p);
              c.push(this.queries[y.indexInDeclarationView].clone());
            }
            return new G0(c);
          }
          return null;
        }
        insertView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        detachView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        dirtyQueriesWithMatches(e) {
          for (let t = 0; t < this.queries.length; t++)
            null !== Ow(e, t).matches && this.queries[t].setDirty();
        }
      }
      class Pw {
        constructor(e, t, s = null) {
          (this.predicate = e), (this.flags = t), (this.read = s);
        }
      }
      class q0 {
        constructor(e = []) {
          this.queries = e;
        }
        elementStart(e, t) {
          for (let s = 0; s < this.queries.length; s++)
            this.queries[s].elementStart(e, t);
        }
        elementEnd(e) {
          for (let t = 0; t < this.queries.length; t++)
            this.queries[t].elementEnd(e);
        }
        embeddedTView(e) {
          let t = null;
          for (let s = 0; s < this.length; s++) {
            const c = null !== t ? t.length : 0,
              p = this.getByIndex(s).embeddedTView(e, c);
            p &&
              ((p.indexInDeclarationView = s),
              null !== t ? t.push(p) : (t = [p]));
          }
          return null !== t ? new q0(t) : null;
        }
        template(e, t) {
          for (let s = 0; s < this.queries.length; s++)
            this.queries[s].template(e, t);
        }
        getByIndex(e) {
          return this.queries[e];
        }
        get length() {
          return this.queries.length;
        }
        track(e) {
          this.queries.push(e);
        }
      }
      class W0 {
        constructor(e, t = -1) {
          (this.metadata = e),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = t);
        }
        elementStart(e, t) {
          this.isApplyingToNode(t) && this.matchTNode(e, t);
        }
        elementEnd(e) {
          this._declarationNodeIndex === e.index &&
            (this._appliesToNextNode = !1);
        }
        template(e, t) {
          this.elementStart(e, t);
        }
        embeddedTView(e, t) {
          return this.isApplyingToNode(e)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-e.index, t),
              new W0(this.metadata))
            : null;
        }
        isApplyingToNode(e) {
          if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
            const t = this._declarationNodeIndex;
            let s = e.parent;
            for (; null !== s && 8 & s.type && s.index !== t; ) s = s.parent;
            return t === (null !== s ? s.index : -1);
          }
          return this._appliesToNextNode;
        }
        matchTNode(e, t) {
          const s = this.metadata.predicate;
          if (Array.isArray(s))
            for (let c = 0; c < s.length; c++) {
              const p = s[c];
              this.matchTNodeWithReadOption(e, t, HS(t, p)),
                this.matchTNodeWithReadOption(e, t, Fn(t, e, p, !1, !1));
            }
          else
            s === nc
              ? 4 & t.type && this.matchTNodeWithReadOption(e, t, -1)
              : this.matchTNodeWithReadOption(e, t, Fn(t, e, s, !1, !1));
        }
        matchTNodeWithReadOption(e, t, s) {
          if (null !== s) {
            const c = this.metadata.read;
            if (null !== c)
              if (c === sl || c === pl || (c === nc && 4 & t.type))
                this.addMatch(t.index, -2);
              else {
                const p = Fn(t, e, c, !1, !1);
                null !== p && this.addMatch(t.index, p);
              }
            else this.addMatch(t.index, s);
          }
        }
        addMatch(e, t) {
          null === this.matches
            ? (this.matches = [e, t])
            : this.matches.push(e, t);
        }
      }
      function HS(n, e) {
        const t = n.localNames;
        if (null !== t)
          for (let s = 0; s < t.length; s += 2) if (t[s] === e) return t[s + 1];
        return null;
      }
      function qS(n, e, t, s) {
        return -1 === t
          ? (function GS(n, e) {
              return 11 & n.type ? ih(n, e) : 4 & n.type ? wy(n, e) : null;
            })(e, n)
          : -2 === t
          ? (function WS(n, e, t) {
              return t === sl
                ? ih(e, n)
                : t === nc
                ? wy(e, n)
                : t === pl
                ? Aw(e, n)
                : void 0;
            })(n, e, s)
          : Gi(n, n[1], t, e);
      }
      function Lw(n, e, t, s) {
        const c = e[19].queries[s];
        if (null === c.matches) {
          const p = n.data,
            y = t.matches,
            w = [];
          for (let C = 0; C < y.length; C += 2) {
            const P = y[C];
            w.push(P < 0 ? null : qS(e, p[P], y[C + 1], t.metadata.read));
          }
          c.matches = w;
        }
        return c.matches;
      }
      function Z0(n, e, t, s) {
        const c = n.queries.getByIndex(t),
          p = c.matches;
        if (null !== p) {
          const y = Lw(n, e, c, t);
          for (let w = 0; w < p.length; w += 2) {
            const C = p[w];
            if (C > 0) s.push(y[w / 2]);
            else {
              const P = p[w + 1],
                N = e[-C];
              for (let j = 10; j < N.length; j++) {
                const Q = N[j];
                Q[17] === Q[3] && Z0(Q[1], Q, P, s);
              }
              if (null !== N[9]) {
                const j = N[9];
                for (let Q = 0; Q < j.length; Q++) {
                  const ie = j[Q];
                  Z0(ie[1], ie, P, s);
                }
              }
            }
          }
        }
        return s;
      }
      function Jc(n) {
        const e = Ze(),
          t = mn(),
          s = Jh();
        Ou(s + 1);
        const c = Ow(t, s);
        if (
          n.dirty &&
          (function Wh(n) {
            return 4 == (4 & n[2]);
          })(e) ===
            (2 == (2 & c.metadata.flags))
        ) {
          if (null === c.matches) n.reset([]);
          else {
            const p = c.crossesNgTemplate ? Z0(t, e, s, []) : Lw(t, e, c, s);
            n.reset(p, ef), n.notifyOnChanges();
          }
          return !0;
        }
        return !1;
      }
      function Jd(n, e, t) {
        const s = mn();
        s.firstCreatePass &&
          (Rw(s, new Pw(n, e, t), -1),
          2 == (2 & e) && (s.staticViewQueries = !0)),
          kw(s, Ze(), e);
      }
      function X0(n, e, t, s) {
        const c = mn();
        if (c.firstCreatePass) {
          const p = ki();
          Rw(c, new Pw(e, t, s), p.index),
            (function XS(n, e) {
              const t = n.contentQueries || (n.contentQueries = []);
              e !== (t.length ? t[t.length - 1] : -1) &&
                t.push(n.queries.length - 1, e);
            })(c, n),
            2 == (2 & t) && (c.staticContentQueries = !0);
        }
        kw(c, Ze(), t);
      }
      function eu() {
        return (function ZS(n, e) {
          return n[19].queries[e].queryList;
        })(Ze(), Jh());
      }
      function kw(n, e, t) {
        const s = new U0(4 == (4 & t));
        gf(n, e, s, s.destroy),
          null === e[19] && (e[19] = new G0()),
          e[19].queries.push(new H0(s));
      }
      function Rw(n, e, t) {
        null === n.queries && (n.queries = new q0()),
          n.queries.track(new W0(e, t));
      }
      function Ow(n, e) {
        return n.queries.getByIndex(e);
      }
      function Ty(...n) {}
      const eE = new sn("Application Initializer");
      let Dy = (() => {
        class n {
          constructor(t) {
            (this.appInits = t),
              (this.resolve = Ty),
              (this.reject = Ty),
              (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((s, c) => {
                (this.resolve = s), (this.reject = c);
              }));
          }
          runInitializers() {
            if (this.initialized) return;
            const t = [],
              s = () => {
                (this.done = !0), this.resolve();
              };
            if (this.appInits)
              for (let c = 0; c < this.appInits.length; c++) {
                const p = this.appInits[c]();
                if (C0(p)) t.push(p);
                else if (ED(p)) {
                  const y = new Promise((w, C) => {
                    p.subscribe({ complete: w, error: C });
                  });
                  t.push(y);
                }
              }
            Promise.all(t)
              .then(() => {
                s();
              })
              .catch((c) => {
                this.reject(c);
              }),
              0 === t.length && s(),
              (this.initialized = !0);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(eE, 8));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const Tg = new sn("AppId", {
        providedIn: "root",
        factory: function tE() {
          return `${ex()}${ex()}${ex()}`;
        },
      });
      function ex() {
        return String.fromCharCode(97 + Math.floor(25 * Math.random()));
      }
      const nE = new sn("Platform Initializer"),
        iE = new sn("Platform ID", {
          providedIn: "platform",
          factory: () => "unknown",
        }),
        gI = new sn("appBootstrapListener"),
        rE = new sn("AnimationModuleType"),
        tu = new sn("LocaleId", {
          providedIn: "root",
          factory: () =>
            (function Xf(n, e = St.Default) {
              return (
                "number" != typeof e &&
                  (e =
                    0 |
                    (e.optional && 8) |
                    (e.host && 1) |
                    (e.self && 2) |
                    (e.skipSelf && 4)),
                Mt(n, e)
              );
            })(tu, St.Optional | St.SkipSelf) ||
            (function _I() {
              return (typeof $localize < "u" && $localize.locale) || wf;
            })(),
        }),
        wI = (() => Promise.resolve(0))();
      function tx(n) {
        typeof Zone > "u"
          ? wI.then(() => {
              n && n.apply(null, null);
            })
          : Zone.current.scheduleMicroTask("scheduleMicrotask", n);
      }
      class dr {
        constructor({
          enableLongStackTrace: e = !1,
          shouldCoalesceEventChangeDetection: t = !1,
          shouldCoalesceRunChangeDetection: s = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new xa(!1)),
            (this.onMicrotaskEmpty = new xa(!1)),
            (this.onStable = new xa(!1)),
            (this.onError = new xa(!1)),
            typeof Zone > "u")
          )
            throw new st(908, !1);
          Zone.assertZonePatched();
          const c = this;
          if (
            ((c._nesting = 0),
            (c._outer = c._inner = Zone.current),
            Zone.AsyncStackTaggingZoneSpec)
          ) {
            const p = Zone.AsyncStackTaggingZoneSpec;
            c._inner = c._inner.fork(new p("Angular"));
          }
          Zone.TaskTrackingZoneSpec &&
            (c._inner = c._inner.fork(new Zone.TaskTrackingZoneSpec())),
            e &&
              Zone.longStackTraceZoneSpec &&
              (c._inner = c._inner.fork(Zone.longStackTraceZoneSpec)),
            (c.shouldCoalesceEventChangeDetection = !s && t),
            (c.shouldCoalesceRunChangeDetection = s),
            (c.lastRequestAnimationFrameId = -1),
            (c.nativeRequestAnimationFrame = (function EI() {
              let n = $n.requestAnimationFrame,
                e = $n.cancelAnimationFrame;
              if (typeof Zone < "u" && n && e) {
                const t = n[Zone.__symbol__("OriginalDelegate")];
                t && (n = t);
                const s = e[Zone.__symbol__("OriginalDelegate")];
                s && (e = s);
              }
              return {
                nativeRequestAnimationFrame: n,
                nativeCancelAnimationFrame: e,
              };
            })().nativeRequestAnimationFrame),
            (function CI(n) {
              const e = () => {
                !(function DI(n) {
                  n.isCheckStableRunning ||
                    -1 !== n.lastRequestAnimationFrameId ||
                    ((n.lastRequestAnimationFrameId =
                      n.nativeRequestAnimationFrame.call($n, () => {
                        n.fakeTopEventTask ||
                          (n.fakeTopEventTask = Zone.root.scheduleEventTask(
                            "fakeTopEventTask",
                            () => {
                              (n.lastRequestAnimationFrameId = -1),
                                ix(n),
                                (n.isCheckStableRunning = !0),
                                nx(n),
                                (n.isCheckStableRunning = !1);
                            },
                            void 0,
                            () => {},
                            () => {}
                          )),
                          n.fakeTopEventTask.invoke();
                      })),
                    ix(n));
                })(n);
              };
              n._inner = n._inner.fork({
                name: "angular",
                properties: { isAngularZone: !0 },
                onInvokeTask: (t, s, c, p, y, w) => {
                  try {
                    return aE(n), t.invokeTask(c, p, y, w);
                  } finally {
                    ((n.shouldCoalesceEventChangeDetection &&
                      "eventTask" === p.type) ||
                      n.shouldCoalesceRunChangeDetection) &&
                      e(),
                      lE(n);
                  }
                },
                onInvoke: (t, s, c, p, y, w, C) => {
                  try {
                    return aE(n), t.invoke(c, p, y, w, C);
                  } finally {
                    n.shouldCoalesceRunChangeDetection && e(), lE(n);
                  }
                },
                onHasTask: (t, s, c, p) => {
                  t.hasTask(c, p),
                    s === c &&
                      ("microTask" == p.change
                        ? ((n._hasPendingMicrotasks = p.microTask),
                          ix(n),
                          nx(n))
                        : "macroTask" == p.change &&
                          (n.hasPendingMacrotasks = p.macroTask));
                },
                onHandleError: (t, s, c, p) => (
                  t.handleError(c, p),
                  n.runOutsideAngular(() => n.onError.emit(p)),
                  !1
                ),
              });
            })(c);
        }
        static isInAngularZone() {
          return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone");
        }
        static assertInAngularZone() {
          if (!dr.isInAngularZone()) throw new st(909, !1);
        }
        static assertNotInAngularZone() {
          if (dr.isInAngularZone()) throw new st(909, !1);
        }
        run(e, t, s) {
          return this._inner.run(e, t, s);
        }
        runTask(e, t, s, c) {
          const p = this._inner,
            y = p.scheduleEventTask("NgZoneEvent: " + c, e, TI, Ty, Ty);
          try {
            return p.runTask(y, t, s);
          } finally {
            p.cancelTask(y);
          }
        }
        runGuarded(e, t, s) {
          return this._inner.runGuarded(e, t, s);
        }
        runOutsideAngular(e) {
          return this._outer.run(e);
        }
      }
      const TI = {};
      function nx(n) {
        if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable)
          try {
            n._nesting++, n.onMicrotaskEmpty.emit(null);
          } finally {
            if ((n._nesting--, !n.hasPendingMicrotasks))
              try {
                n.runOutsideAngular(() => n.onStable.emit(null));
              } finally {
                n.isStable = !0;
              }
          }
      }
      function ix(n) {
        n.hasPendingMicrotasks = !!(
          n._hasPendingMicrotasks ||
          ((n.shouldCoalesceEventChangeDetection ||
            n.shouldCoalesceRunChangeDetection) &&
            -1 !== n.lastRequestAnimationFrameId)
        );
      }
      function aE(n) {
        n._nesting++,
          n.isStable && ((n.isStable = !1), n.onUnstable.emit(null));
      }
      function lE(n) {
        n._nesting--, nx(n);
      }
      class SI {
        constructor() {
          (this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new xa()),
            (this.onMicrotaskEmpty = new xa()),
            (this.onStable = new xa()),
            (this.onError = new xa());
        }
        run(e, t, s) {
          return e.apply(t, s);
        }
        runGuarded(e, t, s) {
          return e.apply(t, s);
        }
        runOutsideAngular(e) {
          return e();
        }
        runTask(e, t, s, c) {
          return e.apply(t, s);
        }
      }
      const cE = new sn(""),
        Cy = new sn("");
      let sx,
        rx = (() => {
          class n {
            constructor(t, s, c) {
              (this._ngZone = t),
                (this.registry = s),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                sx ||
                  ((function II(n) {
                    sx = n;
                  })(c),
                  c.addToWindow(s)),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    typeof Zone > "u"
                      ? null
                      : Zone.current.get("TaskTrackingZone");
                });
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  (this._didWork = !0), (this._isZoneStable = !1);
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      dr.assertNotInAngularZone(),
                        tx(() => {
                          (this._isZoneStable = !0),
                            this._runCallbacksIfReady();
                        });
                    },
                  });
                });
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              );
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error("pending async requests below zero");
              return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              );
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                tx(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop();
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork);
                  }
                  this._didWork = !1;
                });
              else {
                let t = this.getPendingTasks();
                (this._callbacks = this._callbacks.filter(
                  (s) =>
                    !s.updateCb ||
                    !s.updateCb(t) ||
                    (clearTimeout(s.timeoutId), !1)
                )),
                  (this._didWork = !0);
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : [];
            }
            addCallback(t, s, c) {
              let p = -1;
              s &&
                s > 0 &&
                (p = setTimeout(() => {
                  (this._callbacks = this._callbacks.filter(
                    (y) => y.timeoutId !== p
                  )),
                    t(this._didWork, this.getPendingTasks());
                }, s)),
                this._callbacks.push({ doneCb: t, timeoutId: p, updateCb: c });
            }
            whenStable(t, s, c) {
              if (c && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'
                );
              this.addCallback(t, s, c), this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
              return this._pendingCount;
            }
            registerApplication(t) {
              this.registry.registerApplication(t, this);
            }
            unregisterApplication(t) {
              this.registry.unregisterApplication(t);
            }
            findProviders(t, s, c) {
              return [];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Mt(dr), Mt(ox), Mt(Cy));
            }),
            (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        ox = (() => {
          class n {
            constructor() {
              this._applications = new Map();
            }
            registerApplication(t, s) {
              this._applications.set(t, s);
            }
            unregisterApplication(t) {
              this._applications.delete(t);
            }
            unregisterAllApplications() {
              this._applications.clear();
            }
            getTestability(t) {
              return this._applications.get(t) || null;
            }
            getAllTestabilities() {
              return Array.from(this._applications.values());
            }
            getAllRootElements() {
              return Array.from(this._applications.keys());
            }
            findTestabilityInTree(t, s = !0) {
              return sx?.findTestabilityInTree(this, t, s) ?? null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Mn({
              token: n,
              factory: n.ɵfac,
              providedIn: "platform",
            })),
            n
          );
        })(),
        vh = null;
      const uE = new sn("AllowMultipleToken"),
        ax = new sn("PlatformDestroyListeners");
      function dE(n, e, t = []) {
        const s = `Platform: ${e}`,
          c = new sn(s);
        return (p = []) => {
          let y = lx();
          if (!y || y.injector.get(uE, !1)) {
            const w = [...t, ...p, { provide: c, useValue: !0 }];
            n
              ? n(w)
              : (function PI(n) {
                  if (vh && !vh.get(uE, !1)) throw new st(400, !1);
                  vh = n;
                  const e = n.get(fE);
                  (function hE(n) {
                    const e = n.get(nE, null);
                    e && e.forEach((t) => t());
                  })(n);
                })(
                  (function pE(n = [], e) {
                    return Hc.create({
                      name: e,
                      providers: [
                        { provide: Pd, useValue: "platform" },
                        { provide: ax, useValue: new Set([() => (vh = null)]) },
                        ...n,
                      ],
                    });
                  })(w, s)
                );
          }
          return (function kI(n) {
            const e = lx();
            if (!e) throw new st(401, !1);
            return e;
          })();
        };
      }
      function lx() {
        return vh?.get(fE) ?? null;
      }
      let fE = (() => {
        class n {
          constructor(t) {
            (this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1);
          }
          bootstrapModuleFactory(t, s) {
            const c = (function gE(n, e) {
                let t;
                return (
                  (t =
                    "noop" === n
                      ? new SI()
                      : ("zone.js" === n ? void 0 : n) || new dr(e)),
                  t
                );
              })(
                s?.ngZone,
                (function mE(n) {
                  return {
                    enableLongStackTrace: !1,
                    shouldCoalesceEventChangeDetection:
                      !(!n || !n.ngZoneEventCoalescing) || !1,
                    shouldCoalesceRunChangeDetection:
                      !(!n || !n.ngZoneRunCoalescing) || !1,
                  };
                })(s)
              ),
              p = [{ provide: dr, useValue: c }];
            return c.run(() => {
              const y = Hc.create({
                  providers: p,
                  parent: this.injector,
                  name: t.moduleType.name,
                }),
                w = t.create(y),
                C = w.injector.get(Uc, null);
              if (!C) throw new st(402, !1);
              return (
                c.runOutsideAngular(() => {
                  const P = c.onError.subscribe({
                    next: (N) => {
                      C.handleError(N);
                    },
                  });
                  w.onDestroy(() => {
                    Iy(this._modules, w), P.unsubscribe();
                  });
                }),
                (function _E(n, e, t) {
                  try {
                    const s = t();
                    return C0(s)
                      ? s.catch((c) => {
                          throw (
                            (e.runOutsideAngular(() => n.handleError(c)), c)
                          );
                        })
                      : s;
                  } catch (s) {
                    throw (e.runOutsideAngular(() => n.handleError(s)), s);
                  }
                })(C, c, () => {
                  const P = w.injector.get(Dy);
                  return (
                    P.runInitializers(),
                    P.donePromise.then(
                      () => (
                        (function U1(n) {
                          pn(n, "Expected localeId to be defined"),
                            "string" == typeof n &&
                              (j1 = n.toLowerCase().replace(/_/g, "-"));
                        })(w.injector.get(tu, wf) || wf),
                        this._moduleDoBootstrap(w),
                        w
                      )
                    )
                  );
                })
              );
            });
          }
          bootstrapModule(t, s = []) {
            const c = yE({}, s);
            return (function MI(n, e, t) {
              const s = new B0(t);
              return Promise.resolve(s);
            })(0, 0, t).then((p) => this.bootstrapModuleFactory(p, c));
          }
          _moduleDoBootstrap(t) {
            const s = t.injector.get(Sy);
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((c) => s.bootstrap(c));
            else {
              if (!t.instance.ngDoBootstrap) throw new st(403, !1);
              t.instance.ngDoBootstrap(s);
            }
            this._modules.push(t);
          }
          onDestroy(t) {
            this._destroyListeners.push(t);
          }
          get injector() {
            return this._injector;
          }
          destroy() {
            if (this._destroyed) throw new st(404, !1);
            this._modules.slice().forEach((s) => s.destroy()),
              this._destroyListeners.forEach((s) => s());
            const t = this._injector.get(ax, null);
            t && (t.forEach((s) => s()), t.clear()), (this._destroyed = !0);
          }
          get destroyed() {
            return this._destroyed;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(Hc));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac, providedIn: "platform" })),
          n
        );
      })();
      function yE(n, e) {
        return Array.isArray(e) ? e.reduce(yE, n) : { ...n, ...e };
      }
      let Sy = (() => {
        class n {
          constructor(t, s, c) {
            (this._zone = t),
              (this._injector = s),
              (this._exceptionHandler = c),
              (this._bootstrapListeners = []),
              (this._views = []),
              (this._runningTick = !1),
              (this._stable = !0),
              (this._destroyed = !1),
              (this._destroyListeners = []),
              (this.componentTypes = []),
              (this.components = []),
              (this._onMicrotaskEmptySubscription =
                this._zone.onMicrotaskEmpty.subscribe({
                  next: () => {
                    this._zone.run(() => {
                      this.tick();
                    });
                  },
                }));
            const p = new Tn((w) => {
                (this._stable =
                  this._zone.isStable &&
                  !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks),
                  this._zone.runOutsideAngular(() => {
                    w.next(this._stable), w.complete();
                  });
              }),
              y = new Tn((w) => {
                let C;
                this._zone.runOutsideAngular(() => {
                  C = this._zone.onStable.subscribe(() => {
                    dr.assertNotInAngularZone(),
                      tx(() => {
                        !this._stable &&
                          !this._zone.hasPendingMacrotasks &&
                          !this._zone.hasPendingMicrotasks &&
                          ((this._stable = !0), w.next(!0));
                      });
                  });
                });
                const P = this._zone.onUnstable.subscribe(() => {
                  dr.assertInAngularZone(),
                    this._stable &&
                      ((this._stable = !1),
                      this._zone.runOutsideAngular(() => {
                        w.next(!1);
                      }));
                });
                return () => {
                  C.unsubscribe(), P.unsubscribe();
                };
              });
            this.isStable = jo(
              p,
              y.pipe(
                (function Mh(n = {}) {
                  const {
                    connector: e = () => new rs(),
                    resetOnError: t = !0,
                    resetOnComplete: s = !0,
                    resetOnRefCountZero: c = !0,
                  } = n;
                  return (p) => {
                    let y,
                      w,
                      C,
                      P = 0,
                      N = !1,
                      j = !1;
                    const Q = () => {
                        w?.unsubscribe(), (w = void 0);
                      },
                      ie = () => {
                        Q(), (y = C = void 0), (N = j = !1);
                      },
                      pe = () => {
                        const Ee = y;
                        ie(), Ee?.unsubscribe();
                      };
                    return Fs((Ee, Oe) => {
                      P++, !j && !N && Q();
                      const Ue = (C = C ?? e());
                      Oe.add(() => {
                        P--, 0 === P && !j && !N && (w = gu(pe, c));
                      }),
                        Ue.subscribe(Oe),
                        !y &&
                          P > 0 &&
                          ((y = new Sa({
                            next: (ht) => Ue.next(ht),
                            error: (ht) => {
                              (j = !0), Q(), (w = gu(ie, t, ht)), Ue.error(ht);
                            },
                            complete: () => {
                              (N = !0), Q(), (w = gu(ie, s)), Ue.complete();
                            },
                          })),
                          Ct(Ee).subscribe(y));
                    })(p);
                  };
                })()
              )
            );
          }
          get destroyed() {
            return this._destroyed;
          }
          get injector() {
            return this._injector;
          }
          bootstrap(t, s) {
            const c = t instanceof B_;
            if (!this._injector.get(Dy).done)
              throw (
                (!c &&
                  (function Fa(n) {
                    const e = An(n) || lr(n) || _i(n);
                    return null !== e && e.standalone;
                  })(t),
                new st(405, false))
              );
            let y;
            (y = c ? t : this._injector.get(Jp).resolveComponentFactory(t)),
              this.componentTypes.push(y.componentType);
            const w = (function AI(n) {
                return n.isBoundToModule;
              })(y)
                ? void 0
                : this._injector.get(Ef),
              P = y.create(Hc.NULL, [], s || y.selector, w),
              N = P.location.nativeElement,
              j = P.injector.get(cE, null);
            return (
              j?.registerApplication(N),
              P.onDestroy(() => {
                this.detachView(P.hostView),
                  Iy(this.components, P),
                  j?.unregisterApplication(N);
              }),
              this._loadComponent(P),
              P
            );
          }
          tick() {
            if (this._runningTick) throw new st(101, !1);
            try {
              this._runningTick = !0;
              for (let t of this._views) t.detectChanges();
            } catch (t) {
              this._zone.runOutsideAngular(() =>
                this._exceptionHandler.handleError(t)
              );
            } finally {
              this._runningTick = !1;
            }
          }
          attachView(t) {
            const s = t;
            this._views.push(s), s.attachToAppRef(this);
          }
          detachView(t) {
            const s = t;
            Iy(this._views, s), s.detachFromAppRef();
          }
          _loadComponent(t) {
            this.attachView(t.hostView),
              this.tick(),
              this.components.push(t),
              this._injector
                .get(gI, [])
                .concat(this._bootstrapListeners)
                .forEach((c) => c(t));
          }
          ngOnDestroy() {
            if (!this._destroyed)
              try {
                this._destroyListeners.forEach((t) => t()),
                  this._views.slice().forEach((t) => t.destroy()),
                  this._onMicrotaskEmptySubscription.unsubscribe();
              } finally {
                (this._destroyed = !0),
                  (this._views = []),
                  (this._bootstrapListeners = []),
                  (this._destroyListeners = []);
              }
          }
          onDestroy(t) {
            return (
              this._destroyListeners.push(t),
              () => Iy(this._destroyListeners, t)
            );
          }
          destroy() {
            if (this._destroyed) throw new st(406, !1);
            const t = this._injector;
            t.destroy && !t.destroyed && t.destroy();
          }
          get viewCount() {
            return this._views.length;
          }
          warnIfDestroyed() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(dr), Mt(da), Mt(Uc));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function Iy(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      let xE = !0,
        cx = (() => {
          class n {}
          return (n.__NG_ELEMENT_ID__ = FI), n;
        })();
      function FI(n) {
        return (function NI(n, e, t) {
          if (Tu(n) && !t) {
            const s = Ui(n.index, e);
            return new In(s, s);
          }
          return 47 & n.type ? new In(e[16], e) : null;
        })(ki(), Ze(), 16 == (16 & n));
      }
      class DE {
        constructor() {}
        supports(e) {
          return mh(e);
        }
        create(e) {
          return new $I(e);
        }
      }
      const UI = (n, e) => e;
      class $I {
        constructor(e) {
          (this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = e || UI);
        }
        forEachItem(e) {
          let t;
          for (t = this._itHead; null !== t; t = t._next) e(t);
        }
        forEachOperation(e) {
          let t = this._itHead,
            s = this._removalsHead,
            c = 0,
            p = null;
          for (; t || s; ) {
            const y = !s || (t && t.currentIndex < SE(s, c, p)) ? t : s,
              w = SE(y, c, p),
              C = y.currentIndex;
            if (y === s) c--, (s = s._nextRemoved);
            else if (((t = t._next), null == y.previousIndex)) c++;
            else {
              p || (p = []);
              const P = w - c,
                N = C - c;
              if (P != N) {
                for (let Q = 0; Q < P; Q++) {
                  const ie = Q < p.length ? p[Q] : (p[Q] = 0),
                    pe = ie + Q;
                  N <= pe && pe < P && (p[Q] = ie + 1);
                }
                p[y.previousIndex] = N - P;
              }
            }
            w !== C && e(y, w, C);
          }
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousItHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachMovedItem(e) {
          let t;
          for (t = this._movesHead; null !== t; t = t._nextMoved) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        forEachIdentityChange(e) {
          let t;
          for (
            t = this._identityChangesHead;
            null !== t;
            t = t._nextIdentityChange
          )
            e(t);
        }
        diff(e) {
          if ((null == e && (e = []), !mh(e))) throw new st(900, !1);
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let c,
            p,
            y,
            t = this._itHead,
            s = !1;
          if (Array.isArray(e)) {
            this.length = e.length;
            for (let w = 0; w < this.length; w++)
              (p = e[w]),
                (y = this._trackByFn(w, p)),
                null !== t && Object.is(t.trackById, y)
                  ? (s && (t = this._verifyReinsertion(t, p, y, w)),
                    Object.is(t.item, p) || this._addIdentityChange(t, p))
                  : ((t = this._mismatch(t, p, y, w)), (s = !0)),
                (t = t._next);
          } else
            (c = 0),
              (function fy(n, e) {
                if (Array.isArray(n))
                  for (let t = 0; t < n.length; t++) e(n[t]);
                else {
                  const t = n[Cs()]();
                  let s;
                  for (; !(s = t.next()).done; ) e(s.value);
                }
              })(e, (w) => {
                (y = this._trackByFn(c, w)),
                  null !== t && Object.is(t.trackById, y)
                    ? (s && (t = this._verifyReinsertion(t, w, y, c)),
                      Object.is(t.item, w) || this._addIdentityChange(t, w))
                    : ((t = this._mismatch(t, w, y, c)), (s = !0)),
                  (t = t._next),
                  c++;
              }),
              (this.length = c);
          return this._truncate(t), (this.collection = e), this.isDirty;
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              e = this._previousItHead = this._itHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._additionsHead; null !== e; e = e._nextAdded)
              e.previousIndex = e.currentIndex;
            for (
              this._additionsHead = this._additionsTail = null,
                e = this._movesHead;
              null !== e;
              e = e._nextMoved
            )
              e.previousIndex = e.currentIndex;
            (this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null);
          }
        }
        _mismatch(e, t, s, c) {
          let p;
          return (
            null === e ? (p = this._itTail) : ((p = e._prev), this._remove(e)),
            null !==
            (e =
              null === this._unlinkedRecords
                ? null
                : this._unlinkedRecords.get(s, null))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._reinsertAfter(e, p, c))
              : null !==
                (e =
                  null === this._linkedRecords
                    ? null
                    : this._linkedRecords.get(s, c))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._moveAfter(e, p, c))
              : (e = this._addAfter(new HI(t, s), p, c)),
            e
          );
        }
        _verifyReinsertion(e, t, s, c) {
          let p =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(s, null);
          return (
            null !== p
              ? (e = this._reinsertAfter(p, e._prev, c))
              : e.currentIndex != c &&
                ((e.currentIndex = c), this._addToMoves(e, c)),
            e
          );
        }
        _truncate(e) {
          for (; null !== e; ) {
            const t = e._next;
            this._addToRemovals(this._unlink(e)), (e = t);
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null);
        }
        _reinsertAfter(e, t, s) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(e);
          const c = e._prevRemoved,
            p = e._nextRemoved;
          return (
            null === c ? (this._removalsHead = p) : (c._nextRemoved = p),
            null === p ? (this._removalsTail = c) : (p._prevRemoved = c),
            this._insertAfter(e, t, s),
            this._addToMoves(e, s),
            e
          );
        }
        _moveAfter(e, t, s) {
          return (
            this._unlink(e),
            this._insertAfter(e, t, s),
            this._addToMoves(e, s),
            e
          );
        }
        _addAfter(e, t, s) {
          return (
            this._insertAfter(e, t, s),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = e)
                : (this._additionsTail._nextAdded = e)),
            e
          );
        }
        _insertAfter(e, t, s) {
          const c = null === t ? this._itHead : t._next;
          return (
            (e._next = c),
            (e._prev = t),
            null === c ? (this._itTail = e) : (c._prev = e),
            null === t ? (this._itHead = e) : (t._next = e),
            null === this._linkedRecords && (this._linkedRecords = new CE()),
            this._linkedRecords.put(e),
            (e.currentIndex = s),
            e
          );
        }
        _remove(e) {
          return this._addToRemovals(this._unlink(e));
        }
        _unlink(e) {
          null !== this._linkedRecords && this._linkedRecords.remove(e);
          const t = e._prev,
            s = e._next;
          return (
            null === t ? (this._itHead = s) : (t._next = s),
            null === s ? (this._itTail = t) : (s._prev = t),
            e
          );
        }
        _addToMoves(e, t) {
          return (
            e.previousIndex === t ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = e)
                  : (this._movesTail._nextMoved = e)),
            e
          );
        }
        _addToRemovals(e) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new CE()),
            this._unlinkedRecords.put(e),
            (e.currentIndex = null),
            (e._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = e),
                (e._prevRemoved = null))
              : ((e._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = e)),
            e
          );
        }
        _addIdentityChange(e, t) {
          return (
            (e.item = t),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = e)
                : (this._identityChangesTail._nextIdentityChange = e)),
            e
          );
        }
      }
      class HI {
        constructor(e, t) {
          (this.item = e),
            (this.trackById = t),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null);
        }
      }
      class GI {
        constructor() {
          (this._head = null), (this._tail = null);
        }
        add(e) {
          null === this._head
            ? ((this._head = this._tail = e),
              (e._nextDup = null),
              (e._prevDup = null))
            : ((this._tail._nextDup = e),
              (e._prevDup = this._tail),
              (e._nextDup = null),
              (this._tail = e));
        }
        get(e, t) {
          let s;
          for (s = this._head; null !== s; s = s._nextDup)
            if (
              (null === t || t <= s.currentIndex) &&
              Object.is(s.trackById, e)
            )
              return s;
          return null;
        }
        remove(e) {
          const t = e._prevDup,
            s = e._nextDup;
          return (
            null === t ? (this._head = s) : (t._nextDup = s),
            null === s ? (this._tail = t) : (s._prevDup = t),
            null === this._head
          );
        }
      }
      class CE {
        constructor() {
          this.map = new Map();
        }
        put(e) {
          const t = e.trackById;
          let s = this.map.get(t);
          s || ((s = new GI()), this.map.set(t, s)), s.add(e);
        }
        get(e, t) {
          const c = this.map.get(e);
          return c ? c.get(e, t) : null;
        }
        remove(e) {
          const t = e.trackById;
          return this.map.get(t).remove(e) && this.map.delete(t), e;
        }
        get isEmpty() {
          return 0 === this.map.size;
        }
        clear() {
          this.map.clear();
        }
      }
      function SE(n, e, t) {
        const s = n.previousIndex;
        if (null === s) return s;
        let c = 0;
        return t && s < t.length && (c = t[s]), s + e + c;
      }
      class IE {
        constructor() {}
        supports(e) {
          return e instanceof Map || yf(e);
        }
        create() {
          return new qI();
        }
      }
      class qI {
        constructor() {
          (this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null);
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          );
        }
        forEachItem(e) {
          let t;
          for (t = this._mapHead; null !== t; t = t._next) e(t);
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousMapHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachChangedItem(e) {
          let t;
          for (t = this._changesHead; null !== t; t = t._nextChanged) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        diff(e) {
          if (e) {
            if (!(e instanceof Map || yf(e))) throw new st(900, !1);
          } else e = new Map();
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let t = this._mapHead;
          if (
            ((this._appendAfter = null),
            this._forEach(e, (s, c) => {
              if (t && t.key === c)
                this._maybeAddToChanges(t, s),
                  (this._appendAfter = t),
                  (t = t._next);
              else {
                const p = this._getOrCreateRecordForKey(c, s);
                t = this._insertBeforeOrAppend(t, p);
              }
            }),
            t)
          ) {
            t._prev && (t._prev._next = null), (this._removalsHead = t);
            for (let s = t; null !== s; s = s._nextRemoved)
              s === this._mapHead && (this._mapHead = null),
                this._records.delete(s.key),
                (s._nextRemoved = s._next),
                (s.previousValue = s.currentValue),
                (s.currentValue = null),
                (s._prev = null),
                (s._next = null);
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          );
        }
        _insertBeforeOrAppend(e, t) {
          if (e) {
            const s = e._prev;
            return (
              (t._next = e),
              (t._prev = s),
              (e._prev = t),
              s && (s._next = t),
              e === this._mapHead && (this._mapHead = t),
              (this._appendAfter = e),
              e
            );
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = t), (t._prev = this._appendAfter))
              : (this._mapHead = t),
            (this._appendAfter = t),
            null
          );
        }
        _getOrCreateRecordForKey(e, t) {
          if (this._records.has(e)) {
            const c = this._records.get(e);
            this._maybeAddToChanges(c, t);
            const p = c._prev,
              y = c._next;
            return (
              p && (p._next = y),
              y && (y._prev = p),
              (c._next = null),
              (c._prev = null),
              c
            );
          }
          const s = new WI(e);
          return (
            this._records.set(e, s),
            (s.currentValue = t),
            this._addToAdditions(s),
            s
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              this._previousMapHead = this._mapHead, e = this._previousMapHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._changesHead; null !== e; e = e._nextChanged)
              e.previousValue = e.currentValue;
            for (e = this._additionsHead; null != e; e = e._nextAdded)
              e.previousValue = e.currentValue;
            (this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null);
          }
        }
        _maybeAddToChanges(e, t) {
          Object.is(t, e.currentValue) ||
            ((e.previousValue = e.currentValue),
            (e.currentValue = t),
            this._addToChanges(e));
        }
        _addToAdditions(e) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = e)
            : ((this._additionsTail._nextAdded = e), (this._additionsTail = e));
        }
        _addToChanges(e) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = e)
            : ((this._changesTail._nextChanged = e), (this._changesTail = e));
        }
        _forEach(e, t) {
          e instanceof Map
            ? e.forEach(t)
            : Object.keys(e).forEach((s) => t(e[s], s));
        }
      }
      class WI {
        constructor(e) {
          (this.key = e),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null);
        }
      }
      function ME() {
        return new Py([new DE()]);
      }
      let Py = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, s) {
            if (null != s) {
              const c = s.factories.slice();
              t = t.concat(c);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (s) => n.create(t, s || ME()),
              deps: [[n, new aa(), new sd()]],
            };
          }
          find(t) {
            const s = this.factories.find((c) => c.supports(t));
            if (null != s) return s;
            throw new st(901, !1);
          }
        }
        return (n.ɵprov = Mn({ token: n, providedIn: "root", factory: ME })), n;
      })();
      function AE() {
        return new Dg([new IE()]);
      }
      let Dg = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, s) {
            if (s) {
              const c = s.factories.slice();
              t = t.concat(c);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (s) => n.create(t, s || AE()),
              deps: [[n, new aa(), new sd()]],
            };
          }
          find(t) {
            const s = this.factories.find((c) => c.supports(t));
            if (s) return s;
            throw new st(901, !1);
          }
        }
        return (n.ɵprov = Mn({ token: n, providedIn: "root", factory: AE })), n;
      })();
      const KI = dE(null, "core", []);
      let YI = (() => {
          class n {
            constructor(t) {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Mt(Sy));
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({})),
            n
          );
        })(),
        Ly = null;
      function Cg() {
        return Ly;
      }
      const ml = new sn("DocumentToken");
      let Ex = (() => {
        class n {
          constructor(t, s, c, p) {
            (this._iterableDiffers = t),
              (this._keyValueDiffers = s),
              (this._ngEl = c),
              (this._renderer = p),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._initialClasses = []),
              (this._rawClass = null);
          }
          set klass(t) {
            this._removeClasses(this._initialClasses),
              (this._initialClasses =
                "string" == typeof t ? t.split(/\s+/) : []),
              this._applyClasses(this._initialClasses),
              this._applyClasses(this._rawClass);
          }
          set ngClass(t) {
            this._removeClasses(this._rawClass),
              this._applyClasses(this._initialClasses),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._rawClass = "string" == typeof t ? t.split(/\s+/) : t),
              this._rawClass &&
                (mh(this._rawClass)
                  ? (this._iterableDiffer = this._iterableDiffers
                      .find(this._rawClass)
                      .create())
                  : (this._keyValueDiffer = this._keyValueDiffers
                      .find(this._rawClass)
                      .create()));
          }
          ngDoCheck() {
            if (this._iterableDiffer) {
              const t = this._iterableDiffer.diff(this._rawClass);
              t && this._applyIterableChanges(t);
            } else if (this._keyValueDiffer) {
              const t = this._keyValueDiffer.diff(this._rawClass);
              t && this._applyKeyValueChanges(t);
            }
          }
          _applyKeyValueChanges(t) {
            t.forEachAddedItem((s) => this._toggleClass(s.key, s.currentValue)),
              t.forEachChangedItem((s) =>
                this._toggleClass(s.key, s.currentValue)
              ),
              t.forEachRemovedItem((s) => {
                s.previousValue && this._toggleClass(s.key, !1);
              });
          }
          _applyIterableChanges(t) {
            t.forEachAddedItem((s) => {
              if ("string" != typeof s.item)
                throw new Error(
                  `NgClass can only toggle CSS classes expressed as strings, got ${xt(
                    s.item
                  )}`
                );
              this._toggleClass(s.item, !0);
            }),
              t.forEachRemovedItem((s) => this._toggleClass(s.item, !1));
          }
          _applyClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((s) => this._toggleClass(s, !0))
                : Object.keys(t).forEach((s) => this._toggleClass(s, !!t[s])));
          }
          _removeClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((s) => this._toggleClass(s, !1))
                : Object.keys(t).forEach((s) => this._toggleClass(s, !1)));
          }
          _toggleClass(t, s) {
            (t = t.trim()) &&
              t.split(/\s+/g).forEach((c) => {
                s
                  ? this._renderer.addClass(this._ngEl.nativeElement, c)
                  : this._renderer.removeClass(this._ngEl.nativeElement, c);
              });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Ot(Py), Ot(Dg), Ot(sl), Ot(kd));
          }),
          (n.ɵdir = Pi({
            type: n,
            selectors: [["", "ngClass", ""]],
            inputs: { klass: ["class", "klass"], ngClass: "ngClass" },
            standalone: !0,
          })),
          n
        );
      })();
      class jM {
        constructor(e, t, s, c) {
          (this.$implicit = e),
            (this.ngForOf = t),
            (this.index = s),
            (this.count = c);
        }
        get first() {
          return 0 === this.index;
        }
        get last() {
          return this.index === this.count - 1;
        }
        get even() {
          return this.index % 2 == 0;
        }
        get odd() {
          return !this.even;
        }
      }
      let Tx = (() => {
        class n {
          constructor(t, s, c) {
            (this._viewContainer = t),
              (this._template = s),
              (this._differs = c),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null);
          }
          set ngForOf(t) {
            (this._ngForOf = t), (this._ngForOfDirty = !0);
          }
          set ngForTrackBy(t) {
            this._trackByFn = t;
          }
          get ngForTrackBy() {
            return this._trackByFn;
          }
          set ngForTemplate(t) {
            t && (this._template = t);
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1;
              const t = this._ngForOf;
              !this._differ &&
                t &&
                (this._differ = this._differs
                  .find(t)
                  .create(this.ngForTrackBy));
            }
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf);
              t && this._applyChanges(t);
            }
          }
          _applyChanges(t) {
            const s = this._viewContainer;
            t.forEachOperation((c, p, y) => {
              if (null == c.previousIndex)
                s.createEmbeddedView(
                  this._template,
                  new jM(c.item, this._ngForOf, -1, -1),
                  null === y ? void 0 : y
                );
              else if (null == y) s.remove(null === p ? void 0 : p);
              else if (null !== p) {
                const w = s.get(p);
                s.move(w, y), UE(w, c);
              }
            });
            for (let c = 0, p = s.length; c < p; c++) {
              const w = s.get(c).context;
              (w.index = c), (w.count = p), (w.ngForOf = this._ngForOf);
            }
            t.forEachIdentityChange((c) => {
              UE(s.get(c.currentIndex), c);
            });
          }
          static ngTemplateContextGuard(t, s) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Ot(pl), Ot(nc), Ot(Py));
          }),
          (n.ɵdir = Pi({
            type: n,
            selectors: [["", "ngFor", "", "ngForOf", ""]],
            inputs: {
              ngForOf: "ngForOf",
              ngForTrackBy: "ngForTrackBy",
              ngForTemplate: "ngForTemplate",
            },
            standalone: !0,
          })),
          n
        );
      })();
      function UE(n, e) {
        n.context.$implicit = e.item;
      }
      let Uy = (() => {
        class n {
          constructor(t, s) {
            (this._viewContainer = t),
              (this._context = new $M()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = s);
          }
          set ngIf(t) {
            (this._context.$implicit = this._context.ngIf = t),
              this._updateView();
          }
          set ngIfThen(t) {
            $E("ngIfThen", t),
              (this._thenTemplateRef = t),
              (this._thenViewRef = null),
              this._updateView();
          }
          set ngIfElse(t) {
            $E("ngIfElse", t),
              (this._elseTemplateRef = t),
              (this._elseViewRef = null),
              this._updateView();
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )));
          }
          static ngTemplateContextGuard(t, s) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Ot(pl), Ot(nc));
          }),
          (n.ɵdir = Pi({
            type: n,
            selectors: [["", "ngIf", ""]],
            inputs: {
              ngIf: "ngIf",
              ngIfThen: "ngIfThen",
              ngIfElse: "ngIfElse",
            },
            standalone: !0,
          })),
          n
        );
      })();
      class $M {
        constructor() {
          (this.$implicit = null), (this.ngIf = null);
        }
      }
      function $E(n, e) {
        if (e && !e.createEmbeddedView)
          throw new Error(
            `${n} must be a TemplateRef, but received '${xt(e)}'.`
          );
      }
      let GE = (() => {
          class n {
            constructor(t, s, c) {
              (this._ngEl = t),
                (this._differs = s),
                (this._renderer = c),
                (this._ngStyle = null),
                (this._differ = null);
            }
            set ngStyle(t) {
              (this._ngStyle = t),
                !this._differ &&
                  t &&
                  (this._differ = this._differs.find(t).create());
            }
            ngDoCheck() {
              if (this._differ) {
                const t = this._differ.diff(this._ngStyle);
                t && this._applyChanges(t);
              }
            }
            _setStyle(t, s) {
              const [c, p] = t.split("."),
                y = -1 === c.indexOf("-") ? void 0 : Ji.DashCase;
              null != s
                ? this._renderer.setStyle(
                    this._ngEl.nativeElement,
                    c,
                    p ? `${s}${p}` : s,
                    y
                  )
                : this._renderer.removeStyle(this._ngEl.nativeElement, c, y);
            }
            _applyChanges(t) {
              t.forEachRemovedItem((s) => this._setStyle(s.key, null)),
                t.forEachAddedItem((s) =>
                  this._setStyle(s.key, s.currentValue)
                ),
                t.forEachChangedItem((s) =>
                  this._setStyle(s.key, s.currentValue)
                );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Ot(sl), Ot(Dg), Ot(kd));
            }),
            (n.ɵdir = Pi({
              type: n,
              selectors: [["", "ngStyle", ""]],
              inputs: { ngStyle: "ngStyle" },
              standalone: !0,
            })),
            n
          );
        })(),
        Sx = (() => {
          class n {
            constructor(t) {
              (this._viewContainerRef = t),
                (this._viewRef = null),
                (this.ngTemplateOutletContext = null),
                (this.ngTemplateOutlet = null),
                (this.ngTemplateOutletInjector = null);
            }
            ngOnChanges(t) {
              if (t.ngTemplateOutlet || t.ngTemplateOutletInjector) {
                const s = this._viewContainerRef;
                if (
                  (this._viewRef && s.remove(s.indexOf(this._viewRef)),
                  this.ngTemplateOutlet)
                ) {
                  const {
                    ngTemplateOutlet: c,
                    ngTemplateOutletContext: p,
                    ngTemplateOutletInjector: y,
                  } = this;
                  this._viewRef = s.createEmbeddedView(
                    c,
                    p,
                    y ? { injector: y } : void 0
                  );
                } else this._viewRef = null;
              } else
                this._viewRef &&
                  t.ngTemplateOutletContext &&
                  this.ngTemplateOutletContext &&
                  (this._viewRef.context = this.ngTemplateOutletContext);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Ot(pl));
            }),
            (n.ɵdir = Pi({
              type: n,
              selectors: [["", "ngTemplateOutlet", ""]],
              inputs: {
                ngTemplateOutletContext: "ngTemplateOutletContext",
                ngTemplateOutlet: "ngTemplateOutlet",
                ngTemplateOutletInjector: "ngTemplateOutletInjector",
              },
              standalone: !0,
              features: [Zo],
            })),
            n
          );
        })(),
        xh = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({})),
            n
          );
        })();
      class Lx extends class GA extends class eM {} {
        constructor() {
          super(...arguments), (this.supportsDOMEvents = !0);
        }
      } {
        static makeCurrent() {
          !(function JI(n) {
            Ly || (Ly = n);
          })(new Lx());
        }
        onAndCancel(e, t, s) {
          return (
            e.addEventListener(t, s, !1),
            () => {
              e.removeEventListener(t, s, !1);
            }
          );
        }
        dispatchEvent(e, t) {
          e.dispatchEvent(t);
        }
        remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
        createElement(e, t) {
          return (t = t || this.getDefaultDocument()).createElement(e);
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument("fakeTitle");
        }
        getDefaultDocument() {
          return document;
        }
        isElementNode(e) {
          return e.nodeType === Node.ELEMENT_NODE;
        }
        isShadowRoot(e) {
          return e instanceof DocumentFragment;
        }
        getGlobalEventTarget(e, t) {
          return "window" === t
            ? window
            : "document" === t
            ? e
            : "body" === t
            ? e.body
            : null;
        }
        getBaseHref(e) {
          const t = (function qA() {
            return (
              (Ag = Ag || document.querySelector("base")),
              Ag ? Ag.getAttribute("href") : null
            );
          })();
          return null == t
            ? null
            : (function WA(n) {
                (Gy = Gy || document.createElement("a")),
                  Gy.setAttribute("href", n);
                const e = Gy.pathname;
                return "/" === e.charAt(0) ? e : `/${e}`;
              })(t);
        }
        resetBaseElement() {
          Ag = null;
        }
        getUserAgent() {
          return window.navigator.userAgent;
        }
        getCookie(e) {
          return (function BM(n, e) {
            e = encodeURIComponent(e);
            for (const t of n.split(";")) {
              const s = t.indexOf("="),
                [c, p] = -1 == s ? [t, ""] : [t.slice(0, s), t.slice(s + 1)];
              if (c.trim() === e) return decodeURIComponent(p);
            }
            return null;
          })(document.cookie, e);
        }
      }
      let Gy,
        Ag = null;
      const JE = new sn("TRANSITION_ID"),
        XA = [
          {
            provide: eE,
            useFactory: function ZA(n, e, t) {
              return () => {
                t.get(Dy).donePromise.then(() => {
                  const s = Cg(),
                    c = e.querySelectorAll(`style[ng-transition="${n}"]`);
                  for (let p = 0; p < c.length; p++) s.remove(c[p]);
                });
              };
            },
            deps: [JE, ml, Hc],
            multi: !0,
          },
        ];
      let YA = (() => {
        class n {
          build() {
            return new XMLHttpRequest();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const qy = new sn("EventManagerPlugins");
      let Wy = (() => {
        class n {
          constructor(t, s) {
            (this._zone = s),
              (this._eventNameToPlugin = new Map()),
              t.forEach((c) => (c.manager = this)),
              (this._plugins = t.slice().reverse());
          }
          addEventListener(t, s, c) {
            return this._findPluginFor(s).addEventListener(t, s, c);
          }
          addGlobalEventListener(t, s, c) {
            return this._findPluginFor(s).addGlobalEventListener(t, s, c);
          }
          getZone() {
            return this._zone;
          }
          _findPluginFor(t) {
            const s = this._eventNameToPlugin.get(t);
            if (s) return s;
            const c = this._plugins;
            for (let p = 0; p < c.length; p++) {
              const y = c[p];
              if (y.supports(t)) return this._eventNameToPlugin.set(t, y), y;
            }
            throw new Error(`No event manager plugin found for event ${t}`);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(qy), Mt(dr));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class eT {
        constructor(e) {
          this._doc = e;
        }
        addGlobalEventListener(e, t, s) {
          const c = Cg().getGlobalEventTarget(this._doc, e);
          if (!c)
            throw new Error(`Unsupported event target ${c} for event ${t}`);
          return this.addEventListener(c, t, s);
        }
      }
      let tT = (() => {
          class n {
            constructor() {
              this._stylesSet = new Set();
            }
            addStyles(t) {
              const s = new Set();
              t.forEach((c) => {
                this._stylesSet.has(c) || (this._stylesSet.add(c), s.add(c));
              }),
                this.onStylesAdded(s);
            }
            onStylesAdded(t) {}
            getAllStyles() {
              return Array.from(this._stylesSet);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Pg = (() => {
          class n extends tT {
            constructor(t) {
              super(),
                (this._doc = t),
                (this._hostNodes = new Map()),
                this._hostNodes.set(t.head, []);
            }
            _addStylesToHost(t, s, c) {
              t.forEach((p) => {
                const y = this._doc.createElement("style");
                (y.textContent = p), c.push(s.appendChild(y));
              });
            }
            addHost(t) {
              const s = [];
              this._addStylesToHost(this._stylesSet, t, s),
                this._hostNodes.set(t, s);
            }
            removeHost(t) {
              const s = this._hostNodes.get(t);
              s && s.forEach(nT), this._hostNodes.delete(t);
            }
            onStylesAdded(t) {
              this._hostNodes.forEach((s, c) => {
                this._addStylesToHost(t, c, s);
              });
            }
            ngOnDestroy() {
              this._hostNodes.forEach((t) => t.forEach(nT));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Mt(ml));
            }),
            (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
            n
          );
        })();
      function nT(n) {
        Cg().remove(n);
      }
      const kx = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: "http://www.w3.org/1999/xhtml",
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
          math: "http://www.w3.org/1998/MathML/",
        },
        Rx = /%COMP%/g;
      function Zy(n, e, t) {
        for (let s = 0; s < e.length; s++) {
          let c = e[s];
          Array.isArray(c) ? Zy(n, c, t) : ((c = c.replace(Rx, n)), t.push(c));
        }
        return t;
      }
      function oT(n) {
        return (e) => {
          if ("__ngUnwrap__" === e) return n;
          !1 === n(e) && (e.preventDefault(), (e.returnValue = !1));
        };
      }
      let Xy = (() => {
        class n {
          constructor(t, s, c) {
            (this.eventManager = t),
              (this.sharedStylesHost = s),
              (this.appId = c),
              (this.rendererByCompId = new Map()),
              (this.defaultRenderer = new Ox(t));
          }
          createRenderer(t, s) {
            if (!t || !s) return this.defaultRenderer;
            switch (s.encapsulation) {
              case xo.Emulated: {
                let c = this.rendererByCompId.get(s.id);
                return (
                  c ||
                    ((c = new r2(
                      this.eventManager,
                      this.sharedStylesHost,
                      s,
                      this.appId
                    )),
                    this.rendererByCompId.set(s.id, c)),
                  c.applyToHost(t),
                  c
                );
              }
              case 1:
              case xo.ShadowDom:
                return new o2(this.eventManager, this.sharedStylesHost, t, s);
              default:
                if (!this.rendererByCompId.has(s.id)) {
                  const c = Zy(s.id, s.styles, []);
                  this.sharedStylesHost.addStyles(c),
                    this.rendererByCompId.set(s.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
          }
          begin() {}
          end() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(Wy), Mt(Pg), Mt(Tg));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class Ox {
        constructor(e) {
          (this.eventManager = e),
            (this.data = Object.create(null)),
            (this.destroyNode = null);
        }
        destroy() {}
        createElement(e, t) {
          return t
            ? document.createElementNS(kx[t] || t, e)
            : document.createElement(e);
        }
        createComment(e) {
          return document.createComment(e);
        }
        createText(e) {
          return document.createTextNode(e);
        }
        appendChild(e, t) {
          (aT(e) ? e.content : e).appendChild(t);
        }
        insertBefore(e, t, s) {
          e && (aT(e) ? e.content : e).insertBefore(t, s);
        }
        removeChild(e, t) {
          e && e.removeChild(t);
        }
        selectRootElement(e, t) {
          let s = "string" == typeof e ? document.querySelector(e) : e;
          if (!s)
            throw new Error(`The selector "${e}" did not match any elements`);
          return t || (s.textContent = ""), s;
        }
        parentNode(e) {
          return e.parentNode;
        }
        nextSibling(e) {
          return e.nextSibling;
        }
        setAttribute(e, t, s, c) {
          if (c) {
            t = c + ":" + t;
            const p = kx[c];
            p ? e.setAttributeNS(p, t, s) : e.setAttribute(t, s);
          } else e.setAttribute(t, s);
        }
        removeAttribute(e, t, s) {
          if (s) {
            const c = kx[s];
            c ? e.removeAttributeNS(c, t) : e.removeAttribute(`${s}:${t}`);
          } else e.removeAttribute(t);
        }
        addClass(e, t) {
          e.classList.add(t);
        }
        removeClass(e, t) {
          e.classList.remove(t);
        }
        setStyle(e, t, s, c) {
          c & (Ji.DashCase | Ji.Important)
            ? e.style.setProperty(t, s, c & Ji.Important ? "important" : "")
            : (e.style[t] = s);
        }
        removeStyle(e, t, s) {
          s & Ji.DashCase ? e.style.removeProperty(t) : (e.style[t] = "");
        }
        setProperty(e, t, s) {
          e[t] = s;
        }
        setValue(e, t) {
          e.nodeValue = t;
        }
        listen(e, t, s) {
          return "string" == typeof e
            ? this.eventManager.addGlobalEventListener(e, t, oT(s))
            : this.eventManager.addEventListener(e, t, oT(s));
        }
      }
      function aT(n) {
        return "TEMPLATE" === n.tagName && void 0 !== n.content;
      }
      class r2 extends Ox {
        constructor(e, t, s, c) {
          super(e), (this.component = s);
          const p = Zy(c + "-" + s.id, s.styles, []);
          t.addStyles(p),
            (this.contentAttr = (function e2(n) {
              return "_ngcontent-%COMP%".replace(Rx, n);
            })(c + "-" + s.id)),
            (this.hostAttr = (function t2(n) {
              return "_nghost-%COMP%".replace(Rx, n);
            })(c + "-" + s.id));
        }
        applyToHost(e) {
          super.setAttribute(e, this.hostAttr, "");
        }
        createElement(e, t) {
          const s = super.createElement(e, t);
          return super.setAttribute(s, this.contentAttr, ""), s;
        }
      }
      class o2 extends Ox {
        constructor(e, t, s, c) {
          super(e),
            (this.sharedStylesHost = t),
            (this.hostEl = s),
            (this.shadowRoot = s.attachShadow({ mode: "open" })),
            this.sharedStylesHost.addHost(this.shadowRoot);
          const p = Zy(c.id, c.styles, []);
          for (let y = 0; y < p.length; y++) {
            const w = document.createElement("style");
            (w.textContent = p[y]), this.shadowRoot.appendChild(w);
          }
        }
        nodeOrShadowRoot(e) {
          return e === this.hostEl ? this.shadowRoot : e;
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot);
        }
        appendChild(e, t) {
          return super.appendChild(this.nodeOrShadowRoot(e), t);
        }
        insertBefore(e, t, s) {
          return super.insertBefore(this.nodeOrShadowRoot(e), t, s);
        }
        removeChild(e, t) {
          return super.removeChild(this.nodeOrShadowRoot(e), t);
        }
        parentNode(e) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(e))
          );
        }
      }
      let s2 = (() => {
        class n extends eT {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return !0;
          }
          addEventListener(t, s, c) {
            return (
              t.addEventListener(s, c, !1),
              () => this.removeEventListener(t, s, c)
            );
          }
          removeEventListener(t, s, c) {
            return t.removeEventListener(s, c);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(ml));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const lT = ["alt", "control", "meta", "shift"],
        a2 = {
          "\b": "Backspace",
          "\t": "Tab",
          "\x7f": "Delete",
          "\x1b": "Escape",
          Del: "Delete",
          Esc: "Escape",
          Left: "ArrowLeft",
          Right: "ArrowRight",
          Up: "ArrowUp",
          Down: "ArrowDown",
          Menu: "ContextMenu",
          Scroll: "ScrollLock",
          Win: "OS",
        },
        l2 = {
          alt: (n) => n.altKey,
          control: (n) => n.ctrlKey,
          meta: (n) => n.metaKey,
          shift: (n) => n.shiftKey,
        };
      let c2 = (() => {
        class n extends eT {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return null != n.parseEventName(t);
          }
          addEventListener(t, s, c) {
            const p = n.parseEventName(s),
              y = n.eventCallback(p.fullKey, c, this.manager.getZone());
            return this.manager
              .getZone()
              .runOutsideAngular(() => Cg().onAndCancel(t, p.domEventName, y));
          }
          static parseEventName(t) {
            const s = t.toLowerCase().split("."),
              c = s.shift();
            if (0 === s.length || ("keydown" !== c && "keyup" !== c))
              return null;
            const p = n._normalizeKey(s.pop());
            let y = "",
              w = s.indexOf("code");
            if (
              (w > -1 && (s.splice(w, 1), (y = "code.")),
              lT.forEach((P) => {
                const N = s.indexOf(P);
                N > -1 && (s.splice(N, 1), (y += P + "."));
              }),
              (y += p),
              0 != s.length || 0 === p.length)
            )
              return null;
            const C = {};
            return (C.domEventName = c), (C.fullKey = y), C;
          }
          static matchEventFullKeyCode(t, s) {
            let c = a2[t.key] || t.key,
              p = "";
            return (
              s.indexOf("code.") > -1 && ((c = t.code), (p = "code.")),
              !(null == c || !c) &&
                ((c = c.toLowerCase()),
                " " === c ? (c = "space") : "." === c && (c = "dot"),
                lT.forEach((y) => {
                  y !== c && (0, l2[y])(t) && (p += y + ".");
                }),
                (p += c),
                p === s)
            );
          }
          static eventCallback(t, s, c) {
            return (p) => {
              n.matchEventFullKeyCode(p, t) && c.runGuarded(() => s(p));
            };
          }
          static _normalizeKey(t) {
            return "esc" === t ? "escape" : t;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(ml));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const p2 = dE(KI, "browser", [
          { provide: iE, useValue: "browser" },
          {
            provide: nE,
            useValue: function u2() {
              Lx.makeCurrent();
            },
            multi: !0,
          },
          {
            provide: ml,
            useFactory: function d2() {
              return (
                (function wm(n) {
                  bd = n;
                })(document),
                document
              );
            },
            deps: [],
          },
        ]),
        hT = new sn(""),
        dT = [
          {
            provide: Cy,
            useClass: class KA {
              addToWindow(e) {
                ($n.getAngularTestability = (s, c = !0) => {
                  const p = e.findTestabilityInTree(s, c);
                  if (null == p)
                    throw new Error("Could not find testability for element.");
                  return p;
                }),
                  ($n.getAllAngularTestabilities = () =>
                    e.getAllTestabilities()),
                  ($n.getAllAngularRootElements = () => e.getAllRootElements()),
                  $n.frameworkStabilizers || ($n.frameworkStabilizers = []),
                  $n.frameworkStabilizers.push((s) => {
                    const c = $n.getAllAngularTestabilities();
                    let p = c.length,
                      y = !1;
                    const w = function (C) {
                      (y = y || C), p--, 0 == p && s(y);
                    };
                    c.forEach(function (C) {
                      C.whenStable(w);
                    });
                  });
              }
              findTestabilityInTree(e, t, s) {
                return null == t
                  ? null
                  : e.getTestability(t) ??
                      (s
                        ? Cg().isShadowRoot(t)
                          ? this.findTestabilityInTree(e, t.host, !0)
                          : this.findTestabilityInTree(e, t.parentElement, !0)
                        : null);
              }
            },
            deps: [],
          },
          { provide: cE, useClass: rx, deps: [dr, ox, Cy] },
          { provide: rx, useClass: rx, deps: [dr, ox, Cy] },
        ],
        pT = [
          { provide: Pd, useValue: "root" },
          {
            provide: Uc,
            useFactory: function h2() {
              return new Uc();
            },
            deps: [],
          },
          { provide: qy, useClass: s2, multi: !0, deps: [ml, dr, iE] },
          { provide: qy, useClass: c2, multi: !0, deps: [ml] },
          { provide: Xy, useClass: Xy, deps: [Wy, Pg, Tg] },
          { provide: rh, useExisting: Xy },
          { provide: tT, useExisting: Pg },
          { provide: Pg, useClass: Pg, deps: [ml] },
          { provide: Wy, useClass: Wy, deps: [qy, dr] },
          { provide: class yA {}, useClass: YA, deps: [] },
          [],
        ];
      let fT = (() => {
        class n {
          constructor(t) {}
          static withServerTransition(t) {
            return {
              ngModule: n,
              providers: [
                { provide: Tg, useValue: t.appId },
                { provide: JE, useExisting: Tg },
                XA,
              ],
            };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(hT, 12));
          }),
          (n.ɵmod = ar({ type: n })),
          (n.ɵinj = ii({ providers: [...pT, ...dT], imports: [xh, YI] })),
          n
        );
      })();
      typeof window < "u" && window;
      var zx = lu(898);
      let fo = (() => {
          class n {}
          return (
            (n.STARTS_WITH = "startsWith"),
            (n.CONTAINS = "contains"),
            (n.NOT_CONTAINS = "notContains"),
            (n.ENDS_WITH = "endsWith"),
            (n.EQUALS = "equals"),
            (n.NOT_EQUALS = "notEquals"),
            (n.IN = "in"),
            (n.LESS_THAN = "lt"),
            (n.LESS_THAN_OR_EQUAL_TO = "lte"),
            (n.GREATER_THAN = "gt"),
            (n.GREATER_THAN_OR_EQUAL_TO = "gte"),
            (n.BETWEEN = "between"),
            (n.IS = "is"),
            (n.IS_NOT = "isNot"),
            (n.BEFORE = "before"),
            (n.AFTER = "after"),
            (n.DATE_IS = "dateIs"),
            (n.DATE_IS_NOT = "dateIsNot"),
            (n.DATE_BEFORE = "dateBefore"),
            (n.DATE_AFTER = "dateAfter"),
            n
          );
        })(),
        yT = (() => {
          class n {
            constructor() {
              (this.ripple = !1),
                (this.overlayOptions = {}),
                (this.filterMatchModeOptions = {
                  text: [
                    fo.STARTS_WITH,
                    fo.CONTAINS,
                    fo.NOT_CONTAINS,
                    fo.ENDS_WITH,
                    fo.EQUALS,
                    fo.NOT_EQUALS,
                  ],
                  numeric: [
                    fo.EQUALS,
                    fo.NOT_EQUALS,
                    fo.LESS_THAN,
                    fo.LESS_THAN_OR_EQUAL_TO,
                    fo.GREATER_THAN,
                    fo.GREATER_THAN_OR_EQUAL_TO,
                  ],
                  date: [
                    fo.DATE_IS,
                    fo.DATE_IS_NOT,
                    fo.DATE_BEFORE,
                    fo.DATE_AFTER,
                  ],
                }),
                (this.translation = {
                  startsWith: "Starts with",
                  contains: "Contains",
                  notContains: "Not contains",
                  endsWith: "Ends with",
                  equals: "Equals",
                  notEquals: "Not equals",
                  noFilter: "No Filter",
                  lt: "Less than",
                  lte: "Less than or equal to",
                  gt: "Greater than",
                  gte: "Greater than or equal to",
                  is: "Is",
                  isNot: "Is not",
                  before: "Before",
                  after: "After",
                  dateIs: "Date is",
                  dateIsNot: "Date is not",
                  dateBefore: "Date is before",
                  dateAfter: "Date is after",
                  clear: "Clear",
                  apply: "Apply",
                  matchAll: "Match All",
                  matchAny: "Match Any",
                  addRule: "Add Rule",
                  removeRule: "Remove Rule",
                  accept: "Yes",
                  reject: "No",
                  choose: "Choose",
                  upload: "Upload",
                  cancel: "Cancel",
                  dayNames: [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday",
                  ],
                  dayNamesShort: [
                    "Sun",
                    "Mon",
                    "Tue",
                    "Wed",
                    "Thu",
                    "Fri",
                    "Sat",
                  ],
                  dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                  monthNames: [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                  ],
                  monthNamesShort: [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec",
                  ],
                  dateFormat: "mm/dd/yy",
                  firstDayOfWeek: 0,
                  today: "Today",
                  weekHeader: "Wk",
                  weak: "Weak",
                  medium: "Medium",
                  strong: "Strong",
                  passwordPrompt: "Enter a password",
                  emptyMessage: "No results found",
                  emptyFilterMessage: "No results found",
                }),
                (this.zIndex = {
                  modal: 1100,
                  overlay: 1e3,
                  menu: 1e3,
                  tooltip: 1100,
                }),
                (this.translationSource = new rs()),
                (this.translationObserver =
                  this.translationSource.asObservable());
            }
            getTranslation(t) {
              return this.translation[t];
            }
            setTranslation(t) {
              (this.translation = { ...this.translation, ...t }),
                this.translationSource.next(this.translation);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Mn({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        vT = (() => {
          class n {
            constructor(t) {
              this.template = t;
            }
            getType() {
              return this.name;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Ot(nc));
            }),
            (n.ɵdir = Pi({
              type: n,
              selectors: [["", "pTemplate", ""]],
              inputs: { type: "type", name: ["pTemplate", "name"] },
            })),
            n
          );
        })(),
        Bx = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({ imports: [xh] })),
            n
          );
        })(),
        nn = (() => {
          class n {
            static addClass(t, s) {
              t &&
                s &&
                (t.classList ? t.classList.add(s) : (t.className += " " + s));
            }
            static addMultipleClasses(t, s) {
              if (t && s)
                if (t.classList) {
                  let c = s.trim().split(" ");
                  for (let p = 0; p < c.length; p++) t.classList.add(c[p]);
                } else {
                  let c = s.split(" ");
                  for (let p = 0; p < c.length; p++) t.className += " " + c[p];
                }
            }
            static removeClass(t, s) {
              t &&
                s &&
                (t.classList
                  ? t.classList.remove(s)
                  : (t.className = t.className.replace(
                      new RegExp(
                        "(^|\\b)" + s.split(" ").join("|") + "(\\b|$)",
                        "gi"
                      ),
                      " "
                    )));
            }
            static hasClass(t, s) {
              return (
                !(!t || !s) &&
                (t.classList
                  ? t.classList.contains(s)
                  : new RegExp("(^| )" + s + "( |$)", "gi").test(t.className))
              );
            }
            static siblings(t) {
              return Array.prototype.filter.call(
                t.parentNode.children,
                function (s) {
                  return s !== t;
                }
              );
            }
            static find(t, s) {
              return Array.from(t.querySelectorAll(s));
            }
            static findSingle(t, s) {
              return t ? t.querySelector(s) : null;
            }
            static index(t) {
              let s = t.parentNode.childNodes,
                c = 0;
              for (var p = 0; p < s.length; p++) {
                if (s[p] == t) return c;
                1 == s[p].nodeType && c++;
              }
              return -1;
            }
            static indexWithinGroup(t, s) {
              let c = t.parentNode ? t.parentNode.childNodes : [],
                p = 0;
              for (var y = 0; y < c.length; y++) {
                if (c[y] == t) return p;
                c[y].attributes &&
                  c[y].attributes[s] &&
                  1 == c[y].nodeType &&
                  p++;
              }
              return -1;
            }
            static appendOverlay(t, s, c = "self") {
              "self" !== c && t && s && this.appendChild(t, s);
            }
            static alignOverlay(t, s, c = "self", p = !0) {
              t &&
                s &&
                (p &&
                  (t.style.minWidth ||
                    (t.style.minWidth = n.getOuterWidth(s) + "px")),
                "self" === c
                  ? this.relativePosition(t, s)
                  : this.absolutePosition(t, s));
            }
            static relativePosition(t, s) {
              const c = (Ee) => {
                  if (Ee)
                    return "relative" ===
                      getComputedStyle(Ee).getPropertyValue("position")
                      ? Ee
                      : c(Ee.parentElement);
                },
                p = t.offsetParent
                  ? { width: t.offsetWidth, height: t.offsetHeight }
                  : this.getHiddenElementDimensions(t),
                y = s.offsetHeight,
                w = s.getBoundingClientRect(),
                C = this.getWindowScrollTop(),
                P = this.getWindowScrollLeft(),
                N = this.getViewport(),
                Q = c(t)?.getBoundingClientRect() || {
                  top: -1 * C,
                  left: -1 * P,
                };
              let ie, pe;
              w.top + y + p.height > N.height
                ? ((ie = w.top - Q.top - p.height),
                  (t.style.transformOrigin = "bottom"),
                  w.top + ie < 0 && (ie = -1 * w.top))
                : ((ie = y + w.top - Q.top), (t.style.transformOrigin = "top")),
                (pe =
                  p.width > N.width
                    ? -1 * (w.left - Q.left)
                    : w.left - Q.left + p.width > N.width
                    ? -1 * (w.left - Q.left + p.width - N.width)
                    : w.left - Q.left),
                (t.style.top = ie + "px"),
                (t.style.left = pe + "px");
            }
            static absolutePosition(t, s) {
              const c = t.offsetParent
                  ? { width: t.offsetWidth, height: t.offsetHeight }
                  : this.getHiddenElementDimensions(t),
                p = c.height,
                y = c.width,
                w = s.offsetHeight,
                C = s.offsetWidth,
                P = s.getBoundingClientRect(),
                N = this.getWindowScrollTop(),
                j = this.getWindowScrollLeft(),
                Q = this.getViewport();
              let ie, pe;
              P.top + w + p > Q.height
                ? ((ie = P.top + N - p),
                  (t.style.transformOrigin = "bottom"),
                  ie < 0 && (ie = N))
                : ((ie = w + P.top + N), (t.style.transformOrigin = "top")),
                (pe =
                  P.left + y > Q.width
                    ? Math.max(0, P.left + j + C - y)
                    : P.left + j),
                (t.style.top = ie + "px"),
                (t.style.left = pe + "px");
            }
            static getParents(t, s = []) {
              return null === t.parentNode
                ? s
                : this.getParents(t.parentNode, s.concat([t.parentNode]));
            }
            static getScrollableParents(t) {
              let s = [];
              if (t) {
                let c = this.getParents(t);
                const p = /(auto|scroll)/,
                  y = (w) => {
                    let C = window.getComputedStyle(w, null);
                    return (
                      p.test(C.getPropertyValue("overflow")) ||
                      p.test(C.getPropertyValue("overflowX")) ||
                      p.test(C.getPropertyValue("overflowY"))
                    );
                  };
                for (let w of c) {
                  let C = 1 === w.nodeType && w.dataset.scrollselectors;
                  if (C) {
                    let P = C.split(",");
                    for (let N of P) {
                      let j = this.findSingle(w, N);
                      j && y(j) && s.push(j);
                    }
                  }
                  9 !== w.nodeType && y(w) && s.push(w);
                }
              }
              return s;
            }
            static getHiddenElementOuterHeight(t) {
              (t.style.visibility = "hidden"), (t.style.display = "block");
              let s = t.offsetHeight;
              return (
                (t.style.display = "none"), (t.style.visibility = "visible"), s
              );
            }
            static getHiddenElementOuterWidth(t) {
              (t.style.visibility = "hidden"), (t.style.display = "block");
              let s = t.offsetWidth;
              return (
                (t.style.display = "none"), (t.style.visibility = "visible"), s
              );
            }
            static getHiddenElementDimensions(t) {
              let s = {};
              return (
                (t.style.visibility = "hidden"),
                (t.style.display = "block"),
                (s.width = t.offsetWidth),
                (s.height = t.offsetHeight),
                (t.style.display = "none"),
                (t.style.visibility = "visible"),
                s
              );
            }
            static scrollInView(t, s) {
              let c = getComputedStyle(t).getPropertyValue("borderTopWidth"),
                p = c ? parseFloat(c) : 0,
                y = getComputedStyle(t).getPropertyValue("paddingTop"),
                w = y ? parseFloat(y) : 0,
                C = t.getBoundingClientRect(),
                N =
                  s.getBoundingClientRect().top +
                  document.body.scrollTop -
                  (C.top + document.body.scrollTop) -
                  p -
                  w,
                j = t.scrollTop,
                Q = t.clientHeight,
                ie = this.getOuterHeight(s);
              N < 0
                ? (t.scrollTop = j + N)
                : N + ie > Q && (t.scrollTop = j + N - Q + ie);
            }
            static fadeIn(t, s) {
              t.style.opacity = 0;
              let c = +new Date(),
                p = 0,
                y = function () {
                  (p =
                    +t.style.opacity.replace(",", ".") +
                    (new Date().getTime() - c) / s),
                    (t.style.opacity = p),
                    (c = +new Date()),
                    +p < 1 &&
                      ((window.requestAnimationFrame &&
                        requestAnimationFrame(y)) ||
                        setTimeout(y, 16));
                };
              y();
            }
            static fadeOut(t, s) {
              var c = 1,
                w = 50 / s;
              let C = setInterval(() => {
                (c -= w) <= 0 && ((c = 0), clearInterval(C)),
                  (t.style.opacity = c);
              }, 50);
            }
            static getWindowScrollTop() {
              let t = document.documentElement;
              return (window.pageYOffset || t.scrollTop) - (t.clientTop || 0);
            }
            static getWindowScrollLeft() {
              let t = document.documentElement;
              return (window.pageXOffset || t.scrollLeft) - (t.clientLeft || 0);
            }
            static matches(t, s) {
              var c = Element.prototype;
              return (
                c.matches ||
                c.webkitMatchesSelector ||
                c.mozMatchesSelector ||
                c.msMatchesSelector ||
                function (y) {
                  return (
                    -1 !== [].indexOf.call(document.querySelectorAll(y), this)
                  );
                }
              ).call(t, s);
            }
            static getOuterWidth(t, s) {
              let c = t.offsetWidth;
              if (s) {
                let p = getComputedStyle(t);
                c += parseFloat(p.marginLeft) + parseFloat(p.marginRight);
              }
              return c;
            }
            static getHorizontalPadding(t) {
              let s = getComputedStyle(t);
              return parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);
            }
            static getHorizontalMargin(t) {
              let s = getComputedStyle(t);
              return parseFloat(s.marginLeft) + parseFloat(s.marginRight);
            }
            static innerWidth(t) {
              let s = t.offsetWidth,
                c = getComputedStyle(t);
              return (
                (s += parseFloat(c.paddingLeft) + parseFloat(c.paddingRight)), s
              );
            }
            static width(t) {
              let s = t.offsetWidth,
                c = getComputedStyle(t);
              return (
                (s -= parseFloat(c.paddingLeft) + parseFloat(c.paddingRight)), s
              );
            }
            static getInnerHeight(t) {
              let s = t.offsetHeight,
                c = getComputedStyle(t);
              return (
                (s += parseFloat(c.paddingTop) + parseFloat(c.paddingBottom)), s
              );
            }
            static getOuterHeight(t, s) {
              let c = t.offsetHeight;
              if (s) {
                let p = getComputedStyle(t);
                c += parseFloat(p.marginTop) + parseFloat(p.marginBottom);
              }
              return c;
            }
            static getHeight(t) {
              let s = t.offsetHeight,
                c = getComputedStyle(t);
              return (
                (s -=
                  parseFloat(c.paddingTop) +
                  parseFloat(c.paddingBottom) +
                  parseFloat(c.borderTopWidth) +
                  parseFloat(c.borderBottomWidth)),
                s
              );
            }
            static getWidth(t) {
              let s = t.offsetWidth,
                c = getComputedStyle(t);
              return (
                (s -=
                  parseFloat(c.paddingLeft) +
                  parseFloat(c.paddingRight) +
                  parseFloat(c.borderLeftWidth) +
                  parseFloat(c.borderRightWidth)),
                s
              );
            }
            static getViewport() {
              let t = window,
                s = document,
                c = s.documentElement,
                p = s.getElementsByTagName("body")[0];
              return {
                width: t.innerWidth || c.clientWidth || p.clientWidth,
                height: t.innerHeight || c.clientHeight || p.clientHeight,
              };
            }
            static getOffset(t) {
              var s = t.getBoundingClientRect();
              return {
                top:
                  s.top +
                  (window.pageYOffset ||
                    document.documentElement.scrollTop ||
                    document.body.scrollTop ||
                    0),
                left:
                  s.left +
                  (window.pageXOffset ||
                    document.documentElement.scrollLeft ||
                    document.body.scrollLeft ||
                    0),
              };
            }
            static replaceElementWith(t, s) {
              let c = t.parentNode;
              if (!c) throw "Can't replace element";
              return c.replaceChild(s, t);
            }
            static getUserAgent() {
              return navigator.userAgent;
            }
            static isIE() {
              var t = window.navigator.userAgent;
              return (
                t.indexOf("MSIE ") > 0 ||
                (t.indexOf("Trident/") > 0
                  ? (t.indexOf("rv:"), !0)
                  : t.indexOf("Edge/") > 0)
              );
            }
            static isIOS() {
              return (
                /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
              );
            }
            static isAndroid() {
              return /(android)/i.test(navigator.userAgent);
            }
            static isTouchDevice() {
              return "ontouchstart" in window || navigator.maxTouchPoints > 0;
            }
            static appendChild(t, s) {
              if (this.isElement(s)) s.appendChild(t);
              else {
                if (!s.el || !s.el.nativeElement)
                  throw "Cannot append " + s + " to " + t;
                s.el.nativeElement.appendChild(t);
              }
            }
            static removeChild(t, s) {
              if (this.isElement(s)) s.removeChild(t);
              else {
                if (!s.el || !s.el.nativeElement)
                  throw "Cannot remove " + t + " from " + s;
                s.el.nativeElement.removeChild(t);
              }
            }
            static removeElement(t) {
              "remove" in Element.prototype
                ? t.remove()
                : t.parentNode.removeChild(t);
            }
            static isElement(t) {
              return "object" == typeof HTMLElement
                ? t instanceof HTMLElement
                : t &&
                    "object" == typeof t &&
                    null !== t &&
                    1 === t.nodeType &&
                    "string" == typeof t.nodeName;
            }
            static calculateScrollbarWidth(t) {
              if (t) {
                let s = getComputedStyle(t);
                return (
                  t.offsetWidth -
                  t.clientWidth -
                  parseFloat(s.borderLeftWidth) -
                  parseFloat(s.borderRightWidth)
                );
              }
              {
                if (null !== this.calculatedScrollbarWidth)
                  return this.calculatedScrollbarWidth;
                let s = document.createElement("div");
                (s.className = "p-scrollbar-measure"),
                  document.body.appendChild(s);
                let c = s.offsetWidth - s.clientWidth;
                return (
                  document.body.removeChild(s),
                  (this.calculatedScrollbarWidth = c),
                  c
                );
              }
            }
            static calculateScrollbarHeight() {
              if (null !== this.calculatedScrollbarHeight)
                return this.calculatedScrollbarHeight;
              let t = document.createElement("div");
              (t.className = "p-scrollbar-measure"),
                document.body.appendChild(t);
              let s = t.offsetHeight - t.clientHeight;
              return (
                document.body.removeChild(t),
                (this.calculatedScrollbarWidth = s),
                s
              );
            }
            static invokeElementMethod(t, s, c) {
              t[s].apply(t, c);
            }
            static clearSelection() {
              if (window.getSelection)
                window.getSelection().empty
                  ? window.getSelection().empty()
                  : window.getSelection().removeAllRanges &&
                    window.getSelection().rangeCount > 0 &&
                    window.getSelection().getRangeAt(0).getClientRects()
                      .length > 0 &&
                    window.getSelection().removeAllRanges();
              else if (document.selection && document.selection.empty)
                try {
                  document.selection.empty();
                } catch {}
            }
            static getBrowser() {
              if (!this.browser) {
                let t = this.resolveUserAgent();
                (this.browser = {}),
                  t.browser &&
                    ((this.browser[t.browser] = !0),
                    (this.browser.version = t.version)),
                  this.browser.chrome
                    ? (this.browser.webkit = !0)
                    : this.browser.webkit && (this.browser.safari = !0);
              }
              return this.browser;
            }
            static resolveUserAgent() {
              let t = navigator.userAgent.toLowerCase(),
                s =
                  /(chrome)[ \/]([\w.]+)/.exec(t) ||
                  /(webkit)[ \/]([\w.]+)/.exec(t) ||
                  /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(t) ||
                  /(msie) ([\w.]+)/.exec(t) ||
                  (t.indexOf("compatible") < 0 &&
                    /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(t)) ||
                  [];
              return { browser: s[1] || "", version: s[2] || "0" };
            }
            static isInteger(t) {
              return Number.isInteger
                ? Number.isInteger(t)
                : "number" == typeof t && isFinite(t) && Math.floor(t) === t;
            }
            static isHidden(t) {
              return !t || null === t.offsetParent;
            }
            static isVisible(t) {
              return t && null != t.offsetParent;
            }
            static isExist(t) {
              return null !== t && typeof t < "u" && t.nodeName && t.parentNode;
            }
            static focus(t, s) {
              t && document.activeElement !== t && t.focus(s);
            }
            static getFocusableElements(t) {
              let s = n.find(
                  t,
                  'button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]), select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]), [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]):not(.p-disabled)'
                ),
                c = [];
              for (let p of s)
                "none" != getComputedStyle(p).display &&
                  "hidden" != getComputedStyle(p).visibility &&
                  c.push(p);
              return c;
            }
            static generateZIndex() {
              return (this.zindex = this.zindex || 999), ++this.zindex;
            }
            static getSelection() {
              return window.getSelection
                ? window.getSelection().toString()
                : document.getSelection
                ? document.getSelection().toString()
                : document.selection
                ? document.selection.createRange().text
                : null;
            }
            static getTargetElement(t, s) {
              if (!t) return null;
              switch (t) {
                case "document":
                  return document;
                case "window":
                  return window;
                case "@next":
                  return s?.nextElementSibling;
                case "@prev":
                  return s?.previousElementSibling;
                case "@parent":
                  return s?.parentElement;
                case "@grandparent":
                  return s?.parentElement.parentElement;
                default:
                  const c = typeof t;
                  if ("string" === c) return document.querySelector(t);
                  if ("object" === c && t.hasOwnProperty("nativeElement"))
                    return this.isExist(t.nativeElement)
                      ? t.nativeElement
                      : void 0;
                  const y =
                    (w = t) && w.constructor && w.call && w.apply ? t() : t;
                  return (y && 9 === y.nodeType) || this.isExist(y) ? y : null;
              }
              var w;
            }
          }
          return (
            (n.zindex = 1e3),
            (n.calculatedScrollbarWidth = null),
            (n.calculatedScrollbarHeight = null),
            n
          );
        })();
      class E2 {
        constructor(e, t = () => {}) {
          (this.element = e), (this.listener = t);
        }
        bindScrollListener() {
          this.scrollableParents = nn.getScrollableParents(this.element);
          for (let e = 0; e < this.scrollableParents.length; e++)
            this.scrollableParents[e].addEventListener("scroll", this.listener);
        }
        unbindScrollListener() {
          if (this.scrollableParents)
            for (let e = 0; e < this.scrollableParents.length; e++)
              this.scrollableParents[e].removeEventListener(
                "scroll",
                this.listener
              );
        }
        destroy() {
          this.unbindScrollListener(),
            (this.element = null),
            (this.listener = null),
            (this.scrollableParents = null);
        }
      }
      var Vx = (function T2() {
        let n = [];
        const c = (p) => (p && parseInt(p.style.zIndex, 10)) || 0;
        return {
          get: c,
          set: (p, y, w) => {
            y &&
              (y.style.zIndex = String(
                ((p, y) => {
                  let w = n.length > 0 ? n[n.length - 1] : { key: p, value: y },
                    C = w.value + (w.key === p ? 0 : y) + 1;
                  return n.push({ key: p, value: C }), C;
                })(p, w)
              ));
          },
          clear: (p) => {
            p &&
              (((p) => {
                n = n.filter((y) => y.value !== p);
              })(c(p)),
              (p.style.zIndex = ""));
          },
          getCurrent: () => (n.length > 0 ? n[n.length - 1].value : 0),
        };
      })();
      let D2 = (() => {
          class n {
            constructor(t, s, c) {
              (this.el = t),
                (this.zone = s),
                (this.config = c),
                (this.escape = !0),
                (this.fitContent = !0),
                (this._tooltipOptions = {
                  tooltipPosition: "right",
                  tooltipEvent: "hover",
                  appendTo: "body",
                  tooltipZIndex: "auto",
                  escape: !0,
                  positionTop: 0,
                  positionLeft: 0,
                });
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = t), this.deactivate();
            }
            ngAfterViewInit() {
              this.zone.runOutsideAngular(() => {
                if ("hover" === this.getOption("tooltipEvent"))
                  (this.mouseEnterListener = this.onMouseEnter.bind(this)),
                    (this.mouseLeaveListener = this.onMouseLeave.bind(this)),
                    (this.clickListener = this.onClick.bind(this)),
                    this.el.nativeElement.addEventListener(
                      "mouseenter",
                      this.mouseEnterListener
                    ),
                    this.el.nativeElement.addEventListener(
                      "mouseleave",
                      this.mouseLeaveListener
                    ),
                    this.el.nativeElement.addEventListener(
                      "click",
                      this.clickListener
                    );
                else if ("focus" === this.getOption("tooltipEvent")) {
                  (this.focusListener = this.onFocus.bind(this)),
                    (this.blurListener = this.onBlur.bind(this));
                  let t = this.getTarget(this.el.nativeElement);
                  t.addEventListener("focus", this.focusListener),
                    t.addEventListener("blur", this.blurListener);
                }
              });
            }
            ngOnChanges(t) {
              t.tooltipPosition &&
                this.setOption({
                  tooltipPosition: t.tooltipPosition.currentValue,
                }),
                t.tooltipEvent &&
                  this.setOption({ tooltipEvent: t.tooltipEvent.currentValue }),
                t.appendTo &&
                  this.setOption({ appendTo: t.appendTo.currentValue }),
                t.positionStyle &&
                  this.setOption({
                    positionStyle: t.positionStyle.currentValue,
                  }),
                t.tooltipStyleClass &&
                  this.setOption({
                    tooltipStyleClass: t.tooltipStyleClass.currentValue,
                  }),
                t.tooltipZIndex &&
                  this.setOption({
                    tooltipZIndex: t.tooltipZIndex.currentValue,
                  }),
                t.escape && this.setOption({ escape: t.escape.currentValue }),
                t.showDelay &&
                  this.setOption({ showDelay: t.showDelay.currentValue }),
                t.hideDelay &&
                  this.setOption({ hideDelay: t.hideDelay.currentValue }),
                t.life && this.setOption({ life: t.life.currentValue }),
                t.positionTop &&
                  this.setOption({ positionTop: t.positionTop.currentValue }),
                t.positionLeft &&
                  this.setOption({ positionLeft: t.positionLeft.currentValue }),
                t.disabled &&
                  this.setOption({ disabled: t.disabled.currentValue }),
                t.text &&
                  (this.setOption({ tooltipLabel: t.text.currentValue }),
                  this.active &&
                    (t.text.currentValue
                      ? this.container && this.container.offsetParent
                        ? (this.updateText(), this.align())
                        : this.show()
                      : this.hide())),
                t.tooltipOptions &&
                  ((this._tooltipOptions = {
                    ...this._tooltipOptions,
                    ...t.tooltipOptions.currentValue,
                  }),
                  this.deactivate(),
                  this.active &&
                    (this.getOption("tooltipLabel")
                      ? this.container && this.container.offsetParent
                        ? (this.updateText(), this.align())
                        : this.show()
                      : this.hide()));
            }
            onMouseEnter(t) {
              !this.container && !this.showTimeout && this.activate();
            }
            onMouseLeave(t) {
              this.deactivate();
            }
            onFocus(t) {
              this.activate();
            }
            onBlur(t) {
              this.deactivate();
            }
            onClick(t) {
              this.deactivate();
            }
            activate() {
              if (
                ((this.active = !0),
                this.clearHideTimeout(),
                this.getOption("showDelay")
                  ? (this.showTimeout = setTimeout(() => {
                      this.show();
                    }, this.getOption("showDelay")))
                  : this.show(),
                this.getOption("life"))
              ) {
                let t = this.getOption("showDelay")
                  ? this.getOption("life") + this.getOption("showDelay")
                  : this.getOption("life");
                this.hideTimeout = setTimeout(() => {
                  this.hide();
                }, t);
              }
            }
            deactivate() {
              (this.active = !1),
                this.clearShowTimeout(),
                this.getOption("hideDelay")
                  ? (this.clearHideTimeout(),
                    (this.hideTimeout = setTimeout(() => {
                      this.hide();
                    }, this.getOption("hideDelay"))))
                  : this.hide();
            }
            create() {
              this.container && (this.clearHideTimeout(), this.remove()),
                (this.container = document.createElement("div"));
              let t = document.createElement("div");
              (t.className = "p-tooltip-arrow"),
                this.container.appendChild(t),
                (this.tooltipText = document.createElement("div")),
                (this.tooltipText.className = "p-tooltip-text"),
                this.updateText(),
                this.getOption("positionStyle") &&
                  (this.container.style.position =
                    this.getOption("positionStyle")),
                this.container.appendChild(this.tooltipText),
                "body" === this.getOption("appendTo")
                  ? document.body.appendChild(this.container)
                  : "target" === this.getOption("appendTo")
                  ? nn.appendChild(this.container, this.el.nativeElement)
                  : nn.appendChild(this.container, this.getOption("appendTo")),
                (this.container.style.display = "inline-block"),
                this.fitContent && (this.container.style.width = "fit-content");
            }
            show() {
              !this.getOption("tooltipLabel") ||
                this.getOption("disabled") ||
                (this.create(),
                this.align(),
                nn.fadeIn(this.container, 250),
                "auto" === this.getOption("tooltipZIndex")
                  ? Vx.set(
                      "tooltip",
                      this.container,
                      this.config.zIndex.tooltip
                    )
                  : (this.container.style.zIndex =
                      this.getOption("tooltipZIndex")),
                this.bindDocumentResizeListener(),
                this.bindScrollListener());
            }
            hide() {
              "auto" === this.getOption("tooltipZIndex") &&
                Vx.clear(this.container),
                this.remove();
            }
            updateText() {
              this.getOption("escape")
                ? ((this.tooltipText.innerHTML = ""),
                  this.tooltipText.appendChild(
                    document.createTextNode(this.getOption("tooltipLabel"))
                  ))
                : (this.tooltipText.innerHTML = this.getOption("tooltipLabel"));
            }
            align() {
              switch (this.getOption("tooltipPosition")) {
                case "top":
                  this.alignTop(),
                    this.isOutOfBounds() &&
                      (this.alignBottom(),
                      this.isOutOfBounds() &&
                        (this.alignRight(),
                        this.isOutOfBounds() && this.alignLeft()));
                  break;
                case "bottom":
                  this.alignBottom(),
                    this.isOutOfBounds() &&
                      (this.alignTop(),
                      this.isOutOfBounds() &&
                        (this.alignRight(),
                        this.isOutOfBounds() && this.alignLeft()));
                  break;
                case "left":
                  this.alignLeft(),
                    this.isOutOfBounds() &&
                      (this.alignRight(),
                      this.isOutOfBounds() &&
                        (this.alignTop(),
                        this.isOutOfBounds() && this.alignBottom()));
                  break;
                case "right":
                  this.alignRight(),
                    this.isOutOfBounds() &&
                      (this.alignLeft(),
                      this.isOutOfBounds() &&
                        (this.alignTop(),
                        this.isOutOfBounds() && this.alignBottom()));
              }
            }
            getHostOffset() {
              if (
                "body" === this.getOption("appendTo") ||
                "target" === this.getOption("appendTo")
              ) {
                let t = this.el.nativeElement.getBoundingClientRect();
                return {
                  left: t.left + nn.getWindowScrollLeft(),
                  top: t.top + nn.getWindowScrollTop(),
                };
              }
              return { left: 0, top: 0 };
            }
            alignRight() {
              this.preAlign("right");
              let t = this.getHostOffset(),
                s = t.left + nn.getOuterWidth(this.el.nativeElement),
                c =
                  t.top +
                  (nn.getOuterHeight(this.el.nativeElement) -
                    nn.getOuterHeight(this.container)) /
                    2;
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            alignLeft() {
              this.preAlign("left");
              let t = this.getHostOffset(),
                s = t.left - nn.getOuterWidth(this.container),
                c =
                  t.top +
                  (nn.getOuterHeight(this.el.nativeElement) -
                    nn.getOuterHeight(this.container)) /
                    2;
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            alignTop() {
              this.preAlign("top");
              let t = this.getHostOffset(),
                s =
                  t.left +
                  (nn.getOuterWidth(this.el.nativeElement) -
                    nn.getOuterWidth(this.container)) /
                    2,
                c = t.top - nn.getOuterHeight(this.container);
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            alignBottom() {
              this.preAlign("bottom");
              let t = this.getHostOffset(),
                s =
                  t.left +
                  (nn.getOuterWidth(this.el.nativeElement) -
                    nn.getOuterWidth(this.container)) /
                    2,
                c = t.top + nn.getOuterHeight(this.el.nativeElement);
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            setOption(t) {
              this._tooltipOptions = { ...this._tooltipOptions, ...t };
            }
            getOption(t) {
              return this._tooltipOptions[t];
            }
            getTarget(t) {
              return nn.hasClass(t, "p-inputwrapper")
                ? nn.findSingle(t, "input")
                : t;
            }
            preAlign(t) {
              (this.container.style.left = "-999px"),
                (this.container.style.top = "-999px");
              let s = "p-tooltip p-component p-tooltip-" + t;
              this.container.className = this.getOption("tooltipStyleClass")
                ? s + " " + this.getOption("tooltipStyleClass")
                : s;
            }
            isOutOfBounds() {
              let t = this.container.getBoundingClientRect(),
                s = t.top,
                c = t.left,
                p = nn.getOuterWidth(this.container),
                y = nn.getOuterHeight(this.container),
                w = nn.getViewport();
              return c + p > w.width || c < 0 || s < 0 || s + y > w.height;
            }
            onWindowResize(t) {
              this.hide();
            }
            bindDocumentResizeListener() {
              this.zone.runOutsideAngular(() => {
                (this.resizeListener = this.onWindowResize.bind(this)),
                  window.addEventListener("resize", this.resizeListener);
              });
            }
            unbindDocumentResizeListener() {
              this.resizeListener &&
                (window.removeEventListener("resize", this.resizeListener),
                (this.resizeListener = null));
            }
            bindScrollListener() {
              this.scrollHandler ||
                (this.scrollHandler = new E2(this.el.nativeElement, () => {
                  this.container && this.hide();
                })),
                this.scrollHandler.bindScrollListener();
            }
            unbindScrollListener() {
              this.scrollHandler && this.scrollHandler.unbindScrollListener();
            }
            unbindEvents() {
              if ("hover" === this.getOption("tooltipEvent"))
                this.el.nativeElement.removeEventListener(
                  "mouseenter",
                  this.mouseEnterListener
                ),
                  this.el.nativeElement.removeEventListener(
                    "mouseleave",
                    this.mouseLeaveListener
                  ),
                  this.el.nativeElement.removeEventListener(
                    "click",
                    this.clickListener
                  );
              else if ("focus" === this.getOption("tooltipEvent")) {
                let t = this.getTarget(this.el.nativeElement);
                t.removeEventListener("focus", this.focusListener),
                  t.removeEventListener("blur", this.blurListener);
              }
              this.unbindDocumentResizeListener();
            }
            remove() {
              this.container &&
                this.container.parentElement &&
                ("body" === this.getOption("appendTo")
                  ? document.body.removeChild(this.container)
                  : "target" === this.getOption("appendTo")
                  ? this.el.nativeElement.removeChild(this.container)
                  : nn.removeChild(this.container, this.getOption("appendTo"))),
                this.unbindDocumentResizeListener(),
                this.unbindScrollListener(),
                this.clearTimeouts(),
                (this.container = null),
                (this.scrollHandler = null);
            }
            clearShowTimeout() {
              this.showTimeout &&
                (clearTimeout(this.showTimeout), (this.showTimeout = null));
            }
            clearHideTimeout() {
              this.hideTimeout &&
                (clearTimeout(this.hideTimeout), (this.hideTimeout = null));
            }
            clearTimeouts() {
              this.clearShowTimeout(), this.clearHideTimeout();
            }
            ngOnDestroy() {
              this.unbindEvents(),
                this.container && Vx.clear(this.container),
                this.remove(),
                this.scrollHandler &&
                  (this.scrollHandler.destroy(), (this.scrollHandler = null));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Ot(sl), Ot(dr), Ot(yT));
            }),
            (n.ɵdir = Pi({
              type: n,
              selectors: [["", "pTooltip", ""]],
              hostAttrs: [1, "p-element"],
              inputs: {
                tooltipPosition: "tooltipPosition",
                tooltipEvent: "tooltipEvent",
                appendTo: "appendTo",
                positionStyle: "positionStyle",
                tooltipStyleClass: "tooltipStyleClass",
                tooltipZIndex: "tooltipZIndex",
                escape: "escape",
                showDelay: "showDelay",
                hideDelay: "hideDelay",
                life: "life",
                positionTop: "positionTop",
                positionLeft: "positionLeft",
                fitContent: "fitContent",
                text: ["pTooltip", "text"],
                disabled: ["tooltipDisabled", "disabled"],
                tooltipOptions: "tooltipOptions",
              },
              features: [Zo],
            })),
            n
          );
        })(),
        wT = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({ imports: [xh] })),
            n
          );
        })(),
        C2 = (() => {
          class n {
            constructor(t, s, c) {
              (this.el = t), (this.zone = s), (this.config = c);
            }
            ngAfterViewInit() {
              this.config &&
                this.config.ripple &&
                this.zone.runOutsideAngular(() => {
                  this.create(),
                    (this.mouseDownListener = this.onMouseDown.bind(this)),
                    this.el.nativeElement.addEventListener(
                      "mousedown",
                      this.mouseDownListener
                    );
                });
            }
            onMouseDown(t) {
              let s = this.getInk();
              if (!s || "none" === getComputedStyle(s, null).display) return;
              if (
                (nn.removeClass(s, "p-ink-active"),
                !nn.getHeight(s) && !nn.getWidth(s))
              ) {
                let w = Math.max(
                  nn.getOuterWidth(this.el.nativeElement),
                  nn.getOuterHeight(this.el.nativeElement)
                );
                (s.style.height = w + "px"), (s.style.width = w + "px");
              }
              let c = nn.getOffset(this.el.nativeElement),
                p =
                  t.pageX -
                  c.left +
                  document.body.scrollTop -
                  nn.getWidth(s) / 2,
                y =
                  t.pageY -
                  c.top +
                  document.body.scrollLeft -
                  nn.getHeight(s) / 2;
              (s.style.top = y + "px"),
                (s.style.left = p + "px"),
                nn.addClass(s, "p-ink-active"),
                (this.timeout = setTimeout(() => {
                  let w = this.getInk();
                  w && nn.removeClass(w, "p-ink-active");
                }, 401));
            }
            getInk() {
              for (let t = 0; t < this.el.nativeElement.children.length; t++)
                if (
                  -1 !==
                  this.el.nativeElement.children[t].className.indexOf("p-ink")
                )
                  return this.el.nativeElement.children[t];
              return null;
            }
            resetInk() {
              let t = this.getInk();
              t && nn.removeClass(t, "p-ink-active");
            }
            onAnimationEnd(t) {
              this.timeout && clearTimeout(this.timeout),
                nn.removeClass(t.currentTarget, "p-ink-active");
            }
            create() {
              let t = document.createElement("span");
              (t.className = "p-ink"),
                this.el.nativeElement.appendChild(t),
                (this.animationListener = this.onAnimationEnd.bind(this)),
                t.addEventListener("animationend", this.animationListener);
            }
            remove() {
              let t = this.getInk();
              t &&
                (this.el.nativeElement.removeEventListener(
                  "mousedown",
                  this.mouseDownListener
                ),
                t.removeEventListener("animationend", this.animationListener),
                nn.removeElement(t));
            }
            ngOnDestroy() {
              this.config && this.config.ripple && this.remove();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Ot(sl), Ot(dr), Ot(yT, 8));
            }),
            (n.ɵdir = Pi({
              type: n,
              selectors: [["", "pRipple", ""]],
              hostAttrs: [1, "p-ripple", "p-element"],
            })),
            n
          );
        })(),
        jx = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({ imports: [xh] })),
            n
          );
        })();
      function S2(n, e) {
        1 & n && my(0);
      }
      function I2(n, e) {
        if (
          (1 & n && (dg(0), Ri(1, S2, 1, 0, "ng-container", 3), pg()), 2 & n)
        ) {
          const t = po(2);
          ei(1), Gn("ngTemplateOutlet", t.contentTemplate);
        }
      }
      function M2(n, e) {
        if (
          (1 & n &&
            (Ye(0, "div", 1), I0(1), Ri(2, I2, 2, 1, "ng-container", 2), Je()),
          2 & n)
        ) {
          const t = po();
          Gn("hidden", !t.selected),
            Ss("id", t.id)("aria-hidden", !t.selected)(
              "aria-labelledby",
              t.id + "-label"
            ),
            ei(2),
            Gn("ngIf", t.contentTemplate && (t.cache ? t.loaded : t.selected));
        }
      }
      const ET = ["*"],
        A2 = ["content"],
        P2 = ["navbar"],
        L2 = ["prevBtn"],
        k2 = ["nextBtn"],
        R2 = ["inkbar"];
      function O2(n, e) {
        if (1 & n) {
          const t = fg();
          Ye(0, "button", 12, 13),
            yh("click", function () {
              return Ha(t), yi(po().navBackward());
            }),
            an(2, "span", 14),
            Je();
        }
      }
      function F2(n, e) {
        1 & n && an(0, "span", 24),
          2 & n && Gn("ngClass", po(3).$implicit.leftIcon);
      }
      function N2(n, e) {
        1 & n && an(0, "span", 25),
          2 & n && Gn("ngClass", po(3).$implicit.rightIcon);
      }
      function z2(n, e) {
        if (
          (1 & n &&
            (dg(0),
            Ri(1, F2, 1, 1, "span", 21),
            Ye(2, "span", 22),
            ut(3),
            Je(),
            Ri(4, N2, 1, 1, "span", 23),
            pg()),
          2 & n)
        ) {
          const t = po(2).$implicit;
          ei(1),
            Gn("ngIf", t.leftIcon),
            ei(2),
            _y(t.header),
            ei(1),
            Gn("ngIf", t.rightIcon);
        }
      }
      function B2(n, e) {
        1 & n && my(0);
      }
      function V2(n, e) {
        if (1 & n) {
          const t = fg();
          Ye(0, "span", 26),
            yh("click", function (c) {
              Ha(t);
              const p = po(2).$implicit;
              return yi(po().close(c, p));
            }),
            Je();
        }
      }
      const j2 = function (n, e) {
        return { "p-highlight": n, "p-disabled": e };
      };
      function U2(n, e) {
        if (1 & n) {
          const t = fg();
          Ye(0, "li", 16)(1, "a", 17),
            yh("click", function (c) {
              Ha(t);
              const p = po().$implicit;
              return yi(po().open(c, p));
            })("keydown.enter", function (c) {
              Ha(t);
              const p = po().$implicit;
              return yi(po().open(c, p));
            }),
            Ri(2, z2, 5, 3, "ng-container", 18),
            Ri(3, B2, 1, 0, "ng-container", 19),
            Ri(4, V2, 1, 0, "span", 20),
            Je()();
        }
        if (2 & n) {
          const t = po().$implicit;
          A0(t.headerStyleClass),
            Gn("ngClass", ww(16, j2, t.selected, t.disabled))(
              "ngStyle",
              t.headerStyle
            ),
            ei(1),
            Gn("pTooltip", t.tooltip)("tooltipPosition", t.tooltipPosition)(
              "positionStyle",
              t.tooltipPositionStyle
            )("tooltipStyleClass", t.tooltipStyleClass),
            Ss("id", t.id + "-label")("aria-selected", t.selected)(
              "aria-controls",
              t.id
            )("aria-selected", t.selected)("tabindex", t.disabled ? null : "0"),
            ei(1),
            Gn("ngIf", !t.headerTemplate),
            ei(1),
            Gn("ngTemplateOutlet", t.headerTemplate),
            ei(1),
            Gn("ngIf", t.closable);
        }
      }
      function $2(n, e) {
        1 & n && Ri(0, U2, 5, 19, "li", 15),
          2 & n && Gn("ngIf", !e.$implicit.closed);
      }
      function H2(n, e) {
        if (1 & n) {
          const t = fg();
          Ye(0, "button", 27, 28),
            yh("click", function () {
              return Ha(t), yi(po().navForward());
            }),
            an(2, "span", 29),
            Je();
        }
      }
      const G2 = function (n) {
        return { "p-tabview p-component": !0, "p-tabview-scrollable": n };
      };
      let q2 = 0,
        TT = (() => {
          class n {
            constructor(t, s, c) {
              (this.viewContainer = s),
                (this.cd = c),
                (this.cache = !0),
                (this.tooltipPosition = "top"),
                (this.tooltipPositionStyle = "absolute"),
                (this.id = "p-tabpanel-" + q2++),
                (this.tabView = t);
            }
            ngAfterContentInit() {
              this.templates.forEach((t) => {
                "header" === t.getType()
                  ? (this.headerTemplate = t.template)
                  : (this.contentTemplate = t.template);
              });
            }
            get selected() {
              return this._selected;
            }
            set selected(t) {
              (this._selected = t),
                this.loaded || this.cd.detectChanges(),
                t && (this.loaded = !0);
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = t), this.tabView.cd.markForCheck();
            }
            get header() {
              return this._header;
            }
            set header(t) {
              (this._header = t),
                Promise.resolve().then(() => {
                  this.tabView.updateInkBar(), this.tabView.cd.markForCheck();
                });
            }
            get leftIcon() {
              return this._leftIcon;
            }
            set leftIcon(t) {
              (this._leftIcon = t), this.tabView.cd.markForCheck();
            }
            get rightIcon() {
              return this._rightIcon;
            }
            set rightIcon(t) {
              (this._rightIcon = t), this.tabView.cd.markForCheck();
            }
            ngOnDestroy() {
              this.view = null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Ot(Pr(() => DT)), Ot(pl), Ot(cx));
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["p-tabPanel"]],
              contentQueries: function (t, s, c) {
                if ((1 & t && X0(c, vT, 4), 2 & t)) {
                  let p;
                  Jc((p = eu())) && (s.templates = p);
                }
              },
              hostAttrs: [1, "p-element"],
              inputs: {
                closable: "closable",
                headerStyle: "headerStyle",
                headerStyleClass: "headerStyleClass",
                cache: "cache",
                tooltip: "tooltip",
                tooltipPosition: "tooltipPosition",
                tooltipPositionStyle: "tooltipPositionStyle",
                tooltipStyleClass: "tooltipStyleClass",
                selected: "selected",
                disabled: "disabled",
                header: "header",
                leftIcon: "leftIcon",
                rightIcon: "rightIcon",
              },
              ngContentSelectors: ET,
              decls: 1,
              vars: 1,
              consts: [
                [
                  "class",
                  "p-tabview-panel",
                  "role",
                  "tabpanel",
                  3,
                  "hidden",
                  4,
                  "ngIf",
                ],
                ["role", "tabpanel", 1, "p-tabview-panel", 3, "hidden"],
                [4, "ngIf"],
                [4, "ngTemplateOutlet"],
              ],
              template: function (t, s) {
                1 & t && (S0(), Ri(0, M2, 3, 5, "div", 0)),
                  2 & t && Gn("ngIf", !s.closed);
              },
              dependencies: [Uy, Sx],
              encapsulation: 2,
            })),
            n
          );
        })(),
        DT = (() => {
          class n {
            constructor(t, s) {
              (this.el = t),
                (this.cd = s),
                (this.orientation = "top"),
                (this.onChange = new xa()),
                (this.onClose = new xa()),
                (this.activeIndexChange = new xa()),
                (this.backwardIsDisabled = !0),
                (this.forwardIsDisabled = !1);
            }
            ngAfterContentInit() {
              this.initTabs(),
                (this.tabChangesSubscription = this.tabPanels.changes.subscribe(
                  (t) => {
                    this.initTabs();
                  }
                ));
            }
            ngAfterViewChecked() {
              this.tabChanged && (this.updateInkBar(), (this.tabChanged = !1));
            }
            ngOnDestroy() {
              this.tabChangesSubscription &&
                this.tabChangesSubscription.unsubscribe();
            }
            initTabs() {
              (this.tabs = this.tabPanels.toArray()),
                !this.findSelectedTab() &&
                  this.tabs.length &&
                  (null != this.activeIndex &&
                  this.tabs.length > this.activeIndex
                    ? (this.tabs[this.activeIndex].selected = !0)
                    : (this.tabs[0].selected = !0),
                  (this.tabChanged = !0)),
                this.cd.markForCheck();
            }
            open(t, s) {
              if (s.disabled) t && t.preventDefault();
              else {
                if (!s.selected) {
                  let c = this.findSelectedTab();
                  c && (c.selected = !1),
                    (this.tabChanged = !0),
                    (s.selected = !0);
                  let p = this.findTabIndex(s);
                  (this.preventActiveIndexPropagation = !0),
                    this.activeIndexChange.emit(p),
                    this.onChange.emit({ originalEvent: t, index: p }),
                    this.updateScrollBar(p);
                }
                t && t.preventDefault();
              }
            }
            close(t, s) {
              this.controlClose
                ? this.onClose.emit({
                    originalEvent: t,
                    index: this.findTabIndex(s),
                    close: () => {
                      this.closeTab(s);
                    },
                  })
                : (this.closeTab(s),
                  this.onClose.emit({
                    originalEvent: t,
                    index: this.findTabIndex(s),
                  })),
                t.stopPropagation();
            }
            closeTab(t) {
              if (!t.disabled) {
                if (t.selected) {
                  (this.tabChanged = !0), (t.selected = !1);
                  for (let s = 0; s < this.tabs.length; s++) {
                    let c = this.tabs[s];
                    if (!c.closed && !t.disabled) {
                      c.selected = !0;
                      break;
                    }
                  }
                }
                t.closed = !0;
              }
            }
            findSelectedTab() {
              for (let t = 0; t < this.tabs.length; t++)
                if (this.tabs[t].selected) return this.tabs[t];
              return null;
            }
            findTabIndex(t) {
              let s = -1;
              for (let c = 0; c < this.tabs.length; c++)
                if (this.tabs[c] == t) {
                  s = c;
                  break;
                }
              return s;
            }
            getBlockableElement() {
              return this.el.nativeElement.children[0];
            }
            get activeIndex() {
              return this._activeIndex;
            }
            set activeIndex(t) {
              (this._activeIndex = t),
                this.preventActiveIndexPropagation
                  ? (this.preventActiveIndexPropagation = !1)
                  : this.tabs &&
                    this.tabs.length &&
                    null != this._activeIndex &&
                    this.tabs.length > this._activeIndex &&
                    ((this.findSelectedTab().selected = !1),
                    (this.tabs[this._activeIndex].selected = !0),
                    (this.tabChanged = !0),
                    this.updateScrollBar(t));
            }
            updateInkBar() {
              if (this.navbar) {
                const t = nn.findSingle(
                  this.navbar.nativeElement,
                  "li.p-highlight"
                );
                if (!t) return;
                (this.inkbar.nativeElement.style.width = nn.getWidth(t) + "px"),
                  (this.inkbar.nativeElement.style.left =
                    nn.getOffset(t).left -
                    nn.getOffset(this.navbar.nativeElement).left +
                    "px");
              }
            }
            updateScrollBar(t) {
              this.navbar.nativeElement.children[t].scrollIntoView({
                block: "nearest",
              });
            }
            updateButtonState() {
              const t = this.content.nativeElement,
                { scrollLeft: s, scrollWidth: c } = t,
                p = nn.getWidth(t);
              (this.backwardIsDisabled = 0 === s),
                (this.forwardIsDisabled = parseInt(s) === c - p);
            }
            onScroll(t) {
              this.scrollable && this.updateButtonState(), t.preventDefault();
            }
            getVisibleButtonWidths() {
              return [
                this.prevBtn?.nativeElement,
                this.nextBtn?.nativeElement,
              ].reduce((t, s) => (s ? t + nn.getWidth(s) : t), 0);
            }
            navBackward() {
              const t = this.content.nativeElement,
                s = nn.getWidth(t) - this.getVisibleButtonWidths(),
                c = t.scrollLeft - s;
              t.scrollLeft = c <= 0 ? 0 : c;
            }
            navForward() {
              const t = this.content.nativeElement,
                s = nn.getWidth(t) - this.getVisibleButtonWidths(),
                c = t.scrollLeft + s,
                p = t.scrollWidth - s;
              t.scrollLeft = c >= p ? p : c;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Ot(sl), Ot(cx));
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["p-tabView"]],
              contentQueries: function (t, s, c) {
                if ((1 & t && X0(c, TT, 4), 2 & t)) {
                  let p;
                  Jc((p = eu())) && (s.tabPanels = p);
                }
              },
              viewQuery: function (t, s) {
                if (
                  (1 & t &&
                    (Jd(A2, 5), Jd(P2, 5), Jd(L2, 5), Jd(k2, 5), Jd(R2, 5)),
                  2 & t)
                ) {
                  let c;
                  Jc((c = eu())) && (s.content = c.first),
                    Jc((c = eu())) && (s.navbar = c.first),
                    Jc((c = eu())) && (s.prevBtn = c.first),
                    Jc((c = eu())) && (s.nextBtn = c.first),
                    Jc((c = eu())) && (s.inkbar = c.first);
                }
              },
              hostAttrs: [1, "p-element"],
              inputs: {
                orientation: "orientation",
                style: "style",
                styleClass: "styleClass",
                controlClose: "controlClose",
                scrollable: "scrollable",
                activeIndex: "activeIndex",
              },
              outputs: {
                onChange: "onChange",
                onClose: "onClose",
                activeIndexChange: "activeIndexChange",
              },
              ngContentSelectors: ET,
              decls: 13,
              vars: 9,
              consts: [
                [3, "ngClass", "ngStyle"],
                [1, "p-tabview-nav-container"],
                [
                  "class",
                  "p-tabview-nav-prev p-tabview-nav-btn p-link",
                  "type",
                  "button",
                  "pRipple",
                  "",
                  3,
                  "click",
                  4,
                  "ngIf",
                ],
                [1, "p-tabview-nav-content", 3, "scroll"],
                ["content", ""],
                ["role", "tablist", 1, "p-tabview-nav"],
                ["navbar", ""],
                ["ngFor", "", 3, "ngForOf"],
                [1, "p-tabview-ink-bar"],
                ["inkbar", ""],
                [
                  "class",
                  "p-tabview-nav-next p-tabview-nav-btn p-link",
                  "type",
                  "button",
                  "pRipple",
                  "",
                  3,
                  "click",
                  4,
                  "ngIf",
                ],
                [1, "p-tabview-panels"],
                [
                  "type",
                  "button",
                  "pRipple",
                  "",
                  1,
                  "p-tabview-nav-prev",
                  "p-tabview-nav-btn",
                  "p-link",
                  3,
                  "click",
                ],
                ["prevBtn", ""],
                [1, "pi", "pi-chevron-left"],
                [
                  "role",
                  "presentation",
                  3,
                  "ngClass",
                  "ngStyle",
                  "class",
                  4,
                  "ngIf",
                ],
                ["role", "presentation", 3, "ngClass", "ngStyle"],
                [
                  "role",
                  "tab",
                  "pRipple",
                  "",
                  1,
                  "p-tabview-nav-link",
                  3,
                  "pTooltip",
                  "tooltipPosition",
                  "positionStyle",
                  "tooltipStyleClass",
                  "click",
                  "keydown.enter",
                ],
                [4, "ngIf"],
                [4, "ngTemplateOutlet"],
                ["class", "p-tabview-close pi pi-times", 3, "click", 4, "ngIf"],
                ["class", "p-tabview-left-icon", 3, "ngClass", 4, "ngIf"],
                [1, "p-tabview-title"],
                ["class", "p-tabview-right-icon", 3, "ngClass", 4, "ngIf"],
                [1, "p-tabview-left-icon", 3, "ngClass"],
                [1, "p-tabview-right-icon", 3, "ngClass"],
                [1, "p-tabview-close", "pi", "pi-times", 3, "click"],
                [
                  "type",
                  "button",
                  "pRipple",
                  "",
                  1,
                  "p-tabview-nav-next",
                  "p-tabview-nav-btn",
                  "p-link",
                  3,
                  "click",
                ],
                ["nextBtn", ""],
                [1, "pi", "pi-chevron-right"],
              ],
              template: function (t, s) {
                1 & t &&
                  (S0(),
                  Ye(0, "div", 0)(1, "div", 1),
                  Ri(2, O2, 3, 0, "button", 2),
                  Ye(3, "div", 3, 4),
                  yh("scroll", function (p) {
                    return s.onScroll(p);
                  }),
                  Ye(5, "ul", 5, 6),
                  Ri(7, $2, 1, 1, "ng-template", 7),
                  an(8, "li", 8, 9),
                  Je()(),
                  Ri(10, H2, 3, 0, "button", 10),
                  Je(),
                  Ye(11, "div", 11),
                  I0(12),
                  Je()()),
                  2 & t &&
                    (A0(s.styleClass),
                    Gn("ngClass", bw(7, G2, s.scrollable))("ngStyle", s.style),
                    ei(2),
                    Gn("ngIf", s.scrollable && !s.backwardIsDisabled),
                    ei(5),
                    Gn("ngForOf", s.tabs),
                    ei(3),
                    Gn("ngIf", s.scrollable && !s.forwardIsDisabled));
              },
              dependencies: [Ex, Tx, Uy, Sx, GE, D2, C2],
              styles: [
                ".p-tabview-nav-container{position:relative}.p-tabview-scrollable .p-tabview-nav-container{overflow:hidden}.p-tabview-nav-content{overflow-x:auto;overflow-y:hidden;scroll-behavior:smooth;scrollbar-width:none;overscroll-behavior:contain auto}.p-tabview-nav{display:flex;margin:0;padding:0;list-style-type:none;flex:1 1 auto}.p-tabview-nav-link{cursor:pointer;-webkit-user-select:none;user-select:none;display:flex;align-items:center;position:relative;text-decoration:none;overflow:hidden}.p-tabview-ink-bar{display:none;z-index:1}.p-tabview-nav-link:focus{z-index:1}.p-tabview-title{line-height:1;white-space:nowrap}.p-tabview-nav-btn{position:absolute;top:0;z-index:2;height:100%;display:flex;align-items:center;justify-content:center}.p-tabview-nav-prev{left:0}.p-tabview-nav-next{right:0}.p-tabview-nav-content::-webkit-scrollbar{display:none}.p-tabview-close{z-index:1}\n",
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        W2 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({ imports: [xh, Bx, wT, jx, Bx] })),
            n
          );
        })(),
        Z2 = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-intro"]],
              decls: 31,
              vars: 0,
              consts: [
                [
                  "src",
                  "../../luisdebenito/assets/fields.jpeg",
                  1,
                  "img",
                  "rounded",
                ],
                [1, "centered"],
                [1, "pi", "pi-linkedin"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.linkedin.com/in/luis-de-benito/",
                ],
                [1, "pi", "pi-envelope"],
                ["target", "_blank", "href", "mailTo:luisdebenito7@gmail.com"],
                [1, "pi", "pi-instagram"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.instagram.com/luis.bq_/",
                ],
                [1, "pi", "pi-twitter"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.twitter.com/luisbq_/",
                ],
                ["src", "../../luisdebenito/assets/segovia.jpg", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "Luis de Benito"),
                  Je(),
                  Ye(2, "p"),
                  ut(
                    3,
                    " Hello there! Thanks for getting in here. My name is "
                  ),
                  Ye(4, "b"),
                  ut(5, "Luis"),
                  Je(),
                  ut(
                    6,
                    ", and this is the best way I found to tell my story without you falling asleep while reading it. Follow me on a journey through my favourite places in the earth\n"
                  ),
                  Je(),
                  an(7, "img", 0),
                  Ye(8, "div", 1)(9, "p"),
                  an(10, "i", 2),
                  Ye(11, "a", 3),
                  ut(12, "Luis dB.P."),
                  Je()(),
                  Ye(13, "p"),
                  an(14, "i", 4),
                  Ye(15, "a", 5),
                  ut(16, "luisdebenito7@gmail.com"),
                  Je()(),
                  Ye(17, "p"),
                  an(18, "i", 6),
                  Ye(19, "a", 7),
                  ut(20, "@luis.bq_"),
                  Je()(),
                  Ye(21, "p"),
                  an(22, "i", 8),
                  Ye(23, "a", 9),
                  ut(24, "@luisbq_"),
                  Je()()(),
                  Ye(25, "p"),
                  ut(
                    26,
                    " Back in 1995, my parents decided to make my first commit in Segovia, and I spent there the first 17 years of my life. Such a lovely city.\n"
                  ),
                  Je(),
                  an(27, "img", 10),
                  Ye(28, "p")(29, "i"),
                  ut(
                    30,
                    "Location: Santiuste de San Juan Bautista. The place where my grandparents lived, my second home"
                  ),
                  Je()());
              },
              styles: [
                ".centered[_ngcontent-%COMP%]{margin:auto;padding-left:10px;color:#fff}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] > i[_ngcontent-%COMP%]{margin:15px;font-size:25px}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:5px}.centered[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#fff}",
              ],
            })),
            n
          );
        })(),
        X2 = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-education"]],
              decls: 28,
              vars: 0,
              consts: [
                ["src", "../../luisdebenito/assets/uni1.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/unitenis.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/malt.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/iowa.jpg", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "University in Madrid"),
                  Je(),
                  Ye(2, "p"),
                  ut(
                    3,
                    " After a good childhood in the fields, it was my time to move to the big city. I got into UPM (Universidad Polit\xe9cnica de Madrid) to study "
                  ),
                  Ye(4, "b"),
                  ut(5, "Electronic and Automatic Industrial Engineering"),
                  Je()(),
                  an(6, "img", 0),
                  Ye(7, "h1"),
                  ut(8, "University of London"),
                  Je(),
                  Ye(9, "p"),
                  ut(
                    10,
                    " Lucky me, I got sponsored to do an online MSC in Data Science and Artificial Intelligence. It was nice, but not what I expected, easily replaced by Youtube\n"
                  ),
                  Je(),
                  an(11, "img", 1),
                  Ye(12, "p")(13, "i"),
                  ut(
                    14,
                    "I was sick the day we got the trophies, don't judge my face"
                  ),
                  Je()(),
                  Ye(15, "h1"),
                  ut(16, "Volunteering"),
                  Je(),
                  Ye(17, "p"),
                  ut(
                    18,
                    " I have done a lot of volunteering, but Malta was the best one. I got the chance to develop a project to handcraft instruments made by trash, and spent a couple months enjoying the views\n"
                  ),
                  Je(),
                  an(19, "img", 2),
                  Ye(20, "h1"),
                  ut(21, "Others"),
                  Je(),
                  Ye(22, "p"),
                  ut(
                    23,
                    " I got the national tennis teacher license from RFET, did a quarterly exchange in Ames, Iowa, and some other titles that may be interesting for nobody.\n"
                  ),
                  Je(),
                  an(24, "img", 3),
                  Ye(25, "p")(26, "i"),
                  ut(27, "Location: Madrid"),
                  Je()());
              },
              encapsulation: 2,
            })),
            n
          );
        })(),
        K2 = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-experience"]],
              decls: 9,
              vars: 0,
              consts: [
                ["src", "../../luisdebenito/assets/job1.png", 1, "img"],
                ["src", "../../luisdebenito/assets/job2.png", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "Job Experience"),
                  Je(),
                  Ye(2, "p"),
                  ut(3, "Linkedin already did the job of prettifying it"),
                  Je(),
                  an(4, "img", 0)(5, "img", 1),
                  Ye(6, "p")(7, "i"),
                  ut(
                    8,
                    "Location: Treviso. My first international experience as an engineer"
                  ),
                  Je()());
              },
              encapsulation: 2,
            })),
            n
          );
        })(),
        Y2 = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-music"]],
              decls: 19,
              vars: 0,
              consts: [
                [1, "centered"],
                [1, "pi", "pi-youtube"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.youtube.com/@luisbq8045",
                ],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.youtube.com/@bq_tossing_beats",
                ],
                [
                  "width",
                  "560",
                  "height",
                  "315",
                  "src",
                  "https://www.youtube.com/embed/HiON7D8QrsA",
                  "title",
                  "Stenaten",
                  "frameborder",
                  "0",
                  "allow",
                  "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",
                  "allowfullscreen",
                  "",
                ],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "Music"),
                  Je(),
                  Ye(2, "p"),
                  ut(
                    3,
                    " We can say it is my biggest home hobby, listening, producing and mixing music\n"
                  ),
                  Je(),
                  Ye(4, "div", 0)(5, "p"),
                  an(6, "i", 1),
                  Ye(7, "a", 2),
                  ut(8, "Luisbq, producing music channel"),
                  Je()(),
                  Ye(9, "p"),
                  an(10, "i", 1),
                  Ye(11, "a", 3),
                  ut(12, "Bq Tossing Beats, mixing music channel"),
                  Je()()(),
                  Ye(13, "p"),
                  ut(
                    14,
                    " I have played piano and guitar for 15 years, here is a song I made and played:\n"
                  ),
                  Je(),
                  an(15, "iframe", 4),
                  Ye(16, "p")(17, "i"),
                  ut(
                    18,
                    "Location: Saint Pettersburg. My first big international trip with friends. (Such an adventure, ask me if you want to know why)"
                  ),
                  Je()());
              },
              styles: [
                ".centered[_ngcontent-%COMP%]{margin:auto;padding-left:10px;color:#fff}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] > i[_ngcontent-%COMP%]{margin:15px;font-size:25px}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:5px}.centered[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#fff}iframe[_ngcontent-%COMP%]{width:100%}",
              ],
            })),
            n
          );
        })(),
        Q2 = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-trip"]],
              decls: 73,
              vars: 0,
              consts: [
                ["src", "../../luisdebenito/assets/india.JPG", 1, "img"],
                ["src", "../../luisdebenito/assets/rusia.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/forli.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/italy.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/suecia.jpg", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "Trips"),
                  Je(),
                  Ye(2, "p"),
                  ut(
                    3,
                    "As I already said before, travelling is an important part of my life."
                  ),
                  Je(),
                  Ye(4, "p"),
                  ut(5, "This is a list of the places I have been to"),
                  Je(),
                  Ye(6, "ul")(7, "li"),
                  ut(8, "Andorra \u{1f1e6}\u{1f1e9}"),
                  Je(),
                  Ye(9, "li"),
                  ut(10, "Austria \u{1f1e6}\u{1f1f9}"),
                  Je(),
                  Ye(11, "li"),
                  ut(12, "Belgium \u{1f1e7}\u{1f1ea}"),
                  Je(),
                  Ye(13, "li"),
                  ut(14, "Croatia \u{1f1ed}\u{1f1f7}"),
                  Je(),
                  Ye(15, "li"),
                  ut(16, "Denmark \u{1f1e9}\u{1f1f0}"),
                  Je(),
                  Ye(17, "li"),
                  ut(18, "England \u{1f1ec}\u{1f1e7}"),
                  Je(),
                  Ye(19, "li"),
                  ut(20, "France \u{1f1eb}\u{1f1f7}"),
                  Je(),
                  Ye(21, "li"),
                  ut(22, "Germany \u{1f1e9}\u{1f1ea}"),
                  Je(),
                  Ye(23, "li"),
                  ut(24, "Hungary \u{1f1ed}\u{1f1fa}"),
                  Je(),
                  Ye(25, "li"),
                  ut(26, "India \u{1f1ee}\u{1f1f3}"),
                  Je(),
                  Ye(27, "li"),
                  ut(28, "Ireland \u{1f1ee}\u{1f1ea}"),
                  Je(),
                  Ye(29, "li"),
                  ut(30, "Italy \u{1f1ee}\u{1f1f9}"),
                  Je(),
                  Ye(31, "li"),
                  ut(32, "Malta \u{1f1f2}\u{1f1f9}"),
                  Je(),
                  Ye(33, "li"),
                  ut(34, "Monaco \u{1f1f2}\u{1f1e8}"),
                  Je(),
                  Ye(35, "li"),
                  ut(36, "Morocco \u{1f1f2}\u{1f1e6}"),
                  Je(),
                  Ye(37, "li"),
                  ut(38, "Netherlands \u{1f1f3}\u{1f1f1}"),
                  Je(),
                  Ye(39, "li"),
                  ut(40, "Northern Ireland \u{1f1ec}\u{1f1e7}"),
                  Je(),
                  Ye(41, "li"),
                  ut(42, "Poland \u{1f1f5}\u{1f1f1}"),
                  Je(),
                  Ye(43, "li"),
                  ut(44, "Portugal \u{1f1f5}\u{1f1f9}"),
                  Je(),
                  Ye(45, "li"),
                  ut(46, "Russia \u{1f1f7}\u{1f1fa}"),
                  Je(),
                  Ye(47, "li"),
                  ut(48, "San Marino \u{1f1f8}\u{1f1f2}"),
                  Je(),
                  Ye(49, "li"),
                  ut(50, "Slovenia \u{1f1f8}\u{1f1ee}"),
                  Je(),
                  Ye(51, "li"),
                  ut(52, "Scotland \u{1f1ec}\u{1f1e7}"),
                  Je(),
                  Ye(53, "li"),
                  ut(54, "Spain \u{1f1ea}\u{1f1f8}"),
                  Je(),
                  Ye(55, "li"),
                  ut(56, "Sweden \u{1f1f8}\u{1f1ea}"),
                  Je(),
                  Ye(57, "li"),
                  ut(58, "Turkey \u{1f1f9}\u{1f1f7}"),
                  Je(),
                  Ye(59, "li"),
                  ut(60, "USA \u{1f1fa}\u{1f1f8}"),
                  Je()(),
                  Ye(61, "p"),
                  ut(62, "I went to a wedding in India!"),
                  Je(),
                  an(63, "img", 0),
                  Ye(64, "p"),
                  ut(65, "Here are some pics of my trips:"),
                  Je(),
                  an(66, "img", 1)(67, "img", 2)(68, "img", 3)(69, "img", 4),
                  Ye(70, "p")(71, "i"),
                  ut(72, "Location: India, the wedding"),
                  Je()());
              },
              styles: [
                "ul[_ngcontent-%COMP%]{list-style-type:none;columns:2;-webkit-columns:2;-moz-columns:2}",
              ],
            })),
            n
          );
        })(),
        J2 = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-code"]],
              decls: 27,
              vars: 0,
              consts: [
                [1, "centered"],
                [1, "pi", "pi-github"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://github.com/luisdebenito?tab=repositories",
                ],
                ["src", "../../luisdebenito/assets/puebleo.jpeg", 1, "img"],
                [1, "pi", "pi-play"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://luisdebenito.github.io/MDGE/",
                ],
                ["src", "../../luisdebenito/assets/santiuste1.jpg", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "Code"),
                  Je(),
                  Ye(2, "p"),
                  ut(
                    3,
                    " Since I started programming in 2013, I have never stopped developing my own stuff just for fun. I have started this repo with a couple projects, the rest is private in bitbucket\n"
                  ),
                  Je(),
                  Ye(4, "div", 0)(5, "p"),
                  an(6, "i", 1),
                  Ye(7, "a", 2),
                  ut(8, "Github luisdebenito"),
                  Je()()(),
                  Ye(9, "p"),
                  ut(10, " I have created a social network ("),
                  Ye(11, "b"),
                  ut(12, "puebleo"),
                  Je(),
                  ut(
                    13,
                    " that became puebloo), a trivia question game called askIt, a php framework to work with html as jQuery does, and a lot of videogames\n"
                  ),
                  Je(),
                  an(14, "img", 3),
                  Ye(15, "div", 0)(16, "p"),
                  an(17, "i", 4),
                  Ye(18, "a", 5),
                  ut(19, "Most Difficult Game Ever"),
                  Je(),
                  ut(20, " Only PC "),
                  Je()(),
                  Ye(21, "p"),
                  ut(
                    22,
                    "Picture of me happy so you can imagine my face while coding"
                  ),
                  Je(),
                  an(23, "img", 6),
                  Ye(24, "p")(25, "i"),
                  ut(
                    26,
                    "Location: Iowa, place where I spent a quarter in 2012"
                  ),
                  Je()());
              },
              styles: [
                ".centered[_ngcontent-%COMP%]{margin:auto;padding-left:10px;color:#fff}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] > i[_ngcontent-%COMP%]{margin:15px;font-size:25px}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:5px}.centered[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#fff}",
              ],
            })),
            n
          );
        })(),
        eP = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-sport"]],
              decls: 13,
              vars: 0,
              consts: [
                ["src", "../../luisdebenito/assets/tenis.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/bike.jpg", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "Sports"),
                  Je(),
                  Ye(2, "p"),
                  ut(
                    3,
                    " Sports have been a big part of my life, for the good and for the bad. I was a federated tennis player untill the age of 15, when I had to stop because of an injury\n"
                  ),
                  Je(),
                  an(4, "img", 0),
                  Ye(5, "p"),
                  ut(
                    6,
                    " I have been the captain of the university football team and the main responsible for the racket sports. We have won the inter-universities championships twice\n"
                  ),
                  Je(),
                  Ye(7, "p"),
                  ut(8, "I built a fixie bike!"),
                  Je(),
                  an(9, "img", 1),
                  Ye(10, "p")(11, "i"),
                  ut(
                    12,
                    "Location: Rothenburg, place where I worked and played football with Electrolux Team"
                  ),
                  Je()());
              },
            })),
            n
          );
        })(),
        tP = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-final"]],
              decls: 23,
              vars: 0,
              consts: [
                ["src", "../../luisdebenito/assets/radio.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/snow.jpg", 1, "img"],
                ["src", "../../luisdebenito/assets/camper.jpeg", 1, "img"],
                ["src", "../../luisdebenito/assets/forrest.jpg", 1, "img"],
                [1, "jumping"],
                [1, "colors"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Ye(0, "h1"),
                  ut(1, "Miscellanous"),
                  Je(),
                  Ye(2, "p"),
                  ut(
                    3,
                    "Last but not least, some random things I am quite proud of"
                  ),
                  Je(),
                  Ye(4, "p"),
                  ut(5, "I did an interview in the radio (no kidding)"),
                  Je(),
                  an(6, "img", 0),
                  Ye(7, "p"),
                  ut(8, "I created my own version of a snowboard (ski+skate)"),
                  Je(),
                  an(9, "img", 1),
                  Ye(10, "p"),
                  ut(11, "I am campering my van"),
                  Je(),
                  an(12, "img", 2),
                  Ye(13, "p"),
                  ut(14, "I am looking for Jenny"),
                  Je(),
                  an(15, "img", 3),
                  Ye(16, "p")(17, "i"),
                  ut(18, "Location: Stockholm, where I worked with Electrolux"),
                  Je()(),
                  Ye(19, "h1", 4),
                  ut(20, "Thanks for arriving to the end"),
                  Je(),
                  Ye(21, "h1", 5),
                  ut(22, "I hope you enjoyed a bit of my world"),
                  Je());
              },
              encapsulation: 2,
            })),
            n
          );
        })();
      const nP = ["cnt"];
      function iP(n, e) {
        1 & n && an(0, "app-intro");
      }
      function rP(n, e) {
        1 & n && an(0, "app-education");
      }
      function oP(n, e) {
        1 & n && an(0, "app-experience");
      }
      function sP(n, e) {
        1 & n && an(0, "app-music");
      }
      function aP(n, e) {
        1 & n && an(0, "app-trip");
      }
      function lP(n, e) {
        1 & n && an(0, "app-code");
      }
      function cP(n, e) {
        1 & n && an(0, "app-sport");
      }
      function uP(n, e) {
        1 & n && an(0, "app-final");
      }
      function hP(n, e) {
        if ((1 & n && (an(0, "i"), Ye(1, "span", 10), ut(2), Je()), 2 & n)) {
          const t = po().$implicit;
          (function S1(n, e, t) {
            dl(Qn, tc, _h(Ze(), n, e, t), !0);
          })("pi pi-", t.icon, ""),
            ei(2),
            _y(t.name);
        }
      }
      function dP(n, e) {
        1 & n && (Ye(0, "p-tabPanel"), Ri(1, hP, 3, 4, "ng-template", 9), Je());
      }
      let pP = (() => {
          class n {
            constructor() {
              (this.title = "ostoo"),
                (this.mapbox = zx),
                (this.style = "mapbox://styles/mapbox/light-v11"),
                (this.indexSelected = 0),
                (this.headers = [
                  { name: "Info", icon: "id-card", lt: [41.15907, -4.570329] },
                  {
                    name: "Education",
                    icon: "user-plus",
                    lt: [40.429561, -3.713232],
                  },
                  {
                    name: "Experience",
                    icon: "star",
                    lt: [45.508237, 12.267826],
                  },
                  {
                    name: "Music",
                    icon: "volume-up",
                    lt: [59.891037, 30.319812],
                  },
                  { name: "Trips", icon: "map", lt: [17.469947, 78.422454] },
                  { name: "Code", icon: "code", lt: [42.026967, -93.629812] },
                  { name: "Sports", icon: "flag", lt: [49.373385, 10.180248] },
                  { name: "Misc", icon: "globe", lt: [59.333226, 18.06828] },
                ]),
                (this.moving = !1),
                (this.mapbox.accessToken =
                  "pk.eyJ1Ijoid3lra3NzIiwiYSI6ImNqMjR6aTdmdzAwNHMzMnBvbjBucjlqNm8ifQ.6GjGpofWBVaIuSnhdXQb5w");
            }
            ngOnInit() {
              (this.map = new zx.Map({
                container: "map",
                style: this.style,
                zoom: 10,
                center: [0, 0],
                interactive: !1,
              })),
                this.initMap(),
                setTimeout(() => {
                  this.flyTo(this.headers[0].lt);
                }, 50);
            }
            initMap() {
              this.drawLocations();
            }
            generateRandomColor() {
              return "#" + Math.floor(16777215 * Math.random()).toString(16);
            }
            drawLocations() {
              this.headers.forEach((t) => {
                const s = document.createElement("div");
                (s.className = "custom-marker"),
                  (s.innerHTML =
                    ' <i class="pi pi-' +
                    t.icon +
                    '"></i> <p>' +
                    t.name +
                    "</p>"),
                  new zx.Marker({
                    color: this.generateRandomColor(),
                    element: s,
                  })
                    .setLngLat([t.lt[1], t.lt[0]])
                    .addTo(this.map);
              });
            }
            tabChanged(t) {
              t.index != this.indexSelected &&
                ((this.indexSelected = t.index),
                this.flyTo(this.headers[this.indexSelected].lt));
            }
            flyTo(t) {
              (this.moving = !0),
                this.map.flyTo({
                  center: [t[1], t[0]],
                  essential: !0,
                  speed: 1.4,
                  curve: 2.2,
                });
              let s = !1;
              this.map.on("moveend", () => {
                s ||
                  ((this.moving = !1),
                  setTimeout(() => {
                    this.container.nativeElement.scrollTop = 0;
                  }, 5)),
                  (s = !0);
              });
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = Yi({
              type: n,
              selectors: [["app-root"]],
              viewQuery: function (t, s) {
                if ((1 & t && Jd(nP, 5), 2 & t)) {
                  let c;
                  Jc((c = eu())) && (s.container = c.first);
                }
              },
              decls: 16,
              vars: 11,
              consts: [
                ["id", "map", 1, "container"],
                ["id", "mdl", 1, "modal", 3, "ngClass"],
                [1, "container"],
                ["cnt", ""],
                [1, "inContainer"],
                [4, "ngIf"],
                [1, "footer"],
                [3, "activeIndex", "onChange"],
                [4, "ngFor", "ngForOf"],
                ["pTemplate", "header"],
                [1, "spantitle"],
              ],
              template: function (t, s) {
                1 & t &&
                  (an(0, "div", 0),
                  Ye(1, "div", 1)(2, "div", 2, 3)(4, "div", 4),
                  Ri(5, iP, 1, 0, "app-intro", 5),
                  Ri(6, rP, 1, 0, "app-education", 5),
                  Ri(7, oP, 1, 0, "app-experience", 5),
                  Ri(8, sP, 1, 0, "app-music", 5),
                  Ri(9, aP, 1, 0, "app-trip", 5),
                  Ri(10, lP, 1, 0, "app-code", 5),
                  Ri(11, cP, 1, 0, "app-sport", 5),
                  Ri(12, uP, 1, 0, "app-final", 5),
                  Je()(),
                  Ye(13, "div", 6)(14, "p-tabView", 7),
                  yh("onChange", function (p) {
                    return s.tabChanged(p);
                  }),
                  Ri(15, dP, 2, 0, "p-tabPanel", 8),
                  Je()()()),
                  2 & t &&
                    (ei(1),
                    Gn("ngClass", s.moving ? "transp" : ""),
                    ei(4),
                    Gn("ngIf", 0 == s.indexSelected),
                    ei(1),
                    Gn("ngIf", 1 == s.indexSelected),
                    ei(1),
                    Gn("ngIf", 2 == s.indexSelected),
                    ei(1),
                    Gn("ngIf", 3 == s.indexSelected),
                    ei(1),
                    Gn("ngIf", 4 == s.indexSelected),
                    ei(1),
                    Gn("ngIf", 5 == s.indexSelected),
                    ei(1),
                    Gn("ngIf", 6 == s.indexSelected),
                    ei(1),
                    Gn("ngIf", 7 == s.indexSelected),
                    ei(2),
                    Gn("activeIndex", s.indexSelected),
                    ei(1),
                    Gn("ngForOf", s.headers));
              },
              dependencies: [
                Ex,
                Tx,
                Uy,
                vT,
                DT,
                TT,
                Z2,
                X2,
                K2,
                Y2,
                Q2,
                J2,
                eP,
                tP,
              ],
              styles: [
                ".container[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .map[_ngcontent-%COMP%]{height:100%}.container[_ngcontent-%COMP%]     .mapboxgl-control-container{display:none}.container[_ngcontent-%COMP%]     .customRoom:hover{cursor:pointer}  .p-tabview-nav-content{overflow-x:auto;overflow-y:hidden;scroll-behavior:smooth;scrollbar-width:none;overscroll-behavior:contain auto}  .p-tabview-nav{display:flex;margin:0;padding:0;list-style-type:none;flex:1 1 auto}  .p-tabview .p-tabview-nav li{border-top:1px solid white;background-color:#544008}  .p-tabview .p-tabview-nav li span.spantitle{margin:auto 10px}  .p-tabview .p-tabview-nav li.p-highlight .p-tabview-nav-link{background-color:#e8fccf;color:#544008}  .p-tabview .p-tabview-nav li .p-tabview-nav-link{transition:background-color .2s,box-shadow .2s}  .p-tabview .p-tabview-nav li .p-tabview-nav-link{color:#fff;padding:1.25rem;font-weight:700;border-bottom-right-radius:10px;border-bottom-left-radius:10px;transition:box-shadow .2s;margin:0 0 -2px}  .p-tabview-nav-link{cursor:pointer;-webkit-user-select:none;user-select:none;display:flex;align-items:center;position:relative;text-decoration:none;overflow:hidden}.addRoom[_ngcontent-%COMP%]{position:fixed;right:20px;bottom:20px;background-color:#3f51b5;height:70px;width:70px;border-radius:50%}.addRoom[_ngcontent-%COMP%]:hover{cursor:pointer}.modal[_ngcontent-%COMP%]{background-color:#544008;color:#f0f7ee;border:5px solid #f0f7ee;border-radius:20px;height:98%;position:fixed;z-index:800;top:1%}.modal[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{width:100%;height:7%;position:absolute;bottom:0;margin:auto}.modal[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]{width:100%;height:90%;max-height:90%;overflow-y:auto;position:absolute;top:0}.modal[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .inContainer[_ngcontent-%COMP%]{text-align:center}@media (max-width: 800px){  .p-tabview .p-tabview-nav li{padding-right:5px;padding-left:5px}.inContainer[_ngcontent-%COMP%]{margin:20px 3%}.modal[_ngcontent-%COMP%]{width:95%;left:1.5%}}@media (min-width: 800px){  .p-tabview .p-tabview-nav li{padding-right:30px;padding-left:30px}.inContainer[_ngcontent-%COMP%]{margin:20px 20%}.modal[_ngcontent-%COMP%]{width:68%;right:16%}}.transp[_ngcontent-%COMP%]{display:none}  .custom-marker{text-align:center;font-size:20px;background-color:#544008!important;border-radius:20px;padding:18px;color:#e8fccf}  .custom-marker p{margin:0}  .custom-marker i{font-size:60px}",
              ],
            })),
            n
          );
        })(),
        mP = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({ imports: [xh, jx] })),
            n
          );
        })();
      class CT {}
      const ru = "*";
      function ST(n, e = null) {
        return { type: 4, styles: e, timings: n };
      }
      function IT(n, e = null) {
        return { type: 2, steps: n, options: e };
      }
      function Ky(n) {
        return { type: 6, styles: n, offset: null };
      }
      function MT(n, e = null) {
        return { type: 8, animation: n, options: e };
      }
      function AT(n) {
        Promise.resolve().then(n);
      }
      class Lg {
        constructor(e = 0, t = 0) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this._started = !1),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._position = 0),
            (this.parentPlayer = null),
            (this.totalTime = e + t);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        init() {}
        play() {
          this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
            (this._started = !0);
        }
        triggerMicrotask() {
          AT(() => this._onFinish());
        }
        _onStart() {
          this._onStartFns.forEach((e) => e()), (this._onStartFns = []);
        }
        pause() {}
        restart() {}
        finish() {
          this._onFinish();
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.hasStarted() || this._onStart(),
            this.finish(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          (this._started = !1),
            (this._finished = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        setPosition(e) {
          this._position = this.totalTime ? e * this.totalTime : 1;
        }
        getPosition() {
          return this.totalTime ? this._position / this.totalTime : 1;
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((s) => s()), (t.length = 0);
        }
      }
      class PT {
        constructor(e) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._onDestroyFns = []),
            (this.parentPlayer = null),
            (this.totalTime = 0),
            (this.players = e);
          let t = 0,
            s = 0,
            c = 0;
          const p = this.players.length;
          0 == p
            ? AT(() => this._onFinish())
            : this.players.forEach((y) => {
                y.onDone(() => {
                  ++t == p && this._onFinish();
                }),
                  y.onDestroy(() => {
                    ++s == p && this._onDestroy();
                  }),
                  y.onStart(() => {
                    ++c == p && this._onStart();
                  });
              }),
            (this.totalTime = this.players.reduce(
              (y, w) => Math.max(y, w.totalTime),
              0
            ));
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this.players.forEach((e) => e.init());
        }
        onStart(e) {
          this._onStartFns.push(e);
        }
        _onStart() {
          this.hasStarted() ||
            ((this._started = !0),
            this._onStartFns.forEach((e) => e()),
            (this._onStartFns = []));
        }
        onDone(e) {
          this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this.parentPlayer || this.init(),
            this._onStart(),
            this.players.forEach((e) => e.play());
        }
        pause() {
          this.players.forEach((e) => e.pause());
        }
        restart() {
          this.players.forEach((e) => e.restart());
        }
        finish() {
          this._onFinish(), this.players.forEach((e) => e.finish());
        }
        destroy() {
          this._onDestroy();
        }
        _onDestroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._onFinish(),
            this.players.forEach((e) => e.destroy()),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          this.players.forEach((e) => e.reset()),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1);
        }
        setPosition(e) {
          const t = e * this.totalTime;
          this.players.forEach((s) => {
            const c = s.totalTime ? Math.min(1, t / s.totalTime) : 1;
            s.setPosition(c);
          });
        }
        getPosition() {
          const e = this.players.reduce(
            (t, s) => (null === t || s.totalTime > t.totalTime ? s : t),
            null
          );
          return null != e ? e.getPosition() : 0;
        }
        beforeDestroy() {
          this.players.forEach((e) => {
            e.beforeDestroy && e.beforeDestroy();
          });
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((s) => s()), (t.length = 0);
        }
      }
      let _P = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = ar({ type: n })),
          (n.ɵinj = ii({ imports: [xh] })),
          n
        );
      })();
      MT([
        Ky({ transform: "{{transform}}", opacity: 0 }),
        ST("{{transition}}"),
      ]),
        MT([
          ST("{{transition}}", Ky({ transform: "{{transform}}", opacity: 0 })),
        ]);
      let OP = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = ar({ type: n })),
          (n.ɵinj = ii({ imports: [xh, _P, jx, Bx] })),
          n
        );
      })();
      function LT(n) {
        return new st(3e3, !1);
      }
      function gL() {
        return typeof window < "u" && typeof window.document < "u";
      }
      function $x() {
        return (
          typeof process < "u" &&
          "[object process]" === {}.toString.call(process)
        );
      }
      function wh(n) {
        switch (n.length) {
          case 0:
            return new Lg();
          case 1:
            return n[0];
          default:
            return new PT(n);
        }
      }
      function kT(n, e, t, s, c = new Map(), p = new Map()) {
        const y = [],
          w = [];
        let C = -1,
          P = null;
        if (
          (s.forEach((N) => {
            const j = N.get("offset"),
              Q = j == C,
              ie = (Q && P) || new Map();
            N.forEach((pe, Ee) => {
              let Oe = Ee,
                Ue = pe;
              if ("offset" !== Ee)
                switch (((Oe = e.normalizePropertyName(Oe, y)), Ue)) {
                  case "!":
                    Ue = c.get(Ee);
                    break;
                  case ru:
                    Ue = p.get(Ee);
                    break;
                  default:
                    Ue = e.normalizeStyleValue(Ee, Oe, Ue, y);
                }
              ie.set(Oe, Ue);
            }),
              Q || w.push(ie),
              (P = ie),
              (C = j);
          }),
          y.length)
        )
          throw (function rL(n) {
            return new st(3502, !1);
          })();
        return w;
      }
      function Hx(n, e, t, s) {
        switch (e) {
          case "start":
            n.onStart(() => s(t && Gx(t, "start", n)));
            break;
          case "done":
            n.onDone(() => s(t && Gx(t, "done", n)));
            break;
          case "destroy":
            n.onDestroy(() => s(t && Gx(t, "destroy", n)));
        }
      }
      function Gx(n, e, t) {
        const p = qx(
            n.element,
            n.triggerName,
            n.fromState,
            n.toState,
            e || n.phaseName,
            t.totalTime ?? n.totalTime,
            !!t.disabled
          ),
          y = n._data;
        return null != y && (p._data = y), p;
      }
      function qx(n, e, t, s, c = "", p = 0, y) {
        return {
          element: n,
          triggerName: e,
          fromState: t,
          toState: s,
          phaseName: c,
          totalTime: p,
          disabled: !!y,
        };
      }
      function Is(n, e, t) {
        let s = n.get(e);
        return s || n.set(e, (s = t)), s;
      }
      function RT(n) {
        const e = n.indexOf(":");
        return [n.substring(1, e), n.slice(e + 1)];
      }
      let Wx = (n, e) => !1,
        OT = (n, e, t) => [],
        FT = null;
      function Zx(n) {
        const e = n.parentNode || n.host;
        return e === FT ? null : e;
      }
      ($x() || typeof Element < "u") &&
        (gL()
          ? ((FT = (() => document.documentElement)()),
            (Wx = (n, e) => {
              for (; e; ) {
                if (e === n) return !0;
                e = Zx(e);
              }
              return !1;
            }))
          : (Wx = (n, e) => n.contains(e)),
        (OT = (n, e, t) => {
          if (t) return Array.from(n.querySelectorAll(e));
          const s = n.querySelector(e);
          return s ? [s] : [];
        }));
      let tp = null,
        NT = !1;
      const zT = Wx,
        BT = OT;
      let VT = (() => {
          class n {
            validateStyleProperty(t) {
              return (function yL(n) {
                tp ||
                  ((tp =
                    (function vL() {
                      return typeof document < "u" ? document.body : null;
                    })() || {}),
                  (NT = !!tp.style && "WebkitAppearance" in tp.style));
                let e = !0;
                return (
                  tp.style &&
                    !(function _L(n) {
                      return "ebkit" == n.substring(1, 6);
                    })(n) &&
                    ((e = n in tp.style),
                    !e &&
                      NT &&
                      (e =
                        "Webkit" + n.charAt(0).toUpperCase() + n.slice(1) in
                        tp.style)),
                  e
                );
              })(t);
            }
            matchesElement(t, s) {
              return !1;
            }
            containsElement(t, s) {
              return zT(t, s);
            }
            getParentElement(t) {
              return Zx(t);
            }
            query(t, s, c) {
              return BT(t, s, c);
            }
            computeStyle(t, s, c) {
              return c || "";
            }
            animate(t, s, c, p, y, w = [], C) {
              return new Lg(c, p);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Xx = (() => {
          class n {}
          return (n.NOOP = new VT()), n;
        })();
      const Kx = "ng-enter",
        Yy = "ng-leave",
        Qy = "ng-trigger",
        Jy = ".ng-trigger",
        UT = "ng-animating",
        Yx = ".ng-animating";
      function ou(n) {
        if ("number" == typeof n) return n;
        const e = n.match(/^(-?[\.\d]+)(m?s)/);
        return !e || e.length < 2 ? 0 : Qx(parseFloat(e[1]), e[2]);
      }
      function Qx(n, e) {
        return "s" === e ? 1e3 * n : n;
      }
      function ev(n, e, t) {
        return n.hasOwnProperty("duration")
          ? n
          : (function wL(n, e, t) {
              let c,
                p = 0,
                y = "";
              if ("string" == typeof n) {
                const w = n.match(
                  /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i
                );
                if (null === w)
                  return e.push(LT()), { duration: 0, delay: 0, easing: "" };
                c = Qx(parseFloat(w[1]), w[2]);
                const C = w[3];
                null != C && (p = Qx(parseFloat(C), w[4]));
                const P = w[5];
                P && (y = P);
              } else c = n;
              if (!t) {
                let w = !1,
                  C = e.length;
                c < 0 &&
                  (e.push(
                    (function FP() {
                      return new st(3100, !1);
                    })()
                  ),
                  (w = !0)),
                  p < 0 &&
                    (e.push(
                      (function NP() {
                        return new st(3101, !1);
                      })()
                    ),
                    (w = !0)),
                  w && e.splice(C, 0, LT());
              }
              return { duration: c, delay: p, easing: y };
            })(n, e, t);
      }
      function kg(n, e = {}) {
        return (
          Object.keys(n).forEach((t) => {
            e[t] = n[t];
          }),
          e
        );
      }
      function $T(n) {
        const e = new Map();
        return (
          Object.keys(n).forEach((t) => {
            e.set(t, n[t]);
          }),
          e
        );
      }
      function Eh(n, e = new Map(), t) {
        if (t) for (let [s, c] of t) e.set(s, c);
        for (let [s, c] of n) e.set(s, c);
        return e;
      }
      function GT(n, e, t) {
        return t ? e + ":" + t + ";" : "";
      }
      function qT(n) {
        let e = "";
        for (let t = 0; t < n.style.length; t++) {
          const s = n.style.item(t);
          e += GT(0, s, n.style.getPropertyValue(s));
        }
        for (const t in n.style)
          n.style.hasOwnProperty(t) &&
            !t.startsWith("_") &&
            (e += GT(0, CL(t), n.style[t]));
        n.setAttribute("style", e);
      }
      function ic(n, e, t) {
        n.style &&
          (e.forEach((s, c) => {
            const p = eb(c);
            t && !t.has(c) && t.set(c, n.style[p]), (n.style[p] = s);
          }),
          $x() && qT(n));
      }
      function np(n, e) {
        n.style &&
          (e.forEach((t, s) => {
            const c = eb(s);
            n.style[c] = "";
          }),
          $x() && qT(n));
      }
      function Rg(n) {
        return Array.isArray(n) ? (1 == n.length ? n[0] : IT(n)) : n;
      }
      const Jx = new RegExp("{{\\s*(.+?)\\s*}}", "g");
      function WT(n) {
        let e = [];
        if ("string" == typeof n) {
          let t;
          for (; (t = Jx.exec(n)); ) e.push(t[1]);
          Jx.lastIndex = 0;
        }
        return e;
      }
      function Og(n, e, t) {
        const s = n.toString(),
          c = s.replace(Jx, (p, y) => {
            let w = e[y];
            return (
              null == w &&
                (t.push(
                  (function BP(n) {
                    return new st(3003, !1);
                  })()
                ),
                (w = "")),
              w.toString()
            );
          });
        return c == s ? n : c;
      }
      function tv(n) {
        const e = [];
        let t = n.next();
        for (; !t.done; ) e.push(t.value), (t = n.next());
        return e;
      }
      const DL = /-+([a-z0-9])/g;
      function eb(n) {
        return n.replace(DL, (...e) => e[1].toUpperCase());
      }
      function CL(n) {
        return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
      function Ms(n, e, t) {
        switch (e.type) {
          case 7:
            return n.visitTrigger(e, t);
          case 0:
            return n.visitState(e, t);
          case 1:
            return n.visitTransition(e, t);
          case 2:
            return n.visitSequence(e, t);
          case 3:
            return n.visitGroup(e, t);
          case 4:
            return n.visitAnimate(e, t);
          case 5:
            return n.visitKeyframes(e, t);
          case 6:
            return n.visitStyle(e, t);
          case 8:
            return n.visitReference(e, t);
          case 9:
            return n.visitAnimateChild(e, t);
          case 10:
            return n.visitAnimateRef(e, t);
          case 11:
            return n.visitQuery(e, t);
          case 12:
            return n.visitStagger(e, t);
          default:
            throw (function VP(n) {
              return new st(3004, !1);
            })();
        }
      }
      function ZT(n, e) {
        return window.getComputedStyle(n)[e];
      }
      function LL(n, e) {
        const t = [];
        return (
          "string" == typeof n
            ? n.split(/\s*,\s*/).forEach((s) =>
                (function kL(n, e, t) {
                  if (":" == n[0]) {
                    const C = (function RL(n, e) {
                      switch (n) {
                        case ":enter":
                          return "void => *";
                        case ":leave":
                          return "* => void";
                        case ":increment":
                          return (t, s) => parseFloat(s) > parseFloat(t);
                        case ":decrement":
                          return (t, s) => parseFloat(s) < parseFloat(t);
                        default:
                          return (
                            e.push(
                              (function eL(n) {
                                return new st(3016, !1);
                              })()
                            ),
                            "* => *"
                          );
                      }
                    })(n, t);
                    if ("function" == typeof C) return void e.push(C);
                    n = C;
                  }
                  const s = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                  if (null == s || s.length < 4)
                    return (
                      t.push(
                        (function JP(n) {
                          return new st(3015, !1);
                        })()
                      ),
                      e
                    );
                  const c = s[1],
                    p = s[2],
                    y = s[3];
                  e.push(XT(c, y));
                  "<" == p[0] && !("*" == c && "*" == y) && e.push(XT(y, c));
                })(s, t, e)
              )
            : t.push(n),
          t
        );
      }
      const ov = new Set(["true", "1"]),
        sv = new Set(["false", "0"]);
      function XT(n, e) {
        const t = ov.has(n) || sv.has(n),
          s = ov.has(e) || sv.has(e);
        return (c, p) => {
          let y = "*" == n || n == c,
            w = "*" == e || e == p;
          return (
            !y && t && "boolean" == typeof c && (y = c ? ov.has(n) : sv.has(n)),
            !w && s && "boolean" == typeof p && (w = p ? ov.has(e) : sv.has(e)),
            y && w
          );
        };
      }
      const OL = new RegExp("s*:selfs*,?", "g");
      function tb(n, e, t, s) {
        return new FL(n).build(e, t, s);
      }
      class FL {
        constructor(e) {
          this._driver = e;
        }
        build(e, t, s) {
          const c = new BL(t);
          return this._resetContextStyleTimingState(c), Ms(this, Rg(e), c);
        }
        _resetContextStyleTimingState(e) {
          (e.currentQuerySelector = ""),
            (e.collectedStyles = new Map()),
            e.collectedStyles.set("", new Map()),
            (e.currentTime = 0);
        }
        visitTrigger(e, t) {
          let s = (t.queryCount = 0),
            c = (t.depCount = 0);
          const p = [],
            y = [];
          return (
            "@" == e.name.charAt(0) &&
              t.errors.push(
                (function UP() {
                  return new st(3006, !1);
                })()
              ),
            e.definitions.forEach((w) => {
              if ((this._resetContextStyleTimingState(t), 0 == w.type)) {
                const C = w,
                  P = C.name;
                P.toString()
                  .split(/\s*,\s*/)
                  .forEach((N) => {
                    (C.name = N), p.push(this.visitState(C, t));
                  }),
                  (C.name = P);
              } else if (1 == w.type) {
                const C = this.visitTransition(w, t);
                (s += C.queryCount), (c += C.depCount), y.push(C);
              } else
                t.errors.push(
                  (function $P() {
                    return new st(3007, !1);
                  })()
                );
            }),
            {
              type: 7,
              name: e.name,
              states: p,
              transitions: y,
              queryCount: s,
              depCount: c,
              options: null,
            }
          );
        }
        visitState(e, t) {
          const s = this.visitStyle(e.styles, t),
            c = (e.options && e.options.params) || null;
          if (s.containsDynamicStyles) {
            const p = new Set(),
              y = c || {};
            s.styles.forEach((w) => {
              w instanceof Map &&
                w.forEach((C) => {
                  WT(C).forEach((P) => {
                    y.hasOwnProperty(P) || p.add(P);
                  });
                });
            }),
              p.size &&
                (tv(p.values()),
                t.errors.push(
                  (function HP(n, e) {
                    return new st(3008, !1);
                  })()
                ));
          }
          return {
            type: 0,
            name: e.name,
            style: s,
            options: c ? { params: c } : null,
          };
        }
        visitTransition(e, t) {
          (t.queryCount = 0), (t.depCount = 0);
          const s = Ms(this, Rg(e.animation), t);
          return {
            type: 1,
            matchers: LL(e.expr, t.errors),
            animation: s,
            queryCount: t.queryCount,
            depCount: t.depCount,
            options: ip(e.options),
          };
        }
        visitSequence(e, t) {
          return {
            type: 2,
            steps: e.steps.map((s) => Ms(this, s, t)),
            options: ip(e.options),
          };
        }
        visitGroup(e, t) {
          const s = t.currentTime;
          let c = 0;
          const p = e.steps.map((y) => {
            t.currentTime = s;
            const w = Ms(this, y, t);
            return (c = Math.max(c, t.currentTime)), w;
          });
          return (
            (t.currentTime = c), { type: 3, steps: p, options: ip(e.options) }
          );
        }
        visitAnimate(e, t) {
          const s = (function jL(n, e) {
            if (n.hasOwnProperty("duration")) return n;
            if ("number" == typeof n) return nb(ev(n, e).duration, 0, "");
            const t = n;
            if (
              t
                .split(/\s+/)
                .some((p) => "{" == p.charAt(0) && "{" == p.charAt(1))
            ) {
              const p = nb(0, 0, "");
              return (p.dynamic = !0), (p.strValue = t), p;
            }
            const c = ev(t, e);
            return nb(c.duration, c.delay, c.easing);
          })(e.timings, t.errors);
          t.currentAnimateTimings = s;
          let c,
            p = e.styles ? e.styles : Ky({});
          if (5 == p.type) c = this.visitKeyframes(p, t);
          else {
            let y = e.styles,
              w = !1;
            if (!y) {
              w = !0;
              const P = {};
              s.easing && (P.easing = s.easing), (y = Ky(P));
            }
            t.currentTime += s.duration + s.delay;
            const C = this.visitStyle(y, t);
            (C.isEmptyStep = w), (c = C);
          }
          return (
            (t.currentAnimateTimings = null),
            { type: 4, timings: s, style: c, options: null }
          );
        }
        visitStyle(e, t) {
          const s = this._makeStyleAst(e, t);
          return this._validateStyleAst(s, t), s;
        }
        _makeStyleAst(e, t) {
          const s = [],
            c = Array.isArray(e.styles) ? e.styles : [e.styles];
          for (let w of c)
            "string" == typeof w
              ? w === ru
                ? s.push(w)
                : t.errors.push(new st(3002, !1))
              : s.push($T(w));
          let p = !1,
            y = null;
          return (
            s.forEach((w) => {
              if (
                w instanceof Map &&
                (w.has("easing") && ((y = w.get("easing")), w.delete("easing")),
                !p)
              )
                for (let C of w.values())
                  if (C.toString().indexOf("{{") >= 0) {
                    p = !0;
                    break;
                  }
            }),
            {
              type: 6,
              styles: s,
              easing: y,
              offset: e.offset,
              containsDynamicStyles: p,
              options: null,
            }
          );
        }
        _validateStyleAst(e, t) {
          const s = t.currentAnimateTimings;
          let c = t.currentTime,
            p = t.currentTime;
          s && p > 0 && (p -= s.duration + s.delay),
            e.styles.forEach((y) => {
              "string" != typeof y &&
                y.forEach((w, C) => {
                  const P = t.collectedStyles.get(t.currentQuerySelector),
                    N = P.get(C);
                  let j = !0;
                  N &&
                    (p != c &&
                      p >= N.startTime &&
                      c <= N.endTime &&
                      (t.errors.push(
                        (function qP(n, e, t, s, c) {
                          return new st(3010, !1);
                        })()
                      ),
                      (j = !1)),
                    (p = N.startTime)),
                    j && P.set(C, { startTime: p, endTime: c }),
                    t.options &&
                      (function TL(n, e, t) {
                        const s = e.params || {},
                          c = WT(n);
                        c.length &&
                          c.forEach((p) => {
                            s.hasOwnProperty(p) ||
                              t.push(
                                (function zP(n) {
                                  return new st(3001, !1);
                                })()
                              );
                          });
                      })(w, t.options, t.errors);
                });
            });
        }
        visitKeyframes(e, t) {
          const s = { type: 5, styles: [], options: null };
          if (!t.currentAnimateTimings)
            return (
              t.errors.push(
                (function WP() {
                  return new st(3011, !1);
                })()
              ),
              s
            );
          let p = 0;
          const y = [];
          let w = !1,
            C = !1,
            P = 0;
          const N = e.steps.map((Ue) => {
            const ht = this._makeStyleAst(Ue, t);
            let ze =
                null != ht.offset
                  ? ht.offset
                  : (function VL(n) {
                      if ("string" == typeof n) return null;
                      let e = null;
                      if (Array.isArray(n))
                        n.forEach((t) => {
                          if (t instanceof Map && t.has("offset")) {
                            const s = t;
                            (e = parseFloat(s.get("offset"))),
                              s.delete("offset");
                          }
                        });
                      else if (n instanceof Map && n.has("offset")) {
                        const t = n;
                        (e = parseFloat(t.get("offset"))), t.delete("offset");
                      }
                      return e;
                    })(ht.styles),
              vt = 0;
            return (
              null != ze && (p++, (vt = ht.offset = ze)),
              (C = C || vt < 0 || vt > 1),
              (w = w || vt < P),
              (P = vt),
              y.push(vt),
              ht
            );
          });
          C &&
            t.errors.push(
              (function ZP() {
                return new st(3012, !1);
              })()
            ),
            w &&
              t.errors.push(
                (function XP() {
                  return new st(3200, !1);
                })()
              );
          const j = e.steps.length;
          let Q = 0;
          p > 0 && p < j
            ? t.errors.push(
                (function KP() {
                  return new st(3202, !1);
                })()
              )
            : 0 == p && (Q = 1 / (j - 1));
          const ie = j - 1,
            pe = t.currentTime,
            Ee = t.currentAnimateTimings,
            Oe = Ee.duration;
          return (
            N.forEach((Ue, ht) => {
              const ze = Q > 0 ? (ht == ie ? 1 : Q * ht) : y[ht],
                vt = ze * Oe;
              (t.currentTime = pe + Ee.delay + vt),
                (Ee.duration = vt),
                this._validateStyleAst(Ue, t),
                (Ue.offset = ze),
                s.styles.push(Ue);
            }),
            s
          );
        }
        visitReference(e, t) {
          return {
            type: 8,
            animation: Ms(this, Rg(e.animation), t),
            options: ip(e.options),
          };
        }
        visitAnimateChild(e, t) {
          return t.depCount++, { type: 9, options: ip(e.options) };
        }
        visitAnimateRef(e, t) {
          return {
            type: 10,
            animation: this.visitReference(e.animation, t),
            options: ip(e.options),
          };
        }
        visitQuery(e, t) {
          const s = t.currentQuerySelector,
            c = e.options || {};
          t.queryCount++, (t.currentQuery = e);
          const [p, y] = (function NL(n) {
            const e = !!n.split(/\s*,\s*/).find((t) => ":self" == t);
            return (
              e && (n = n.replace(OL, "")),
              (n = n
                .replace(/@\*/g, Jy)
                .replace(/@\w+/g, (t) => Jy + "-" + t.slice(1))
                .replace(/:animating/g, Yx)),
              [n, e]
            );
          })(e.selector);
          (t.currentQuerySelector = s.length ? s + " " + p : p),
            Is(t.collectedStyles, t.currentQuerySelector, new Map());
          const w = Ms(this, Rg(e.animation), t);
          return (
            (t.currentQuery = null),
            (t.currentQuerySelector = s),
            {
              type: 11,
              selector: p,
              limit: c.limit || 0,
              optional: !!c.optional,
              includeSelf: y,
              animation: w,
              originalSelector: e.selector,
              options: ip(e.options),
            }
          );
        }
        visitStagger(e, t) {
          t.currentQuery ||
            t.errors.push(
              (function YP() {
                return new st(3013, !1);
              })()
            );
          const s =
            "full" === e.timings
              ? { duration: 0, delay: 0, easing: "full" }
              : ev(e.timings, t.errors, !0);
          return {
            type: 12,
            animation: Ms(this, Rg(e.animation), t),
            timings: s,
            options: null,
          };
        }
      }
      class BL {
        constructor(e) {
          (this.errors = e),
            (this.queryCount = 0),
            (this.depCount = 0),
            (this.currentTransition = null),
            (this.currentQuery = null),
            (this.currentQuerySelector = null),
            (this.currentAnimateTimings = null),
            (this.currentTime = 0),
            (this.collectedStyles = new Map()),
            (this.options = null),
            (this.unsupportedCSSPropertiesFound = new Set());
        }
      }
      function ip(n) {
        return (
          n
            ? (n = kg(n)).params &&
              (n.params = (function zL(n) {
                return n ? kg(n) : null;
              })(n.params))
            : (n = {}),
          n
        );
      }
      function nb(n, e, t) {
        return { duration: n, delay: e, easing: t };
      }
      function ib(n, e, t, s, c, p, y = null, w = !1) {
        return {
          type: 1,
          element: n,
          keyframes: e,
          preStyleProps: t,
          postStyleProps: s,
          duration: c,
          delay: p,
          totalTime: c + p,
          easing: y,
          subTimeline: w,
        };
      }
      class av {
        constructor() {
          this._map = new Map();
        }
        get(e) {
          return this._map.get(e) || [];
        }
        append(e, t) {
          let s = this._map.get(e);
          s || this._map.set(e, (s = [])), s.push(...t);
        }
        has(e) {
          return this._map.has(e);
        }
        clear() {
          this._map.clear();
        }
      }
      const HL = new RegExp(":enter", "g"),
        qL = new RegExp(":leave", "g");
      function rb(n, e, t, s, c, p = new Map(), y = new Map(), w, C, P = []) {
        return new WL().buildKeyframes(n, e, t, s, c, p, y, w, C, P);
      }
      class WL {
        buildKeyframes(e, t, s, c, p, y, w, C, P, N = []) {
          P = P || new av();
          const j = new ob(e, t, P, c, p, N, []);
          j.options = C;
          const Q = C.delay ? ou(C.delay) : 0;
          j.currentTimeline.delayNextStep(Q),
            j.currentTimeline.setStyles([y], null, j.errors, C),
            Ms(this, s, j);
          const ie = j.timelines.filter((pe) => pe.containsAnimation());
          if (ie.length && w.size) {
            let pe;
            for (let Ee = ie.length - 1; Ee >= 0; Ee--) {
              const Oe = ie[Ee];
              if (Oe.element === t) {
                pe = Oe;
                break;
              }
            }
            pe &&
              !pe.allowOnlyTimelineStyles() &&
              pe.setStyles([w], null, j.errors, C);
          }
          return ie.length
            ? ie.map((pe) => pe.buildKeyframes())
            : [ib(t, [], [], [], 0, Q, "", !1)];
        }
        visitTrigger(e, t) {}
        visitState(e, t) {}
        visitTransition(e, t) {}
        visitAnimateChild(e, t) {
          const s = t.subInstructions.get(t.element);
          if (s) {
            const c = t.createSubContext(e.options),
              p = t.currentTimeline.currentTime,
              y = this._visitSubInstructions(s, c, c.options);
            p != y && t.transformIntoNewTimeline(y);
          }
          t.previousNode = e;
        }
        visitAnimateRef(e, t) {
          const s = t.createSubContext(e.options);
          s.transformIntoNewTimeline(),
            this._applyAnimationRefDelays(
              [e.options, e.animation.options],
              t,
              s
            ),
            this.visitReference(e.animation, s),
            t.transformIntoNewTimeline(s.currentTimeline.currentTime),
            (t.previousNode = e);
        }
        _applyAnimationRefDelays(e, t, s) {
          for (const c of e) {
            const p = c?.delay;
            if (p) {
              const y =
                "number" == typeof p ? p : ou(Og(p, c?.params ?? {}, t.errors));
              s.delayNextStep(y);
            }
          }
        }
        _visitSubInstructions(e, t, s) {
          let p = t.currentTimeline.currentTime;
          const y = null != s.duration ? ou(s.duration) : null,
            w = null != s.delay ? ou(s.delay) : null;
          return (
            0 !== y &&
              e.forEach((C) => {
                const P = t.appendInstructionToTimeline(C, y, w);
                p = Math.max(p, P.duration + P.delay);
              }),
            p
          );
        }
        visitReference(e, t) {
          t.updateOptions(e.options, !0),
            Ms(this, e.animation, t),
            (t.previousNode = e);
        }
        visitSequence(e, t) {
          const s = t.subContextCount;
          let c = t;
          const p = e.options;
          if (
            p &&
            (p.params || p.delay) &&
            ((c = t.createSubContext(p)),
            c.transformIntoNewTimeline(),
            null != p.delay)
          ) {
            6 == c.previousNode.type &&
              (c.currentTimeline.snapshotCurrentStyles(),
              (c.previousNode = lv));
            const y = ou(p.delay);
            c.delayNextStep(y);
          }
          e.steps.length &&
            (e.steps.forEach((y) => Ms(this, y, c)),
            c.currentTimeline.applyStylesToKeyframe(),
            c.subContextCount > s && c.transformIntoNewTimeline()),
            (t.previousNode = e);
        }
        visitGroup(e, t) {
          const s = [];
          let c = t.currentTimeline.currentTime;
          const p = e.options && e.options.delay ? ou(e.options.delay) : 0;
          e.steps.forEach((y) => {
            const w = t.createSubContext(e.options);
            p && w.delayNextStep(p),
              Ms(this, y, w),
              (c = Math.max(c, w.currentTimeline.currentTime)),
              s.push(w.currentTimeline);
          }),
            s.forEach((y) => t.currentTimeline.mergeTimelineCollectedStyles(y)),
            t.transformIntoNewTimeline(c),
            (t.previousNode = e);
        }
        _visitTiming(e, t) {
          if (e.dynamic) {
            const s = e.strValue;
            return ev(t.params ? Og(s, t.params, t.errors) : s, t.errors);
          }
          return { duration: e.duration, delay: e.delay, easing: e.easing };
        }
        visitAnimate(e, t) {
          const s = (t.currentAnimateTimings = this._visitTiming(e.timings, t)),
            c = t.currentTimeline;
          s.delay && (t.incrementTime(s.delay), c.snapshotCurrentStyles());
          const p = e.style;
          5 == p.type
            ? this.visitKeyframes(p, t)
            : (t.incrementTime(s.duration),
              this.visitStyle(p, t),
              c.applyStylesToKeyframe()),
            (t.currentAnimateTimings = null),
            (t.previousNode = e);
        }
        visitStyle(e, t) {
          const s = t.currentTimeline,
            c = t.currentAnimateTimings;
          !c && s.hasCurrentStyleProperties() && s.forwardFrame();
          const p = (c && c.easing) || e.easing;
          e.isEmptyStep
            ? s.applyEmptyStep(p)
            : s.setStyles(e.styles, p, t.errors, t.options),
            (t.previousNode = e);
        }
        visitKeyframes(e, t) {
          const s = t.currentAnimateTimings,
            c = t.currentTimeline.duration,
            p = s.duration,
            w = t.createSubContext().currentTimeline;
          (w.easing = s.easing),
            e.styles.forEach((C) => {
              w.forwardTime((C.offset || 0) * p),
                w.setStyles(C.styles, C.easing, t.errors, t.options),
                w.applyStylesToKeyframe();
            }),
            t.currentTimeline.mergeTimelineCollectedStyles(w),
            t.transformIntoNewTimeline(c + p),
            (t.previousNode = e);
        }
        visitQuery(e, t) {
          const s = t.currentTimeline.currentTime,
            c = e.options || {},
            p = c.delay ? ou(c.delay) : 0;
          p &&
            (6 === t.previousNode.type ||
              (0 == s && t.currentTimeline.hasCurrentStyleProperties())) &&
            (t.currentTimeline.snapshotCurrentStyles(), (t.previousNode = lv));
          let y = s;
          const w = t.invokeQuery(
            e.selector,
            e.originalSelector,
            e.limit,
            e.includeSelf,
            !!c.optional,
            t.errors
          );
          t.currentQueryTotal = w.length;
          let C = null;
          w.forEach((P, N) => {
            t.currentQueryIndex = N;
            const j = t.createSubContext(e.options, P);
            p && j.delayNextStep(p),
              P === t.element && (C = j.currentTimeline),
              Ms(this, e.animation, j),
              j.currentTimeline.applyStylesToKeyframe(),
              (y = Math.max(y, j.currentTimeline.currentTime));
          }),
            (t.currentQueryIndex = 0),
            (t.currentQueryTotal = 0),
            t.transformIntoNewTimeline(y),
            C &&
              (t.currentTimeline.mergeTimelineCollectedStyles(C),
              t.currentTimeline.snapshotCurrentStyles()),
            (t.previousNode = e);
        }
        visitStagger(e, t) {
          const s = t.parentContext,
            c = t.currentTimeline,
            p = e.timings,
            y = Math.abs(p.duration),
            w = y * (t.currentQueryTotal - 1);
          let C = y * t.currentQueryIndex;
          switch (p.duration < 0 ? "reverse" : p.easing) {
            case "reverse":
              C = w - C;
              break;
            case "full":
              C = s.currentStaggerTime;
          }
          const N = t.currentTimeline;
          C && N.delayNextStep(C);
          const j = N.currentTime;
          Ms(this, e.animation, t),
            (t.previousNode = e),
            (s.currentStaggerTime =
              c.currentTime - j + (c.startTime - s.currentTimeline.startTime));
        }
      }
      const lv = {};
      class ob {
        constructor(e, t, s, c, p, y, w, C) {
          (this._driver = e),
            (this.element = t),
            (this.subInstructions = s),
            (this._enterClassName = c),
            (this._leaveClassName = p),
            (this.errors = y),
            (this.timelines = w),
            (this.parentContext = null),
            (this.currentAnimateTimings = null),
            (this.previousNode = lv),
            (this.subContextCount = 0),
            (this.options = {}),
            (this.currentQueryIndex = 0),
            (this.currentQueryTotal = 0),
            (this.currentStaggerTime = 0),
            (this.currentTimeline = C || new cv(this._driver, t, 0)),
            w.push(this.currentTimeline);
        }
        get params() {
          return this.options.params;
        }
        updateOptions(e, t) {
          if (!e) return;
          const s = e;
          let c = this.options;
          null != s.duration && (c.duration = ou(s.duration)),
            null != s.delay && (c.delay = ou(s.delay));
          const p = s.params;
          if (p) {
            let y = c.params;
            y || (y = this.options.params = {}),
              Object.keys(p).forEach((w) => {
                (!t || !y.hasOwnProperty(w)) &&
                  (y[w] = Og(p[w], y, this.errors));
              });
          }
        }
        _copyOptions() {
          const e = {};
          if (this.options) {
            const t = this.options.params;
            if (t) {
              const s = (e.params = {});
              Object.keys(t).forEach((c) => {
                s[c] = t[c];
              });
            }
          }
          return e;
        }
        createSubContext(e = null, t, s) {
          const c = t || this.element,
            p = new ob(
              this._driver,
              c,
              this.subInstructions,
              this._enterClassName,
              this._leaveClassName,
              this.errors,
              this.timelines,
              this.currentTimeline.fork(c, s || 0)
            );
          return (
            (p.previousNode = this.previousNode),
            (p.currentAnimateTimings = this.currentAnimateTimings),
            (p.options = this._copyOptions()),
            p.updateOptions(e),
            (p.currentQueryIndex = this.currentQueryIndex),
            (p.currentQueryTotal = this.currentQueryTotal),
            (p.parentContext = this),
            this.subContextCount++,
            p
          );
        }
        transformIntoNewTimeline(e) {
          return (
            (this.previousNode = lv),
            (this.currentTimeline = this.currentTimeline.fork(this.element, e)),
            this.timelines.push(this.currentTimeline),
            this.currentTimeline
          );
        }
        appendInstructionToTimeline(e, t, s) {
          const c = {
              duration: t ?? e.duration,
              delay: this.currentTimeline.currentTime + (s ?? 0) + e.delay,
              easing: "",
            },
            p = new ZL(
              this._driver,
              e.element,
              e.keyframes,
              e.preStyleProps,
              e.postStyleProps,
              c,
              e.stretchStartingKeyframe
            );
          return this.timelines.push(p), c;
        }
        incrementTime(e) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + e);
        }
        delayNextStep(e) {
          e > 0 && this.currentTimeline.delayNextStep(e);
        }
        invokeQuery(e, t, s, c, p, y) {
          let w = [];
          if ((c && w.push(this.element), e.length > 0)) {
            e = (e = e.replace(HL, "." + this._enterClassName)).replace(
              qL,
              "." + this._leaveClassName
            );
            let P = this._driver.query(this.element, e, 1 != s);
            0 !== s &&
              (P = s < 0 ? P.slice(P.length + s, P.length) : P.slice(0, s)),
              w.push(...P);
          }
          return (
            !p &&
              0 == w.length &&
              y.push(
                (function QP(n) {
                  return new st(3014, !1);
                })()
              ),
            w
          );
        }
      }
      class cv {
        constructor(e, t, s, c) {
          (this._driver = e),
            (this.element = t),
            (this.startTime = s),
            (this._elementTimelineStylesLookup = c),
            (this.duration = 0),
            (this._previousKeyframe = new Map()),
            (this._currentKeyframe = new Map()),
            (this._keyframes = new Map()),
            (this._styleSummary = new Map()),
            (this._localTimelineStyles = new Map()),
            (this._pendingStyles = new Map()),
            (this._backFill = new Map()),
            (this._currentEmptyStepKeyframe = null),
            this._elementTimelineStylesLookup ||
              (this._elementTimelineStylesLookup = new Map()),
            (this._globalTimelineStyles =
              this._elementTimelineStylesLookup.get(t)),
            this._globalTimelineStyles ||
              ((this._globalTimelineStyles = this._localTimelineStyles),
              this._elementTimelineStylesLookup.set(
                t,
                this._localTimelineStyles
              )),
            this._loadKeyframe();
        }
        containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return !1;
            case 1:
              return this.hasCurrentStyleProperties();
            default:
              return !0;
          }
        }
        hasCurrentStyleProperties() {
          return this._currentKeyframe.size > 0;
        }
        get currentTime() {
          return this.startTime + this.duration;
        }
        delayNextStep(e) {
          const t = 1 === this._keyframes.size && this._pendingStyles.size;
          this.duration || t
            ? (this.forwardTime(this.currentTime + e),
              t && this.snapshotCurrentStyles())
            : (this.startTime += e);
        }
        fork(e, t) {
          return (
            this.applyStylesToKeyframe(),
            new cv(
              this._driver,
              e,
              t || this.currentTime,
              this._elementTimelineStylesLookup
            )
          );
        }
        _loadKeyframe() {
          this._currentKeyframe &&
            (this._previousKeyframe = this._currentKeyframe),
            (this._currentKeyframe = this._keyframes.get(this.duration)),
            this._currentKeyframe ||
              ((this._currentKeyframe = new Map()),
              this._keyframes.set(this.duration, this._currentKeyframe));
        }
        forwardFrame() {
          (this.duration += 1), this._loadKeyframe();
        }
        forwardTime(e) {
          this.applyStylesToKeyframe(),
            (this.duration = e),
            this._loadKeyframe();
        }
        _updateStyle(e, t) {
          this._localTimelineStyles.set(e, t),
            this._globalTimelineStyles.set(e, t),
            this._styleSummary.set(e, { time: this.currentTime, value: t });
        }
        allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe;
        }
        applyEmptyStep(e) {
          e && this._previousKeyframe.set("easing", e);
          for (let [t, s] of this._globalTimelineStyles)
            this._backFill.set(t, s || ru), this._currentKeyframe.set(t, ru);
          this._currentEmptyStepKeyframe = this._currentKeyframe;
        }
        setStyles(e, t, s, c) {
          t && this._previousKeyframe.set("easing", t);
          const p = (c && c.params) || {},
            y = (function XL(n, e) {
              const t = new Map();
              let s;
              return (
                n.forEach((c) => {
                  if ("*" === c) {
                    s = s || e.keys();
                    for (let p of s) t.set(p, ru);
                  } else Eh(c, t);
                }),
                t
              );
            })(e, this._globalTimelineStyles);
          for (let [w, C] of y) {
            const P = Og(C, p, s);
            this._pendingStyles.set(w, P),
              this._localTimelineStyles.has(w) ||
                this._backFill.set(w, this._globalTimelineStyles.get(w) ?? ru),
              this._updateStyle(w, P);
          }
        }
        applyStylesToKeyframe() {
          0 != this._pendingStyles.size &&
            (this._pendingStyles.forEach((e, t) => {
              this._currentKeyframe.set(t, e);
            }),
            this._pendingStyles.clear(),
            this._localTimelineStyles.forEach((e, t) => {
              this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e);
            }));
        }
        snapshotCurrentStyles() {
          for (let [e, t] of this._localTimelineStyles)
            this._pendingStyles.set(e, t), this._updateStyle(e, t);
        }
        getFinalKeyframe() {
          return this._keyframes.get(this.duration);
        }
        get properties() {
          const e = [];
          for (let t in this._currentKeyframe) e.push(t);
          return e;
        }
        mergeTimelineCollectedStyles(e) {
          e._styleSummary.forEach((t, s) => {
            const c = this._styleSummary.get(s);
            (!c || t.time > c.time) && this._updateStyle(s, t.value);
          });
        }
        buildKeyframes() {
          this.applyStylesToKeyframe();
          const e = new Set(),
            t = new Set(),
            s = 1 === this._keyframes.size && 0 === this.duration;
          let c = [];
          this._keyframes.forEach((w, C) => {
            const P = Eh(w, new Map(), this._backFill);
            P.forEach((N, j) => {
              "!" === N ? e.add(j) : N === ru && t.add(j);
            }),
              s || P.set("offset", C / this.duration),
              c.push(P);
          });
          const p = e.size ? tv(e.values()) : [],
            y = t.size ? tv(t.values()) : [];
          if (s) {
            const w = c[0],
              C = new Map(w);
            w.set("offset", 0), C.set("offset", 1), (c = [w, C]);
          }
          return ib(
            this.element,
            c,
            p,
            y,
            this.duration,
            this.startTime,
            this.easing,
            !1
          );
        }
      }
      class ZL extends cv {
        constructor(e, t, s, c, p, y, w = !1) {
          super(e, t, y.delay),
            (this.keyframes = s),
            (this.preStyleProps = c),
            (this.postStyleProps = p),
            (this._stretchStartingKeyframe = w),
            (this.timings = {
              duration: y.duration,
              delay: y.delay,
              easing: y.easing,
            });
        }
        containsAnimation() {
          return this.keyframes.length > 1;
        }
        buildKeyframes() {
          let e = this.keyframes,
            { delay: t, duration: s, easing: c } = this.timings;
          if (this._stretchStartingKeyframe && t) {
            const p = [],
              y = s + t,
              w = t / y,
              C = Eh(e[0]);
            C.set("offset", 0), p.push(C);
            const P = Eh(e[0]);
            P.set("offset", QT(w)), p.push(P);
            const N = e.length - 1;
            for (let j = 1; j <= N; j++) {
              let Q = Eh(e[j]);
              const ie = Q.get("offset");
              Q.set("offset", QT((t + ie * s) / y)), p.push(Q);
            }
            (s = y), (t = 0), (c = ""), (e = p);
          }
          return ib(
            this.element,
            e,
            this.preStyleProps,
            this.postStyleProps,
            s,
            t,
            c,
            !0
          );
        }
      }
      function QT(n, e = 3) {
        const t = Math.pow(10, e - 1);
        return Math.round(n * t) / t;
      }
      class sb {}
      const KL = new Set([
        "width",
        "height",
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight",
        "left",
        "top",
        "bottom",
        "right",
        "fontSize",
        "outlineWidth",
        "outlineOffset",
        "paddingTop",
        "paddingLeft",
        "paddingBottom",
        "paddingRight",
        "marginTop",
        "marginLeft",
        "marginBottom",
        "marginRight",
        "borderRadius",
        "borderWidth",
        "borderTopWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderBottomWidth",
        "textIndent",
        "perspective",
      ]);
      class YL extends sb {
        normalizePropertyName(e, t) {
          return eb(e);
        }
        normalizeStyleValue(e, t, s, c) {
          let p = "";
          const y = s.toString().trim();
          if (KL.has(t) && 0 !== s && "0" !== s)
            if ("number" == typeof s) p = "px";
            else {
              const w = s.match(/^[+-]?[\d\.]+([a-z]*)$/);
              w &&
                0 == w[1].length &&
                c.push(
                  (function jP(n, e) {
                    return new st(3005, !1);
                  })()
                );
            }
          return y + p;
        }
      }
      function JT(n, e, t, s, c, p, y, w, C, P, N, j, Q) {
        return {
          type: 0,
          element: n,
          triggerName: e,
          isRemovalTransition: c,
          fromState: t,
          fromStyles: p,
          toState: s,
          toStyles: y,
          timelines: w,
          queriedElements: C,
          preStyleProps: P,
          postStyleProps: N,
          totalTime: j,
          errors: Q,
        };
      }
      const ab = {};
      class eD {
        constructor(e, t, s) {
          (this._triggerName = e), (this.ast = t), (this._stateStyles = s);
        }
        match(e, t, s, c) {
          return (function QL(n, e, t, s, c) {
            return n.some((p) => p(e, t, s, c));
          })(this.ast.matchers, e, t, s, c);
        }
        buildStyles(e, t, s) {
          let c = this._stateStyles.get("*");
          return (
            void 0 !== e && (c = this._stateStyles.get(e?.toString()) || c),
            c ? c.buildStyles(t, s) : new Map()
          );
        }
        build(e, t, s, c, p, y, w, C, P, N) {
          const j = [],
            Q = (this.ast.options && this.ast.options.params) || ab,
            pe = this.buildStyles(s, (w && w.params) || ab, j),
            Ee = (C && C.params) || ab,
            Oe = this.buildStyles(c, Ee, j),
            Ue = new Set(),
            ht = new Map(),
            ze = new Map(),
            vt = "void" === c,
            un = { params: JL(Ee, Q), delay: this.ast.options?.delay },
            Rn = N ? [] : rb(e, t, this.ast.animation, p, y, pe, Oe, un, P, j);
          let Fi = 0;
          if (
            (Rn.forEach((Ps) => {
              Fi = Math.max(Ps.duration + Ps.delay, Fi);
            }),
            j.length)
          )
            return JT(
              t,
              this._triggerName,
              s,
              c,
              vt,
              pe,
              Oe,
              [],
              [],
              ht,
              ze,
              Fi,
              j
            );
          Rn.forEach((Ps) => {
            const Ls = Ps.element,
              Sf = Is(ht, Ls, new Set());
            Ps.preStyleProps.forEach((yl) => Sf.add(yl));
            const su = Is(ze, Ls, new Set());
            Ps.postStyleProps.forEach((yl) => su.add(yl)),
              Ls !== t && Ue.add(Ls);
          });
          const As = tv(Ue.values());
          return JT(t, this._triggerName, s, c, vt, pe, Oe, Rn, As, ht, ze, Fi);
        }
      }
      function JL(n, e) {
        const t = kg(e);
        for (const s in n) n.hasOwnProperty(s) && null != n[s] && (t[s] = n[s]);
        return t;
      }
      class ek {
        constructor(e, t, s) {
          (this.styles = e), (this.defaultParams = t), (this.normalizer = s);
        }
        buildStyles(e, t) {
          const s = new Map(),
            c = kg(this.defaultParams);
          return (
            Object.keys(e).forEach((p) => {
              const y = e[p];
              null !== y && (c[p] = y);
            }),
            this.styles.styles.forEach((p) => {
              "string" != typeof p &&
                p.forEach((y, w) => {
                  y && (y = Og(y, c, t));
                  const C = this.normalizer.normalizePropertyName(w, t);
                  (y = this.normalizer.normalizeStyleValue(w, C, y, t)),
                    s.set(C, y);
                });
            }),
            s
          );
        }
      }
      class nk {
        constructor(e, t, s) {
          (this.name = e),
            (this.ast = t),
            (this._normalizer = s),
            (this.transitionFactories = []),
            (this.states = new Map()),
            t.states.forEach((c) => {
              this.states.set(
                c.name,
                new ek(c.style, (c.options && c.options.params) || {}, s)
              );
            }),
            tD(this.states, "true", "1"),
            tD(this.states, "false", "0"),
            t.transitions.forEach((c) => {
              this.transitionFactories.push(new eD(e, c, this.states));
            }),
            (this.fallbackTransition = (function ik(n, e, t) {
              return new eD(
                n,
                {
                  type: 1,
                  animation: { type: 2, steps: [], options: null },
                  matchers: [(y, w) => !0],
                  options: null,
                  queryCount: 0,
                  depCount: 0,
                },
                e
              );
            })(e, this.states));
        }
        get containsQueries() {
          return this.ast.queryCount > 0;
        }
        matchTransition(e, t, s, c) {
          return (
            this.transitionFactories.find((y) => y.match(e, t, s, c)) || null
          );
        }
        matchStyles(e, t, s) {
          return this.fallbackTransition.buildStyles(e, t, s);
        }
      }
      function tD(n, e, t) {
        n.has(e)
          ? n.has(t) || n.set(t, n.get(e))
          : n.has(t) && n.set(e, n.get(t));
      }
      const rk = new av();
      class ok {
        constructor(e, t, s) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = s),
            (this._animations = new Map()),
            (this._playersById = new Map()),
            (this.players = []);
        }
        register(e, t) {
          const s = [],
            p = tb(this._driver, t, s, []);
          if (s.length)
            throw (function oL(n) {
              return new st(3503, !1);
            })();
          this._animations.set(e, p);
        }
        _buildPlayer(e, t, s) {
          const c = e.element,
            p = kT(0, this._normalizer, 0, e.keyframes, t, s);
          return this._driver.animate(
            c,
            p,
            e.duration,
            e.delay,
            e.easing,
            [],
            !0
          );
        }
        create(e, t, s = {}) {
          const c = [],
            p = this._animations.get(e);
          let y;
          const w = new Map();
          if (
            (p
              ? ((y = rb(
                  this._driver,
                  t,
                  p,
                  Kx,
                  Yy,
                  new Map(),
                  new Map(),
                  s,
                  rk,
                  c
                )),
                y.forEach((N) => {
                  const j = Is(w, N.element, new Map());
                  N.postStyleProps.forEach((Q) => j.set(Q, null));
                }))
              : (c.push(
                  (function sL() {
                    return new st(3300, !1);
                  })()
                ),
                (y = [])),
            c.length)
          )
            throw (function aL(n) {
              return new st(3504, !1);
            })();
          w.forEach((N, j) => {
            N.forEach((Q, ie) => {
              N.set(ie, this._driver.computeStyle(j, ie, ru));
            });
          });
          const P = wh(
            y.map((N) => {
              const j = w.get(N.element);
              return this._buildPlayer(N, new Map(), j);
            })
          );
          return (
            this._playersById.set(e, P),
            P.onDestroy(() => this.destroy(e)),
            this.players.push(P),
            P
          );
        }
        destroy(e) {
          const t = this._getPlayer(e);
          t.destroy(), this._playersById.delete(e);
          const s = this.players.indexOf(t);
          s >= 0 && this.players.splice(s, 1);
        }
        _getPlayer(e) {
          const t = this._playersById.get(e);
          if (!t)
            throw (function lL(n) {
              return new st(3301, !1);
            })();
          return t;
        }
        listen(e, t, s, c) {
          const p = qx(t, "", "", "");
          return Hx(this._getPlayer(e), s, p, c), () => {};
        }
        command(e, t, s, c) {
          if ("register" == s) return void this.register(e, c[0]);
          if ("create" == s) return void this.create(e, t, c[0] || {});
          const p = this._getPlayer(e);
          switch (s) {
            case "play":
              p.play();
              break;
            case "pause":
              p.pause();
              break;
            case "reset":
              p.reset();
              break;
            case "restart":
              p.restart();
              break;
            case "finish":
              p.finish();
              break;
            case "init":
              p.init();
              break;
            case "setPosition":
              p.setPosition(parseFloat(c[0]));
              break;
            case "destroy":
              this.destroy(e);
          }
        }
      }
      const nD = "ng-animate-queued",
        lb = "ng-animate-disabled",
        uk = [],
        iD = {
          namespaceId: "",
          setForRemoval: !1,
          setForMove: !1,
          hasAnimation: !1,
          removedBeforeQueried: !1,
        },
        hk = {
          namespaceId: "",
          setForMove: !1,
          setForRemoval: !1,
          hasAnimation: !1,
          removedBeforeQueried: !0,
        },
        Ea = "__ng_removed";
      class cb {
        constructor(e, t = "") {
          this.namespaceId = t;
          const s = e && e.hasOwnProperty("value");
          if (
            ((this.value = (function mk(n) {
              return n ?? null;
            })(s ? e.value : e)),
            s)
          ) {
            const p = kg(e);
            delete p.value, (this.options = p);
          } else this.options = {};
          this.options.params || (this.options.params = {});
        }
        get params() {
          return this.options.params;
        }
        absorbOptions(e) {
          const t = e.params;
          if (t) {
            const s = this.options.params;
            Object.keys(t).forEach((c) => {
              null == s[c] && (s[c] = t[c]);
            });
          }
        }
      }
      const Fg = "void",
        ub = new cb(Fg);
      class dk {
        constructor(e, t, s) {
          (this.id = e),
            (this.hostElement = t),
            (this._engine = s),
            (this.players = []),
            (this._triggers = new Map()),
            (this._queue = []),
            (this._elementListeners = new Map()),
            (this._hostClassName = "ng-tns-" + e),
            Ta(t, this._hostClassName);
        }
        listen(e, t, s, c) {
          if (!this._triggers.has(t))
            throw (function cL(n, e) {
              return new st(3302, !1);
            })();
          if (null == s || 0 == s.length)
            throw (function uL(n) {
              return new st(3303, !1);
            })();
          if (
            !(function gk(n) {
              return "start" == n || "done" == n;
            })(s)
          )
            throw (function hL(n, e) {
              return new st(3400, !1);
            })();
          const p = Is(this._elementListeners, e, []),
            y = { name: t, phase: s, callback: c };
          p.push(y);
          const w = Is(this._engine.statesByElement, e, new Map());
          return (
            w.has(t) || (Ta(e, Qy), Ta(e, Qy + "-" + t), w.set(t, ub)),
            () => {
              this._engine.afterFlush(() => {
                const C = p.indexOf(y);
                C >= 0 && p.splice(C, 1), this._triggers.has(t) || w.delete(t);
              });
            }
          );
        }
        register(e, t) {
          return !this._triggers.has(e) && (this._triggers.set(e, t), !0);
        }
        _getTrigger(e) {
          const t = this._triggers.get(e);
          if (!t)
            throw (function dL(n) {
              return new st(3401, !1);
            })();
          return t;
        }
        trigger(e, t, s, c = !0) {
          const p = this._getTrigger(t),
            y = new hb(this.id, t, e);
          let w = this._engine.statesByElement.get(e);
          w ||
            (Ta(e, Qy),
            Ta(e, Qy + "-" + t),
            this._engine.statesByElement.set(e, (w = new Map())));
          let C = w.get(t);
          const P = new cb(s, this.id);
          if (
            (!(s && s.hasOwnProperty("value")) &&
              C &&
              P.absorbOptions(C.options),
            w.set(t, P),
            C || (C = ub),
            P.value !== Fg && C.value === P.value)
          ) {
            if (
              !(function vk(n, e) {
                const t = Object.keys(n),
                  s = Object.keys(e);
                if (t.length != s.length) return !1;
                for (let c = 0; c < t.length; c++) {
                  const p = t[c];
                  if (!e.hasOwnProperty(p) || n[p] !== e[p]) return !1;
                }
                return !0;
              })(C.params, P.params)
            ) {
              const Ee = [],
                Oe = p.matchStyles(C.value, C.params, Ee),
                Ue = p.matchStyles(P.value, P.params, Ee);
              Ee.length
                ? this._engine.reportError(Ee)
                : this._engine.afterFlush(() => {
                    np(e, Oe), ic(e, Ue);
                  });
            }
            return;
          }
          const Q = Is(this._engine.playersByElement, e, []);
          Q.forEach((Ee) => {
            Ee.namespaceId == this.id &&
              Ee.triggerName == t &&
              Ee.queued &&
              Ee.destroy();
          });
          let ie = p.matchTransition(C.value, P.value, e, P.params),
            pe = !1;
          if (!ie) {
            if (!c) return;
            (ie = p.fallbackTransition), (pe = !0);
          }
          return (
            this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: e,
              triggerName: t,
              transition: ie,
              fromState: C,
              toState: P,
              player: y,
              isFallbackTransition: pe,
            }),
            pe ||
              (Ta(e, nD),
              y.onStart(() => {
                Cf(e, nD);
              })),
            y.onDone(() => {
              let Ee = this.players.indexOf(y);
              Ee >= 0 && this.players.splice(Ee, 1);
              const Oe = this._engine.playersByElement.get(e);
              if (Oe) {
                let Ue = Oe.indexOf(y);
                Ue >= 0 && Oe.splice(Ue, 1);
              }
            }),
            this.players.push(y),
            Q.push(y),
            y
          );
        }
        deregister(e) {
          this._triggers.delete(e),
            this._engine.statesByElement.forEach((t) => t.delete(e)),
            this._elementListeners.forEach((t, s) => {
              this._elementListeners.set(
                s,
                t.filter((c) => c.name != e)
              );
            });
        }
        clearElementCache(e) {
          this._engine.statesByElement.delete(e),
            this._elementListeners.delete(e);
          const t = this._engine.playersByElement.get(e);
          t &&
            (t.forEach((s) => s.destroy()),
            this._engine.playersByElement.delete(e));
        }
        _signalRemovalForInnerTriggers(e, t) {
          const s = this._engine.driver.query(e, Jy, !0);
          s.forEach((c) => {
            if (c[Ea]) return;
            const p = this._engine.fetchNamespacesByElement(c);
            p.size
              ? p.forEach((y) => y.triggerLeaveAnimation(c, t, !1, !0))
              : this.clearElementCache(c);
          }),
            this._engine.afterFlushAnimationsDone(() =>
              s.forEach((c) => this.clearElementCache(c))
            );
        }
        triggerLeaveAnimation(e, t, s, c) {
          const p = this._engine.statesByElement.get(e),
            y = new Map();
          if (p) {
            const w = [];
            if (
              (p.forEach((C, P) => {
                if ((y.set(P, C.value), this._triggers.has(P))) {
                  const N = this.trigger(e, P, Fg, c);
                  N && w.push(N);
                }
              }),
              w.length)
            )
              return (
                this._engine.markElementAsRemoved(this.id, e, !0, t, y),
                s && wh(w).onDone(() => this._engine.processLeaveNode(e)),
                !0
              );
          }
          return !1;
        }
        prepareLeaveAnimationListeners(e) {
          const t = this._elementListeners.get(e),
            s = this._engine.statesByElement.get(e);
          if (t && s) {
            const c = new Set();
            t.forEach((p) => {
              const y = p.name;
              if (c.has(y)) return;
              c.add(y);
              const C = this._triggers.get(y).fallbackTransition,
                P = s.get(y) || ub,
                N = new cb(Fg),
                j = new hb(this.id, y, e);
              this._engine.totalQueuedPlayers++,
                this._queue.push({
                  element: e,
                  triggerName: y,
                  transition: C,
                  fromState: P,
                  toState: N,
                  player: j,
                  isFallbackTransition: !0,
                });
            });
          }
        }
        removeNode(e, t) {
          const s = this._engine;
          if (
            (e.childElementCount && this._signalRemovalForInnerTriggers(e, t),
            this.triggerLeaveAnimation(e, t, !0))
          )
            return;
          let c = !1;
          if (s.totalAnimations) {
            const p = s.players.length ? s.playersByQueriedElement.get(e) : [];
            if (p && p.length) c = !0;
            else {
              let y = e;
              for (; (y = y.parentNode); )
                if (s.statesByElement.get(y)) {
                  c = !0;
                  break;
                }
            }
          }
          if ((this.prepareLeaveAnimationListeners(e), c))
            s.markElementAsRemoved(this.id, e, !1, t);
          else {
            const p = e[Ea];
            (!p || p === iD) &&
              (s.afterFlush(() => this.clearElementCache(e)),
              s.destroyInnerAnimations(e),
              s._onRemovalComplete(e, t));
          }
        }
        insertNode(e, t) {
          Ta(e, this._hostClassName);
        }
        drainQueuedTransitions(e) {
          const t = [];
          return (
            this._queue.forEach((s) => {
              const c = s.player;
              if (c.destroyed) return;
              const p = s.element,
                y = this._elementListeners.get(p);
              y &&
                y.forEach((w) => {
                  if (w.name == s.triggerName) {
                    const C = qx(
                      p,
                      s.triggerName,
                      s.fromState.value,
                      s.toState.value
                    );
                    (C._data = e), Hx(s.player, w.phase, C, w.callback);
                  }
                }),
                c.markedForDestroy
                  ? this._engine.afterFlush(() => {
                      c.destroy();
                    })
                  : t.push(s);
            }),
            (this._queue = []),
            t.sort((s, c) => {
              const p = s.transition.ast.depCount,
                y = c.transition.ast.depCount;
              return 0 == p || 0 == y
                ? p - y
                : this._engine.driver.containsElement(s.element, c.element)
                ? 1
                : -1;
            })
          );
        }
        destroy(e) {
          this.players.forEach((t) => t.destroy()),
            this._signalRemovalForInnerTriggers(this.hostElement, e);
        }
        elementContainsData(e) {
          let t = !1;
          return (
            this._elementListeners.has(e) && (t = !0),
            (t = !!this._queue.find((s) => s.element === e) || t),
            t
          );
        }
      }
      class pk {
        constructor(e, t, s) {
          (this.bodyNode = e),
            (this.driver = t),
            (this._normalizer = s),
            (this.players = []),
            (this.newHostElements = new Map()),
            (this.playersByElement = new Map()),
            (this.playersByQueriedElement = new Map()),
            (this.statesByElement = new Map()),
            (this.disabledNodes = new Set()),
            (this.totalAnimations = 0),
            (this.totalQueuedPlayers = 0),
            (this._namespaceLookup = {}),
            (this._namespaceList = []),
            (this._flushFns = []),
            (this._whenQuietFns = []),
            (this.namespacesByHostElement = new Map()),
            (this.collectedEnterElements = []),
            (this.collectedLeaveElements = []),
            (this.onRemovalComplete = (c, p) => {});
        }
        _onRemovalComplete(e, t) {
          this.onRemovalComplete(e, t);
        }
        get queuedPlayers() {
          const e = [];
          return (
            this._namespaceList.forEach((t) => {
              t.players.forEach((s) => {
                s.queued && e.push(s);
              });
            }),
            e
          );
        }
        createNamespace(e, t) {
          const s = new dk(e, t, this);
          return (
            this.bodyNode && this.driver.containsElement(this.bodyNode, t)
              ? this._balanceNamespaceList(s, t)
              : (this.newHostElements.set(t, s), this.collectEnterElement(t)),
            (this._namespaceLookup[e] = s)
          );
        }
        _balanceNamespaceList(e, t) {
          const s = this._namespaceList,
            c = this.namespacesByHostElement;
          if (s.length - 1 >= 0) {
            let y = !1,
              w = this.driver.getParentElement(t);
            for (; w; ) {
              const C = c.get(w);
              if (C) {
                const P = s.indexOf(C);
                s.splice(P + 1, 0, e), (y = !0);
                break;
              }
              w = this.driver.getParentElement(w);
            }
            y || s.unshift(e);
          } else s.push(e);
          return c.set(t, e), e;
        }
        register(e, t) {
          let s = this._namespaceLookup[e];
          return s || (s = this.createNamespace(e, t)), s;
        }
        registerTrigger(e, t, s) {
          let c = this._namespaceLookup[e];
          c && c.register(t, s) && this.totalAnimations++;
        }
        destroy(e, t) {
          if (!e) return;
          const s = this._fetchNamespace(e);
          this.afterFlush(() => {
            this.namespacesByHostElement.delete(s.hostElement),
              delete this._namespaceLookup[e];
            const c = this._namespaceList.indexOf(s);
            c >= 0 && this._namespaceList.splice(c, 1);
          }),
            this.afterFlushAnimationsDone(() => s.destroy(t));
        }
        _fetchNamespace(e) {
          return this._namespaceLookup[e];
        }
        fetchNamespacesByElement(e) {
          const t = new Set(),
            s = this.statesByElement.get(e);
          if (s)
            for (let c of s.values())
              if (c.namespaceId) {
                const p = this._fetchNamespace(c.namespaceId);
                p && t.add(p);
              }
          return t;
        }
        trigger(e, t, s, c) {
          if (uv(t)) {
            const p = this._fetchNamespace(e);
            if (p) return p.trigger(t, s, c), !0;
          }
          return !1;
        }
        insertNode(e, t, s, c) {
          if (!uv(t)) return;
          const p = t[Ea];
          if (p && p.setForRemoval) {
            (p.setForRemoval = !1), (p.setForMove = !0);
            const y = this.collectedLeaveElements.indexOf(t);
            y >= 0 && this.collectedLeaveElements.splice(y, 1);
          }
          if (e) {
            const y = this._fetchNamespace(e);
            y && y.insertNode(t, s);
          }
          c && this.collectEnterElement(t);
        }
        collectEnterElement(e) {
          this.collectedEnterElements.push(e);
        }
        markElementAsDisabled(e, t) {
          t
            ? this.disabledNodes.has(e) ||
              (this.disabledNodes.add(e), Ta(e, lb))
            : this.disabledNodes.has(e) &&
              (this.disabledNodes.delete(e), Cf(e, lb));
        }
        removeNode(e, t, s, c) {
          if (uv(t)) {
            const p = e ? this._fetchNamespace(e) : null;
            if (
              (p ? p.removeNode(t, c) : this.markElementAsRemoved(e, t, !1, c),
              s)
            ) {
              const y = this.namespacesByHostElement.get(t);
              y && y.id !== e && y.removeNode(t, c);
            }
          } else this._onRemovalComplete(t, c);
        }
        markElementAsRemoved(e, t, s, c, p) {
          this.collectedLeaveElements.push(t),
            (t[Ea] = {
              namespaceId: e,
              setForRemoval: c,
              hasAnimation: s,
              removedBeforeQueried: !1,
              previousTriggersValues: p,
            });
        }
        listen(e, t, s, c, p) {
          return uv(t) ? this._fetchNamespace(e).listen(t, s, c, p) : () => {};
        }
        _buildInstruction(e, t, s, c, p) {
          return e.transition.build(
            this.driver,
            e.element,
            e.fromState.value,
            e.toState.value,
            s,
            c,
            e.fromState.options,
            e.toState.options,
            t,
            p
          );
        }
        destroyInnerAnimations(e) {
          let t = this.driver.query(e, Jy, !0);
          t.forEach((s) => this.destroyActiveAnimationsForElement(s)),
            0 != this.playersByQueriedElement.size &&
              ((t = this.driver.query(e, Yx, !0)),
              t.forEach((s) => this.finishActiveQueriedAnimationOnElement(s)));
        }
        destroyActiveAnimationsForElement(e) {
          const t = this.playersByElement.get(e);
          t &&
            t.forEach((s) => {
              s.queued ? (s.markedForDestroy = !0) : s.destroy();
            });
        }
        finishActiveQueriedAnimationOnElement(e) {
          const t = this.playersByQueriedElement.get(e);
          t && t.forEach((s) => s.finish());
        }
        whenRenderingDone() {
          return new Promise((e) => {
            if (this.players.length) return wh(this.players).onDone(() => e());
            e();
          });
        }
        processLeaveNode(e) {
          const t = e[Ea];
          if (t && t.setForRemoval) {
            if (((e[Ea] = iD), t.namespaceId)) {
              this.destroyInnerAnimations(e);
              const s = this._fetchNamespace(t.namespaceId);
              s && s.clearElementCache(e);
            }
            this._onRemovalComplete(e, t.setForRemoval);
          }
          e.classList?.contains(lb) && this.markElementAsDisabled(e, !1),
            this.driver.query(e, ".ng-animate-disabled", !0).forEach((s) => {
              this.markElementAsDisabled(s, !1);
            });
        }
        flush(e = -1) {
          let t = [];
          if (
            (this.newHostElements.size &&
              (this.newHostElements.forEach((s, c) =>
                this._balanceNamespaceList(s, c)
              ),
              this.newHostElements.clear()),
            this.totalAnimations && this.collectedEnterElements.length)
          )
            for (let s = 0; s < this.collectedEnterElements.length; s++)
              Ta(this.collectedEnterElements[s], "ng-star-inserted");
          if (
            this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)
          ) {
            const s = [];
            try {
              t = this._flushAnimations(s, e);
            } finally {
              for (let c = 0; c < s.length; c++) s[c]();
            }
          } else
            for (let s = 0; s < this.collectedLeaveElements.length; s++)
              this.processLeaveNode(this.collectedLeaveElements[s]);
          if (
            ((this.totalQueuedPlayers = 0),
            (this.collectedEnterElements.length = 0),
            (this.collectedLeaveElements.length = 0),
            this._flushFns.forEach((s) => s()),
            (this._flushFns = []),
            this._whenQuietFns.length)
          ) {
            const s = this._whenQuietFns;
            (this._whenQuietFns = []),
              t.length
                ? wh(t).onDone(() => {
                    s.forEach((c) => c());
                  })
                : s.forEach((c) => c());
          }
        }
        reportError(e) {
          throw (function pL(n) {
            return new st(3402, !1);
          })();
        }
        _flushAnimations(e, t) {
          const s = new av(),
            c = [],
            p = new Map(),
            y = [],
            w = new Map(),
            C = new Map(),
            P = new Map(),
            N = new Set();
          this.disabledNodes.forEach((Tt) => {
            N.add(Tt);
            const Ft = this.driver.query(Tt, ".ng-animate-queued", !0);
            for (let Wt = 0; Wt < Ft.length; Wt++) N.add(Ft[Wt]);
          });
          const j = this.bodyNode,
            Q = Array.from(this.statesByElement.keys()),
            ie = sD(Q, this.collectedEnterElements),
            pe = new Map();
          let Ee = 0;
          ie.forEach((Tt, Ft) => {
            const Wt = Kx + Ee++;
            pe.set(Ft, Wt), Tt.forEach((Un) => Ta(Un, Wt));
          });
          const Oe = [],
            Ue = new Set(),
            ht = new Set();
          for (let Tt = 0; Tt < this.collectedLeaveElements.length; Tt++) {
            const Ft = this.collectedLeaveElements[Tt],
              Wt = Ft[Ea];
            Wt &&
              Wt.setForRemoval &&
              (Oe.push(Ft),
              Ue.add(Ft),
              Wt.hasAnimation
                ? this.driver
                    .query(Ft, ".ng-star-inserted", !0)
                    .forEach((Un) => Ue.add(Un))
                : ht.add(Ft));
          }
          const ze = new Map(),
            vt = sD(Q, Array.from(Ue));
          vt.forEach((Tt, Ft) => {
            const Wt = Yy + Ee++;
            ze.set(Ft, Wt), Tt.forEach((Un) => Ta(Un, Wt));
          }),
            e.push(() => {
              ie.forEach((Tt, Ft) => {
                const Wt = pe.get(Ft);
                Tt.forEach((Un) => Cf(Un, Wt));
              }),
                vt.forEach((Tt, Ft) => {
                  const Wt = ze.get(Ft);
                  Tt.forEach((Un) => Cf(Un, Wt));
                }),
                Oe.forEach((Tt) => {
                  this.processLeaveNode(Tt);
                });
            });
          const un = [],
            Rn = [];
          for (let Tt = this._namespaceList.length - 1; Tt >= 0; Tt--)
            this._namespaceList[Tt].drainQueuedTransitions(t).forEach((Wt) => {
              const Un = Wt.player,
                jr = Wt.element;
              if ((un.push(Un), this.collectedEnterElements.length)) {
                const mo = jr[Ea];
                if (mo && mo.setForMove) {
                  if (
                    mo.previousTriggersValues &&
                    mo.previousTriggersValues.has(Wt.triggerName)
                  ) {
                    const rp = mo.previousTriggersValues.get(Wt.triggerName),
                      Da = this.statesByElement.get(Wt.element);
                    if (Da && Da.has(Wt.triggerName)) {
                      const pv = Da.get(Wt.triggerName);
                      (pv.value = rp), Da.set(Wt.triggerName, pv);
                    }
                  }
                  return void Un.destroy();
                }
              }
              const rc = !j || !this.driver.containsElement(j, jr),
                ks = ze.get(jr),
                Th = pe.get(jr),
                Ni = this._buildInstruction(Wt, s, Th, ks, rc);
              if (Ni.errors && Ni.errors.length) return void Rn.push(Ni);
              if (rc)
                return (
                  Un.onStart(() => np(jr, Ni.fromStyles)),
                  Un.onDestroy(() => ic(jr, Ni.toStyles)),
                  void c.push(Un)
                );
              if (Wt.isFallbackTransition)
                return (
                  Un.onStart(() => np(jr, Ni.fromStyles)),
                  Un.onDestroy(() => ic(jr, Ni.toStyles)),
                  void c.push(Un)
                );
              const mD = [];
              Ni.timelines.forEach((mo) => {
                (mo.stretchStartingKeyframe = !0),
                  this.disabledNodes.has(mo.element) || mD.push(mo);
              }),
                (Ni.timelines = mD),
                s.append(jr, Ni.timelines),
                y.push({ instruction: Ni, player: Un, element: jr }),
                Ni.queriedElements.forEach((mo) => Is(w, mo, []).push(Un)),
                Ni.preStyleProps.forEach((mo, rp) => {
                  if (mo.size) {
                    let Da = C.get(rp);
                    Da || C.set(rp, (Da = new Set())),
                      mo.forEach((pv, fb) => Da.add(fb));
                  }
                }),
                Ni.postStyleProps.forEach((mo, rp) => {
                  let Da = P.get(rp);
                  Da || P.set(rp, (Da = new Set())),
                    mo.forEach((pv, fb) => Da.add(fb));
                });
            });
          if (Rn.length) {
            const Tt = [];
            Rn.forEach((Ft) => {
              Tt.push(
                (function fL(n, e) {
                  return new st(3505, !1);
                })()
              );
            }),
              un.forEach((Ft) => Ft.destroy()),
              this.reportError(Tt);
          }
          const Fi = new Map(),
            As = new Map();
          y.forEach((Tt) => {
            const Ft = Tt.element;
            s.has(Ft) &&
              (As.set(Ft, Ft),
              this._beforeAnimationBuild(
                Tt.player.namespaceId,
                Tt.instruction,
                Fi
              ));
          }),
            c.forEach((Tt) => {
              const Ft = Tt.element;
              this._getPreviousPlayers(
                Ft,
                !1,
                Tt.namespaceId,
                Tt.triggerName,
                null
              ).forEach((Un) => {
                Is(Fi, Ft, []).push(Un), Un.destroy();
              });
            });
          const Ps = Oe.filter((Tt) => lD(Tt, C, P)),
            Ls = new Map();
          oD(Ls, this.driver, ht, P, ru).forEach((Tt) => {
            lD(Tt, C, P) && Ps.push(Tt);
          });
          const su = new Map();
          ie.forEach((Tt, Ft) => {
            oD(su, this.driver, new Set(Tt), C, "!");
          }),
            Ps.forEach((Tt) => {
              const Ft = Ls.get(Tt),
                Wt = su.get(Tt);
              Ls.set(
                Tt,
                new Map([
                  ...Array.from(Ft?.entries() ?? []),
                  ...Array.from(Wt?.entries() ?? []),
                ])
              );
            });
          const yl = [],
            If = [],
            Mf = {};
          y.forEach((Tt) => {
            const { element: Ft, player: Wt, instruction: Un } = Tt;
            if (s.has(Ft)) {
              if (N.has(Ft))
                return (
                  Wt.onDestroy(() => ic(Ft, Un.toStyles)),
                  (Wt.disabled = !0),
                  Wt.overrideTotalTime(Un.totalTime),
                  void c.push(Wt)
                );
              let jr = Mf;
              if (As.size > 1) {
                let ks = Ft;
                const Th = [];
                for (; (ks = ks.parentNode); ) {
                  const Ni = As.get(ks);
                  if (Ni) {
                    jr = Ni;
                    break;
                  }
                  Th.push(ks);
                }
                Th.forEach((Ni) => As.set(Ni, jr));
              }
              const rc = this._buildAnimation(
                Wt.namespaceId,
                Un,
                Fi,
                p,
                su,
                Ls
              );
              if ((Wt.setRealPlayer(rc), jr === Mf)) yl.push(Wt);
              else {
                const ks = this.playersByElement.get(jr);
                ks && ks.length && (Wt.parentPlayer = wh(ks)), c.push(Wt);
              }
            } else
              np(Ft, Un.fromStyles),
                Wt.onDestroy(() => ic(Ft, Un.toStyles)),
                If.push(Wt),
                N.has(Ft) && c.push(Wt);
          }),
            If.forEach((Tt) => {
              const Ft = p.get(Tt.element);
              if (Ft && Ft.length) {
                const Wt = wh(Ft);
                Tt.setRealPlayer(Wt);
              }
            }),
            c.forEach((Tt) => {
              Tt.parentPlayer
                ? Tt.syncPlayerEvents(Tt.parentPlayer)
                : Tt.destroy();
            });
          for (let Tt = 0; Tt < Oe.length; Tt++) {
            const Ft = Oe[Tt],
              Wt = Ft[Ea];
            if ((Cf(Ft, Yy), Wt && Wt.hasAnimation)) continue;
            let Un = [];
            if (w.size) {
              let rc = w.get(Ft);
              rc && rc.length && Un.push(...rc);
              let ks = this.driver.query(Ft, Yx, !0);
              for (let Th = 0; Th < ks.length; Th++) {
                let Ni = w.get(ks[Th]);
                Ni && Ni.length && Un.push(...Ni);
              }
            }
            const jr = Un.filter((rc) => !rc.destroyed);
            jr.length ? _k(this, Ft, jr) : this.processLeaveNode(Ft);
          }
          return (
            (Oe.length = 0),
            yl.forEach((Tt) => {
              this.players.push(Tt),
                Tt.onDone(() => {
                  Tt.destroy();
                  const Ft = this.players.indexOf(Tt);
                  this.players.splice(Ft, 1);
                }),
                Tt.play();
            }),
            yl
          );
        }
        elementContainsData(e, t) {
          let s = !1;
          const c = t[Ea];
          return (
            c && c.setForRemoval && (s = !0),
            this.playersByElement.has(t) && (s = !0),
            this.playersByQueriedElement.has(t) && (s = !0),
            this.statesByElement.has(t) && (s = !0),
            this._fetchNamespace(e).elementContainsData(t) || s
          );
        }
        afterFlush(e) {
          this._flushFns.push(e);
        }
        afterFlushAnimationsDone(e) {
          this._whenQuietFns.push(e);
        }
        _getPreviousPlayers(e, t, s, c, p) {
          let y = [];
          if (t) {
            const w = this.playersByQueriedElement.get(e);
            w && (y = w);
          } else {
            const w = this.playersByElement.get(e);
            if (w) {
              const C = !p || p == Fg;
              w.forEach((P) => {
                P.queued || (!C && P.triggerName != c) || y.push(P);
              });
            }
          }
          return (
            (s || c) &&
              (y = y.filter(
                (w) => !((s && s != w.namespaceId) || (c && c != w.triggerName))
              )),
            y
          );
        }
        _beforeAnimationBuild(e, t, s) {
          const p = t.element,
            y = t.isRemovalTransition ? void 0 : e,
            w = t.isRemovalTransition ? void 0 : t.triggerName;
          for (const C of t.timelines) {
            const P = C.element,
              N = P !== p,
              j = Is(s, P, []);
            this._getPreviousPlayers(P, N, y, w, t.toState).forEach((ie) => {
              const pe = ie.getRealPlayer();
              pe.beforeDestroy && pe.beforeDestroy(), ie.destroy(), j.push(ie);
            });
          }
          np(p, t.fromStyles);
        }
        _buildAnimation(e, t, s, c, p, y) {
          const w = t.triggerName,
            C = t.element,
            P = [],
            N = new Set(),
            j = new Set(),
            Q = t.timelines.map((pe) => {
              const Ee = pe.element;
              N.add(Ee);
              const Oe = Ee[Ea];
              if (Oe && Oe.removedBeforeQueried)
                return new Lg(pe.duration, pe.delay);
              const Ue = Ee !== C,
                ht = (function yk(n) {
                  const e = [];
                  return aD(n, e), e;
                })((s.get(Ee) || uk).map((Fi) => Fi.getRealPlayer())).filter(
                  (Fi) => !!Fi.element && Fi.element === Ee
                ),
                ze = p.get(Ee),
                vt = y.get(Ee),
                un = kT(0, this._normalizer, 0, pe.keyframes, ze, vt),
                Rn = this._buildPlayer(pe, un, ht);
              if ((pe.subTimeline && c && j.add(Ee), Ue)) {
                const Fi = new hb(e, w, Ee);
                Fi.setRealPlayer(Rn), P.push(Fi);
              }
              return Rn;
            });
          P.forEach((pe) => {
            Is(this.playersByQueriedElement, pe.element, []).push(pe),
              pe.onDone(() =>
                (function fk(n, e, t) {
                  let s = n.get(e);
                  if (s) {
                    if (s.length) {
                      const c = s.indexOf(t);
                      s.splice(c, 1);
                    }
                    0 == s.length && n.delete(e);
                  }
                  return s;
                })(this.playersByQueriedElement, pe.element, pe)
              );
          }),
            N.forEach((pe) => Ta(pe, UT));
          const ie = wh(Q);
          return (
            ie.onDestroy(() => {
              N.forEach((pe) => Cf(pe, UT)), ic(C, t.toStyles);
            }),
            j.forEach((pe) => {
              Is(c, pe, []).push(ie);
            }),
            ie
          );
        }
        _buildPlayer(e, t, s) {
          return t.length > 0
            ? this.driver.animate(
                e.element,
                t,
                e.duration,
                e.delay,
                e.easing,
                s
              )
            : new Lg(e.duration, e.delay);
        }
      }
      class hb {
        constructor(e, t, s) {
          (this.namespaceId = e),
            (this.triggerName = t),
            (this.element = s),
            (this._player = new Lg()),
            (this._containsRealPlayer = !1),
            (this._queuedCallbacks = new Map()),
            (this.destroyed = !1),
            (this.markedForDestroy = !1),
            (this.disabled = !1),
            (this.queued = !0),
            (this.totalTime = 0);
        }
        setRealPlayer(e) {
          this._containsRealPlayer ||
            ((this._player = e),
            this._queuedCallbacks.forEach((t, s) => {
              t.forEach((c) => Hx(e, s, void 0, c));
            }),
            this._queuedCallbacks.clear(),
            (this._containsRealPlayer = !0),
            this.overrideTotalTime(e.totalTime),
            (this.queued = !1));
        }
        getRealPlayer() {
          return this._player;
        }
        overrideTotalTime(e) {
          this.totalTime = e;
        }
        syncPlayerEvents(e) {
          const t = this._player;
          t.triggerCallback && e.onStart(() => t.triggerCallback("start")),
            e.onDone(() => this.finish()),
            e.onDestroy(() => this.destroy());
        }
        _queueEvent(e, t) {
          Is(this._queuedCallbacks, e, []).push(t);
        }
        onDone(e) {
          this.queued && this._queueEvent("done", e), this._player.onDone(e);
        }
        onStart(e) {
          this.queued && this._queueEvent("start", e), this._player.onStart(e);
        }
        onDestroy(e) {
          this.queued && this._queueEvent("destroy", e),
            this._player.onDestroy(e);
        }
        init() {
          this._player.init();
        }
        hasStarted() {
          return !this.queued && this._player.hasStarted();
        }
        play() {
          !this.queued && this._player.play();
        }
        pause() {
          !this.queued && this._player.pause();
        }
        restart() {
          !this.queued && this._player.restart();
        }
        finish() {
          this._player.finish();
        }
        destroy() {
          (this.destroyed = !0), this._player.destroy();
        }
        reset() {
          !this.queued && this._player.reset();
        }
        setPosition(e) {
          this.queued || this._player.setPosition(e);
        }
        getPosition() {
          return this.queued ? 0 : this._player.getPosition();
        }
        triggerCallback(e) {
          const t = this._player;
          t.triggerCallback && t.triggerCallback(e);
        }
      }
      function uv(n) {
        return n && 1 === n.nodeType;
      }
      function rD(n, e) {
        const t = n.style.display;
        return (n.style.display = e ?? "none"), t;
      }
      function oD(n, e, t, s, c) {
        const p = [];
        t.forEach((C) => p.push(rD(C)));
        const y = [];
        s.forEach((C, P) => {
          const N = new Map();
          C.forEach((j) => {
            const Q = e.computeStyle(P, j, c);
            N.set(j, Q), (!Q || 0 == Q.length) && ((P[Ea] = hk), y.push(P));
          }),
            n.set(P, N);
        });
        let w = 0;
        return t.forEach((C) => rD(C, p[w++])), y;
      }
      function sD(n, e) {
        const t = new Map();
        if ((n.forEach((w) => t.set(w, [])), 0 == e.length)) return t;
        const c = new Set(e),
          p = new Map();
        function y(w) {
          if (!w) return 1;
          let C = p.get(w);
          if (C) return C;
          const P = w.parentNode;
          return (C = t.has(P) ? P : c.has(P) ? 1 : y(P)), p.set(w, C), C;
        }
        return (
          e.forEach((w) => {
            const C = y(w);
            1 !== C && t.get(C).push(w);
          }),
          t
        );
      }
      function Ta(n, e) {
        n.classList?.add(e);
      }
      function Cf(n, e) {
        n.classList?.remove(e);
      }
      function _k(n, e, t) {
        wh(t).onDone(() => n.processLeaveNode(e));
      }
      function aD(n, e) {
        for (let t = 0; t < n.length; t++) {
          const s = n[t];
          s instanceof PT ? aD(s.players, e) : e.push(s);
        }
      }
      function lD(n, e, t) {
        const s = t.get(n);
        if (!s) return !1;
        let c = e.get(n);
        return c ? s.forEach((p) => c.add(p)) : e.set(n, s), t.delete(n), !0;
      }
      class hv {
        constructor(e, t, s) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = s),
            (this._triggerCache = {}),
            (this.onRemovalComplete = (c, p) => {}),
            (this._transitionEngine = new pk(e, t, s)),
            (this._timelineEngine = new ok(e, t, s)),
            (this._transitionEngine.onRemovalComplete = (c, p) =>
              this.onRemovalComplete(c, p));
        }
        registerTrigger(e, t, s, c, p) {
          const y = e + "-" + c;
          let w = this._triggerCache[y];
          if (!w) {
            const C = [],
              N = tb(this._driver, p, C, []);
            if (C.length)
              throw (function iL(n, e) {
                return new st(3404, !1);
              })();
            (w = (function tk(n, e, t) {
              return new nk(n, e, t);
            })(c, N, this._normalizer)),
              (this._triggerCache[y] = w);
          }
          this._transitionEngine.registerTrigger(t, c, w);
        }
        register(e, t) {
          this._transitionEngine.register(e, t);
        }
        destroy(e, t) {
          this._transitionEngine.destroy(e, t);
        }
        onInsert(e, t, s, c) {
          this._transitionEngine.insertNode(e, t, s, c);
        }
        onRemove(e, t, s, c) {
          this._transitionEngine.removeNode(e, t, c || !1, s);
        }
        disableAnimations(e, t) {
          this._transitionEngine.markElementAsDisabled(e, t);
        }
        process(e, t, s, c) {
          if ("@" == s.charAt(0)) {
            const [p, y] = RT(s);
            this._timelineEngine.command(p, t, y, c);
          } else this._transitionEngine.trigger(e, t, s, c);
        }
        listen(e, t, s, c, p) {
          if ("@" == s.charAt(0)) {
            const [y, w] = RT(s);
            return this._timelineEngine.listen(y, t, w, p);
          }
          return this._transitionEngine.listen(e, t, s, c, p);
        }
        flush(e = -1) {
          this._transitionEngine.flush(e);
        }
        get players() {
          return this._transitionEngine.players.concat(
            this._timelineEngine.players
          );
        }
        whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone();
        }
      }
      let bk = (() => {
        class n {
          constructor(t, s, c) {
            (this._element = t),
              (this._startStyles = s),
              (this._endStyles = c),
              (this._state = 0);
            let p = n.initialStylesByElement.get(t);
            p || n.initialStylesByElement.set(t, (p = new Map())),
              (this._initialStyles = p);
          }
          start() {
            this._state < 1 &&
              (this._startStyles &&
                ic(this._element, this._startStyles, this._initialStyles),
              (this._state = 1));
          }
          finish() {
            this.start(),
              this._state < 2 &&
                (ic(this._element, this._initialStyles),
                this._endStyles &&
                  (ic(this._element, this._endStyles),
                  (this._endStyles = null)),
                (this._state = 1));
          }
          destroy() {
            this.finish(),
              this._state < 3 &&
                (n.initialStylesByElement.delete(this._element),
                this._startStyles &&
                  (np(this._element, this._startStyles),
                  (this._endStyles = null)),
                this._endStyles &&
                  (np(this._element, this._endStyles),
                  (this._endStyles = null)),
                ic(this._element, this._initialStyles),
                (this._state = 3));
          }
        }
        return (n.initialStylesByElement = new WeakMap()), n;
      })();
      function db(n) {
        let e = null;
        return (
          n.forEach((t, s) => {
            (function wk(n) {
              return "display" === n || "position" === n;
            })(s) && ((e = e || new Map()), e.set(s, t));
          }),
          e
        );
      }
      class cD {
        constructor(e, t, s, c) {
          (this.element = e),
            (this.keyframes = t),
            (this.options = s),
            (this._specialStyles = c),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._initialized = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this.time = 0),
            (this.parentPlayer = null),
            (this.currentSnapshot = new Map()),
            (this._duration = s.duration),
            (this._delay = s.delay || 0),
            (this.time = this._duration + this._delay);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this._buildPlayer(), this._preparePlayerBeforeStart();
        }
        _buildPlayer() {
          if (this._initialized) return;
          this._initialized = !0;
          const e = this.keyframes;
          (this.domPlayer = this._triggerWebAnimation(
            this.element,
            e,
            this.options
          )),
            (this._finalKeyframe = e.length ? e[e.length - 1] : new Map()),
            this.domPlayer.addEventListener("finish", () => this._onFinish());
        }
        _preparePlayerBeforeStart() {
          this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
        }
        _convertKeyframesToObject(e) {
          const t = [];
          return (
            e.forEach((s) => {
              t.push(Object.fromEntries(s));
            }),
            t
          );
        }
        _triggerWebAnimation(e, t, s) {
          return e.animate(this._convertKeyframesToObject(t), s);
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        play() {
          this._buildPlayer(),
            this.hasStarted() ||
              (this._onStartFns.forEach((e) => e()),
              (this._onStartFns = []),
              (this._started = !0),
              this._specialStyles && this._specialStyles.start()),
            this.domPlayer.play();
        }
        pause() {
          this.init(), this.domPlayer.pause();
        }
        finish() {
          this.init(),
            this._specialStyles && this._specialStyles.finish(),
            this._onFinish(),
            this.domPlayer.finish();
        }
        reset() {
          this._resetDomPlayerState(),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        _resetDomPlayerState() {
          this.domPlayer && this.domPlayer.cancel();
        }
        restart() {
          this.reset(), this.play();
        }
        hasStarted() {
          return this._started;
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._resetDomPlayerState(),
            this._onFinish(),
            this._specialStyles && this._specialStyles.destroy(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        setPosition(e) {
          void 0 === this.domPlayer && this.init(),
            (this.domPlayer.currentTime = e * this.time);
        }
        getPosition() {
          return this.domPlayer.currentTime / this.time;
        }
        get totalTime() {
          return this._delay + this._duration;
        }
        beforeDestroy() {
          const e = new Map();
          this.hasStarted() &&
            this._finalKeyframe.forEach((s, c) => {
              "offset" !== c &&
                e.set(c, this._finished ? s : ZT(this.element, c));
            }),
            (this.currentSnapshot = e);
        }
        triggerCallback(e) {
          const t = "start" === e ? this._onStartFns : this._onDoneFns;
          t.forEach((s) => s()), (t.length = 0);
        }
      }
      class Ek {
        validateStyleProperty(e) {
          return !0;
        }
        validateAnimatableStyleProperty(e) {
          return !0;
        }
        matchesElement(e, t) {
          return !1;
        }
        containsElement(e, t) {
          return zT(e, t);
        }
        getParentElement(e) {
          return Zx(e);
        }
        query(e, t, s) {
          return BT(e, t, s);
        }
        computeStyle(e, t, s) {
          return window.getComputedStyle(e)[t];
        }
        animate(e, t, s, c, p, y = []) {
          const C = {
            duration: s,
            delay: c,
            fill: 0 == c ? "both" : "forwards",
          };
          p && (C.easing = p);
          const P = new Map(),
            N = y.filter((ie) => ie instanceof cD);
          (function SL(n, e) {
            return 0 === n || 0 === e;
          })(s, c) &&
            N.forEach((ie) => {
              ie.currentSnapshot.forEach((pe, Ee) => P.set(Ee, pe));
            });
          let j = (function EL(n) {
            return n.length
              ? n[0] instanceof Map
                ? n
                : n.map((e) => $T(e))
              : [];
          })(t).map((ie) => Eh(ie));
          j = (function IL(n, e, t) {
            if (t.size && e.length) {
              let s = e[0],
                c = [];
              if (
                (t.forEach((p, y) => {
                  s.has(y) || c.push(y), s.set(y, p);
                }),
                c.length)
              )
                for (let p = 1; p < e.length; p++) {
                  let y = e[p];
                  c.forEach((w) => y.set(w, ZT(n, w)));
                }
            }
            return e;
          })(e, j, P);
          const Q = (function xk(n, e) {
            let t = null,
              s = null;
            return (
              Array.isArray(e) && e.length
                ? ((t = db(e[0])), e.length > 1 && (s = db(e[e.length - 1])))
                : e instanceof Map && (t = db(e)),
              t || s ? new bk(n, t, s) : null
            );
          })(e, j);
          return new cD(e, j, C, Q);
        }
      }
      let Tk = (() => {
        class n extends CT {
          constructor(t, s) {
            super(),
              (this._nextAnimationId = 0),
              (this._renderer = t.createRenderer(s.body, {
                id: "0",
                encapsulation: xo.None,
                styles: [],
                data: { animation: [] },
              }));
          }
          build(t) {
            const s = this._nextAnimationId.toString();
            this._nextAnimationId++;
            const c = Array.isArray(t) ? IT(t) : t;
            return (
              uD(this._renderer, null, s, "register", [c]),
              new Dk(s, this._renderer)
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(rh), Mt(ml));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class Dk extends class gP {} {
        constructor(e, t) {
          super(), (this._id = e), (this._renderer = t);
        }
        create(e, t) {
          return new Ck(this._id, e, t || {}, this._renderer);
        }
      }
      class Ck {
        constructor(e, t, s, c) {
          (this.id = e),
            (this.element = t),
            (this._renderer = c),
            (this.parentPlayer = null),
            (this._started = !1),
            (this.totalTime = 0),
            this._command("create", s);
        }
        _listen(e, t) {
          return this._renderer.listen(this.element, `@@${this.id}:${e}`, t);
        }
        _command(e, ...t) {
          return uD(this._renderer, this.element, this.id, e, t);
        }
        onDone(e) {
          this._listen("done", e);
        }
        onStart(e) {
          this._listen("start", e);
        }
        onDestroy(e) {
          this._listen("destroy", e);
        }
        init() {
          this._command("init");
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this._command("play"), (this._started = !0);
        }
        pause() {
          this._command("pause");
        }
        restart() {
          this._command("restart");
        }
        finish() {
          this._command("finish");
        }
        destroy() {
          this._command("destroy");
        }
        reset() {
          this._command("reset"), (this._started = !1);
        }
        setPosition(e) {
          this._command("setPosition", e);
        }
        getPosition() {
          return this._renderer.engine.players[+this.id]?.getPosition() ?? 0;
        }
      }
      function uD(n, e, t, s, c) {
        return n.setProperty(e, `@@${t}:${s}`, c);
      }
      const hD = "@.disabled";
      let Sk = (() => {
        class n {
          constructor(t, s, c) {
            (this.delegate = t),
              (this.engine = s),
              (this._zone = c),
              (this._currentId = 0),
              (this._microtaskId = 1),
              (this._animationCallbacksBuffer = []),
              (this._rendererCache = new Map()),
              (this._cdRecurDepth = 0),
              (this.promise = Promise.resolve(0)),
              (s.onRemovalComplete = (p, y) => {
                const w = y?.parentNode(p);
                w && y.removeChild(w, p);
              });
          }
          createRenderer(t, s) {
            const p = this.delegate.createRenderer(t, s);
            if (!(t && s && s.data && s.data.animation)) {
              let N = this._rendererCache.get(p);
              return (
                N ||
                  ((N = new dD("", p, this.engine, () =>
                    this._rendererCache.delete(p)
                  )),
                  this._rendererCache.set(p, N)),
                N
              );
            }
            const y = s.id,
              w = s.id + "-" + this._currentId;
            this._currentId++, this.engine.register(w, t);
            const C = (N) => {
              Array.isArray(N)
                ? N.forEach(C)
                : this.engine.registerTrigger(y, w, t, N.name, N);
            };
            return s.data.animation.forEach(C), new Ik(this, w, p, this.engine);
          }
          begin() {
            this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
          }
          _scheduleCountTask() {
            this.promise.then(() => {
              this._microtaskId++;
            });
          }
          scheduleListenerCallback(t, s, c) {
            t >= 0 && t < this._microtaskId
              ? this._zone.run(() => s(c))
              : (0 == this._animationCallbacksBuffer.length &&
                  Promise.resolve(null).then(() => {
                    this._zone.run(() => {
                      this._animationCallbacksBuffer.forEach((p) => {
                        const [y, w] = p;
                        y(w);
                      }),
                        (this._animationCallbacksBuffer = []);
                    });
                  }),
                this._animationCallbacksBuffer.push([s, c]));
          }
          end() {
            this._cdRecurDepth--,
              0 == this._cdRecurDepth &&
                this._zone.runOutsideAngular(() => {
                  this._scheduleCountTask(),
                    this.engine.flush(this._microtaskId);
                }),
              this.delegate.end && this.delegate.end();
          }
          whenRenderingDone() {
            return this.engine.whenRenderingDone();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Mt(rh), Mt(hv), Mt(dr));
          }),
          (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class dD {
        constructor(e, t, s, c) {
          (this.namespaceId = e),
            (this.delegate = t),
            (this.engine = s),
            (this._onDestroy = c),
            (this.destroyNode = this.delegate.destroyNode
              ? (p) => t.destroyNode(p)
              : null);
        }
        get data() {
          return this.delegate.data;
        }
        destroy() {
          this.engine.destroy(this.namespaceId, this.delegate),
            this.delegate.destroy(),
            this._onDestroy?.();
        }
        createElement(e, t) {
          return this.delegate.createElement(e, t);
        }
        createComment(e) {
          return this.delegate.createComment(e);
        }
        createText(e) {
          return this.delegate.createText(e);
        }
        appendChild(e, t) {
          this.delegate.appendChild(e, t),
            this.engine.onInsert(this.namespaceId, t, e, !1);
        }
        insertBefore(e, t, s, c = !0) {
          this.delegate.insertBefore(e, t, s),
            this.engine.onInsert(this.namespaceId, t, e, c);
        }
        removeChild(e, t, s) {
          this.engine.onRemove(this.namespaceId, t, this.delegate, s);
        }
        selectRootElement(e, t) {
          return this.delegate.selectRootElement(e, t);
        }
        parentNode(e) {
          return this.delegate.parentNode(e);
        }
        nextSibling(e) {
          return this.delegate.nextSibling(e);
        }
        setAttribute(e, t, s, c) {
          this.delegate.setAttribute(e, t, s, c);
        }
        removeAttribute(e, t, s) {
          this.delegate.removeAttribute(e, t, s);
        }
        addClass(e, t) {
          this.delegate.addClass(e, t);
        }
        removeClass(e, t) {
          this.delegate.removeClass(e, t);
        }
        setStyle(e, t, s, c) {
          this.delegate.setStyle(e, t, s, c);
        }
        removeStyle(e, t, s) {
          this.delegate.removeStyle(e, t, s);
        }
        setProperty(e, t, s) {
          "@" == t.charAt(0) && t == hD
            ? this.disableAnimations(e, !!s)
            : this.delegate.setProperty(e, t, s);
        }
        setValue(e, t) {
          this.delegate.setValue(e, t);
        }
        listen(e, t, s) {
          return this.delegate.listen(e, t, s);
        }
        disableAnimations(e, t) {
          this.engine.disableAnimations(e, t);
        }
      }
      class Ik extends dD {
        constructor(e, t, s, c, p) {
          super(t, s, c, p), (this.factory = e), (this.namespaceId = t);
        }
        setProperty(e, t, s) {
          "@" == t.charAt(0)
            ? "." == t.charAt(1) && t == hD
              ? this.disableAnimations(e, (s = void 0 === s || !!s))
              : this.engine.process(this.namespaceId, e, t.slice(1), s)
            : this.delegate.setProperty(e, t, s);
        }
        listen(e, t, s) {
          if ("@" == t.charAt(0)) {
            const c = (function Mk(n) {
              switch (n) {
                case "body":
                  return document.body;
                case "document":
                  return document;
                case "window":
                  return window;
                default:
                  return n;
              }
            })(e);
            let p = t.slice(1),
              y = "";
            return (
              "@" != p.charAt(0) &&
                ([p, y] = (function Ak(n) {
                  const e = n.indexOf(".");
                  return [n.substring(0, e), n.slice(e + 1)];
                })(p)),
              this.engine.listen(this.namespaceId, c, p, y, (w) => {
                this.factory.scheduleListenerCallback(w._data || -1, s, w);
              })
            );
          }
          return this.delegate.listen(e, t, s);
        }
      }
      const pD = [
          { provide: CT, useClass: Tk },
          {
            provide: sb,
            useFactory: function Lk() {
              return new YL();
            },
          },
          {
            provide: hv,
            useClass: (() => {
              class n extends hv {
                constructor(t, s, c, p) {
                  super(t.body, s, c);
                }
                ngOnDestroy() {
                  this.flush();
                }
              }
              return (
                (n.ɵfac = function (t) {
                  return new (t || n)(Mt(ml), Mt(Xx), Mt(sb), Mt(Sy));
                }),
                (n.ɵprov = Mn({ token: n, factory: n.ɵfac })),
                n
              );
            })(),
          },
          {
            provide: rh,
            useFactory: function kk(n, e, t) {
              return new Sk(n, e, t);
            },
            deps: [Xy, hv, dr],
          },
        ],
        pb = [
          { provide: Xx, useFactory: () => new Ek() },
          { provide: rE, useValue: "BrowserAnimations" },
          ...pD,
        ],
        fD = [
          { provide: Xx, useClass: VT },
          { provide: rE, useValue: "NoopAnimations" },
          ...pD,
        ];
      let Rk = (() => {
          class n {
            static withConfig(t) {
              return { ngModule: n, providers: t.disableAnimations ? fD : pb };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n })),
            (n.ɵinj = ii({ providers: pb, imports: [fT] })),
            n
          );
        })(),
        Ok = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = ar({ type: n, bootstrap: [pP] })),
            (n.ɵinj = ii({ imports: [fT, Rk, mP, OP, wT, W2] })),
            n
          );
        })();
      (function OI() {
        xE = !1;
      })(),
        p2()
          .bootstrapModule(Ok)
          .catch((n) => console.error(n));
    },
    898: function (Af) {
      Af.exports = (function () {
        "use strict";
        var au, lu, di;
        function op(d, Be) {
          if (au)
            if (lu) {
              var Oo =
                  "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" +
                  au +
                  ")(sharedChunk); (" +
                  lu +
                  ")(sharedChunk); self.onerror = null;",
                eo = {};
              au(eo),
                (di = Be(eo)),
                typeof window < "u" &&
                  window &&
                  window.URL &&
                  window.URL.createObjectURL &&
                  (di.workerUrl = window.URL.createObjectURL(
                    new Blob([Oo], { type: "text/javascript" })
                  ));
            } else lu = Be;
          else au = Be;
        }
        return (
          op(0, function (d) {
            var Be = typeof self < "u" ? self : {},
              Oo = "2.15.0";
            let eo;
            const jt = {
                API_URL: "https://api.mapbox.com",
                get API_URL_REGEX() {
                  if (null == eo) {
                    const r =
                      /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                      eo =
                        null != process.env.API_URL_REGEX
                          ? new RegExp(process.env.API_URL_REGEX)
                          : r;
                    } catch {
                      eo = r;
                    }
                  }
                  return eo;
                },
                get API_TILEJSON_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
                },
                get API_SPRITE_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
                },
                get API_FONTS_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
                },
                get API_STYLE_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
                },
                get API_CDN_URL_REGEX() {
                  return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
                },
                get EVENTS_URL() {
                  if (!jt.API_URL) return null;
                  try {
                    const r = new URL(jt.API_URL);
                    return "api.mapbox.cn" === r.hostname
                      ? "https://events.mapbox.cn/events/v2"
                      : "api.mapbox.com" === r.hostname
                      ? "https://events.mapbox.com/events/v2"
                      : null;
                  } catch {
                    return null;
                  }
                },
                SESSION_PATH: "/map-sessions/v1",
                FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                TILE_URL_VERSION: "v4",
                RASTER_URL_PREFIX: "raster/v1",
                REQUIRE_ACCESS_TOKEN: !0,
                ACCESS_TOKEN: null,
                MAX_PARALLEL_IMAGE_REQUESTS: 16,
              },
              zt = {
                supported: !1,
                testSupport: function (r) {
                  !Fo && mr && (ns ? oc(r) : (Mi = r));
                },
              };
            let Mi,
              mr,
              Fo = !1,
              ns = !1;
            function oc(r) {
              const i = r.createTexture();
              r.bindTexture(r.TEXTURE_2D, i);
              try {
                if (
                  (r.texImage2D(
                    r.TEXTURE_2D,
                    0,
                    r.RGBA,
                    r.RGBA,
                    r.UNSIGNED_BYTE,
                    mr
                  ),
                  r.isContextLost())
                )
                  return;
                zt.supported = !0;
              } catch {}
              r.deleteTexture(i), (Fo = !0);
            }
            Be.document &&
              ((mr = Be.document.createElement("img")),
              (mr.onload = function () {
                Mi && oc(Mi), (Mi = null), (ns = !0);
              }),
              (mr.onerror = function () {
                (Fo = !0), (Mi = null);
              }),
              (mr.src =
                "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="));
            const vl = "01";
            function Ur(r) {
              return r &&
                r.__esModule &&
                Object.prototype.hasOwnProperty.call(r, "default")
                ? r.default
                : r;
            }
            var to = Mr;
            function Mr(r, i, o, l) {
              (this.cx = 3 * r),
                (this.bx = 3 * (o - r) - this.cx),
                (this.ax = 1 - this.cx - this.bx),
                (this.cy = 3 * i),
                (this.by = 3 * (l - i) - this.cy),
                (this.ay = 1 - this.cy - this.by),
                (this.p1x = r),
                (this.p1y = i),
                (this.p2x = o),
                (this.p2y = l);
            }
            Mr.prototype = {
              sampleCurveX: function (r) {
                return ((this.ax * r + this.bx) * r + this.cx) * r;
              },
              sampleCurveY: function (r) {
                return ((this.ay * r + this.by) * r + this.cy) * r;
              },
              sampleCurveDerivativeX: function (r) {
                return (3 * this.ax * r + 2 * this.bx) * r + this.cx;
              },
              solveCurveX: function (r, i) {
                if ((void 0 === i && (i = 1e-6), r < 0)) return 0;
                if (r > 1) return 1;
                for (var o = r, l = 0; l < 8; l++) {
                  var h = this.sampleCurveX(o) - r;
                  if (Math.abs(h) < i) return o;
                  var m = this.sampleCurveDerivativeX(o);
                  if (Math.abs(m) < 1e-6) break;
                  o -= h / m;
                }
                var _ = 0,
                  x = 1;
                for (
                  o = r, l = 0;
                  l < 20 &&
                  ((h = this.sampleCurveX(o)), !(Math.abs(h - r) < i));
                  l++
                )
                  r > h ? (_ = o) : (x = o), (o = 0.5 * (x - _) + _);
                return o;
              },
              solve: function (r, i) {
                return this.sampleCurveY(this.solveCurveX(r, i));
              },
            };
            var Ca = Ur(to),
              is = go;
            function go(r, i) {
              (this.x = r), (this.y = i);
            }
            (go.prototype = {
              clone: function () {
                return new go(this.x, this.y);
              },
              add: function (r) {
                return this.clone()._add(r);
              },
              sub: function (r) {
                return this.clone()._sub(r);
              },
              multByPoint: function (r) {
                return this.clone()._multByPoint(r);
              },
              divByPoint: function (r) {
                return this.clone()._divByPoint(r);
              },
              mult: function (r) {
                return this.clone()._mult(r);
              },
              div: function (r) {
                return this.clone()._div(r);
              },
              rotate: function (r) {
                return this.clone()._rotate(r);
              },
              rotateAround: function (r, i) {
                return this.clone()._rotateAround(r, i);
              },
              matMult: function (r) {
                return this.clone()._matMult(r);
              },
              unit: function () {
                return this.clone()._unit();
              },
              perp: function () {
                return this.clone()._perp();
              },
              round: function () {
                return this.clone()._round();
              },
              mag: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              },
              equals: function (r) {
                return this.x === r.x && this.y === r.y;
              },
              dist: function (r) {
                return Math.sqrt(this.distSqr(r));
              },
              distSqr: function (r) {
                var i = r.x - this.x,
                  o = r.y - this.y;
                return i * i + o * o;
              },
              angle: function () {
                return Math.atan2(this.y, this.x);
              },
              angleTo: function (r) {
                return Math.atan2(this.y - r.y, this.x - r.x);
              },
              angleWith: function (r) {
                return this.angleWithSep(r.x, r.y);
              },
              angleWithSep: function (r, i) {
                return Math.atan2(
                  this.x * i - this.y * r,
                  this.x * r + this.y * i
                );
              },
              _matMult: function (r) {
                var i = r[2] * this.x + r[3] * this.y;
                return (
                  (this.x = r[0] * this.x + r[1] * this.y), (this.y = i), this
                );
              },
              _add: function (r) {
                return (this.x += r.x), (this.y += r.y), this;
              },
              _sub: function (r) {
                return (this.x -= r.x), (this.y -= r.y), this;
              },
              _mult: function (r) {
                return (this.x *= r), (this.y *= r), this;
              },
              _div: function (r) {
                return (this.x /= r), (this.y /= r), this;
              },
              _multByPoint: function (r) {
                return (this.x *= r.x), (this.y *= r.y), this;
              },
              _divByPoint: function (r) {
                return (this.x /= r.x), (this.y /= r.y), this;
              },
              _unit: function () {
                return this._div(this.mag()), this;
              },
              _perp: function () {
                var r = this.y;
                return (this.y = this.x), (this.x = -r), this;
              },
              _rotate: function (r) {
                var i = Math.cos(r),
                  o = Math.sin(r),
                  l = o * this.x + i * this.y;
                return (this.x = i * this.x - o * this.y), (this.y = l), this;
              },
              _rotateAround: function (r, i) {
                var o = Math.cos(r),
                  l = Math.sin(r),
                  h = i.y + l * (this.x - i.x) + o * (this.y - i.y);
                return (
                  (this.x = i.x + o * (this.x - i.x) - l * (this.y - i.y)),
                  (this.y = h),
                  this
                );
              },
              _round: function () {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  this
                );
              },
            }),
              (go.convert = function (r) {
                return r instanceof go
                  ? r
                  : Array.isArray(r)
                  ? new go(r[0], r[1])
                  : r;
              });
            var nt = Ur(is);
            const Dh = Math.PI / 180,
              Sa = 180 / Math.PI;
            function Qt(r) {
              return r * Dh;
            }
            function zi(r) {
              return r * Sa;
            }
            const sc = [
              [0, 0],
              [1, 0],
              [1, 1],
              [0, 1],
            ];
            function cu(r) {
              if (r <= 0) return 0;
              if (r >= 1) return 1;
              const i = r * r,
                o = i * r;
              return 4 * (r < 0.5 ? o : 3 * (r - i) + o - 0.75);
            }
            function Ia(r, i, o, l) {
              const h = new Ca(r, i, o, l);
              return function (m) {
                return h.solve(m);
              };
            }
            const ac = Ia(0.25, 0.1, 0.25, 1);
            function tn(r, i, o) {
              return Math.min(o, Math.max(i, r));
            }
            function Ma(r, i, o) {
              return (o = tn((o - r) / (i - r), 0, 1)) * o * (3 - 2 * o);
            }
            function Tn(r, i, o) {
              const l = o - i,
                h = ((((r - i) % l) + l) % l) + i;
              return h === i ? o : h;
            }
            function Ai(r, i, o) {
              if (!r.length) return o(null, []);
              let l = r.length;
              const h = new Array(r.length);
              let m = null;
              r.forEach((_, x) => {
                i(_, (E, T) => {
                  E && (m = E), (h[x] = T), 0 == --l && o(m, h);
                });
              });
            }
            function Rs(r) {
              const i = [];
              for (const o in r) i.push(r[o]);
              return i;
            }
            function pi(r, ...i) {
              for (const o of i) for (const l in o) r[l] = o[l];
              return r;
            }
            let Os = 1;
            function rs() {
              return Os++;
            }
            function os() {
              return (function r(i) {
                return i
                  ? (i ^ (Math.random() * (16 >> (i / 4)))).toString(16)
                  : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
              })();
            }
            function ss(r) {
              return r <= 1
                ? 1
                : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
            }
            function Fs(r) {
              return (
                !!r &&
                /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                  r
                )
              );
            }
            function No(r, i) {
              r.forEach((o) => {
                i[o] && (i[o] = i[o].bind(i));
              });
            }
            function xl(r, i) {
              return -1 !== r.indexOf(i, r.length - i.length);
            }
            function rn(r, i, o) {
              const l = {};
              for (const h in r) l[h] = i.call(o || this, r[h], h, r);
              return l;
            }
            function Ns(r, i, o) {
              const l = {};
              for (const h in r) i.call(o || this, r[h], h, r) && (l[h] = r[h]);
              return l;
            }
            function $r(r) {
              return Array.isArray(r)
                ? r.map($r)
                : "object" == typeof r && r
                ? rn(r, $r)
                : r;
            }
            const Aa = {};
            function Wn(r) {
              Aa[r] || (typeof console < "u" && console.warn(r), (Aa[r] = !0));
            }
            function no(r, i, o) {
              return (o.y - r.y) * (i.x - r.x) > (i.y - r.y) * (o.x - r.x);
            }
            function uu(r) {
              let i = 0;
              for (let o, l, h = 0, m = r.length, _ = m - 1; h < m; _ = h++)
                (o = r[h]), (l = r[_]), (i += (l.x - o.x) * (o.y + l.y));
              return i;
            }
            function zs() {
              return (
                typeof WorkerGlobalScope < "u" &&
                typeof self < "u" &&
                self instanceof WorkerGlobalScope
              );
            }
            function io(r) {
              const i = {};
              if (
                (r.replace(
                  /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
                  (o, l, h, m) => {
                    const _ = h || m;
                    return (i[l] = !_ || _.toLowerCase()), "";
                  }
                ),
                i["max-age"])
              ) {
                const o = parseInt(i["max-age"], 10);
                isNaN(o) ? delete i["max-age"] : (i["max-age"] = o);
              }
              return i;
            }
            let hu = null;
            function lc(r) {
              if (null == hu) {
                const i = r.navigator ? r.navigator.userAgent : null;
                hu =
                  !!r.safari ||
                  !(
                    !i ||
                    !(
                      /\b(iPad|iPhone|iPod)\b/.test(i) ||
                      (i.match("Safari") && !i.match("Chrome"))
                    )
                  );
              }
              return hu;
            }
            function cc(r) {
              try {
                const i = Be[r];
                return (
                  i.setItem("_mapbox_test_", 1),
                  i.removeItem("_mapbox_test_"),
                  !0
                );
              } catch {
                return !1;
              }
            }
            function as(r, i) {
              return [r[4 * i], r[4 * i + 1], r[4 * i + 2], r[4 * i + 3]];
            }
            const bl = "mapbox-tiles";
            let Ar,
              ls,
              wl = 500,
              du = 50;
            function uc() {
              try {
                return Be.caches;
              } catch {}
            }
            function Pa() {
              uc() && !Ar && (Ar = Be.caches.open(bl));
            }
            function El(r) {
              const i = r.indexOf("?");
              if (i < 0) return r;
              const l = (function (h) {
                const m = h.indexOf("?");
                return m > 0 ? h.slice(m + 1).split("&") : [];
              })(r).filter((h) => {
                const m = h.split("=");
                return "language" === m[0] || "worldview" === m[0];
              });
              return l.length
                ? `${r.slice(0, i)}?${l.join("&")}`
                : r.slice(0, i);
            }
            let ro = 1 / 0;
            const Bs = {
              Unknown: "Unknown",
              Style: "Style",
              Source: "Source",
              Tile: "Tile",
              Glyphs: "Glyphs",
              SpriteImage: "SpriteImage",
              SpriteJSON: "SpriteJSON",
              Image: "Image",
            };
            "function" == typeof Object.freeze && Object.freeze(Bs);
            class Vs extends Error {
              constructor(i, o, l) {
                401 === o &&
                  ve(l) &&
                  (i +=
                    ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                  super(i),
                  (this.status = o),
                  (this.url = l);
              }
              toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
              }
            }
            const js = zs()
                ? () => self.worker && self.worker.referrer
                : () =>
                    ("blob:" === Be.location.protocol ? Be.parent : Be).location
                      .href,
              La = function (r, i) {
                if (
                  !(
                    /^file:/.test((o = r.url)) ||
                    (/^file:/.test(js()) && !/^\w+:/.test(o))
                  )
                ) {
                  if (
                    Be.fetch &&
                    Be.Request &&
                    Be.AbortController &&
                    Be.Request.prototype.hasOwnProperty("signal")
                  )
                    return (function (l, h) {
                      const m = new Be.AbortController(),
                        _ = new Be.Request(l.url, {
                          method: l.method || "GET",
                          body: l.body,
                          credentials: l.credentials,
                          headers: l.headers,
                          referrer: js(),
                          referrerPolicy: l.referrerPolicy,
                          signal: m.signal,
                        });
                      let x = !1,
                        E = !1;
                      const T = (I = _.url).indexOf("sku=") > 0 && ve(I);
                      var I;
                      "json" === l.type &&
                        _.headers.set("Accept", "application/json");
                      const A = (O, F, V) => {
                          if (E) return;
                          if (
                            (O &&
                              "SecurityError" !== O.message &&
                              Wn(O.toString()),
                            F && V)
                          )
                            return L(F);
                          const G = Date.now();
                          Be.fetch(_)
                            .then((K) => {
                              if (K.ok) {
                                const oe = T ? K.clone() : null;
                                return L(K, oe, G);
                              }
                              return h(new Vs(K.statusText, K.status, l.url));
                            })
                            .catch((K) => {
                              "AbortError" !== K.name &&
                                h(new Error(`${K.message} ${l.url}`));
                            });
                        },
                        L = (O, F, V) => {
                          ("arrayBuffer" === l.type
                            ? O.arrayBuffer()
                            : "json" === l.type
                            ? O.json()
                            : O.text()
                          )
                            .then((G) => {
                              E ||
                                (F &&
                                  V &&
                                  (function (K, oe, J) {
                                    if ((Pa(), !Ar)) return;
                                    const re = {
                                      status: oe.status,
                                      statusText: oe.statusText,
                                      headers: new Be.Headers(),
                                    };
                                    oe.headers.forEach((De, xe) =>
                                      re.headers.set(xe, De)
                                    );
                                    const le = io(
                                      oe.headers.get("Cache-Control") || ""
                                    );
                                    if (le["no-store"]) return;
                                    le["max-age"] &&
                                      re.headers.set(
                                        "Expires",
                                        new Date(
                                          J + 1e3 * le["max-age"]
                                        ).toUTCString()
                                      );
                                    const ae = re.headers.get("Expires");
                                    ae &&
                                      (new Date(ae).getTime() - J < 42e4 ||
                                        (function (De, xe) {
                                          if (void 0 === ls)
                                            try {
                                              new Response(
                                                new ReadableStream()
                                              ),
                                                (ls = !0);
                                            } catch {
                                              ls = !1;
                                            }
                                          ls ? xe(De.body) : De.blob().then(xe);
                                        })(oe, (De) => {
                                          const xe = new Be.Response(De, re);
                                          Pa(),
                                            Ar &&
                                              Ar.then((Pe) =>
                                                Pe.put(El(K.url), xe)
                                              ).catch((Pe) => Wn(Pe.message));
                                        }));
                                  })(_, F, V),
                                (x = !0),
                                h(
                                  null,
                                  G,
                                  O.headers.get("Cache-Control"),
                                  O.headers.get("Expires")
                                ));
                            })
                            .catch((G) => {
                              E || h(new Error(G.message));
                            });
                        };
                      return (
                        T
                          ? (function (O, F) {
                              if ((Pa(), !Ar)) return F(null);
                              const V = El(O.url);
                              Ar.then((G) => {
                                G.match(V)
                                  .then((K) => {
                                    const oe = (function (J) {
                                      if (!J) return !1;
                                      const re = new Date(
                                          J.headers.get("Expires") || 0
                                        ),
                                        le = io(
                                          J.headers.get("Cache-Control") || ""
                                        );
                                      return re > Date.now() && !le["no-cache"];
                                    })(K);
                                    G.delete(V),
                                      oe && G.put(V, K.clone()),
                                      F(null, K, oe);
                                  })
                                  .catch(F);
                              }).catch(F);
                            })(_, A)
                          : A(null, null),
                        {
                          cancel: () => {
                            (E = !0), x || m.abort();
                          },
                        }
                      );
                    })(r, i);
                  if (zs() && self.worker && self.worker.actor)
                    return self.worker.actor.send(
                      "getResource",
                      r,
                      i,
                      void 0,
                      !0
                    );
                }
                var o;
                return (function (l, h) {
                  const m = new Be.XMLHttpRequest();
                  m.open(l.method || "GET", l.url, !0),
                    "arrayBuffer" === l.type &&
                      (m.responseType = "arraybuffer");
                  for (const _ in l.headers)
                    m.setRequestHeader(_, l.headers[_]);
                  return (
                    "json" === l.type &&
                      ((m.responseType = "text"),
                      m.setRequestHeader("Accept", "application/json")),
                    (m.withCredentials = "include" === l.credentials),
                    (m.onerror = () => {
                      h(new Error(m.statusText));
                    }),
                    (m.onload = () => {
                      if (
                        ((m.status >= 200 && m.status < 300) ||
                          0 === m.status) &&
                        null !== m.response
                      ) {
                        let _ = m.response;
                        if ("json" === l.type)
                          try {
                            _ = JSON.parse(m.response);
                          } catch (x) {
                            return h(x);
                          }
                        h(
                          null,
                          _,
                          m.getResponseHeader("Cache-Control"),
                          m.getResponseHeader("Expires")
                        );
                      } else h(new Vs(m.statusText, m.status, l.url));
                    }),
                    m.send(l.body),
                    { cancel: () => m.abort() }
                  );
                })(r, i);
              },
              Tl = function (r, i) {
                return La(pi(r, { type: "arrayBuffer" }), i);
              };
            function pu(r) {
              const i = Be.document.createElement("a");
              return (
                (i.href = r),
                i.protocol === Be.document.location.protocol &&
                  i.host === Be.document.location.host
              );
            }
            const se =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let U, $;
            (U = []), ($ = 0);
            const ne = function (r, i) {
                if (
                  (zt.supported &&
                    (r.headers || (r.headers = {}),
                    (r.headers.accept = "image/webp,*/*")),
                  $ >= jt.MAX_PARALLEL_IMAGE_REQUESTS)
                ) {
                  const m = {
                    requestParameters: r,
                    callback: i,
                    cancelled: !1,
                    cancel() {
                      this.cancelled = !0;
                    },
                  };
                  return U.push(m), m;
                }
                $++;
                let o = !1;
                const l = () => {
                    if (!o)
                      for (
                        o = !0, $--;
                        U.length && $ < jt.MAX_PARALLEL_IMAGE_REQUESTS;

                      ) {
                        const m = U.shift(),
                          {
                            requestParameters: _,
                            callback: x,
                            cancelled: E,
                          } = m;
                        E || (m.cancel = ne(_, x).cancel);
                      }
                  },
                  h = Tl(r, (m, _, x, E) => {
                    l(),
                      m
                        ? i(m)
                        : _ &&
                          (Be.createImageBitmap
                            ? (function (T, I) {
                                const A = new Be.Blob([new Uint8Array(T)], {
                                  type: "image/png",
                                });
                                Be.createImageBitmap(A)
                                  .then((L) => {
                                    I(null, L);
                                  })
                                  .catch((L) => {
                                    I(
                                      new Error(
                                        `Could not load image because of ${L.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
                                      )
                                    );
                                  });
                              })(_, (T, I) => i(T, I, x, E))
                            : (function (T, I) {
                                const A = new Be.Image(),
                                  L = Be.URL;
                                (A.onload = () => {
                                  I(null, A),
                                    L.revokeObjectURL(A.src),
                                    (A.onload = null),
                                    Be.requestAnimationFrame(() => {
                                      A.src = se;
                                    });
                                }),
                                  (A.onerror = () =>
                                    I(
                                      new Error(
                                        "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
                                      )
                                    ));
                                const O = new Be.Blob([new Uint8Array(T)], {
                                  type: "image/png",
                                });
                                A.src = T.byteLength
                                  ? L.createObjectURL(O)
                                  : se;
                              })(_, (T, I) => i(T, I, x, E)));
                  });
                return {
                  cancel: () => {
                    h.cancel(), l();
                  },
                };
              },
              ce = "NO_ACCESS_TOKEN";
            function me(r) {
              return 0 === r.indexOf("mapbox:");
            }
            function ve(r) {
              return jt.API_URL_REGEX.test(r);
            }
            function ye(r) {
              return jt.API_CDN_URL_REGEX.test(r);
            }
            function fe(r) {
              return jt.API_STYLE_REGEX.test(r) && !Ce(r);
            }
            function Ce(r) {
              return jt.API_SPRITE_REGEX.test(r);
            }
            const Qe = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
            function et(r) {
              const i = r.match(Qe);
              if (!i) throw new Error("Unable to parse URL object");
              return {
                protocol: i[1],
                authority: i[2],
                path: i[3] || "/",
                params: i[4] ? i[4].split("&") : [],
              };
            }
            function We(r) {
              const i = r.params.length ? `?${r.params.join("&")}` : "";
              return `${r.protocol}://${r.authority}${r.path}${i}`;
            }
            const Rt = "mapbox.eventData";
            function Ut(r) {
              if (!r) return null;
              const i = r.split(".");
              if (!i || 3 !== i.length) return null;
              try {
                return JSON.parse(
                  decodeURIComponent(
                    Be.atob(i[1])
                      .split("")
                      .map(
                        (o) =>
                          "%" + ("00" + o.charCodeAt(0).toString(16)).slice(-2)
                      )
                      .join("")
                  )
                );
              } catch {
                return null;
              }
            }
            class Ct {
              constructor(i) {
                (this.type = i),
                  (this.anonId = null),
                  (this.eventData = {}),
                  (this.queue = []),
                  (this.pendingRequest = null);
              }
              getStorageKey(i) {
                const o = Ut(jt.ACCESS_TOKEN);
                let l = "";
                return (
                  (l =
                    o && o.u
                      ? Be.btoa(
                          encodeURIComponent(o.u).replace(
                            /%([0-9A-F]{2})/g,
                            (h, m) => String.fromCharCode(Number("0x" + m))
                          )
                        )
                      : jt.ACCESS_TOKEN || ""),
                  i ? `${Rt}.${i}:${l}` : `${Rt}:${l}`
                );
              }
              fetchEventData() {
                const i = cc("localStorage"),
                  o = this.getStorageKey(),
                  l = this.getStorageKey("uuid");
                if (i)
                  try {
                    const h = Be.localStorage.getItem(o);
                    h && (this.eventData = JSON.parse(h));
                    const m = Be.localStorage.getItem(l);
                    m && (this.anonId = m);
                  } catch {
                    Wn("Unable to read from LocalStorage");
                  }
              }
              saveEventData() {
                const i = cc("localStorage"),
                  o = this.getStorageKey(),
                  l = this.getStorageKey("uuid");
                if (i)
                  try {
                    Be.localStorage.setItem(l, this.anonId),
                      Object.keys(this.eventData).length >= 1 &&
                        Be.localStorage.setItem(
                          o,
                          JSON.stringify(this.eventData)
                        );
                  } catch {
                    Wn("Unable to write to LocalStorage");
                  }
              }
              processRequests(i) {}
              postEvent(i, o, l, h) {
                if (!jt.EVENTS_URL) return;
                const m = et(jt.EVENTS_URL);
                m.params.push(`access_token=${h || jt.ACCESS_TOKEN || ""}`);
                const _ = {
                    event: this.type,
                    created: new Date(i).toISOString(),
                  },
                  x = o ? pi(_, o) : _,
                  E = {
                    url: We(m),
                    headers: { "Content-Type": "text/plain" },
                    body: JSON.stringify([x]),
                  };
                var I;
                this.pendingRequest =
                  ((I = (T) => {
                    (this.pendingRequest = null),
                      l(T),
                      this.saveEventData(),
                      this.processRequests(h);
                  }),
                  La(pi(E, { method: "POST" }), I));
              }
              queueRequest(i, o) {
                this.queue.push(i), this.processRequests(o);
              }
            }
            const Zt = new (class extends Ct {
                constructor(r) {
                  super("appUserTurnstile"), (this._customAccessToken = r);
                }
                postTurnstileEvent(r, i) {
                  jt.EVENTS_URL &&
                    jt.ACCESS_TOKEN &&
                    Array.isArray(r) &&
                    r.some((o) => me(o) || ve(o)) &&
                    this.queueRequest(Date.now(), i);
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  (this.anonId &&
                    this.eventData.lastSuccess &&
                    this.eventData.tokenU) ||
                    this.fetchEventData();
                  const i = Ut(jt.ACCESS_TOKEN),
                    o = i ? i.u : jt.ACCESS_TOKEN;
                  let l = o !== this.eventData.tokenU;
                  Fs(this.anonId) || ((this.anonId = os()), (l = !0));
                  const h = this.queue.shift();
                  if (this.eventData.lastSuccess) {
                    const m = new Date(this.eventData.lastSuccess),
                      _ = new Date(h),
                      x = (h - this.eventData.lastSuccess) / 864e5;
                    l = l || x >= 1 || x < -1 || m.getDate() !== _.getDate();
                  } else l = !0;
                  l
                    ? this.postEvent(
                        h,
                        {
                          sdkIdentifier: "mapbox-gl-js",
                          sdkVersion: Oo,
                          skuId: vl,
                          "enabled.telemetry": !1,
                          userId: this.anonId,
                        },
                        (m) => {
                          m ||
                            ((this.eventData.lastSuccess = h),
                            (this.eventData.tokenU = o));
                        },
                        r
                      )
                    : this.processRequests();
                }
              })(),
              on = Zt.postTurnstileEvent.bind(Zt),
              Zn = new (class extends Ct {
                constructor() {
                  super("map.load"), (this.success = {}), (this.skuToken = "");
                }
                postMapLoadEvent(r, i, o, l) {
                  (this.skuToken = i),
                    (this.errorCb = l),
                    jt.EVENTS_URL &&
                      (o || jt.ACCESS_TOKEN
                        ? this.queueRequest({ id: r, timestamp: Date.now() }, o)
                        : this.errorCb(new Error(ce)));
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: i, timestamp: o } = this.queue.shift();
                  (i && this.success[i]) ||
                    (this.anonId || this.fetchEventData(),
                    Fs(this.anonId) || (this.anonId = os()),
                    this.postEvent(
                      o,
                      {
                        sdkIdentifier: "mapbox-gl-js",
                        sdkVersion: Oo,
                        skuId: vl,
                        skuToken: this.skuToken,
                        userId: this.anonId,
                      },
                      (l) => {
                        l ? this.errorCb(l) : i && (this.success[i] = !0);
                      },
                      r
                    ));
                }
              })(),
              fi = Zn.postMapLoadEvent.bind(Zn),
              Ki = new (class extends Ct {
                constructor() {
                  super("gljs.performance");
                }
                postPerformanceEvent(r, i) {
                  jt.EVENTS_URL &&
                    (r || jt.ACCESS_TOKEN) &&
                    this.queueRequest(
                      { timestamp: Date.now(), performanceData: i },
                      r
                    );
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { timestamp: i, performanceData: o } =
                      this.queue.shift(),
                    l = (function (h) {
                      const m = Be.performance.getEntriesByType("resource"),
                        _ = Be.performance.getEntriesByType("mark"),
                        x = (function (L) {
                          const O = {};
                          if (L)
                            for (const F in L)
                              if ("other" !== F)
                                for (const V of L[F]) {
                                  const G = `${F}ResolveRangeMin`,
                                    K = `${F}ResolveRangeMax`,
                                    oe = `${F}RequestCount`,
                                    J = `${F}RequestCachedCount`;
                                  (O[G] = Math.min(O[G] || 1 / 0, V.startTime)),
                                    (O[K] = Math.max(
                                      O[K] || -1 / 0,
                                      V.responseEnd
                                    ));
                                  const re = (le) => {
                                    void 0 === O[le] && (O[le] = 0), ++O[le];
                                  };
                                  void 0 !== V.transferSize &&
                                    0 === V.transferSize &&
                                    re(J),
                                    re(oe);
                                }
                          return O;
                        })(
                          (function (L, O) {
                            const F = {};
                            if (L)
                              for (const V of L) {
                                const G = O(V);
                                void 0 === F[G] && (F[G] = []), F[G].push(V);
                              }
                            return F;
                          })(m, Ch)
                        ),
                        E = Be.devicePixelRatio,
                        T =
                          Be.navigator.connection ||
                          Be.navigator.mozConnection ||
                          Be.navigator.webkitConnection,
                        I = { counters: [], metadata: [], attributes: [] },
                        A = (L, O, F) => {
                          null != F && L.push({ name: O, value: F.toString() });
                        };
                      for (const L in x) A(I.counters, L, x[L]);
                      if (
                        (h.interactionRange[0] !== 1 / 0 &&
                          h.interactionRange[1] !== -1 / 0 &&
                          (A(
                            I.counters,
                            "interactionRangeMin",
                            h.interactionRange[0]
                          ),
                          A(
                            I.counters,
                            "interactionRangeMax",
                            h.interactionRange[1]
                          )),
                        _)
                      )
                        for (const L of Object.keys(ka)) {
                          const O = ka[L],
                            F = _.find((V) => V.name === O);
                          F && A(I.counters, O, F.startTime);
                        }
                      return (
                        A(I.counters, "visibilityHidden", h.visibilityHidden),
                        A(
                          I.attributes,
                          "style",
                          (function (L) {
                            if (L)
                              for (const O of L) {
                                const F = O.name.split("?")[0];
                                if (fe(F)) {
                                  const V = F.split("/").slice(-2);
                                  if (2 === V.length)
                                    return `mapbox://styles/${V[0]}/${V[1]}`;
                                }
                              }
                          })(m)
                        ),
                        A(
                          I.attributes,
                          "terrainEnabled",
                          h.terrainEnabled ? "true" : "false"
                        ),
                        A(
                          I.attributes,
                          "fogEnabled",
                          h.fogEnabled ? "true" : "false"
                        ),
                        A(I.attributes, "projection", h.projection),
                        A(I.attributes, "zoom", h.zoom),
                        A(I.metadata, "devicePixelRatio", E),
                        A(
                          I.metadata,
                          "connectionEffectiveType",
                          T ? T.effectiveType : void 0
                        ),
                        A(
                          I.metadata,
                          "navigatorUserAgent",
                          Be.navigator.userAgent
                        ),
                        A(I.metadata, "screenWidth", Be.screen.width),
                        A(I.metadata, "screenHeight", Be.screen.height),
                        A(I.metadata, "windowWidth", Be.innerWidth),
                        A(I.metadata, "windowHeight", Be.innerHeight),
                        A(I.metadata, "mapWidth", h.width / E),
                        A(I.metadata, "mapHeight", h.height / E),
                        A(I.metadata, "webglRenderer", h.renderer),
                        A(I.metadata, "webglVendor", h.vendor),
                        A(I.metadata, "sdkVersion", Oo),
                        A(I.metadata, "sdkIdentifier", "mapbox-gl-js"),
                        I
                      );
                    })(o);
                  for (const h of l.metadata);
                  for (const h of l.counters);
                  for (const h of l.attributes);
                  this.postEvent(i, l, () => {}, r);
                }
              })(),
              Di = Ki.postPerformanceEvent.bind(Ki),
              zo = new (class extends Ct {
                constructor() {
                  super("map.auth"), (this.success = {}), (this.skuToken = "");
                }
                getSession(r, i, o, l) {
                  if (!jt.API_URL || !jt.SESSION_PATH) return;
                  const h = et(jt.API_URL + jt.SESSION_PATH);
                  h.params.push(`sku=${i || ""}`),
                    h.params.push(`access_token=${l || jt.ACCESS_TOKEN || ""}`);
                  const m = {
                    url: We(h),
                    headers: { "Content-Type": "text/plain" },
                  };
                  var x;
                  this.pendingRequest =
                    ((x = (_) => {
                      (this.pendingRequest = null),
                        o(_),
                        this.saveEventData(),
                        this.processRequests(l);
                    }),
                    La(pi(m, { method: "GET" }), x));
                }
                getSessionAPI(r, i, o, l) {
                  (this.skuToken = i),
                    (this.errorCb = l),
                    jt.SESSION_PATH &&
                      jt.API_URL &&
                      (o || jt.ACCESS_TOKEN
                        ? this.queueRequest({ id: r, timestamp: Date.now() }, o)
                        : this.errorCb(new Error(ce)));
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: i, timestamp: o } = this.queue.shift();
                  (i && this.success[i]) ||
                    this.getSession(
                      o,
                      this.skuToken,
                      (l) => {
                        l ? this.errorCb(l) : i && (this.success[i] = !0);
                      },
                      r
                    );
                }
              })(),
              Xn = zo.getSessionAPI.bind(zo),
              gr = new Set(),
              ka = { create: "create", load: "load", fullLoad: "fullLoad" },
              Lf = {
                mark(r) {
                  Be.performance.mark(r);
                },
                measure(r, i, o) {
                  Be.performance.measure(r, i, o);
                },
              };
            function Ch(r) {
              const i = r.name.split("?")[0];
              return ye(i) && i.includes("mapbox-gl.js")
                ? "javascript"
                : ye(i) && i.includes("mapbox-gl.css")
                ? "css"
                : jt.API_FONTS_REGEX.test(i)
                ? "fontRange"
                : Ce(i)
                ? "sprite"
                : fe(i)
                ? "style"
                : jt.API_TILEJSON_REGEX.test(i)
                ? "tilejson"
                : "other";
            }
            const xn = Be.performance;
            function Sh(r) {
              const i = r ? r.url.toString() : void 0;
              return xn.getEntriesByName(i);
            }
            let hc, dc, Ih, Bo;
            const cs = {
              now: () => (void 0 !== Ih ? Ih : Be.performance.now()),
              setNow(r) {
                Ih = r;
              },
              restoreNow() {
                Ih = void 0;
              },
              frame(r) {
                const i = Be.requestAnimationFrame(r);
                return { cancel: () => Be.cancelAnimationFrame(i) };
              },
              getImageData(r, i = 0) {
                const { width: o, height: l } = r;
                Bo || (Bo = Be.document.createElement("canvas"));
                const h = Bo.getContext("2d", { willReadFrequently: !0 });
                if (!h) throw new Error("failed to create canvas 2d context");
                return (
                  (o > Bo.width || l > Bo.height) &&
                    ((Bo.width = o), (Bo.height = l)),
                  h.clearRect(-i, -i, o + 2 * i, l + 2 * i),
                  h.drawImage(r, 0, 0, o, l),
                  h.getImageData(-i, -i, o + 2 * i, l + 2 * i)
                );
              },
              resolveURL: (r) => (
                hc || (hc = Be.document.createElement("a")),
                (hc.href = r),
                hc.href
              ),
              get devicePixelRatio() {
                return Be.devicePixelRatio;
              },
              get prefersReducedMotion() {
                return (
                  !!Be.matchMedia &&
                  (null == dc &&
                    (dc = Be.matchMedia("(prefers-reduced-motion: reduce)")),
                  dc.matches)
                );
              },
            };
            function fu(r, i, o) {
              (o[r] && -1 !== o[r].indexOf(i)) ||
                ((o[r] = o[r] || []), o[r].push(i));
            }
            function mu(r, i, o) {
              if (o && o[r]) {
                const l = o[r].indexOf(i);
                -1 !== l && o[r].splice(l, 1);
              }
            }
            class Ra {
              constructor(i, o = {}) {
                pi(this, o), (this.type = i);
              }
            }
            class us extends Ra {
              constructor(i, o = {}) {
                super("error", pi({ error: i }, o));
              }
            }
            class pc {
              on(i, o) {
                return (
                  (this._listeners = this._listeners || {}),
                  fu(i, o, this._listeners),
                  this
                );
              }
              off(i, o) {
                return (
                  mu(i, o, this._listeners),
                  mu(i, o, this._oneTimeListeners),
                  this
                );
              }
              once(i, o) {
                return o
                  ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
                    fu(i, o, this._oneTimeListeners),
                    this)
                  : new Promise((l) => this.once(i, l));
              }
              fire(i, o) {
                "string" == typeof i && (i = new Ra(i, o || {}));
                const l = i.type;
                if (this.listens(l)) {
                  i.target = this;
                  const h =
                    this._listeners && this._listeners[l]
                      ? this._listeners[l].slice()
                      : [];
                  for (const x of h) x.call(this, i);
                  const m =
                    this._oneTimeListeners && this._oneTimeListeners[l]
                      ? this._oneTimeListeners[l].slice()
                      : [];
                  for (const x of m)
                    mu(l, x, this._oneTimeListeners), x.call(this, i);
                  const _ = this._eventedParent;
                  _ &&
                    (pi(
                      i,
                      "function" == typeof this._eventedParentData
                        ? this._eventedParentData()
                        : this._eventedParentData
                    ),
                    _.fire(i));
                } else i instanceof us && console.error(i.error);
                return this;
              }
              listens(i) {
                return !!(
                  (this._listeners &&
                    this._listeners[i] &&
                    this._listeners[i].length > 0) ||
                  (this._oneTimeListeners &&
                    this._oneTimeListeners[i] &&
                    this._oneTimeListeners[i].length > 0) ||
                  (this._eventedParent && this._eventedParent.listens(i))
                );
              }
              setEventedParent(i, o) {
                return (
                  (this._eventedParent = i), (this._eventedParentData = o), this
                );
              }
            }
            var Ae = JSON.parse(
              '{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}'
            );
            function Vo(r, ...i) {
              for (const o of i) for (const l in o) r[l] = o[l];
              return r;
            }
            function mi(r) {
              return r instanceof Number ||
                r instanceof String ||
                r instanceof Boolean
                ? r.valueOf()
                : r;
            }
            function Bi(r) {
              if (Array.isArray(r)) return r.map(Bi);
              if (
                r instanceof Object &&
                !(
                  r instanceof Number ||
                  r instanceof String ||
                  r instanceof Boolean
                )
              ) {
                const i = {};
                for (const o in r) i[o] = Bi(r[o]);
                return i;
              }
              return mi(r);
            }
            class sp extends Error {
              constructor(i, o) {
                super(o), (this.message = o), (this.key = i);
              }
            }
            var jo = sp;
            class Mh {
              constructor(i, o = []) {
                (this.parent = i), (this.bindings = {});
                for (const [l, h] of o) this.bindings[l] = h;
              }
              concat(i) {
                return new Mh(this, i);
              }
              get(i) {
                if (this.bindings[i]) return this.bindings[i];
                if (this.parent) return this.parent.get(i);
                throw new Error(`${i} not found in scope.`);
              }
              has(i) {
                return (
                  !!this.bindings[i] || (!!this.parent && this.parent.has(i))
                );
              }
            }
            var gu = Mh;
            const Dn = { kind: "null" },
              ot = { kind: "number" },
              xt = { kind: "string" },
              $t = { kind: "boolean" },
              Hr = { kind: "color" },
              Pr = { kind: "object" },
              it = { kind: "value" },
              _r = { kind: "collator" },
              _u = { kind: "formatted" },
              st = { kind: "resolvedImage" };
            function yr(r, i) {
              return { kind: "array", itemType: r, N: i };
            }
            function gt(r) {
              if ("array" === r.kind) {
                const i = gt(r.itemType);
                return "number" == typeof r.N
                  ? `array<${i}, ${r.N}>`
                  : "value" === r.itemType.kind
                  ? "array"
                  : `array<${i}>`;
              }
              return r.kind;
            }
            const Cn = [Dn, ot, xt, $t, Hr, _u, Pr, yr(it), st];
            function hs(r, i) {
              if ("error" === i.kind) return null;
              if ("array" === r.kind) {
                if (
                  "array" === i.kind &&
                  ((0 === i.N && "value" === i.itemType.kind) ||
                    !hs(r.itemType, i.itemType)) &&
                  ("number" != typeof r.N || r.N === i.N)
                )
                  return null;
              } else {
                if (r.kind === i.kind) return null;
                if ("value" === r.kind)
                  for (const o of Cn) if (!hs(o, i)) return null;
              }
              return `Expected ${gt(r)} but found ${gt(i)} instead.`;
            }
            function yu(r, i) {
              return i.some((o) => o.kind === r.kind);
            }
            function fc(r, i) {
              return i.some((o) =>
                "null" === o
                  ? null === r
                  : "array" === o
                  ? Array.isArray(r)
                  : "object" === o
                  ? r && !Array.isArray(r) && "object" == typeof r
                  : o === typeof r
              );
            }
            var Dl,
              Lr = {
                transparent: [0, 0, 0, 0],
                aliceblue: [240, 248, 255, 1],
                antiquewhite: [250, 235, 215, 1],
                aqua: [0, 255, 255, 1],
                aquamarine: [127, 255, 212, 1],
                azure: [240, 255, 255, 1],
                beige: [245, 245, 220, 1],
                bisque: [255, 228, 196, 1],
                black: [0, 0, 0, 1],
                blanchedalmond: [255, 235, 205, 1],
                blue: [0, 0, 255, 1],
                blueviolet: [138, 43, 226, 1],
                brown: [165, 42, 42, 1],
                burlywood: [222, 184, 135, 1],
                cadetblue: [95, 158, 160, 1],
                chartreuse: [127, 255, 0, 1],
                chocolate: [210, 105, 30, 1],
                coral: [255, 127, 80, 1],
                cornflowerblue: [100, 149, 237, 1],
                cornsilk: [255, 248, 220, 1],
                crimson: [220, 20, 60, 1],
                cyan: [0, 255, 255, 1],
                darkblue: [0, 0, 139, 1],
                darkcyan: [0, 139, 139, 1],
                darkgoldenrod: [184, 134, 11, 1],
                darkgray: [169, 169, 169, 1],
                darkgreen: [0, 100, 0, 1],
                darkgrey: [169, 169, 169, 1],
                darkkhaki: [189, 183, 107, 1],
                darkmagenta: [139, 0, 139, 1],
                darkolivegreen: [85, 107, 47, 1],
                darkorange: [255, 140, 0, 1],
                darkorchid: [153, 50, 204, 1],
                darkred: [139, 0, 0, 1],
                darksalmon: [233, 150, 122, 1],
                darkseagreen: [143, 188, 143, 1],
                darkslateblue: [72, 61, 139, 1],
                darkslategray: [47, 79, 79, 1],
                darkslategrey: [47, 79, 79, 1],
                darkturquoise: [0, 206, 209, 1],
                darkviolet: [148, 0, 211, 1],
                deeppink: [255, 20, 147, 1],
                deepskyblue: [0, 191, 255, 1],
                dimgray: [105, 105, 105, 1],
                dimgrey: [105, 105, 105, 1],
                dodgerblue: [30, 144, 255, 1],
                firebrick: [178, 34, 34, 1],
                floralwhite: [255, 250, 240, 1],
                forestgreen: [34, 139, 34, 1],
                fuchsia: [255, 0, 255, 1],
                gainsboro: [220, 220, 220, 1],
                ghostwhite: [248, 248, 255, 1],
                gold: [255, 215, 0, 1],
                goldenrod: [218, 165, 32, 1],
                gray: [128, 128, 128, 1],
                green: [0, 128, 0, 1],
                greenyellow: [173, 255, 47, 1],
                grey: [128, 128, 128, 1],
                honeydew: [240, 255, 240, 1],
                hotpink: [255, 105, 180, 1],
                indianred: [205, 92, 92, 1],
                indigo: [75, 0, 130, 1],
                ivory: [255, 255, 240, 1],
                khaki: [240, 230, 140, 1],
                lavender: [230, 230, 250, 1],
                lavenderblush: [255, 240, 245, 1],
                lawngreen: [124, 252, 0, 1],
                lemonchiffon: [255, 250, 205, 1],
                lightblue: [173, 216, 230, 1],
                lightcoral: [240, 128, 128, 1],
                lightcyan: [224, 255, 255, 1],
                lightgoldenrodyellow: [250, 250, 210, 1],
                lightgray: [211, 211, 211, 1],
                lightgreen: [144, 238, 144, 1],
                lightgrey: [211, 211, 211, 1],
                lightpink: [255, 182, 193, 1],
                lightsalmon: [255, 160, 122, 1],
                lightseagreen: [32, 178, 170, 1],
                lightskyblue: [135, 206, 250, 1],
                lightslategray: [119, 136, 153, 1],
                lightslategrey: [119, 136, 153, 1],
                lightsteelblue: [176, 196, 222, 1],
                lightyellow: [255, 255, 224, 1],
                lime: [0, 255, 0, 1],
                limegreen: [50, 205, 50, 1],
                linen: [250, 240, 230, 1],
                magenta: [255, 0, 255, 1],
                maroon: [128, 0, 0, 1],
                mediumaquamarine: [102, 205, 170, 1],
                mediumblue: [0, 0, 205, 1],
                mediumorchid: [186, 85, 211, 1],
                mediumpurple: [147, 112, 219, 1],
                mediumseagreen: [60, 179, 113, 1],
                mediumslateblue: [123, 104, 238, 1],
                mediumspringgreen: [0, 250, 154, 1],
                mediumturquoise: [72, 209, 204, 1],
                mediumvioletred: [199, 21, 133, 1],
                midnightblue: [25, 25, 112, 1],
                mintcream: [245, 255, 250, 1],
                mistyrose: [255, 228, 225, 1],
                moccasin: [255, 228, 181, 1],
                navajowhite: [255, 222, 173, 1],
                navy: [0, 0, 128, 1],
                oldlace: [253, 245, 230, 1],
                olive: [128, 128, 0, 1],
                olivedrab: [107, 142, 35, 1],
                orange: [255, 165, 0, 1],
                orangered: [255, 69, 0, 1],
                orchid: [218, 112, 214, 1],
                palegoldenrod: [238, 232, 170, 1],
                palegreen: [152, 251, 152, 1],
                paleturquoise: [175, 238, 238, 1],
                palevioletred: [219, 112, 147, 1],
                papayawhip: [255, 239, 213, 1],
                peachpuff: [255, 218, 185, 1],
                peru: [205, 133, 63, 1],
                pink: [255, 192, 203, 1],
                plum: [221, 160, 221, 1],
                powderblue: [176, 224, 230, 1],
                purple: [128, 0, 128, 1],
                rebeccapurple: [102, 51, 153, 1],
                red: [255, 0, 0, 1],
                rosybrown: [188, 143, 143, 1],
                royalblue: [65, 105, 225, 1],
                saddlebrown: [139, 69, 19, 1],
                salmon: [250, 128, 114, 1],
                sandybrown: [244, 164, 96, 1],
                seagreen: [46, 139, 87, 1],
                seashell: [255, 245, 238, 1],
                sienna: [160, 82, 45, 1],
                silver: [192, 192, 192, 1],
                skyblue: [135, 206, 235, 1],
                slateblue: [106, 90, 205, 1],
                slategray: [112, 128, 144, 1],
                slategrey: [112, 128, 144, 1],
                snow: [255, 250, 250, 1],
                springgreen: [0, 255, 127, 1],
                steelblue: [70, 130, 180, 1],
                tan: [210, 180, 140, 1],
                teal: [0, 128, 128, 1],
                thistle: [216, 191, 216, 1],
                tomato: [255, 99, 71, 1],
                turquoise: [64, 224, 208, 1],
                violet: [238, 130, 238, 1],
                wheat: [245, 222, 179, 1],
                white: [255, 255, 255, 1],
                whitesmoke: [245, 245, 245, 1],
                yellow: [255, 255, 0, 1],
                yellowgreen: [154, 205, 50, 1],
              };
            function vu(r) {
              return (r = Math.round(r)) < 0 ? 0 : r > 255 ? 255 : r;
            }
            function mc(r) {
              return vu(
                "%" === r[r.length - 1]
                  ? (parseFloat(r) / 100) * 255
                  : parseInt(r)
              );
            }
            function Ah(r) {
              return (i =
                "%" === r[r.length - 1] ? parseFloat(r) / 100 : parseFloat(r)) <
                0
                ? 0
                : i > 1
                ? 1
                : i;
              var i;
            }
            function kr(r, i, o) {
              return (
                o < 0 ? (o += 1) : o > 1 && (o -= 1),
                6 * o < 1
                  ? r + (i - r) * o * 6
                  : 2 * o < 1
                  ? i
                  : 3 * o < 2
                  ? r + (i - r) * (2 / 3 - o) * 6
                  : r
              );
            }
            try {
              Dl = {}.parseCSSColor = function (r) {
                var i,
                  o = r.replace(/ /g, "").toLowerCase();
                if (o in Lr) return Lr[o].slice();
                if ("#" === o[0])
                  return 4 === o.length
                    ? (i = parseInt(o.substr(1), 16)) >= 0 && i <= 4095
                      ? [
                          ((3840 & i) >> 4) | ((3840 & i) >> 8),
                          (240 & i) | ((240 & i) >> 4),
                          (15 & i) | ((15 & i) << 4),
                          1,
                        ]
                      : null
                    : 7 === o.length &&
                      (i = parseInt(o.substr(1), 16)) >= 0 &&
                      i <= 16777215
                    ? [(16711680 & i) >> 16, (65280 & i) >> 8, 255 & i, 1]
                    : null;
                var l = o.indexOf("("),
                  h = o.indexOf(")");
                if (-1 !== l && h + 1 === o.length) {
                  var m = o.substr(0, l),
                    _ = o.substr(l + 1, h - (l + 1)).split(","),
                    x = 1;
                  switch (m) {
                    case "rgba":
                      if (4 !== _.length) return null;
                      x = Ah(_.pop());
                    case "rgb":
                      return 3 !== _.length
                        ? null
                        : [mc(_[0]), mc(_[1]), mc(_[2]), x];
                    case "hsla":
                      if (4 !== _.length) return null;
                      x = Ah(_.pop());
                    case "hsl":
                      if (3 !== _.length) return null;
                      var E = (((parseFloat(_[0]) % 360) + 360) % 360) / 360,
                        T = Ah(_[1]),
                        I = Ah(_[2]),
                        A = I <= 0.5 ? I * (T + 1) : I + T - I * T,
                        L = 2 * I - A;
                      return [
                        vu(255 * kr(L, A, E + 1 / 3)),
                        vu(255 * kr(L, A, E)),
                        vu(255 * kr(L, A, E - 1 / 3)),
                        x,
                      ];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch {}
            class Gr {
              constructor(i, o, l, h = 1) {
                (this.r = i), (this.g = o), (this.b = l), (this.a = h);
              }
              static parse(i) {
                if (!i) return;
                if (i instanceof Gr) return i;
                if ("string" != typeof i) return;
                const o = Dl(i);
                return o
                  ? new Gr(
                      (o[0] / 255) * o[3],
                      (o[1] / 255) * o[3],
                      (o[2] / 255) * o[3],
                      o[3]
                    )
                  : void 0;
              }
              toString() {
                const [i, o, l, h] = this.toArray();
                return `rgba(${Math.round(
                  i
                )},${Math.round(o)},${Math.round(l)},${h})`;
              }
              toArray() {
                const { r: i, g: o, b: l, a: h } = this;
                return 0 === h
                  ? [0, 0, 0, 0]
                  : [(255 * i) / h, (255 * o) / h, (255 * l) / h, h];
              }
              toArray01() {
                const { r: i, g: o, b: l, a: h } = this;
                return 0 === h ? [0, 0, 0, 0] : [i / h, o / h, l / h, h];
              }
              toArray01PremultipliedAlpha() {
                const { r: i, g: o, b: l, a: h } = this;
                return [i, o, l, h];
              }
            }
            (Gr.black = new Gr(0, 0, 0, 1)),
              (Gr.white = new Gr(1, 1, 1, 1)),
              (Gr.transparent = new Gr(0, 0, 0, 0)),
              (Gr.red = new Gr(1, 0, 0, 1)),
              (Gr.blue = new Gr(0, 0, 1, 1));
            var gi = Gr;
            class ap {
              constructor(i, o, l) {
                (this.sensitivity = i
                  ? o
                    ? "variant"
                    : "case"
                  : o
                  ? "accent"
                  : "base"),
                  (this.locale = l),
                  (this.collator = new Intl.Collator(
                    this.locale ? this.locale : [],
                    { sensitivity: this.sensitivity, usage: "search" }
                  ));
              }
              compare(i, o) {
                return this.collator.compare(i, o);
              }
              resolvedLocale() {
                return new Intl.Collator(
                  this.locale ? this.locale : []
                ).resolvedOptions().locale;
              }
            }
            class lp {
              constructor(i, o, l, h, m) {
                (this.text = i.normalize ? i.normalize() : i),
                  (this.image = o),
                  (this.scale = l),
                  (this.fontStack = h),
                  (this.textColor = m);
              }
            }
            class Rr {
              constructor(i) {
                this.sections = i;
              }
              static fromString(i) {
                return new Rr([new lp(i, null, null, null, null)]);
              }
              isEmpty() {
                return (
                  0 === this.sections.length ||
                  !this.sections.some(
                    (i) =>
                      0 !== i.text.length ||
                      (i.image && 0 !== i.image.name.length)
                  )
                );
              }
              static factory(i) {
                return i instanceof Rr ? i : Rr.fromString(i);
              }
              toString() {
                return 0 === this.sections.length
                  ? ""
                  : this.sections.map((i) => i.text).join("");
              }
              serialize() {
                const i = ["format"];
                for (const o of this.sections) {
                  if (o.image) {
                    i.push(["image", o.image.name]);
                    continue;
                  }
                  i.push(o.text);
                  const l = {};
                  o.fontStack &&
                    (l["text-font"] = ["literal", o.fontStack.split(",")]),
                    o.scale && (l["font-scale"] = o.scale),
                    o.textColor &&
                      (l["text-color"] = ["rgba"].concat(
                        o.textColor.toArray()
                      )),
                    i.push(l);
                }
                return i;
              }
            }
            class _o {
              constructor(i) {
                (this.name = i.name), (this.available = i.available);
              }
              toString() {
                return this.name;
              }
              static fromString(i) {
                return i ? new _o({ name: i, available: !1 }) : null;
              }
              serialize() {
                return ["image", this.name];
              }
            }
            function cp(r, i, o, l) {
              return "number" == typeof r &&
                r >= 0 &&
                r <= 255 &&
                "number" == typeof i &&
                i >= 0 &&
                i <= 255 &&
                "number" == typeof o &&
                o >= 0 &&
                o <= 255
                ? void 0 === l || ("number" == typeof l && l >= 0 && l <= 1)
                  ? null
                  : `Invalid rgba value [${[r, i, o, l].join(
                      ", "
                    )}]: 'a' must be between 0 and 1.`
                : `Invalid rgba value [${("number" == typeof l
                    ? [r, i, o, l]
                    : [r, i, o]
                  ).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
            }
            function xu(r) {
              if (
                null === r ||
                "string" == typeof r ||
                "boolean" == typeof r ||
                "number" == typeof r ||
                r instanceof gi ||
                r instanceof ap ||
                r instanceof Rr ||
                r instanceof _o
              )
                return !0;
              if (Array.isArray(r)) {
                for (const i of r) if (!xu(i)) return !1;
                return !0;
              }
              if ("object" == typeof r) {
                for (const i in r) if (!xu(r[i])) return !1;
                return !0;
              }
              return !1;
            }
            function pn(r) {
              if (null === r) return Dn;
              if ("string" == typeof r) return xt;
              if ("boolean" == typeof r) return $t;
              if ("number" == typeof r) return ot;
              if (r instanceof gi) return Hr;
              if (r instanceof ap) return _r;
              if (r instanceof Rr) return _u;
              if (r instanceof _o) return st;
              if (Array.isArray(r)) {
                const i = r.length;
                let o;
                for (const l of r) {
                  const h = pn(l);
                  if (o) {
                    if (o === h) continue;
                    o = it;
                    break;
                  }
                  o = h;
                }
                return yr(o || it, i);
              }
              return Pr;
            }
            function gn(r) {
              const i = typeof r;
              return null === r
                ? ""
                : "string" === i || "number" === i || "boolean" === i
                ? String(r)
                : r instanceof gi || r instanceof Rr || r instanceof _o
                ? r.toString()
                : JSON.stringify(r);
            }
            class up {
              constructor(i, o) {
                (this.type = i), (this.value = o);
              }
              static parse(i, o) {
                if (2 !== i.length)
                  return o.error(
                    `'literal' expression requires exactly one argument, but found ${
                      i.length - 1
                    } instead.`
                  );
                if (!xu(i[1])) return o.error("invalid value");
                const l = i[1];
                let h = pn(l);
                const m = o.expectedType;
                return (
                  "array" !== h.kind ||
                    0 !== h.N ||
                    !m ||
                    "array" !== m.kind ||
                    ("number" == typeof m.N && 0 !== m.N) ||
                    (h = m),
                  new up(h, l)
                );
              }
              evaluate() {
                return this.value;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return "array" === this.type.kind || "object" === this.type.kind
                  ? ["literal", this.value]
                  : this.value instanceof gi
                  ? ["rgba"].concat(this.value.toArray())
                  : this.value instanceof Rr
                  ? this.value.serialize()
                  : this.value;
              }
            }
            var Cl = up,
              or = class {
                constructor(r) {
                  (this.name = "ExpressionEvaluationError"), (this.message = r);
                }
                toJSON() {
                  return this.message;
                }
              };
            const Mn = { string: xt, number: ot, boolean: $t, object: Pr };
            class hp {
              constructor(i, o) {
                (this.type = i), (this.args = o);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expected at least one argument.");
                let l,
                  h = 1;
                const m = i[0];
                if ("array" === m) {
                  let x, E;
                  if (i.length > 2) {
                    const T = i[1];
                    if ("string" != typeof T || !(T in Mn) || "object" === T)
                      return o.error(
                        'The item type argument of "array" must be one of string, number, boolean',
                        1
                      );
                    (x = Mn[T]), h++;
                  } else x = it;
                  if (i.length > 3) {
                    if (
                      null !== i[2] &&
                      ("number" != typeof i[2] ||
                        i[2] < 0 ||
                        i[2] !== Math.floor(i[2]))
                    )
                      return o.error(
                        'The length argument to "array" must be a positive integer literal',
                        2
                      );
                    (E = i[2]), h++;
                  }
                  l = yr(x, E);
                } else l = Mn[m];
                const _ = [];
                for (; h < i.length; h++) {
                  const x = o.parse(i[h], h, it);
                  if (!x) return null;
                  _.push(x);
                }
                return new hp(l, _);
              }
              evaluate(i) {
                for (let o = 0; o < this.args.length; o++) {
                  const l = this.args[o].evaluate(i);
                  if (!hs(this.type, pn(l))) return l;
                  if (o === this.args.length - 1)
                    throw new or(
                      `Expected value to be of type ${gt(
                        this.type
                      )}, but found ${gt(pn(l))} instead.`
                    );
                }
                return null;
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return this.args.every((i) => i.outputDefined());
              }
              serialize() {
                const i = this.type,
                  o = [i.kind];
                if ("array" === i.kind) {
                  const l = i.itemType;
                  if (
                    "string" === l.kind ||
                    "number" === l.kind ||
                    "boolean" === l.kind
                  ) {
                    o.push(l.kind);
                    const h = i.N;
                    ("number" == typeof h || this.args.length > 1) && o.push(h);
                  }
                }
                return o.concat(this.args.map((l) => l.serialize()));
              }
            }
            var ii = hp;
            class yo {
              constructor(i) {
                (this.type = _u), (this.sections = i);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expected at least one argument.");
                const l = i[1];
                if (!Array.isArray(l) && "object" == typeof l)
                  return o.error(
                    "First argument must be an image or text section."
                  );
                const h = [];
                let m = !1;
                for (let _ = 1; _ <= i.length - 1; ++_) {
                  const x = i[_];
                  if (m && "object" == typeof x && !Array.isArray(x)) {
                    m = !1;
                    let E = null;
                    if (
                      x["font-scale"] &&
                      ((E = o.parse(x["font-scale"], 1, ot)), !E)
                    )
                      return null;
                    let T = null;
                    if (
                      x["text-font"] &&
                      ((T = o.parse(x["text-font"], 1, yr(xt))), !T)
                    )
                      return null;
                    let I = null;
                    if (
                      x["text-color"] &&
                      ((I = o.parse(x["text-color"], 1, Hr)), !I)
                    )
                      return null;
                    const A = h[h.length - 1];
                    (A.scale = E), (A.font = T), (A.textColor = I);
                  } else {
                    const E = o.parse(i[_], 1, it);
                    if (!E) return null;
                    const T = E.type.kind;
                    if (
                      "string" !== T &&
                      "value" !== T &&
                      "null" !== T &&
                      "resolvedImage" !== T
                    )
                      return o.error(
                        "Formatted text type must be 'string', 'value', 'image' or 'null'."
                      );
                    (m = !0),
                      h.push({
                        content: E,
                        scale: null,
                        font: null,
                        textColor: null,
                      });
                  }
                }
                return new yo(h);
              }
              evaluate(i) {
                return new Rr(
                  this.sections.map((o) => {
                    const l = o.content.evaluate(i);
                    return pn(l) === st
                      ? new lp("", l, null, null, null)
                      : new lp(
                          gn(l),
                          null,
                          o.scale ? o.scale.evaluate(i) : null,
                          o.font ? o.font.evaluate(i).join(",") : null,
                          o.textColor ? o.textColor.evaluate(i) : null
                        );
                  })
                );
              }
              eachChild(i) {
                for (const o of this.sections)
                  i(o.content),
                    o.scale && i(o.scale),
                    o.font && i(o.font),
                    o.textColor && i(o.textColor);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = ["format"];
                for (const o of this.sections) {
                  i.push(o.content.serialize());
                  const l = {};
                  o.scale && (l["font-scale"] = o.scale.serialize()),
                    o.font && (l["text-font"] = o.font.serialize()),
                    o.textColor && (l["text-color"] = o.textColor.serialize()),
                    i.push(l);
                }
                return i;
              }
            }
            class Ph {
              constructor(i) {
                (this.type = st), (this.input = i);
              }
              static parse(i, o) {
                if (2 !== i.length) return o.error("Expected two arguments.");
                const l = o.parse(i[1], 1, xt);
                return l ? new Ph(l) : o.error("No image name provided.");
              }
              evaluate(i) {
                const o = this.input.evaluate(i),
                  l = _o.fromString(o);
                return (
                  l &&
                    i.availableImages &&
                    (l.available = i.availableImages.indexOf(o) > -1),
                  l
                );
              }
              eachChild(i) {
                i(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["image", this.input.serialize()];
              }
            }
            const dp = {
              "to-boolean": $t,
              "to-color": Hr,
              "to-number": ot,
              "to-string": xt,
            };
            class Lh {
              constructor(i, o) {
                (this.type = i), (this.args = o);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expected at least one argument.");
                const l = i[0];
                if (("to-boolean" === l || "to-string" === l) && 2 !== i.length)
                  return o.error("Expected one argument.");
                const h = dp[l],
                  m = [];
                for (let _ = 1; _ < i.length; _++) {
                  const x = o.parse(i[_], _, it);
                  if (!x) return null;
                  m.push(x);
                }
                return new Lh(h, m);
              }
              evaluate(i) {
                if ("boolean" === this.type.kind)
                  return Boolean(this.args[0].evaluate(i));
                if ("color" === this.type.kind) {
                  let o, l;
                  for (const h of this.args) {
                    if (((o = h.evaluate(i)), (l = null), o instanceof gi))
                      return o;
                    if ("string" == typeof o) {
                      const m = i.parseColor(o);
                      if (m) return m;
                    } else if (
                      Array.isArray(o) &&
                      ((l =
                        o.length < 3 || o.length > 4
                          ? `Invalid rbga value ${JSON.stringify(
                              o
                            )}: expected an array containing either three or four numeric values.`
                          : cp(o[0], o[1], o[2], o[3])),
                      !l)
                    )
                      return new gi(o[0] / 255, o[1] / 255, o[2] / 255, o[3]);
                  }
                  throw new or(
                    l ||
                      `Could not parse color from value '${
                        "string" == typeof o ? o : String(JSON.stringify(o))
                      }'`
                  );
                }
                if ("number" === this.type.kind) {
                  let o = null;
                  for (const l of this.args) {
                    if (((o = l.evaluate(i)), null === o)) return 0;
                    const h = Number(o);
                    if (!isNaN(h)) return h;
                  }
                  throw new or(
                    `Could not convert ${JSON.stringify(o)} to number.`
                  );
                }
                return "formatted" === this.type.kind
                  ? Rr.fromString(gn(this.args[0].evaluate(i)))
                  : "resolvedImage" === this.type.kind
                  ? _o.fromString(gn(this.args[0].evaluate(i)))
                  : gn(this.args[0].evaluate(i));
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return this.args.every((i) => i.outputDefined());
              }
              serialize() {
                if ("formatted" === this.type.kind)
                  return new yo([
                    {
                      content: this.args[0],
                      scale: null,
                      font: null,
                      textColor: null,
                    },
                  ]).serialize();
                if ("resolvedImage" === this.type.kind)
                  return new Ph(this.args[0]).serialize();
                const i = [`to-${this.type.kind}`];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            var Sl = Lh;
            const vo = ["Unknown", "Point", "LineString", "Polygon"];
            var Il = class {
              constructor() {
                (this.globals = null),
                  (this.feature = null),
                  (this.featureState = null),
                  (this.formattedSection = null),
                  (this._parseColorCache = {}),
                  (this.availableImages = null),
                  (this.canonical = null),
                  (this.featureTileCoord = null),
                  (this.featureDistanceData = null);
              }
              id() {
                return this.feature && void 0 !== this.feature.id
                  ? this.feature.id
                  : null;
              }
              geometryType() {
                return this.feature
                  ? "number" == typeof this.feature.type
                    ? vo[this.feature.type]
                    : this.feature.type
                  : null;
              }
              geometry() {
                return this.feature && "geometry" in this.feature
                  ? this.feature.geometry
                  : null;
              }
              canonicalID() {
                return this.canonical;
              }
              properties() {
                return (this.feature && this.feature.properties) || {};
              }
              distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                  const r = this.featureDistanceData.center,
                    i = this.featureDistanceData.scale,
                    { x: o, y: l } = this.featureTileCoord;
                  return (
                    this.featureDistanceData.bearing[0] * (o * i - r[0]) +
                    this.featureDistanceData.bearing[1] * (l * i - r[1])
                  );
                }
                return 0;
              }
              parseColor(r) {
                let i = this._parseColorCache[r];
                return i || (i = this._parseColorCache[r] = gi.parse(r)), i;
              }
            };
            class ds {
              constructor(i, o, l, h) {
                (this.name = i),
                  (this.type = o),
                  (this._evaluate = l),
                  (this.args = h);
              }
              evaluate(i) {
                return this._evaluate(i, this.args);
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return [this.name].concat(this.args.map((i) => i.serialize()));
              }
              static parse(i, o) {
                const l = i[0],
                  h = ds.definitions[l];
                if (!h)
                  return o.error(
                    `Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                const m = Array.isArray(h) ? h[0] : h.type,
                  _ = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads,
                  x = _.filter(
                    ([T]) => !Array.isArray(T) || T.length === i.length - 1
                  );
                let E = null;
                for (const [T, I] of x) {
                  E = new Oh(o.registry, o.path, null, o.scope);
                  const A = [];
                  let L = !1;
                  for (let O = 1; O < i.length; O++) {
                    const F = i[O],
                      V = Array.isArray(T) ? T[O - 1] : T.type,
                      G = E.parse(F, 1 + A.length, V);
                    if (!G) {
                      L = !0;
                      break;
                    }
                    A.push(G);
                  }
                  if (!L)
                    if (Array.isArray(T) && T.length !== A.length)
                      E.error(
                        `Expected ${T.length} arguments, but found ${A.length} instead.`
                      );
                    else {
                      for (let O = 0; O < A.length; O++) {
                        const F = Array.isArray(T) ? T[O] : T.type,
                          V = A[O];
                        E.concat(O + 1).checkSubtype(F, V.type);
                      }
                      if (0 === E.errors.length) return new ds(l, m, I, A);
                    }
                }
                if (1 === x.length) o.errors.push(...E.errors);
                else {
                  const T = (x.length ? x : _)
                      .map(([A]) => {
                        return (
                          (L = A),
                          Array.isArray(L)
                            ? `(${L.map(gt).join(", ")})`
                            : `(${gt(L.type)}...)`
                        );
                        var L;
                      })
                      .join(" | "),
                    I = [];
                  for (let A = 1; A < i.length; A++) {
                    const L = o.parse(i[A], 1 + I.length);
                    if (!L) return null;
                    I.push(gt(L.type));
                  }
                  o.error(
                    `Expected arguments of type ${T}, but found (${I.join(
                      ", "
                    )}) instead.`
                  );
                }
                return null;
              }
              static register(i, o) {
                ds.definitions = o;
                for (const l in o) i[l] = ds;
              }
            }
            var Uo = ds;
            class gc {
              constructor(i, o, l) {
                (this.type = _r),
                  (this.locale = l),
                  (this.caseSensitive = i),
                  (this.diacriticSensitive = o);
              }
              static parse(i, o) {
                if (2 !== i.length) return o.error("Expected one argument.");
                const l = i[1];
                if ("object" != typeof l || Array.isArray(l))
                  return o.error(
                    "Collator options argument must be an object."
                  );
                const h = o.parse(
                  void 0 !== l["case-sensitive"] && l["case-sensitive"],
                  1,
                  $t
                );
                if (!h) return null;
                const m = o.parse(
                  void 0 !== l["diacritic-sensitive"] &&
                    l["diacritic-sensitive"],
                  1,
                  $t
                );
                if (!m) return null;
                let _ = null;
                return l.locale && ((_ = o.parse(l.locale, 1, xt)), !_)
                  ? null
                  : new gc(h, m, _);
              }
              evaluate(i) {
                return new ap(
                  this.caseSensitive.evaluate(i),
                  this.diacriticSensitive.evaluate(i),
                  this.locale ? this.locale.evaluate(i) : null
                );
              }
              eachChild(i) {
                i(this.caseSensitive),
                  i(this.diacriticSensitive),
                  this.locale && i(this.locale);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = {};
                return (
                  (i["case-sensitive"] = this.caseSensitive.serialize()),
                  (i["diacritic-sensitive"] =
                    this.diacriticSensitive.serialize()),
                  this.locale && (i.locale = this.locale.serialize()),
                  ["collator", i]
                );
              }
            }
            const St = 8192;
            function Ml(r, i) {
              (r[0] = Math.min(r[0], i[0])),
                (r[1] = Math.min(r[1], i[1])),
                (r[2] = Math.max(r[2], i[0])),
                (r[3] = Math.max(r[3], i[1]));
            }
            function Al(r, i) {
              return !(
                r[0] <= i[0] ||
                r[2] >= i[2] ||
                r[1] <= i[1] ||
                r[3] >= i[3]
              );
            }
            function sr(r, i) {
              const o = (180 + r[0]) / 360,
                l =
                  (180 -
                    (180 / Math.PI) *
                      Math.log(
                        Math.tan(Math.PI / 4 + (r[1] * Math.PI) / 360)
                      )) /
                  360,
                h = Math.pow(2, i.z);
              return [Math.round(o * h * St), Math.round(l * h * St)];
            }
            function kh(r, i, o) {
              const l = r[0] - i[0],
                h = r[1] - i[1],
                m = r[0] - o[0],
                _ = r[1] - o[1];
              return l * _ - m * h == 0 && l * m <= 0 && h * _ <= 0;
            }
            function Rh(r, i) {
              let o = !1;
              for (let _ = 0, x = i.length; _ < x; _++) {
                const E = i[_];
                for (let T = 0, I = E.length; T < I - 1; T++) {
                  if (kh(r, E[T], E[T + 1])) return !1;
                  (h = E[T])[1] > (l = r)[1] != (m = E[T + 1])[1] > l[1] &&
                    l[0] <
                      ((m[0] - h[0]) * (l[1] - h[1])) / (m[1] - h[1]) + h[0] &&
                    (o = !o);
                }
              }
              var l, h, m;
              return o;
            }
            function $o(r, i) {
              for (let o = 0; o < i.length; o++) if (Rh(r, i[o])) return !0;
              return !1;
            }
            function qr(r, i, o, l) {
              const h = l[0] - o[0],
                m = l[1] - o[1],
                _ = (r[0] - o[0]) * m - h * (r[1] - o[1]),
                x = (i[0] - o[0]) * m - h * (i[1] - o[1]);
              return (_ > 0 && x < 0) || (_ < 0 && x > 0);
            }
            function _c(r, i, o) {
              for (const T of o)
                for (let I = 0; I < T.length - 1; ++I)
                  if (
                    (x = [(_ = T[I + 1])[0] - (m = T[I])[0], _[1] - m[1]])[0] *
                      (E = [(h = i)[0] - (l = r)[0], h[1] - l[1]])[1] -
                      x[1] * E[0] !=
                      0 &&
                    qr(l, h, m, _) &&
                    qr(m, _, l, h)
                  )
                    return !0;
              var l, h, m, _, x, E;
              return !1;
            }
            function bn(r, i) {
              for (let o = 0; o < r.length; ++o) if (!Rh(r[o], i)) return !1;
              for (let o = 0; o < r.length - 1; ++o)
                if (_c(r[o], r[o + 1], i)) return !1;
              return !0;
            }
            function xo(r, i) {
              for (let o = 0; o < i.length; o++) if (bn(r, i[o])) return !0;
              return !1;
            }
            function $n(r, i, o) {
              const l = [];
              for (let h = 0; h < r.length; h++) {
                const m = [];
                for (let _ = 0; _ < r[h].length; _++) {
                  const x = sr(r[h][_], o);
                  Ml(i, x), m.push(x);
                }
                l.push(m);
              }
              return l;
            }
            function kf(r, i, o) {
              const l = [];
              for (let h = 0; h < r.length; h++) {
                const m = $n(r[h], i, o);
                l.push(m);
              }
              return l;
            }
            function pp(r, i, o, l) {
              if (r[0] < o[0] || r[0] > o[2]) {
                const h = 0.5 * l;
                let m = r[0] - o[0] > h ? -l : o[0] - r[0] > h ? l : 0;
                0 === m && (m = r[0] - o[2] > h ? -l : o[2] - r[0] > h ? l : 0),
                  (r[0] += m);
              }
              Ml(i, r);
            }
            function Oa(r, i, o, l) {
              const h = Math.pow(2, l.z) * St,
                m = [l.x * St, l.y * St],
                _ = [];
              if (!r) return _;
              for (const x of r)
                for (const E of x) {
                  const T = [E.x + m[0], E.y + m[1]];
                  pp(T, i, o, h), _.push(T);
                }
              return _;
            }
            function wn(r, i, o, l) {
              const h = Math.pow(2, l.z) * St,
                m = [l.x * St, l.y * St],
                _ = [];
              if (!r) return _;
              for (const E of r) {
                const T = [];
                for (const I of E) {
                  const A = [I.x + m[0], I.y + m[1]];
                  Ml(i, A), T.push(A);
                }
                _.push(T);
              }
              if (i[2] - i[0] <= h / 2) {
                ((x = i)[0] = x[1] = 1 / 0), (x[2] = x[3] = -1 / 0);
                for (const E of _) for (const T of E) pp(T, i, o, h);
              }
              var x;
              return _;
            }
            class ps {
              constructor(i, o) {
                (this.type = $t), (this.geojson = i), (this.geometries = o);
              }
              static parse(i, o) {
                if (2 !== i.length)
                  return o.error(
                    `'within' expression requires exactly one argument, but found ${
                      i.length - 1
                    } instead.`
                  );
                if (xu(i[1])) {
                  const l = i[1];
                  if ("FeatureCollection" === l.type)
                    for (let h = 0; h < l.features.length; ++h) {
                      const m = l.features[h].geometry.type;
                      if ("Polygon" === m || "MultiPolygon" === m)
                        return new ps(l, l.features[h].geometry);
                    }
                  else if ("Feature" === l.type) {
                    const h = l.geometry.type;
                    if ("Polygon" === h || "MultiPolygon" === h)
                      return new ps(l, l.geometry);
                  } else if ("Polygon" === l.type || "MultiPolygon" === l.type)
                    return new ps(l, l);
                }
                return o.error(
                  "'within' expression requires valid geojson object that contains polygon geometry type."
                );
              }
              evaluate(i) {
                if (null != i.geometry() && null != i.canonicalID()) {
                  if ("Point" === i.geometryType())
                    return (function (o, l) {
                      const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        m = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        _ = o.canonicalID();
                      if (!_) return !1;
                      if ("Polygon" === l.type) {
                        const x = $n(l.coordinates, m, _),
                          E = Oa(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!Rh(T, x)) return !1;
                      }
                      if ("MultiPolygon" === l.type) {
                        const x = kf(l.coordinates, m, _),
                          E = Oa(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!$o(T, x)) return !1;
                      }
                      return !0;
                    })(i, this.geometries);
                  if ("LineString" === i.geometryType())
                    return (function (o, l) {
                      const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        m = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        _ = o.canonicalID();
                      if (!_) return !1;
                      if ("Polygon" === l.type) {
                        const x = $n(l.coordinates, m, _),
                          E = wn(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!bn(T, x)) return !1;
                      }
                      if ("MultiPolygon" === l.type) {
                        const x = kf(l.coordinates, m, _),
                          E = wn(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!xo(T, x)) return !1;
                      }
                      return !0;
                    })(i, this.geometries);
                }
                return !1;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return ["within", this.geojson];
              }
            }
            var Pl = ps;
            function Us(r) {
              if (
                (r instanceof Uo &&
                  (("get" === r.name && 1 === r.args.length) ||
                    "feature-state" === r.name ||
                    ("has" === r.name && 1 === r.args.length) ||
                    "properties" === r.name ||
                    "geometry-type" === r.name ||
                    "id" === r.name ||
                    /^filter-/.test(r.name))) ||
                r instanceof Pl
              )
                return !1;
              let i = !0;
              return (
                r.eachChild((o) => {
                  i && !Us(o) && (i = !1);
                }),
                i
              );
            }
            function Ho(r) {
              if (r instanceof Uo && "feature-state" === r.name) return !1;
              let i = !0;
              return (
                r.eachChild((o) => {
                  i && !Ho(o) && (i = !1);
                }),
                i
              );
            }
            function vr(r, i) {
              if (r instanceof Uo && i.indexOf(r.name) >= 0) return !1;
              let o = !0;
              return (
                r.eachChild((l) => {
                  o && !vr(l, i) && (o = !1);
                }),
                o
              );
            }
            class $s {
              constructor(i, o) {
                (this.type = o.type),
                  (this.name = i),
                  (this.boundExpression = o);
              }
              static parse(i, o) {
                if (2 !== i.length || "string" != typeof i[1])
                  return o.error(
                    "'var' expression requires exactly one string literal argument."
                  );
                const l = i[1];
                return o.scope.has(l)
                  ? new $s(l, o.scope.get(l))
                  : o.error(
                      `Unknown variable "${l}". Make sure "${l}" has been bound in an enclosing "let" expression before using it.`,
                      1
                    );
              }
              evaluate(i) {
                return this.boundExpression.evaluate(i);
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["var", this.name];
              }
            }
            var fp = $s;
            class Yi {
              constructor(i, o = [], l, h = new gu(), m = []) {
                (this.registry = i),
                  (this.path = o),
                  (this.key = o.map((_) => `[${_}]`).join("")),
                  (this.scope = h),
                  (this.errors = m),
                  (this.expectedType = l);
              }
              parse(i, o, l, h, m = {}) {
                return o
                  ? this.concat(o, l, h)._parse(i, m)
                  : this._parse(i, m);
              }
              _parse(i, o) {
                function l(h, m, _) {
                  return "assert" === _
                    ? new ii(m, [h])
                    : "coerce" === _
                    ? new Sl(m, [h])
                    : h;
                }
                if (
                  ((null !== i &&
                    "string" != typeof i &&
                    "boolean" != typeof i &&
                    "number" != typeof i) ||
                    (i = ["literal", i]),
                  Array.isArray(i))
                ) {
                  if (0 === i.length)
                    return this.error(
                      'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'
                    );
                  const h = i[0];
                  if ("string" != typeof h)
                    return (
                      this.error(
                        `Expression name must be a string, but found ${typeof h} instead. If you wanted a literal array, use ["literal", [...]].`,
                        0
                      ),
                      null
                    );
                  const m = this.registry[h];
                  if (m) {
                    let _ = m.parse(i, this);
                    if (!_) return null;
                    if (this.expectedType) {
                      const x = this.expectedType,
                        E = _.type;
                      if (
                        ("string" !== x.kind &&
                          "number" !== x.kind &&
                          "boolean" !== x.kind &&
                          "object" !== x.kind &&
                          "array" !== x.kind) ||
                        "value" !== E.kind
                      )
                        if (
                          ("color" !== x.kind &&
                            "formatted" !== x.kind &&
                            "resolvedImage" !== x.kind) ||
                          ("value" !== E.kind && "string" !== E.kind)
                        ) {
                          if (this.checkSubtype(x, E)) return null;
                        } else _ = l(_, x, o.typeAnnotation || "coerce");
                      else _ = l(_, x, o.typeAnnotation || "assert");
                    }
                    if (
                      !(_ instanceof Cl) &&
                      "resolvedImage" !== _.type.kind &&
                      bu(_)
                    ) {
                      const x = new Il();
                      try {
                        _ = new Cl(_.type, _.evaluate(x));
                      } catch (E) {
                        return this.error(E.message), null;
                      }
                    }
                    return _;
                  }
                  return this.error(
                    `Unknown expression "${h}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                }
                return this.error(
                  void 0 === i
                    ? "'undefined' value invalid. Use null instead."
                    : "object" == typeof i
                    ? 'Bare objects invalid. Use ["literal", {...}] instead.'
                    : `Expected an array, but found ${typeof i} instead.`
                );
              }
              concat(i, o, l) {
                const h =
                    "number" == typeof i ? this.path.concat(i) : this.path,
                  m = l ? this.scope.concat(l) : this.scope;
                return new Yi(this.registry, h, o || null, m, this.errors);
              }
              error(i, ...o) {
                const l = `${this.key}${o.map((h) => `[${h}]`).join("")}`;
                this.errors.push(new jo(l, i));
              }
              checkSubtype(i, o) {
                const l = hs(i, o);
                return l && this.error(l), l;
              }
            }
            var Oh = Yi;
            function bu(r) {
              if (r instanceof fp) return bu(r.boundExpression);
              if (
                (r instanceof Uo && "error" === r.name) ||
                r instanceof gc ||
                r instanceof Pl
              )
                return !1;
              const i = r instanceof Sl || r instanceof ii;
              let o = !0;
              return (
                r.eachChild((l) => {
                  o = i ? o && bu(l) : o && l instanceof Cl;
                }),
                !!o &&
                  Us(r) &&
                  vr(r, [
                    "zoom",
                    "heatmap-density",
                    "line-progress",
                    "sky-radial-progress",
                    "accumulated",
                    "is-supported-script",
                    "pitch",
                    "distance-from-center",
                  ])
              );
            }
            function yc(r, i) {
              const o = r.length - 1;
              let l,
                h,
                m = 0,
                _ = o,
                x = 0;
              for (; m <= _; )
                if (
                  ((x = Math.floor((m + _) / 2)),
                  (l = r[x]),
                  (h = r[x + 1]),
                  l <= i)
                ) {
                  if (x === o || i < h) return x;
                  m = x + 1;
                } else {
                  if (!(l > i)) throw new or("Input is not a number.");
                  _ = x - 1;
                }
              return 0;
            }
            class ar {
              constructor(i, o, l) {
                (this.type = i),
                  (this.input = o),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [h, m] of l)
                  this.labels.push(h), this.outputs.push(m);
              }
              static parse(i, o) {
                if (i.length - 1 < 4)
                  return o.error(
                    `Expected at least 4 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if ((i.length - 1) % 2 != 0)
                  return o.error("Expected an even number of arguments.");
                const l = o.parse(i[1], 1, ot);
                if (!l) return null;
                const h = [];
                let m = null;
                o.expectedType &&
                  "value" !== o.expectedType.kind &&
                  (m = o.expectedType);
                for (let _ = 1; _ < i.length; _ += 2) {
                  const x = 1 === _ ? -1 / 0 : i[_],
                    E = i[_ + 1],
                    T = _,
                    I = _ + 1;
                  if ("number" != typeof x)
                    return o.error(
                      'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      T
                    );
                  if (h.length && h[h.length - 1][0] >= x)
                    return o.error(
                      'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                      T
                    );
                  const A = o.parse(E, I, m);
                  if (!A) return null;
                  (m = m || A.type), h.push([x, A]);
                }
                return new ar(m, l, h);
              }
              evaluate(i) {
                const o = this.labels,
                  l = this.outputs;
                if (1 === o.length) return l[0].evaluate(i);
                const h = this.input.evaluate(i);
                if (h <= o[0]) return l[0].evaluate(i);
                const m = o.length;
                return h >= o[m - 1]
                  ? l[m - 1].evaluate(i)
                  : l[yc(o, h)].evaluate(i);
              }
              eachChild(i) {
                i(this.input);
                for (const o of this.outputs) i(o);
              }
              outputDefined() {
                return this.outputs.every((i) => i.outputDefined());
              }
              serialize() {
                const i = ["step", this.input.serialize()];
                for (let o = 0; o < this.labels.length; o++)
                  o > 0 && i.push(this.labels[o]),
                    i.push(this.outputs[o].serialize());
                return i;
              }
            }
            var Fh = ar;
            function ln(r, i, o) {
              return r * (1 - o) + i * o;
            }
            var Pi = Object.freeze({
              __proto__: null,
              array: function (r, i, o) {
                return r.map((l, h) => ln(l, i[h], o));
              },
              color: function (r, i, o) {
                return new gi(
                  ln(r.r, i.r, o),
                  ln(r.g, i.g, o),
                  ln(r.b, i.b, o),
                  ln(r.a, i.a, o)
                );
              },
              number: ln,
            });
            const lr = 4 / 29,
              _i = 6 / 29,
              Fa = 3 * _i * _i,
              oo = Math.PI / 180,
              ft = 180 / Math.PI;
            function Xt(r) {
              return r > 0.008856451679035631
                ? Math.pow(r, 1 / 3)
                : r / Fa + lr;
            }
            function qn(r) {
              return r > _i ? r * r * r : Fa * (r - lr);
            }
            function br(r) {
              return (
                255 *
                (r <= 0.0031308
                  ? 12.92 * r
                  : 1.055 * Math.pow(r, 1 / 2.4) - 0.055)
              );
            }
            function Go(r) {
              return (r /= 255) <= 0.04045
                ? r / 12.92
                : Math.pow((r + 0.055) / 1.055, 2.4);
            }
            function Li(r) {
              const i = Go(r.r),
                o = Go(r.g),
                l = Go(r.b),
                h = Xt(
                  (0.4124564 * i + 0.3575761 * o + 0.1804375 * l) / 0.95047
                ),
                m = Xt((0.2126729 * i + 0.7151522 * o + 0.072175 * l) / 1);
              return {
                l: 116 * m - 16,
                a: 500 * (h - m),
                b:
                  200 *
                  (m -
                    Xt(
                      (0.0193339 * i + 0.119192 * o + 0.9503041 * l) / 1.08883
                    )),
                alpha: r.a,
              };
            }
            function Hs(r) {
              let i = (r.l + 16) / 116,
                o = isNaN(r.a) ? i : i + r.a / 500,
                l = isNaN(r.b) ? i : i - r.b / 200;
              return (
                (i = 1 * qn(i)),
                (o = 0.95047 * qn(o)),
                (l = 1.08883 * qn(l)),
                new gi(
                  br(3.2404542 * o - 1.5371385 * i - 0.4985314 * l),
                  br(-0.969266 * o + 1.8760108 * i + 0.041556 * l),
                  br(0.0556434 * o - 0.2040259 * i + 1.0572252 * l),
                  r.alpha
                )
              );
            }
            function ri(r, i, o) {
              const l = i - r;
              return (
                r +
                o * (l > 180 || l < -180 ? l - 360 * Math.round(l / 360) : l)
              );
            }
            const fs = {
                forward: Li,
                reverse: Hs,
                interpolate: function (r, i, o) {
                  return {
                    l: ln(r.l, i.l, o),
                    a: ln(r.a, i.a, o),
                    b: ln(r.b, i.b, o),
                    alpha: ln(r.alpha, i.alpha, o),
                  };
                },
              },
              qo = {
                forward: function (r) {
                  const { l: i, a: o, b: l } = Li(r),
                    h = Math.atan2(l, o) * ft;
                  return {
                    h: h < 0 ? h + 360 : h,
                    c: Math.sqrt(o * o + l * l),
                    l: i,
                    alpha: r.a,
                  };
                },
                reverse: function (r) {
                  const i = r.h * oo,
                    o = r.c;
                  return Hs({
                    l: r.l,
                    a: Math.cos(i) * o,
                    b: Math.sin(i) * o,
                    alpha: r.alpha,
                  });
                },
                interpolate: function (r, i, o) {
                  return {
                    h: ri(r.h, i.h, o),
                    c: ln(r.c, i.c, o),
                    l: ln(r.l, i.l, o),
                    alpha: ln(r.alpha, i.alpha, o),
                  };
                },
              };
            var Jt = Object.freeze({ __proto__: null, hcl: qo, lab: fs });
            class Gs {
              constructor(i, o, l, h, m) {
                (this.type = i),
                  (this.operator = o),
                  (this.interpolation = l),
                  (this.input = h),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [_, x] of m)
                  this.labels.push(_), this.outputs.push(x);
              }
              static interpolationFactor(i, o, l, h) {
                let m = 0;
                if ("exponential" === i.name) m = qs(o, i.base, l, h);
                else if ("linear" === i.name) m = qs(o, 1, l, h);
                else if ("cubic-bezier" === i.name) {
                  const _ = i.controlPoints;
                  m = new Ca(_[0], _[1], _[2], _[3]).solve(qs(o, 1, l, h));
                }
                return m;
              }
              static parse(i, o) {
                let [l, h, m, ..._] = i;
                if (!Array.isArray(h) || 0 === h.length)
                  return o.error(
                    "Expected an interpolation type expression.",
                    1
                  );
                if ("linear" === h[0]) h = { name: "linear" };
                else if ("exponential" === h[0]) {
                  const T = h[1];
                  if ("number" != typeof T)
                    return o.error(
                      "Exponential interpolation requires a numeric base.",
                      1,
                      1
                    );
                  h = { name: "exponential", base: T };
                } else {
                  if ("cubic-bezier" !== h[0])
                    return o.error(
                      `Unknown interpolation type ${String(h[0])}`,
                      1,
                      0
                    );
                  {
                    const T = h.slice(1);
                    if (
                      4 !== T.length ||
                      T.some((I) => "number" != typeof I || I < 0 || I > 1)
                    )
                      return o.error(
                        "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                        1
                      );
                    h = { name: "cubic-bezier", controlPoints: T };
                  }
                }
                if (i.length - 1 < 4)
                  return o.error(
                    `Expected at least 4 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if ((i.length - 1) % 2 != 0)
                  return o.error("Expected an even number of arguments.");
                if (((m = o.parse(m, 2, ot)), !m)) return null;
                const x = [];
                let E = null;
                "interpolate-hcl" === l || "interpolate-lab" === l
                  ? (E = Hr)
                  : o.expectedType &&
                    "value" !== o.expectedType.kind &&
                    (E = o.expectedType);
                for (let T = 0; T < _.length; T += 2) {
                  const I = _[T],
                    A = _[T + 1],
                    L = T + 3,
                    O = T + 4;
                  if ("number" != typeof I)
                    return o.error(
                      'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      L
                    );
                  if (x.length && x[x.length - 1][0] >= I)
                    return o.error(
                      'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                      L
                    );
                  const F = o.parse(A, O, E);
                  if (!F) return null;
                  (E = E || F.type), x.push([I, F]);
                }
                return "number" === E.kind ||
                  "color" === E.kind ||
                  ("array" === E.kind &&
                    "number" === E.itemType.kind &&
                    "number" == typeof E.N)
                  ? new Gs(E, l, h, m, x)
                  : o.error(`Type ${gt(E)} is not interpolatable.`);
              }
              evaluate(i) {
                const o = this.labels,
                  l = this.outputs;
                if (1 === o.length) return l[0].evaluate(i);
                const h = this.input.evaluate(i);
                if (h <= o[0]) return l[0].evaluate(i);
                const m = o.length;
                if (h >= o[m - 1]) return l[m - 1].evaluate(i);
                const _ = yc(o, h),
                  x = Gs.interpolationFactor(
                    this.interpolation,
                    h,
                    o[_],
                    o[_ + 1]
                  ),
                  E = l[_].evaluate(i),
                  T = l[_ + 1].evaluate(i);
                return "interpolate" === this.operator
                  ? Pi[this.type.kind.toLowerCase()](E, T, x)
                  : "interpolate-hcl" === this.operator
                  ? qo.reverse(qo.interpolate(qo.forward(E), qo.forward(T), x))
                  : fs.reverse(fs.interpolate(fs.forward(E), fs.forward(T), x));
              }
              eachChild(i) {
                i(this.input);
                for (const o of this.outputs) i(o);
              }
              outputDefined() {
                return this.outputs.every((i) => i.outputDefined());
              }
              serialize() {
                let i;
                i =
                  "linear" === this.interpolation.name
                    ? ["linear"]
                    : "exponential" === this.interpolation.name
                    ? 1 === this.interpolation.base
                      ? ["linear"]
                      : ["exponential", this.interpolation.base]
                    : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                const o = [this.operator, i, this.input.serialize()];
                for (let l = 0; l < this.labels.length; l++)
                  o.push(this.labels[l], this.outputs[l].serialize());
                return o;
              }
            }
            function qs(r, i, o, l) {
              const h = l - o,
                m = r - o;
              return 0 === h
                ? 0
                : 1 === i
                ? m / h
                : (Math.pow(i, m) - 1) / (Math.pow(i, h) - 1);
            }
            var so = Gs;
            class Wo {
              constructor(i, o) {
                (this.type = i), (this.args = o);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expectected at least one argument.");
                let l = null;
                const h = o.expectedType;
                h && "value" !== h.kind && (l = h);
                const m = [];
                for (const x of i.slice(1)) {
                  const E = o.parse(x, 1 + m.length, l, void 0, {
                    typeAnnotation: "omit",
                  });
                  if (!E) return null;
                  (l = l || E.type), m.push(E);
                }
                const _ = h && m.some((x) => hs(h, x.type));
                return new Wo(_ ? it : l, m);
              }
              evaluate(i) {
                let o,
                  l = null,
                  h = 0;
                for (const m of this.args) {
                  if (
                    (h++,
                    (l = m.evaluate(i)),
                    l &&
                      l instanceof _o &&
                      !l.available &&
                      (o || (o = l), (l = null), h === this.args.length))
                  )
                    return o;
                  if (null !== l) break;
                }
                return l;
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return this.args.every((i) => i.outputDefined());
              }
              serialize() {
                const i = ["coalesce"];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            var Vi = Wo;
            class Ws {
              constructor(i, o) {
                (this.type = o.type),
                  (this.bindings = [].concat(i)),
                  (this.result = o);
              }
              evaluate(i) {
                return this.result.evaluate(i);
              }
              eachChild(i) {
                for (const o of this.bindings) i(o[1]);
                i(this.result);
              }
              static parse(i, o) {
                if (i.length < 4)
                  return o.error(
                    `Expected at least 3 arguments, but found ${
                      i.length - 1
                    } instead.`
                  );
                const l = [];
                for (let m = 1; m < i.length - 1; m += 2) {
                  const _ = i[m];
                  if ("string" != typeof _)
                    return o.error(
                      `Expected string, but found ${typeof _} instead.`,
                      m
                    );
                  if (/[^a-zA-Z0-9_]/.test(_))
                    return o.error(
                      "Variable names must contain only alphanumeric characters or '_'.",
                      m
                    );
                  const x = o.parse(i[m + 1], m + 1);
                  if (!x) return null;
                  l.push([_, x]);
                }
                const h = o.parse(
                  i[i.length - 1],
                  i.length - 1,
                  o.expectedType,
                  l
                );
                return h ? new Ws(l, h) : null;
              }
              outputDefined() {
                return this.result.outputDefined();
              }
              serialize() {
                const i = ["let"];
                for (const [o, l] of this.bindings) i.push(o, l.serialize());
                return i.push(this.result.serialize()), i;
              }
            }
            var Na = Ws;
            class Zr {
              constructor(i, o, l) {
                (this.type = i), (this.index = o), (this.input = l);
              }
              static parse(i, o) {
                if (3 !== i.length)
                  return o.error(
                    `Expected 2 arguments, but found ${i.length - 1} instead.`
                  );
                const l = o.parse(i[1], 1, ot),
                  h = o.parse(i[2], 2, yr(o.expectedType || it));
                return l && h ? new Zr(h.type.itemType, l, h) : null;
              }
              evaluate(i) {
                const o = this.index.evaluate(i),
                  l = this.input.evaluate(i);
                if (o < 0) throw new or(`Array index out of bounds: ${o} < 0.`);
                if (o >= l.length)
                  throw new or(
                    `Array index out of bounds: ${o} > ${l.length - 1}.`
                  );
                if (o !== Math.floor(o))
                  throw new or(
                    `Array index must be an integer, but found ${o} instead.`
                  );
                return l[o];
              }
              eachChild(i) {
                i(this.index), i(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["at", this.index.serialize(), this.input.serialize()];
              }
            }
            var Ll = Zr;
            class wu {
              constructor(i, o) {
                (this.type = $t), (this.needle = i), (this.haystack = o);
              }
              static parse(i, o) {
                if (3 !== i.length)
                  return o.error(
                    `Expected 2 arguments, but found ${i.length - 1} instead.`
                  );
                const l = o.parse(i[1], 1, it),
                  h = o.parse(i[2], 2, it);
                return l && h
                  ? yu(l.type, [$t, xt, ot, Dn, it])
                    ? new wu(l, h)
                    : o.error(
                        `Expected first argument to be of type boolean, string, number or null, but found ${gt(
                          l.type
                        )} instead`
                      )
                  : null;
              }
              evaluate(i) {
                const o = this.needle.evaluate(i),
                  l = this.haystack.evaluate(i);
                if (null == l) return !1;
                if (!fc(o, ["boolean", "string", "number", "null"]))
                  throw new or(
                    `Expected first argument to be of type boolean, string, number or null, but found ${gt(
                      pn(o)
                    )} instead.`
                  );
                if (!fc(l, ["string", "array"]))
                  throw new or(
                    `Expected second argument to be of type array or string, but found ${gt(
                      pn(l)
                    )} instead.`
                  );
                return l.indexOf(o) >= 0;
              }
              eachChild(i) {
                i(this.needle), i(this.haystack);
              }
              outputDefined() {
                return !0;
              }
              serialize() {
                return [
                  "in",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            var Nn = wu;
            class vc {
              constructor(i, o, l) {
                (this.type = ot),
                  (this.needle = i),
                  (this.haystack = o),
                  (this.fromIndex = l);
              }
              static parse(i, o) {
                if (i.length <= 2 || i.length >= 5)
                  return o.error(
                    `Expected 3 or 4 arguments, but found ${
                      i.length - 1
                    } instead.`
                  );
                const l = o.parse(i[1], 1, it),
                  h = o.parse(i[2], 2, it);
                if (!l || !h) return null;
                if (!yu(l.type, [$t, xt, ot, Dn, it]))
                  return o.error(
                    `Expected first argument to be of type boolean, string, number or null, but found ${gt(
                      l.type
                    )} instead`
                  );
                if (4 === i.length) {
                  const m = o.parse(i[3], 3, ot);
                  return m ? new vc(l, h, m) : null;
                }
                return new vc(l, h);
              }
              evaluate(i) {
                const o = this.needle.evaluate(i),
                  l = this.haystack.evaluate(i);
                if (!fc(o, ["boolean", "string", "number", "null"]))
                  throw new or(
                    `Expected first argument to be of type boolean, string, number or null, but found ${gt(
                      pn(o)
                    )} instead.`
                  );
                if (!fc(l, ["string", "array"]))
                  throw new or(
                    `Expected second argument to be of type array or string, but found ${gt(
                      pn(l)
                    )} instead.`
                  );
                if (this.fromIndex) {
                  const h = this.fromIndex.evaluate(i);
                  return l.indexOf(o, h);
                }
                return l.indexOf(o);
              }
              eachChild(i) {
                i(this.needle),
                  i(this.haystack),
                  this.fromIndex && i(this.fromIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                  const i = this.fromIndex.serialize();
                  return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize(),
                    i,
                  ];
                }
                return [
                  "index-of",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            var mp = vc;
            class kl {
              constructor(i, o, l, h, m, _) {
                (this.inputType = i),
                  (this.type = o),
                  (this.input = l),
                  (this.cases = h),
                  (this.outputs = m),
                  (this.otherwise = _);
              }
              static parse(i, o) {
                if (i.length < 5)
                  return o.error(
                    `Expected at least 4 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if (i.length % 2 != 1)
                  return o.error("Expected an even number of arguments.");
                let l, h;
                o.expectedType &&
                  "value" !== o.expectedType.kind &&
                  (h = o.expectedType);
                const m = {},
                  _ = [];
                for (let T = 2; T < i.length - 1; T += 2) {
                  let I = i[T];
                  const A = i[T + 1];
                  Array.isArray(I) || (I = [I]);
                  const L = o.concat(T);
                  if (0 === I.length)
                    return L.error("Expected at least one branch label.");
                  for (const F of I) {
                    if ("number" != typeof F && "string" != typeof F)
                      return L.error(
                        "Branch labels must be numbers or strings."
                      );
                    if (
                      "number" == typeof F &&
                      Math.abs(F) > Number.MAX_SAFE_INTEGER
                    )
                      return L.error(
                        `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`
                      );
                    if ("number" == typeof F && Math.floor(F) !== F)
                      return L.error(
                        "Numeric branch labels must be integer values."
                      );
                    if (l) {
                      if (L.checkSubtype(l, pn(F))) return null;
                    } else l = pn(F);
                    if (void 0 !== m[String(F)])
                      return L.error("Branch labels must be unique.");
                    m[String(F)] = _.length;
                  }
                  const O = o.parse(A, T, h);
                  if (!O) return null;
                  (h = h || O.type), _.push(O);
                }
                const x = o.parse(i[1], 1, it);
                if (!x) return null;
                const E = o.parse(i[i.length - 1], i.length - 1, h);
                return E
                  ? "value" !== x.type.kind &&
                    o.concat(1).checkSubtype(l, x.type)
                    ? null
                    : new kl(l, h, x, m, _, E)
                  : null;
              }
              evaluate(i) {
                const o = this.input.evaluate(i);
                return (
                  (pn(o) === this.inputType && this.outputs[this.cases[o]]) ||
                  this.otherwise
                ).evaluate(i);
              }
              eachChild(i) {
                i(this.input), this.outputs.forEach(i), i(this.otherwise);
              }
              outputDefined() {
                return (
                  this.outputs.every((i) => i.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const i = ["match", this.input.serialize()],
                  o = Object.keys(this.cases).sort(),
                  l = [],
                  h = {};
                for (const _ of o) {
                  const x = h[this.cases[_]];
                  void 0 === x
                    ? ((h[this.cases[_]] = l.length),
                      l.push([this.cases[_], [_]]))
                    : l[x][1].push(_);
                }
                const m = (_) =>
                  "number" === this.inputType.kind ? Number(_) : _;
                for (const [_, x] of l)
                  i.push(1 === x.length ? m(x[0]) : x.map(m)),
                    i.push(this.outputs[_].serialize());
                return i.push(this.otherwise.serialize()), i;
              }
            }
            var Nh = kl;
            class za {
              constructor(i, o, l) {
                (this.type = i), (this.branches = o), (this.otherwise = l);
              }
              static parse(i, o) {
                if (i.length < 4)
                  return o.error(
                    `Expected at least 3 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if (i.length % 2 != 0)
                  return o.error("Expected an odd number of arguments.");
                let l;
                o.expectedType &&
                  "value" !== o.expectedType.kind &&
                  (l = o.expectedType);
                const h = [];
                for (let _ = 1; _ < i.length - 1; _ += 2) {
                  const x = o.parse(i[_], _, $t);
                  if (!x) return null;
                  const E = o.parse(i[_ + 1], _ + 1, l);
                  if (!E) return null;
                  h.push([x, E]), (l = l || E.type);
                }
                const m = o.parse(i[i.length - 1], i.length - 1, l);
                return m ? new za(l, h, m) : null;
              }
              evaluate(i) {
                for (const [o, l] of this.branches)
                  if (o.evaluate(i)) return l.evaluate(i);
                return this.otherwise.evaluate(i);
              }
              eachChild(i) {
                for (const [o, l] of this.branches) i(o), i(l);
                i(this.otherwise);
              }
              outputDefined() {
                return (
                  this.branches.every(([i, o]) => o.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const i = ["case"];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            var xc = za;
            class bo {
              constructor(i, o, l, h) {
                (this.type = i),
                  (this.input = o),
                  (this.beginIndex = l),
                  (this.endIndex = h);
              }
              static parse(i, o) {
                if (i.length <= 2 || i.length >= 5)
                  return o.error(
                    `Expected 3 or 4 arguments, but found ${
                      i.length - 1
                    } instead.`
                  );
                const l = o.parse(i[1], 1, it),
                  h = o.parse(i[2], 2, ot);
                if (!l || !h) return null;
                if (!yu(l.type, [yr(it), xt, it]))
                  return o.error(
                    `Expected first argument to be of type array or string, but found ${gt(
                      l.type
                    )} instead`
                  );
                if (4 === i.length) {
                  const m = o.parse(i[3], 3, ot);
                  return m ? new bo(l.type, l, h, m) : null;
                }
                return new bo(l.type, l, h);
              }
              evaluate(i) {
                const o = this.input.evaluate(i),
                  l = this.beginIndex.evaluate(i);
                if (!fc(o, ["string", "array"]))
                  throw new or(
                    `Expected first argument to be of type array or string, but found ${gt(
                      pn(o)
                    )} instead.`
                  );
                if (this.endIndex) {
                  const h = this.endIndex.evaluate(i);
                  return o.slice(l, h);
                }
                return o.slice(l);
              }
              eachChild(i) {
                i(this.input),
                  i(this.beginIndex),
                  this.endIndex && i(this.endIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                  const i = this.endIndex.serialize();
                  return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize(),
                    i,
                  ];
                }
                return [
                  "slice",
                  this.input.serialize(),
                  this.beginIndex.serialize(),
                ];
              }
            }
            var Qi = bo;
            function Eu(r, i) {
              return "==" === r || "!=" === r
                ? "boolean" === i.kind ||
                    "string" === i.kind ||
                    "number" === i.kind ||
                    "null" === i.kind ||
                    "value" === i.kind
                : "string" === i.kind ||
                    "number" === i.kind ||
                    "value" === i.kind;
            }
            function wr(r, i, o, l) {
              return 0 === l.compare(i, o);
            }
            function cr(r, i, o) {
              const l = "==" !== r && "!=" !== r;
              return class gD {
                constructor(m, _, x) {
                  (this.type = $t),
                    (this.lhs = m),
                    (this.rhs = _),
                    (this.collator = x),
                    (this.hasUntypedArgument =
                      "value" === m.type.kind || "value" === _.type.kind);
                }
                static parse(m, _) {
                  if (3 !== m.length && 4 !== m.length)
                    return _.error("Expected two or three arguments.");
                  const x = m[0];
                  let E = _.parse(m[1], 1, it);
                  if (!E) return null;
                  if (!Eu(x, E.type))
                    return _.concat(1).error(
                      `"${x}" comparisons are not supported for type '${gt(
                        E.type
                      )}'.`
                    );
                  let T = _.parse(m[2], 2, it);
                  if (!T) return null;
                  if (!Eu(x, T.type))
                    return _.concat(2).error(
                      `"${x}" comparisons are not supported for type '${gt(
                        T.type
                      )}'.`
                    );
                  if (
                    E.type.kind !== T.type.kind &&
                    "value" !== E.type.kind &&
                    "value" !== T.type.kind
                  )
                    return _.error(
                      `Cannot compare types '${gt(E.type)}' and '${gt(
                        T.type
                      )}'.`
                    );
                  l &&
                    ("value" === E.type.kind && "value" !== T.type.kind
                      ? (E = new ii(T.type, [E]))
                      : "value" !== E.type.kind &&
                        "value" === T.type.kind &&
                        (T = new ii(E.type, [T])));
                  let I = null;
                  if (4 === m.length) {
                    if (
                      "string" !== E.type.kind &&
                      "string" !== T.type.kind &&
                      "value" !== E.type.kind &&
                      "value" !== T.type.kind
                    )
                      return _.error(
                        "Cannot use collator to compare non-string types."
                      );
                    if (((I = _.parse(m[3], 3, _r)), !I)) return null;
                  }
                  return new gD(E, T, I);
                }
                evaluate(m) {
                  const _ = this.lhs.evaluate(m),
                    x = this.rhs.evaluate(m);
                  if (l && this.hasUntypedArgument) {
                    const E = pn(_),
                      T = pn(x);
                    if (
                      E.kind !== T.kind ||
                      ("string" !== E.kind && "number" !== E.kind)
                    )
                      throw new or(
                        `Expected arguments for "${r}" to be (string, string) or (number, number), but found (${E.kind}, ${T.kind}) instead.`
                      );
                  }
                  if (this.collator && !l && this.hasUntypedArgument) {
                    const E = pn(_),
                      T = pn(x);
                    if ("string" !== E.kind || "string" !== T.kind)
                      return i(m, _, x);
                  }
                  return this.collator
                    ? o(m, _, x, this.collator.evaluate(m))
                    : i(m, _, x);
                }
                eachChild(m) {
                  m(this.lhs), m(this.rhs), this.collator && m(this.collator);
                }
                outputDefined() {
                  return !0;
                }
                serialize() {
                  const m = [r];
                  return (
                    this.eachChild((_) => {
                      m.push(_.serialize());
                    }),
                    m
                  );
                }
              };
            }
            const zh = cr(
                "==",
                function (r, i, o) {
                  return i === o;
                },
                wr
              ),
              Tu = cr(
                "!=",
                function (r, i, o) {
                  return i !== o;
                },
                function (r, i, o, l) {
                  return !wr(0, i, o, l);
                }
              ),
              Du = cr(
                "<",
                function (r, i, o) {
                  return i < o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) < 0;
                }
              ),
              wo = cr(
                ">",
                function (r, i, o) {
                  return i > o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) > 0;
                }
              ),
              Rf = cr(
                "<=",
                function (r, i, o) {
                  return i <= o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) <= 0;
                }
              ),
              Of = cr(
                ">=",
                function (r, i, o) {
                  return i >= o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) >= 0;
                }
              );
            class Cu {
              constructor(i, o, l, h, m, _) {
                (this.type = xt),
                  (this.number = i),
                  (this.locale = o),
                  (this.currency = l),
                  (this.unit = h),
                  (this.minFractionDigits = m),
                  (this.maxFractionDigits = _);
              }
              static parse(i, o) {
                if (3 !== i.length) return o.error("Expected two arguments.");
                const l = o.parse(i[1], 1, ot);
                if (!l) return null;
                const h = i[2];
                if ("object" != typeof h || Array.isArray(h))
                  return o.error(
                    "NumberFormat options argument must be an object."
                  );
                let m = null;
                if (h.locale && ((m = o.parse(h.locale, 1, xt)), !m))
                  return null;
                let _ = null;
                if (h.currency && ((_ = o.parse(h.currency, 1, xt)), !_))
                  return null;
                let x = null;
                if (h.unit && ((x = o.parse(h.unit, 1, xt)), !x)) return null;
                let E = null;
                if (
                  h["min-fraction-digits"] &&
                  ((E = o.parse(h["min-fraction-digits"], 1, ot)), !E)
                )
                  return null;
                let T = null;
                return h["max-fraction-digits"] &&
                  ((T = o.parse(h["max-fraction-digits"], 1, ot)), !T)
                  ? null
                  : new Cu(l, m, _, x, E, T);
              }
              evaluate(i) {
                return new Intl.NumberFormat(
                  this.locale ? this.locale.evaluate(i) : [],
                  {
                    style:
                      (this.currency ? "currency" : this.unit && "unit") ||
                      "decimal",
                    currency: this.currency
                      ? this.currency.evaluate(i)
                      : void 0,
                    unit: this.unit ? this.unit.evaluate(i) : void 0,
                    minimumFractionDigits: this.minFractionDigits
                      ? this.minFractionDigits.evaluate(i)
                      : void 0,
                    maximumFractionDigits: this.maxFractionDigits
                      ? this.maxFractionDigits.evaluate(i)
                      : void 0,
                  }
                ).format(this.number.evaluate(i));
              }
              eachChild(i) {
                i(this.number),
                  this.locale && i(this.locale),
                  this.currency && i(this.currency),
                  this.unit && i(this.unit),
                  this.minFractionDigits && i(this.minFractionDigits),
                  this.maxFractionDigits && i(this.maxFractionDigits);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = {};
                return (
                  this.locale && (i.locale = this.locale.serialize()),
                  this.currency && (i.currency = this.currency.serialize()),
                  this.unit && (i.unit = this.unit.serialize()),
                  this.minFractionDigits &&
                    (i["min-fraction-digits"] =
                      this.minFractionDigits.serialize()),
                  this.maxFractionDigits &&
                    (i["max-fraction-digits"] =
                      this.maxFractionDigits.serialize()),
                  ["number-format", this.number.serialize(), i]
                );
              }
            }
            class Rl {
              constructor(i) {
                (this.type = ot), (this.input = i);
              }
              static parse(i, o) {
                if (2 !== i.length)
                  return o.error(
                    `Expected 1 argument, but found ${i.length - 1} instead.`
                  );
                const l = o.parse(i[1], 1);
                return l
                  ? "array" !== l.type.kind &&
                    "string" !== l.type.kind &&
                    "value" !== l.type.kind
                    ? o.error(
                        `Expected argument of type string or array, but found ${gt(
                          l.type
                        )} instead.`
                      )
                    : new Rl(l)
                  : null;
              }
              evaluate(i) {
                const o = this.input.evaluate(i);
                if ("string" == typeof o || Array.isArray(o)) return o.length;
                throw new or(
                  `Expected value to be of type string or array, but found ${gt(
                    pn(o)
                  )} instead.`
                );
              }
              eachChild(i) {
                i(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = ["length"];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            const Ff = {
              "==": zh,
              "!=": Tu,
              ">": wo,
              "<": Du,
              ">=": Of,
              "<=": Rf,
              array: ii,
              at: Ll,
              boolean: ii,
              case: xc,
              coalesce: Vi,
              collator: gc,
              format: yo,
              image: Ph,
              in: Nn,
              "index-of": mp,
              interpolate: so,
              "interpolate-hcl": so,
              "interpolate-lab": so,
              length: Rl,
              let: Na,
              literal: Cl,
              match: Nh,
              number: ii,
              "number-format": Cu,
              object: ii,
              slice: Qi,
              step: Fh,
              string: ii,
              "to-boolean": Sl,
              "to-color": Sl,
              "to-number": Sl,
              "to-string": Sl,
              var: fp,
              within: Pl,
            };
            function Nf(r, [i, o, l, h]) {
              (i = i.evaluate(r)), (o = o.evaluate(r)), (l = l.evaluate(r));
              const m = h ? h.evaluate(r) : 1,
                _ = cp(i, o, l, m);
              if (_) throw new or(_);
              return new gi((i / 255) * m, (o / 255) * m, (l / 255) * m, m);
            }
            function Zs(r, i) {
              return r in i;
            }
            function Bh(r, i) {
              const o = i[r];
              return void 0 === o ? null : o;
            }
            function Eo(r) {
              return { type: r };
            }
            Uo.register(Ff, {
              error: [
                { kind: "error" },
                [xt],
                (r, [i]) => {
                  throw new or(i.evaluate(r));
                },
              ],
              typeof: [xt, [it], (r, [i]) => gt(pn(i.evaluate(r)))],
              "to-rgba": [yr(ot, 4), [Hr], (r, [i]) => i.evaluate(r).toArray()],
              rgb: [Hr, [ot, ot, ot], Nf],
              rgba: [Hr, [ot, ot, ot, ot], Nf],
              has: {
                type: $t,
                overloads: [
                  [[xt], (r, [i]) => Zs(i.evaluate(r), r.properties())],
                  [[xt, Pr], (r, [i, o]) => Zs(i.evaluate(r), o.evaluate(r))],
                ],
              },
              get: {
                type: it,
                overloads: [
                  [[xt], (r, [i]) => Bh(i.evaluate(r), r.properties())],
                  [[xt, Pr], (r, [i, o]) => Bh(i.evaluate(r), o.evaluate(r))],
                ],
              },
              "feature-state": [
                it,
                [xt],
                (r, [i]) => Bh(i.evaluate(r), r.featureState || {}),
              ],
              properties: [Pr, [], (r) => r.properties()],
              "geometry-type": [xt, [], (r) => r.geometryType()],
              id: [it, [], (r) => r.id()],
              zoom: [ot, [], (r) => r.globals.zoom],
              pitch: [ot, [], (r) => r.globals.pitch || 0],
              "distance-from-center": [ot, [], (r) => r.distanceFromCenter()],
              "heatmap-density": [ot, [], (r) => r.globals.heatmapDensity || 0],
              "line-progress": [ot, [], (r) => r.globals.lineProgress || 0],
              "sky-radial-progress": [
                ot,
                [],
                (r) => r.globals.skyRadialProgress || 0,
              ],
              accumulated: [
                it,
                [],
                (r) =>
                  void 0 === r.globals.accumulated
                    ? null
                    : r.globals.accumulated,
              ],
              "+": [
                ot,
                Eo(ot),
                (r, i) => {
                  let o = 0;
                  for (const l of i) o += l.evaluate(r);
                  return o;
                },
              ],
              "*": [
                ot,
                Eo(ot),
                (r, i) => {
                  let o = 1;
                  for (const l of i) o *= l.evaluate(r);
                  return o;
                },
              ],
              "-": {
                type: ot,
                overloads: [
                  [[ot, ot], (r, [i, o]) => i.evaluate(r) - o.evaluate(r)],
                  [[ot], (r, [i]) => -i.evaluate(r)],
                ],
              },
              "/": [ot, [ot, ot], (r, [i, o]) => i.evaluate(r) / o.evaluate(r)],
              "%": [ot, [ot, ot], (r, [i, o]) => i.evaluate(r) % o.evaluate(r)],
              ln2: [ot, [], () => Math.LN2],
              pi: [ot, [], () => Math.PI],
              e: [ot, [], () => Math.E],
              "^": [
                ot,
                [ot, ot],
                (r, [i, o]) => Math.pow(i.evaluate(r), o.evaluate(r)),
              ],
              sqrt: [ot, [ot], (r, [i]) => Math.sqrt(i.evaluate(r))],
              log10: [
                ot,
                [ot],
                (r, [i]) => Math.log(i.evaluate(r)) / Math.LN10,
              ],
              ln: [ot, [ot], (r, [i]) => Math.log(i.evaluate(r))],
              log2: [ot, [ot], (r, [i]) => Math.log(i.evaluate(r)) / Math.LN2],
              sin: [ot, [ot], (r, [i]) => Math.sin(i.evaluate(r))],
              cos: [ot, [ot], (r, [i]) => Math.cos(i.evaluate(r))],
              tan: [ot, [ot], (r, [i]) => Math.tan(i.evaluate(r))],
              asin: [ot, [ot], (r, [i]) => Math.asin(i.evaluate(r))],
              acos: [ot, [ot], (r, [i]) => Math.acos(i.evaluate(r))],
              atan: [ot, [ot], (r, [i]) => Math.atan(i.evaluate(r))],
              min: [
                ot,
                Eo(ot),
                (r, i) => Math.min(...i.map((o) => o.evaluate(r))),
              ],
              max: [
                ot,
                Eo(ot),
                (r, i) => Math.max(...i.map((o) => o.evaluate(r))),
              ],
              abs: [ot, [ot], (r, [i]) => Math.abs(i.evaluate(r))],
              round: [
                ot,
                [ot],
                (r, [i]) => {
                  const o = i.evaluate(r);
                  return o < 0 ? -Math.round(-o) : Math.round(o);
                },
              ],
              floor: [ot, [ot], (r, [i]) => Math.floor(i.evaluate(r))],
              ceil: [ot, [ot], (r, [i]) => Math.ceil(i.evaluate(r))],
              "filter-==": [
                $t,
                [xt, it],
                (r, [i, o]) => r.properties()[i.value] === o.value,
              ],
              "filter-id-==": [$t, [it], (r, [i]) => r.id() === i.value],
              "filter-type-==": [
                $t,
                [xt],
                (r, [i]) => r.geometryType() === i.value,
              ],
              "filter-<": [
                $t,
                [xt, it],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l < h;
                },
              ],
              "filter-id-<": [
                $t,
                [it],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o < l;
                },
              ],
              "filter->": [
                $t,
                [xt, it],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l > h;
                },
              ],
              "filter-id->": [
                $t,
                [it],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o > l;
                },
              ],
              "filter-<=": [
                $t,
                [xt, it],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l <= h;
                },
              ],
              "filter-id-<=": [
                $t,
                [it],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o <= l;
                },
              ],
              "filter->=": [
                $t,
                [xt, it],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l >= h;
                },
              ],
              "filter-id->=": [
                $t,
                [it],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o >= l;
                },
              ],
              "filter-has": [$t, [it], (r, [i]) => i.value in r.properties()],
              "filter-has-id": [
                $t,
                [],
                (r) => null !== r.id() && void 0 !== r.id(),
              ],
              "filter-type-in": [
                $t,
                [yr(xt)],
                (r, [i]) => i.value.indexOf(r.geometryType()) >= 0,
              ],
              "filter-id-in": [
                $t,
                [yr(it)],
                (r, [i]) => i.value.indexOf(r.id()) >= 0,
              ],
              "filter-in-small": [
                $t,
                [xt, yr(it)],
                (r, [i, o]) => o.value.indexOf(r.properties()[i.value]) >= 0,
              ],
              "filter-in-large": [
                $t,
                [xt, yr(it)],
                (r, [i, o]) =>
                  (function (l, h, m, _) {
                    for (; m <= _; ) {
                      const x = (m + _) >> 1;
                      if (h[x] === l) return !0;
                      h[x] > l ? (_ = x - 1) : (m = x + 1);
                    }
                    return !1;
                  })(r.properties()[i.value], o.value, 0, o.value.length - 1),
              ],
              all: {
                type: $t,
                overloads: [
                  [[$t, $t], (r, [i, o]) => i.evaluate(r) && o.evaluate(r)],
                  [
                    Eo($t),
                    (r, i) => {
                      for (const o of i) if (!o.evaluate(r)) return !1;
                      return !0;
                    },
                  ],
                ],
              },
              any: {
                type: $t,
                overloads: [
                  [[$t, $t], (r, [i, o]) => i.evaluate(r) || o.evaluate(r)],
                  [
                    Eo($t),
                    (r, i) => {
                      for (const o of i) if (o.evaluate(r)) return !0;
                      return !1;
                    },
                  ],
                ],
              },
              "!": [$t, [$t], (r, [i]) => !i.evaluate(r)],
              "is-supported-script": [
                $t,
                [xt],
                (r, [i]) => {
                  const o = r.globals && r.globals.isSupportedScript;
                  return !o || o(i.evaluate(r));
                },
              ],
              upcase: [xt, [xt], (r, [i]) => i.evaluate(r).toUpperCase()],
              downcase: [xt, [xt], (r, [i]) => i.evaluate(r).toLowerCase()],
              concat: [
                xt,
                Eo(it),
                (r, i) => i.map((o) => gn(o.evaluate(r))).join(""),
              ],
              "resolved-locale": [
                xt,
                [_r],
                (r, [i]) => i.evaluate(r).resolvedLocale(),
              ],
            });
            var Su = Ff;
            function zf(r) {
              return { result: "success", value: r };
            }
            function Ol(r) {
              return { result: "error", value: r };
            }
            function bc(r) {
              return "data-driven" === r["property-type"];
            }
            function Vh(r) {
              return (
                !!r.expression && r.expression.parameters.indexOf("zoom") > -1
              );
            }
            function jh(r) {
              return !!r.expression && r.expression.interpolated;
            }
            function fn(r) {
              return r instanceof Number
                ? "number"
                : r instanceof String
                ? "string"
                : r instanceof Boolean
                ? "boolean"
                : Array.isArray(r)
                ? "array"
                : null === r
                ? "null"
                : typeof r;
            }
            function Iu(r) {
              return "object" == typeof r && null !== r && !Array.isArray(r);
            }
            function Bf(r) {
              return r;
            }
            function wc(r, i) {
              const o = "color" === i.type,
                l = r.stops && "object" == typeof r.stops[0][0],
                h = l || !(l || void 0 !== r.property),
                m = r.type || (jh(i) ? "exponential" : "interval");
              if (
                (o &&
                  ((r = Vo({}, r)).stops &&
                    (r.stops = r.stops.map((T) => [T[0], gi.parse(T[1])])),
                  (r.default = gi.parse(r.default ? r.default : i.default))),
                r.colorSpace && "rgb" !== r.colorSpace && !Jt[r.colorSpace])
              )
                throw new Error(`Unknown color space: ${r.colorSpace}`);
              let _, x, E;
              if ("exponential" === m) _ = Ks;
              else if ("interval" === m) _ = Uh;
              else if ("categorical" === m) {
                (_ = Vf), (x = Object.create(null));
                for (const T of r.stops) x[T[0]] = T[1];
                E = typeof r.stops[0][0];
              } else {
                if ("identity" !== m)
                  throw new Error(`Unknown function type "${m}"`);
                _ = Ys;
              }
              if (l) {
                const T = {},
                  I = [];
                for (let O = 0; O < r.stops.length; O++) {
                  const F = r.stops[O],
                    V = F[0].zoom;
                  void 0 === T[V] &&
                    ((T[V] = {
                      zoom: V,
                      type: r.type,
                      property: r.property,
                      default: r.default,
                      stops: [],
                    }),
                    I.push(V)),
                    T[V].stops.push([F[0].value, F[1]]);
                }
                const A = [];
                for (const O of I) A.push([T[O].zoom, wc(T[O], i)]);
                const L = { name: "linear" };
                return {
                  kind: "composite",
                  interpolationType: L,
                  interpolationFactor: so.interpolationFactor.bind(void 0, L),
                  zoomStops: A.map((O) => O[0]),
                  evaluate: ({ zoom: O }, F) =>
                    Ks({ stops: A, base: r.base }, i, O).evaluate(O, F),
                };
              }
              if (h) {
                const T =
                  "exponential" === m
                    ? {
                        name: "exponential",
                        base: void 0 !== r.base ? r.base : 1,
                      }
                    : null;
                return {
                  kind: "camera",
                  interpolationType: T,
                  interpolationFactor: so.interpolationFactor.bind(void 0, T),
                  zoomStops: r.stops.map((I) => I[0]),
                  evaluate: ({ zoom: I }) => _(r, i, I, x, E),
                };
              }
              return {
                kind: "source",
                evaluate(T, I) {
                  const A =
                    I && I.properties ? I.properties[r.property] : void 0;
                  return void 0 === A
                    ? Xs(r.default, i.default)
                    : _(r, i, A, x, E);
                },
              };
            }
            function Xs(r, i, o) {
              return void 0 !== r
                ? r
                : void 0 !== i
                ? i
                : void 0 !== o
                ? o
                : void 0;
            }
            function Vf(r, i, o, l, h) {
              return Xs(typeof o === h ? l[o] : void 0, r.default, i.default);
            }
            function Uh(r, i, o) {
              if ("number" !== fn(o)) return Xs(r.default, i.default);
              const l = r.stops.length;
              if (1 === l || o <= r.stops[0][0]) return r.stops[0][1];
              if (o >= r.stops[l - 1][0]) return r.stops[l - 1][1];
              const h = yc(
                r.stops.map((m) => m[0]),
                o
              );
              return r.stops[h][1];
            }
            function Ks(r, i, o) {
              const l = void 0 !== r.base ? r.base : 1;
              if ("number" !== fn(o)) return Xs(r.default, i.default);
              const h = r.stops.length;
              if (1 === h || o <= r.stops[0][0]) return r.stops[0][1];
              if (o >= r.stops[h - 1][0]) return r.stops[h - 1][1];
              const m = yc(
                  r.stops.map((I) => I[0]),
                  o
                ),
                _ = (function (I, A, L, O) {
                  const F = O - L,
                    V = I - L;
                  return 0 === F
                    ? 0
                    : 1 === A
                    ? V / F
                    : (Math.pow(A, V) - 1) / (Math.pow(A, F) - 1);
                })(o, l, r.stops[m][0], r.stops[m + 1][0]),
                x = r.stops[m][1],
                E = r.stops[m + 1][1];
              let T = Pi[i.type] || Bf;
              if (r.colorSpace && "rgb" !== r.colorSpace) {
                const I = Jt[r.colorSpace];
                T = (A, L) =>
                  I.reverse(I.interpolate(I.forward(A), I.forward(L), _));
              }
              return "function" == typeof x.evaluate
                ? {
                    evaluate(...I) {
                      const A = x.evaluate.apply(void 0, I),
                        L = E.evaluate.apply(void 0, I);
                      if (void 0 !== A && void 0 !== L) return T(A, L, _);
                    },
                  }
                : T(x, E, _);
            }
            function Ys(r, i, o) {
              return (
                "color" === i.type
                  ? (o = gi.parse(o))
                  : "formatted" === i.type
                  ? (o = Rr.fromString(o.toString()))
                  : "resolvedImage" === i.type
                  ? (o = _o.fromString(o.toString()))
                  : fn(o) === i.type ||
                    ("enum" === i.type && i.values[o]) ||
                    (o = void 0),
                Xs(o, r.default, i.default)
              );
            }
            class Mu {
              constructor(i, o) {
                var l;
                (this.expression = i),
                  (this._warningHistory = {}),
                  (this._evaluator = new Il()),
                  (this._defaultValue = o
                    ? "color" === (l = o).type &&
                      (Iu(l.default) || Array.isArray(l.default))
                      ? new gi(0, 0, 0, 0)
                      : "color" === l.type
                      ? gi.parse(l.default) || null
                      : void 0 === l.default
                      ? null
                      : l.default
                    : null),
                  (this._enumValues = o && "enum" === o.type ? o.values : null);
              }
              evaluateWithoutErrorHandling(i, o, l, h, m, _, x, E) {
                return (
                  (this._evaluator.globals = i),
                  (this._evaluator.feature = o),
                  (this._evaluator.featureState = l),
                  (this._evaluator.canonical = h || null),
                  (this._evaluator.availableImages = m || null),
                  (this._evaluator.formattedSection = _),
                  (this._evaluator.featureTileCoord = x || null),
                  (this._evaluator.featureDistanceData = E || null),
                  this.expression.evaluate(this._evaluator)
                );
              }
              evaluate(i, o, l, h, m, _, x, E) {
                (this._evaluator.globals = i),
                  (this._evaluator.feature = o || null),
                  (this._evaluator.featureState = l || null),
                  (this._evaluator.canonical = h || null),
                  (this._evaluator.availableImages = m || null),
                  (this._evaluator.formattedSection = _ || null),
                  (this._evaluator.featureTileCoord = x || null),
                  (this._evaluator.featureDistanceData = E || null);
                try {
                  const T = this.expression.evaluate(this._evaluator);
                  if (null == T || ("number" == typeof T && T != T))
                    return this._defaultValue;
                  if (this._enumValues && !(T in this._enumValues))
                    throw new or(
                      `Expected value to be one of ${Object.keys(
                        this._enumValues
                      )
                        .map((I) => JSON.stringify(I))
                        .join(", ")}, but found ${JSON.stringify(T)} instead.`
                    );
                  return T;
                } catch (T) {
                  return (
                    this._warningHistory[T.message] ||
                      ((this._warningHistory[T.message] = !0),
                      typeof console < "u" && console.warn(T.message)),
                    this._defaultValue
                  );
                }
              }
            }
            function Zo(r) {
              return (
                Array.isArray(r) &&
                r.length > 0 &&
                "string" == typeof r[0] &&
                r[0] in Su
              );
            }
            function Ba(r, i) {
              const o = new Oh(
                  Su,
                  [],
                  i
                    ? (function (h) {
                        const m = {
                          color: Hr,
                          string: xt,
                          number: ot,
                          enum: xt,
                          boolean: $t,
                          formatted: _u,
                          resolvedImage: st,
                        };
                        return "array" === h.type
                          ? yr(m[h.value] || it, h.length)
                          : m[h.type];
                      })(i)
                    : void 0
                ),
                l = o.parse(
                  r,
                  void 0,
                  void 0,
                  void 0,
                  i && "string" === i.type
                    ? { typeAnnotation: "coerce" }
                    : void 0
                );
              return l ? zf(new Mu(l, i)) : Ol(o.errors);
            }
            class $h {
              constructor(i, o) {
                (this.kind = i),
                  (this._styleExpression = o),
                  (this.isStateDependent =
                    "constant" !== i && !Ho(o.expression));
              }
              evaluateWithoutErrorHandling(i, o, l, h, m, _) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  i,
                  o,
                  l,
                  h,
                  m,
                  _
                );
              }
              evaluate(i, o, l, h, m, _) {
                return this._styleExpression.evaluate(i, o, l, h, m, _);
              }
            }
            class Ec {
              constructor(i, o, l, h) {
                (this.kind = i),
                  (this.zoomStops = l),
                  (this._styleExpression = o),
                  (this.isStateDependent = "camera" !== i && !Ho(o.expression)),
                  (this.interpolationType = h);
              }
              evaluateWithoutErrorHandling(i, o, l, h, m, _) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  i,
                  o,
                  l,
                  h,
                  m,
                  _
                );
              }
              evaluate(i, o, l, h, m, _) {
                return this._styleExpression.evaluate(i, o, l, h, m, _);
              }
              interpolationFactor(i, o, l) {
                return this.interpolationType
                  ? so.interpolationFactor(this.interpolationType, i, o, l)
                  : 0;
              }
            }
            function Fl(r, i) {
              if ("error" === (r = Ba(r, i)).result) return r;
              const o = r.value.expression,
                l = Us(o);
              if (!l && !bc(i))
                return Ol([new jo("", "data expressions not supported")]);
              const h = vr(o, ["zoom", "pitch", "distance-from-center"]);
              if (!h && !Vh(i))
                return Ol([new jo("", "zoom expressions not supported")]);
              const m = Au(o);
              return m || h
                ? m instanceof jo
                  ? Ol([m])
                  : m instanceof so && !jh(i)
                  ? Ol([
                      new jo(
                        "",
                        '"interpolate" expressions cannot be used with this property'
                      ),
                    ])
                  : zf(
                      m
                        ? new Ec(
                            l ? "camera" : "composite",
                            r.value,
                            m.labels,
                            m instanceof so ? m.interpolation : void 0
                          )
                        : new $h(l ? "constant" : "source", r.value)
                    )
                : Ol([
                    new jo(
                      "",
                      '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                    ),
                  ]);
            }
            class Tc {
              constructor(i, o) {
                (this._parameters = i),
                  (this._specification = o),
                  Vo(this, wc(this._parameters, this._specification));
              }
              static deserialize(i) {
                return new Tc(i._parameters, i._specification);
              }
              static serialize(i) {
                return {
                  _parameters: i._parameters,
                  _specification: i._specification,
                };
              }
            }
            function Au(r) {
              let i = null;
              if (r instanceof Na) i = Au(r.result);
              else if (r instanceof Vi) {
                for (const o of r.args) if (((i = Au(o)), i)) break;
              } else
                (r instanceof Fh || r instanceof so) &&
                  r.input instanceof Uo &&
                  "zoom" === r.input.name &&
                  (i = r);
              return (
                i instanceof jo ||
                  r.eachChild((o) => {
                    const l = Au(o);
                    l instanceof jo
                      ? (i = l)
                      : !i && l
                      ? (i = new jo(
                          "",
                          '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                        ))
                      : i &&
                        l &&
                        i !== l &&
                        (i = new jo(
                          "",
                          'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
                        ));
                  }),
                i
              );
            }
            class ct {
              constructor(i, o, l, h) {
                (this.message = (i ? `${i}: ` : "") + l),
                  h && (this.identifier = h),
                  null != o && o.__line__ && (this.line = o.__line__);
              }
            }
            function To(r) {
              const i = r.key,
                o = r.value,
                l = r.valueSpec || {},
                h = r.objectElementValidators || {},
                m = r.style,
                _ = r.styleSpec;
              let x = [];
              const E = fn(o);
              if ("object" !== E)
                return [new ct(i, o, `object expected, ${E} found`)];
              for (const T in o) {
                const I = T.split(".")[0];
                let A;
                h[I]
                  ? (A = h[I])
                  : l[I]
                  ? (A = yi)
                  : h["*"]
                  ? (A = h["*"])
                  : l["*"] && (A = yi),
                  A
                    ? (x = x.concat(
                        A(
                          {
                            key: (i && `${i}.`) + T,
                            value: o[T],
                            valueSpec: l[I] || l["*"],
                            style: m,
                            styleSpec: _,
                            object: o,
                            objectKey: T,
                          },
                          o
                        )
                      ))
                    : x.push(new ct(i, o[T], `unknown property "${T}"`));
              }
              for (const T in l)
                h[T] ||
                  (l[T].required &&
                    void 0 === l[T].default &&
                    void 0 === o[T] &&
                    x.push(new ct(i, o, `missing required property "${T}"`)));
              return x;
            }
            function Xr(r) {
              const i = r.value,
                o = r.valueSpec,
                l = r.style,
                h = r.styleSpec,
                m = r.key,
                _ = r.arrayElementValidator || yi;
              if ("array" !== fn(i))
                return [new ct(m, i, `array expected, ${fn(i)} found`)];
              if (o.length && i.length !== o.length)
                return [
                  new ct(
                    m,
                    i,
                    `array length ${o.length} expected, length ${i.length} found`
                  ),
                ];
              if (o["min-length"] && i.length < o["min-length"])
                return [
                  new ct(
                    m,
                    i,
                    `array length at least ${o["min-length"]} expected, length ${i.length} found`
                  ),
                ];
              let x = {
                type: o.value,
                values: o.values,
                minimum: o.minimum,
                maximum: o.maximum,
                function: void 0,
              };
              h.$version < 7 && (x.function = o.function),
                "object" === fn(o.value) && (x = o.value);
              let E = [];
              for (let T = 0; T < i.length; T++)
                E = E.concat(
                  _({
                    array: i,
                    arrayIndex: T,
                    value: i[T],
                    valueSpec: x,
                    style: l,
                    styleSpec: h,
                    key: `${m}[${T}]`,
                  })
                );
              return E;
            }
            function Va(r) {
              const i = r.key,
                o = r.value,
                l = r.valueSpec;
              let h = fn(o);
              if (("number" === h && o != o && (h = "NaN"), "number" !== h))
                return [new ct(i, o, `number expected, ${h} found`)];
              if ("minimum" in l) {
                let m = l.minimum;
                if (
                  ("array" === fn(l.minimum) && (m = l.minimum[r.arrayIndex]),
                  o < m)
                )
                  return [
                    new ct(i, o, `${o} is less than the minimum value ${m}`),
                  ];
              }
              if ("maximum" in l) {
                let m = l.maximum;
                if (
                  ("array" === fn(l.maximum) && (m = l.maximum[r.arrayIndex]),
                  o > m)
                )
                  return [
                    new ct(i, o, `${o} is greater than the maximum value ${m}`),
                  ];
              }
              return [];
            }
            function Dc(r) {
              const i = r.valueSpec,
                o = mi(r.value.type);
              let l,
                h,
                m,
                _ = {};
              const x = "categorical" !== o && void 0 === r.value.property,
                E = !x,
                T =
                  "array" === fn(r.value.stops) &&
                  "array" === fn(r.value.stops[0]) &&
                  "object" === fn(r.value.stops[0][0]),
                I = To({
                  key: r.key,
                  value: r.value,
                  valueSpec: r.styleSpec.function,
                  style: r.style,
                  styleSpec: r.styleSpec,
                  objectElementValidators: {
                    stops: function (O) {
                      if ("identity" === o)
                        return [
                          new ct(
                            O.key,
                            O.value,
                            'identity function may not have a "stops" property'
                          ),
                        ];
                      let F = [];
                      const V = O.value;
                      return (
                        (F = F.concat(
                          Xr({
                            key: O.key,
                            value: V,
                            valueSpec: O.valueSpec,
                            style: O.style,
                            styleSpec: O.styleSpec,
                            arrayElementValidator: A,
                          })
                        )),
                        "array" === fn(V) &&
                          0 === V.length &&
                          F.push(
                            new ct(
                              O.key,
                              V,
                              "array must have at least one stop"
                            )
                          ),
                        F
                      );
                    },
                    default: function (O) {
                      return yi({
                        key: O.key,
                        value: O.value,
                        valueSpec: i,
                        style: O.style,
                        styleSpec: O.styleSpec,
                      });
                    },
                  },
                });
              return (
                "identity" === o &&
                  x &&
                  I.push(
                    new ct(
                      r.key,
                      r.value,
                      'missing required property "property"'
                    )
                  ),
                "identity" === o ||
                  r.value.stops ||
                  I.push(
                    new ct(r.key, r.value, 'missing required property "stops"')
                  ),
                "exponential" === o &&
                  r.valueSpec.expression &&
                  !jh(r.valueSpec) &&
                  I.push(
                    new ct(
                      r.key,
                      r.value,
                      "exponential functions not supported"
                    )
                  ),
                r.styleSpec.$version >= 8 &&
                  (E && !bc(r.valueSpec)
                    ? I.push(
                        new ct(
                          r.key,
                          r.value,
                          "property functions not supported"
                        )
                      )
                    : x &&
                      !Vh(r.valueSpec) &&
                      I.push(
                        new ct(r.key, r.value, "zoom functions not supported")
                      )),
                ("categorical" !== o && !T) ||
                  void 0 !== r.value.property ||
                  I.push(
                    new ct(r.key, r.value, '"property" property is required')
                  ),
                I
              );
              function A(O) {
                let F = [];
                const V = O.value,
                  G = O.key;
                if ("array" !== fn(V))
                  return [new ct(G, V, `array expected, ${fn(V)} found`)];
                if (2 !== V.length)
                  return [
                    new ct(
                      G,
                      V,
                      `array length 2 expected, length ${V.length} found`
                    ),
                  ];
                if (T) {
                  if ("object" !== fn(V[0]))
                    return [new ct(G, V, `object expected, ${fn(V[0])} found`)];
                  if (void 0 === V[0].zoom)
                    return [new ct(G, V, "object stop key must have zoom")];
                  if (void 0 === V[0].value)
                    return [new ct(G, V, "object stop key must have value")];
                  const K = mi(V[0].zoom);
                  if ("number" != typeof K)
                    return [
                      new ct(G, V[0].zoom, "stop zoom values must be numbers"),
                    ];
                  if (m && m > K)
                    return [
                      new ct(
                        G,
                        V[0].zoom,
                        "stop zoom values must appear in ascending order"
                      ),
                    ];
                  K !== m && ((m = K), (h = void 0), (_ = {})),
                    (F = F.concat(
                      To({
                        key: `${G}[0]`,
                        value: V[0],
                        valueSpec: { zoom: {} },
                        style: O.style,
                        styleSpec: O.styleSpec,
                        objectElementValidators: { zoom: Va, value: L },
                      })
                    ));
                } else F = F.concat(L({ key: `${G}[0]`, value: V[0], valueSpec: {}, style: O.style, styleSpec: O.styleSpec }, V));
                return Zo(Bi(V[1]))
                  ? F.concat([
                      new ct(
                        `${G}[1]`,
                        V[1],
                        "expressions are not allowed in function stops."
                      ),
                    ])
                  : F.concat(
                      yi({
                        key: `${G}[1]`,
                        value: V[1],
                        valueSpec: i,
                        style: O.style,
                        styleSpec: O.styleSpec,
                      })
                    );
              }
              function L(O, F) {
                const V = fn(O.value),
                  G = mi(O.value),
                  K = null !== O.value ? O.value : F;
                if (l) {
                  if (V !== l)
                    return [
                      new ct(
                        O.key,
                        K,
                        `${V} stop domain type must match previous stop domain type ${l}`
                      ),
                    ];
                } else l = V;
                if (
                  "number" !== V &&
                  "string" !== V &&
                  "boolean" !== V &&
                  "number" != typeof G &&
                  "string" != typeof G &&
                  "boolean" != typeof G
                )
                  return [
                    new ct(
                      O.key,
                      K,
                      "stop domain value must be a number, string, or boolean"
                    ),
                  ];
                if ("number" !== V && "categorical" !== o) {
                  let oe = `number expected, ${V} found`;
                  return (
                    bc(i) &&
                      void 0 === o &&
                      (oe +=
                        '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new ct(O.key, K, oe)]
                  );
                }
                return "categorical" !== o ||
                  "number" !== V ||
                  ("number" == typeof G && isFinite(G) && Math.floor(G) === G)
                  ? "categorical" !== o &&
                    "number" === V &&
                    "number" == typeof G &&
                    "number" == typeof h &&
                    void 0 !== h &&
                    G < h
                    ? [
                        new ct(
                          O.key,
                          K,
                          "stop domain values must appear in ascending order"
                        ),
                      ]
                    : ((h = G),
                      "categorical" === o && G in _
                        ? [
                            new ct(
                              O.key,
                              K,
                              "stop domain values must be unique"
                            ),
                          ]
                        : ((_[G] = !0), []))
                  : [new ct(O.key, K, `integer expected, found ${String(G)}`)];
              }
            }
            function Ci(r) {
              const i = ("property" === r.expressionContext ? Fl : Ba)(
                Bi(r.value),
                r.valueSpec
              );
              if ("error" === i.result)
                return i.value.map(
                  (l) => new ct(`${r.key}${l.key}`, r.value, l.message)
                );
              const o =
                i.value.expression || i.value._styleExpression.expression;
              if (
                "property" === r.expressionContext &&
                "text-font" === r.propertyKey &&
                !o.outputDefined()
              )
                return [
                  new ct(
                    r.key,
                    r.value,
                    `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`
                  ),
                ];
              if (
                "property" === r.expressionContext &&
                "layout" === r.propertyType &&
                !Ho(o)
              )
                return [
                  new ct(
                    r.key,
                    r.value,
                    '"feature-state" data expressions are not supported with layout properties.'
                  ),
                ];
              if ("filter" === r.expressionContext) return Cc(o, r);
              if (
                r.expressionContext &&
                0 === r.expressionContext.indexOf("cluster")
              ) {
                if (!vr(o, ["zoom", "feature-state"]))
                  return [
                    new ct(
                      r.key,
                      r.value,
                      '"zoom" and "feature-state" expressions are not supported with cluster properties.'
                    ),
                  ];
                if ("cluster-initial" === r.expressionContext && !Us(o))
                  return [
                    new ct(
                      r.key,
                      r.value,
                      "Feature data expressions are not supported with initial expression part of cluster properties."
                    ),
                  ];
              }
              return [];
            }
            function Cc(r, i) {
              const o = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center",
              ]);
              if (i.valueSpec && i.valueSpec.expression)
                for (const h of i.valueSpec.expression.parameters) o.delete(h);
              if (0 === o.size) return [];
              const l = [];
              return r instanceof Uo && o.has(r.name)
                ? [
                    new ct(
                      i.key,
                      i.value,
                      `["${r.name}"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`
                    ),
                  ]
                : (r.eachChild((h) => {
                    l.push(...Cc(h, i));
                  }),
                  l);
            }
            function Hh(r) {
              const i = r.key,
                o = r.value,
                l = r.valueSpec,
                h = [];
              return (
                Array.isArray(l.values)
                  ? -1 === l.values.indexOf(mi(o)) &&
                    h.push(
                      new ct(
                        i,
                        o,
                        `expected one of [${l.values.join(
                          ", "
                        )}], ${JSON.stringify(o)} found`
                      )
                    )
                  : -1 === Object.keys(l.values).indexOf(mi(o)) &&
                    h.push(
                      new ct(
                        i,
                        o,
                        `expected one of [${Object.keys(l.values).join(
                          ", "
                        )}], ${JSON.stringify(o)} found`
                      )
                    ),
                h
              );
            }
            function oi(r) {
              if (!0 === r || !1 === r) return !0;
              if (!Array.isArray(r) || 0 === r.length) return !1;
              switch (r[0]) {
                case "has":
                  return r.length >= 2 && "$id" !== r[1] && "$type" !== r[1];
                case "in":
                  return (
                    r.length >= 3 &&
                    ("string" != typeof r[1] || Array.isArray(r[2]))
                  );
                case "!in":
                case "!has":
                case "none":
                  return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                  return (
                    3 !== r.length || Array.isArray(r[1]) || Array.isArray(r[2])
                  );
                case "any":
                case "all":
                  for (const i of r.slice(1))
                    if (!oi(i) && "boolean" != typeof i) return !1;
                  return !0;
                default:
                  return !0;
              }
            }
            function Pu(r, i = "fill") {
              if (null == r)
                return { filter: () => !0, needGeometry: !1, needFeature: !1 };
              oi(r) || (r = Ui(r));
              const o = r;
              let l = !0;
              try {
                l = (function (T) {
                  if (!ji(T)) return T;
                  let I = Bi(T);
                  return ja(I), (I = jf(I)), I;
                })(o);
              } catch {
                console.warn(
                  `Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(
                    o,
                    null,
                    2
                  )}\n        `
                );
              }
              const h = Ae[`filter_${i}`],
                m = Ba(l, h);
              let _ = null;
              if ("error" === m.result)
                throw new Error(
                  m.value.map((T) => `${T.key}: ${T.message}`).join(", ")
                );
              _ = (T, I, A) => m.value.evaluate(T, I, {}, A);
              let x = null,
                E = null;
              if (l !== o) {
                const T = Ba(o, h);
                if ("error" === T.result)
                  throw new Error(
                    T.value.map((I) => `${I.key}: ${I.message}`).join(", ")
                  );
                (x = (I, A, L, O, F) =>
                  T.value.evaluate(I, A, {}, L, void 0, void 0, O, F)),
                  (E = !Us(T.value.expression));
              }
              return {
                filter: _,
                dynamicFilter: x || void 0,
                needGeometry: Ua(l),
                needFeature: !!E,
              };
            }
            function jf(r) {
              if (!Array.isArray(r)) return r;
              const i = (function (o) {
                if (Gh.has(o[0]))
                  for (let l = 1; l < o.length; l++) if (ji(o[l])) return !0;
                return o;
              })(r);
              return !0 === i ? i : i.map((o) => jf(o));
            }
            function ja(r) {
              let i = !1;
              const o = [];
              if ("case" === r[0]) {
                for (let l = 1; l < r.length - 1; l += 2)
                  (i = i || ji(r[l])), o.push(r[l + 1]);
                o.push(r[r.length - 1]);
              } else if ("match" === r[0]) {
                i = i || ji(r[1]);
                for (let l = 2; l < r.length - 1; l += 2) o.push(r[l + 1]);
                o.push(r[r.length - 1]);
              } else if ("step" === r[0]) {
                i = i || ji(r[1]);
                for (let l = 1; l < r.length - 1; l += 2) o.push(r[l + 1]);
              }
              i && ((r.length = 0), r.push("any", ...o));
              for (let l = 1; l < r.length; l++) ja(r[l]);
            }
            function ji(r) {
              if (!Array.isArray(r)) return !1;
              if ("pitch" === (i = r[0]) || "distance-from-center" === i)
                return !0;
              var i;
              for (let o = 1; o < r.length; o++) if (ji(r[o])) return !0;
              return !1;
            }
            const Gh = new Set([
              "in",
              "==",
              "!=",
              ">",
              ">=",
              "<",
              "<=",
              "to-boolean",
            ]);
            function qh(r, i) {
              return r < i ? -1 : r > i ? 1 : 0;
            }
            function Ua(r) {
              if (!Array.isArray(r)) return !1;
              if ("within" === r[0]) return !0;
              for (let i = 1; i < r.length; i++) if (Ua(r[i])) return !0;
              return !1;
            }
            function Ui(r) {
              if (!r) return !0;
              const i = r[0];
              return r.length <= 1
                ? "any" !== i
                : "==" === i
                ? Wh(r[1], r[2], "==")
                : "!=" === i
                ? Do(Wh(r[1], r[2], "=="))
                : "<" === i || ">" === i || "<=" === i || ">=" === i
                ? Wh(r[1], r[2], i)
                : "any" === i
                ? ((o = r.slice(1)), ["any"].concat(o.map(Ui)))
                : "all" === i
                ? ["all"].concat(r.slice(1).map(Ui))
                : "none" === i
                ? ["all"].concat(r.slice(1).map(Ui).map(Do))
                : "in" === i
                ? Nl(r[1], r.slice(2))
                : "!in" === i
                ? Do(Nl(r[1], r.slice(2)))
                : "has" === i
                ? Zh(r[1])
                : "!has" === i
                ? Do(Zh(r[1]))
                : "within" !== i || r;
              var o;
            }
            function Wh(r, i, o) {
              switch (r) {
                case "$type":
                  return [`filter-type-${o}`, i];
                case "$id":
                  return [`filter-id-${o}`, i];
                default:
                  return [`filter-${o}`, r, i];
              }
            }
            function Nl(r, i) {
              if (0 === i.length) return !1;
              switch (r) {
                case "$type":
                  return ["filter-type-in", ["literal", i]];
                case "$id":
                  return ["filter-id-in", ["literal", i]];
                default:
                  return i.length > 200 &&
                    !i.some((o) => typeof o != typeof i[0])
                    ? ["filter-in-large", r, ["literal", i.sort(qh)]]
                    : ["filter-in-small", r, ["literal", i]];
              }
            }
            function Zh(r) {
              switch (r) {
                case "$type":
                  return !0;
                case "$id":
                  return ["filter-has-id"];
                default:
                  return ["filter-has", r];
              }
            }
            function Do(r) {
              return ["!", r];
            }
            function zl(r) {
              return oi(Bi(r.value))
                ? Ci(
                    Vo({}, r, {
                      expressionContext: "filter",
                      valueSpec: r.styleSpec[`filter_${r.layerType || "fill"}`],
                    })
                  )
                : $a(r);
            }
            function $a(r) {
              const i = r.value,
                o = r.key;
              if ("array" !== fn(i))
                return [new ct(o, i, `array expected, ${fn(i)} found`)];
              const l = r.styleSpec;
              let h,
                m = [];
              if (i.length < 1)
                return [
                  new ct(o, i, "filter array must have at least 1 element"),
                ];
              switch (
                ((m = m.concat(
                  Hh({
                    key: `${o}[0]`,
                    value: i[0],
                    valueSpec: l.filter_operator,
                    style: r.style,
                    styleSpec: r.styleSpec,
                  })
                )),
                mi(i[0]))
              ) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                  i.length >= 2 &&
                    "$type" === mi(i[1]) &&
                    m.push(
                      new ct(
                        o,
                        i,
                        `"$type" cannot be use with operator "${i[0]}"`
                      )
                    );
                case "==":
                case "!=":
                  3 !== i.length &&
                    m.push(
                      new ct(
                        o,
                        i,
                        `filter array for operator "${i[0]}" must have 3 elements`
                      )
                    );
                case "in":
                case "!in":
                  i.length >= 2 &&
                    ((h = fn(i[1])),
                    "string" !== h &&
                      m.push(
                        new ct(`${o}[1]`, i[1], `string expected, ${h} found`)
                      ));
                  for (let _ = 2; _ < i.length; _++)
                    (h = fn(i[_])),
                      "$type" === mi(i[1])
                        ? (m = m.concat(
                            Hh({
                              key: `${o}[${_}]`,
                              value: i[_],
                              valueSpec: l.geometry_type,
                              style: r.style,
                              styleSpec: r.styleSpec,
                            })
                          ))
                        : "string" !== h &&
                          "number" !== h &&
                          "boolean" !== h &&
                          m.push(
                            new ct(
                              `${o}[${_}]`,
                              i[_],
                              `string, number, or boolean expected, ${h} found`
                            )
                          );
                  break;
                case "any":
                case "all":
                case "none":
                  for (let _ = 1; _ < i.length; _++)
                    m = m.concat(
                      $a({
                        key: `${o}[${_}]`,
                        value: i[_],
                        style: r.style,
                        styleSpec: r.styleSpec,
                      })
                    );
                  break;
                case "has":
                case "!has":
                  (h = fn(i[1])),
                    2 !== i.length
                      ? m.push(
                          new ct(
                            o,
                            i,
                            `filter array for "${i[0]}" operator must have 2 elements`
                          )
                        )
                      : "string" !== h &&
                        m.push(
                          new ct(`${o}[1]`, i[1], `string expected, ${h} found`)
                        );
                  break;
                case "within":
                  (h = fn(i[1])),
                    2 !== i.length
                      ? m.push(
                          new ct(
                            o,
                            i,
                            `filter array for "${i[0]}" operator must have 2 elements`
                          )
                        )
                      : "object" !== h &&
                        m.push(
                          new ct(`${o}[1]`, i[1], `object expected, ${h} found`)
                        );
              }
              return m;
            }
            function Bt(r, i) {
              const o = r.key,
                l = r.style,
                h = r.styleSpec,
                m = r.value,
                _ = r.objectKey,
                x = h[`${i}_${r.layerType}`];
              if (!x) return [];
              const E = _.match(/^(.*)-transition$/);
              if ("paint" === i && E && x[E[1]] && x[E[1]].transition)
                return yi({
                  key: o,
                  value: m,
                  valueSpec: h.transition,
                  style: l,
                  styleSpec: h,
                });
              const T = r.valueSpec || x[_];
              if (!T) return [new ct(o, m, `unknown property "${_}"`)];
              let I;
              if (
                "string" === fn(m) &&
                bc(T) &&
                !T.tokens &&
                (I = /^{([^}]+)}$/.exec(m))
              ) {
                const L = `\`{ "type": "identity", "property": ${
                  I ? JSON.stringify(I[1]) : '"_"'
                } }\``;
                return [
                  new ct(
                    o,
                    m,
                    `"${_}" does not support interpolation syntax\nUse an identity property function instead: ${L}.`
                  ),
                ];
              }
              const A = [];
              return (
                "symbol" === r.layerType &&
                  ("text-field" === _ &&
                    l &&
                    !l.glyphs &&
                    A.push(
                      new ct(
                        o,
                        m,
                        'use of "text-field" requires a style "glyphs" property'
                      )
                    ),
                  "text-font" === _ &&
                    Iu(Bi(m)) &&
                    "identity" === mi(m.type) &&
                    A.push(
                      new ct(
                        o,
                        m,
                        '"text-font" does not support identity functions'
                      )
                    )),
                A.concat(
                  yi({
                    key: r.key,
                    value: m,
                    valueSpec: T,
                    style: l,
                    styleSpec: h,
                    expressionContext: "property",
                    propertyType: i,
                    propertyKey: _,
                  })
                )
              );
            }
            function Xh(r) {
              return Bt(r, "paint");
            }
            function gp(r) {
              return Bt(r, "layout");
            }
            function _p(r) {
              let i = [];
              const o = r.value,
                l = r.key,
                h = r.style,
                m = r.styleSpec;
              o.type ||
                o.ref ||
                i.push(new ct(l, o, 'either "type" or "ref" is required'));
              let _ = mi(o.type);
              const x = mi(o.ref);
              if (o.id) {
                const E = mi(o.id);
                for (let T = 0; T < r.arrayIndex; T++) {
                  const I = h.layers[T];
                  mi(I.id) === E &&
                    i.push(
                      new ct(
                        l,
                        o.id,
                        `duplicate layer id "${o.id}", previously used at line ${I.id.__line__}`
                      )
                    );
                }
              }
              if ("ref" in o) {
                let E;
                ["type", "source", "source-layer", "filter", "layout"].forEach(
                  (T) => {
                    T in o &&
                      i.push(
                        new ct(l, o[T], `"${T}" is prohibited for ref layers`)
                      );
                  }
                ),
                  h.layers.forEach((T) => {
                    mi(T.id) === x && (E = T);
                  }),
                  E
                    ? E.ref
                      ? i.push(
                          new ct(
                            l,
                            o.ref,
                            "ref cannot reference another ref layer"
                          )
                        )
                      : (_ = mi(E.type))
                    : "string" == typeof x &&
                      i.push(new ct(l, o.ref, `ref layer "${x}" not found`));
              } else if ("background" !== _ && "sky" !== _)
                if (o.source) {
                  const E = h.sources && h.sources[o.source],
                    T = E && mi(E.type);
                  E
                    ? "vector" === T && "raster" === _
                      ? i.push(
                          new ct(
                            l,
                            o.source,
                            `layer "${o.id}" requires a raster source`
                          )
                        )
                      : "raster" === T && "raster" !== _
                      ? i.push(
                          new ct(
                            l,
                            o.source,
                            `layer "${o.id}" requires a vector source`
                          )
                        )
                      : "vector" !== T || o["source-layer"]
                      ? "raster-dem" === T && "hillshade" !== _
                        ? i.push(
                            new ct(
                              l,
                              o.source,
                              "raster-dem source can only be used with layer type 'hillshade'."
                            )
                          )
                        : "line" !== _ ||
                          !o.paint ||
                          (!o.paint["line-gradient"] &&
                            !o.paint["line-trim-offset"]) ||
                          ("geojson" === T && E.lineMetrics) ||
                          i.push(
                            new ct(
                              l,
                              o,
                              `layer "${o.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`
                            )
                          )
                      : i.push(
                          new ct(
                            l,
                            o,
                            `layer "${o.id}" must specify a "source-layer"`
                          )
                        )
                    : i.push(
                        new ct(l, o.source, `source "${o.source}" not found`)
                      );
                } else
                  i.push(new ct(l, o, 'missing required property "source"'));
              return (
                (i = i.concat(
                  To({
                    key: l,
                    value: o,
                    valueSpec: m.layer,
                    style: r.style,
                    styleSpec: r.styleSpec,
                    objectElementValidators: {
                      "*": () => [],
                      type: () =>
                        yi({
                          key: `${l}.type`,
                          value: o.type,
                          valueSpec: m.layer.type,
                          style: r.style,
                          styleSpec: r.styleSpec,
                          object: o,
                          objectKey: "type",
                        }),
                      filter: (E) => zl(Vo({ layerType: _ }, E)),
                      layout: (E) =>
                        To({
                          layer: o,
                          key: E.key,
                          value: E.value,
                          valueSpec: {},
                          style: E.style,
                          styleSpec: E.styleSpec,
                          objectElementValidators: {
                            "*": (T) => gp(Vo({ layerType: _ }, T)),
                          },
                        }),
                      paint: (E) =>
                        To({
                          layer: o,
                          key: E.key,
                          value: E.value,
                          valueSpec: {},
                          style: E.style,
                          styleSpec: E.styleSpec,
                          objectElementValidators: {
                            "*": (T) => Xh(Vo({ layerType: _ }, T)),
                          },
                        }),
                    },
                  })
                )),
                i
              );
            }
            function Qs(r) {
              const i = r.value,
                o = r.key,
                l = fn(i);
              return "string" !== l
                ? [new ct(o, i, `string expected, ${l} found`)]
                : [];
            }
            const yp = {
              promoteId: function ({ key: r, value: i }) {
                if ("string" === fn(i)) return Qs({ key: r, value: i });
                {
                  const o = [];
                  for (const l in i)
                    o.push(...Qs({ key: `${r}.${l}`, value: i[l] }));
                  return o;
                }
              },
            };
            function Kh(r) {
              const i = r.value,
                o = r.key,
                l = r.styleSpec,
                h = r.style;
              if (!i.type) return [new ct(o, i, '"type" is required')];
              const m = mi(i.type);
              let _;
              switch (m) {
                case "vector":
                case "raster":
                case "raster-dem":
                  return (
                    (_ = To({
                      key: o,
                      value: i,
                      valueSpec: l[`source_${m.replace("-", "_")}`],
                      style: r.style,
                      styleSpec: l,
                      objectElementValidators: yp,
                    })),
                    _
                  );
                case "geojson":
                  if (
                    ((_ = To({
                      key: o,
                      value: i,
                      valueSpec: l.source_geojson,
                      style: h,
                      styleSpec: l,
                      objectElementValidators: yp,
                    })),
                    i.cluster)
                  )
                    for (const x in i.clusterProperties) {
                      const [E, T] = i.clusterProperties[x],
                        I =
                          "string" == typeof E
                            ? [E, ["accumulated"], ["get", x]]
                            : E;
                      _.push(
                        ...Ci({
                          key: `${o}.${x}.map`,
                          value: T,
                          expressionContext: "cluster-map",
                        })
                      ),
                        _.push(
                          ...Ci({
                            key: `${o}.${x}.reduce`,
                            value: I,
                            expressionContext: "cluster-reduce",
                          })
                        );
                    }
                  return _;
                case "video":
                  return To({
                    key: o,
                    value: i,
                    valueSpec: l.source_video,
                    style: h,
                    styleSpec: l,
                  });
                case "image":
                  return To({
                    key: o,
                    value: i,
                    valueSpec: l.source_image,
                    style: h,
                    styleSpec: l,
                  });
                case "canvas":
                  return [
                    new ct(
                      o,
                      null,
                      "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
                      "source.canvas"
                    ),
                  ];
                default:
                  return Hh({
                    key: `${o}.type`,
                    value: i.type,
                    valueSpec: { values: Uf(l) },
                    style: h,
                    styleSpec: l,
                  });
              }
            }
            function Uf(r) {
              return r.source.reduce((i, o) => {
                const l = r[o];
                return (
                  "enum" === l.type.type &&
                    (i = i.concat(Object.keys(l.type.values))),
                  i
                );
              }, []);
            }
            function vp(r) {
              const i = r.value,
                o = r.styleSpec,
                l = o.light,
                h = r.style;
              let m = [];
              const _ = fn(i);
              if (void 0 === i) return m;
              if ("object" !== _)
                return (
                  (m = m.concat([
                    new ct("light", i, `object expected, ${_} found`),
                  ])),
                  m
                );
              for (const x in i) {
                const E = x.match(/^(.*)-transition$/);
                m = m.concat(
                  E && l[E[1]] && l[E[1]].transition
                    ? yi({
                        key: x,
                        value: i[x],
                        valueSpec: o.transition,
                        style: h,
                        styleSpec: o,
                      })
                    : l[x]
                    ? yi({
                        key: x,
                        value: i[x],
                        valueSpec: l[x],
                        style: h,
                        styleSpec: o,
                      })
                    : [new ct(x, i[x], `unknown property "${x}"`)]
                );
              }
              return m;
            }
            function Ze(r) {
              const i = r.value,
                o = r.key,
                l = r.style,
                h = r.styleSpec,
                m = h.terrain;
              let _ = [];
              const x = fn(i);
              if (void 0 === i) return _;
              if ("object" !== x)
                return (
                  (_ = _.concat([
                    new ct("terrain", i, `object expected, ${x} found`),
                  ])),
                  _
                );
              for (const E in i) {
                const T = E.match(/^(.*)-transition$/);
                _ = _.concat(
                  T && m[T[1]] && m[T[1]].transition
                    ? yi({
                        key: E,
                        value: i[E],
                        valueSpec: h.transition,
                        style: l,
                        styleSpec: h,
                      })
                    : m[E]
                    ? yi({
                        key: E,
                        value: i[E],
                        valueSpec: m[E],
                        style: l,
                        styleSpec: h,
                      })
                    : [new ct(E, i[E], `unknown property "${E}"`)]
                );
              }
              if (i.source) {
                const E = l.sources && l.sources[i.source],
                  T = E && mi(E.type);
                E
                  ? "raster-dem" !== T &&
                    _.push(
                      new ct(
                        o,
                        i.source,
                        `terrain cannot be used with a source of type ${String(
                          T
                        )}, it only be used with a "raster-dem" source type`
                      )
                    )
                  : _.push(
                      new ct(o, i.source, `source "${i.source}" not found`)
                    );
              } else _.push(new ct(o, i, 'terrain is missing required property "source"'));
              return _;
            }
            function mn(r) {
              const i = r.value,
                o = r.style,
                l = r.styleSpec,
                h = l.fog;
              let m = [];
              const _ = fn(i);
              if (void 0 === i) return m;
              if ("object" !== _)
                return (
                  (m = m.concat([
                    new ct("fog", i, `object expected, ${_} found`),
                  ])),
                  m
                );
              for (const x in i) {
                const E = x.match(/^(.*)-transition$/);
                m = m.concat(
                  E && h[E[1]] && h[E[1]].transition
                    ? yi({
                        key: x,
                        value: i[x],
                        valueSpec: l.transition,
                        style: o,
                        styleSpec: l,
                      })
                    : h[x]
                    ? yi({
                        key: x,
                        value: i[x],
                        valueSpec: h[x],
                        style: o,
                        styleSpec: l,
                      })
                    : [new ct(x, i[x], `unknown property "${x}"`)]
                );
              }
              return m;
            }
            const Ha = {
              "*": () => [],
              array: Xr,
              boolean: function (r) {
                const i = r.value,
                  o = r.key,
                  l = fn(i);
                return "boolean" !== l
                  ? [new ct(o, i, `boolean expected, ${l} found`)]
                  : [];
              },
              number: Va,
              color: function (r) {
                const i = r.key,
                  o = r.value,
                  l = fn(o);
                return "string" !== l
                  ? [new ct(i, o, `color expected, ${l} found`)]
                  : null === Dl(o)
                  ? [new ct(i, o, `color expected, "${o}" found`)]
                  : [];
              },
              enum: Hh,
              filter: zl,
              function: Dc,
              layer: _p,
              object: To,
              source: Kh,
              light: vp,
              terrain: Ze,
              fog: mn,
              string: Qs,
              formatted: function (r) {
                return 0 === Qs(r).length ? [] : Ci(r);
              },
              resolvedImage: function (r) {
                return 0 === Qs(r).length ? [] : Ci(r);
              },
              projection: function (r) {
                const i = r.value,
                  o = r.styleSpec,
                  l = o.projection,
                  h = r.style;
                let m = [];
                const _ = fn(i);
                if ("object" === _)
                  for (const x in i)
                    m = m.concat(
                      yi({
                        key: x,
                        value: i[x],
                        valueSpec: l[x],
                        style: h,
                        styleSpec: o,
                      })
                    );
                else
                  "string" !== _ &&
                    (m = m.concat([
                      new ct(
                        "projection",
                        i,
                        `object or string expected, ${_} found`
                      ),
                    ]));
                return m;
              },
            };
            function yi(r) {
              const i = r.value,
                o = r.valueSpec,
                l = r.styleSpec;
              return o.expression && Iu(mi(i))
                ? Dc(r)
                : o.expression && Zo(Bi(i))
                ? Ci(r)
                : o.type && Ha[o.type]
                ? Ha[o.type](r)
                : To(Vo({}, r, { valueSpec: o.type ? l[o.type] : o }));
            }
            function ki(r) {
              const i = r.value,
                o = r.key,
                l = Qs(r);
              return (
                l.length ||
                  (-1 === i.indexOf("{fontstack}") &&
                    l.push(
                      new ct(
                        o,
                        i,
                        '"glyphs" url must include a "{fontstack}" token'
                      )
                    ),
                  -1 === i.indexOf("{range}") &&
                    l.push(
                      new ct(
                        o,
                        i,
                        '"glyphs" url must include a "{range}" token'
                      )
                    )),
                l
              );
            }
            function Yh(r, i = Ae) {
              return Or(
                yi({
                  key: "",
                  value: r,
                  valueSpec: i.$root,
                  styleSpec: i,
                  style: r,
                  objectElementValidators: { glyphs: ki, "*": () => [] },
                })
              );
            }
            const Sc = (r) => Or(Xh(r)),
              Xo = (r) => Or(gp(r));
            function Or(r) {
              return r
                .slice()
                .sort((i, o) => (i.line && o.line ? i.line - o.line : 0));
            }
            function Lu(r, i) {
              let o = !1;
              if (i && i.length)
                for (const l of i)
                  r.fire(new us(new Error(l.message))), (o = !0);
              return o;
            }
            var Ng = ms;
            function ms(r, i, o) {
              var l = (this.cells = []);
              if (r instanceof ArrayBuffer) {
                this.arrayBuffer = r;
                var h = new Int32Array(this.arrayBuffer);
                (r = h[0]), (this.d = (i = h[1]) + 2 * (o = h[2]));
                for (var m = 0; m < this.d * this.d; m++) {
                  var _ = h[3 + m],
                    x = h[3 + m + 1];
                  l.push(_ === x ? null : h.subarray(_, x));
                }
                var E = h[3 + l.length + 1];
                (this.keys = h.subarray(h[3 + l.length], E)),
                  (this.bboxes = h.subarray(E)),
                  (this.insert = this._insertReadonly);
              } else {
                this.d = i + 2 * o;
                for (var T = 0; T < this.d * this.d; T++) l.push([]);
                (this.keys = []), (this.bboxes = []);
              }
              (this.n = i),
                (this.extent = r),
                (this.padding = o),
                (this.scale = i / r),
                (this.uid = 0);
              var I = (o / i) * r;
              (this.min = -I), (this.max = r + I);
            }
            (ms.prototype.insert = function (r, i, o, l, h) {
              this._forEachCell(i, o, l, h, this._insertCell, this.uid++),
                this.keys.push(r),
                this.bboxes.push(i),
                this.bboxes.push(o),
                this.bboxes.push(l),
                this.bboxes.push(h);
            }),
              (ms.prototype._insertReadonly = function () {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
              }),
              (ms.prototype._insertCell = function (r, i, o, l, h, m) {
                this.cells[h].push(m);
              }),
              (ms.prototype.query = function (r, i, o, l, h) {
                var m = this.min,
                  _ = this.max;
                if (r <= m && i <= m && _ <= o && _ <= l && !h)
                  return Array.prototype.slice.call(this.keys);
                var x = [];
                return (
                  this._forEachCell(r, i, o, l, this._queryCell, x, {}, h), x
                );
              }),
              (ms.prototype._queryCell = function (r, i, o, l, h, m, _, x) {
                var E = this.cells[h];
                if (null !== E)
                  for (
                    var T = this.keys, I = this.bboxes, A = 0;
                    A < E.length;
                    A++
                  ) {
                    var L = E[A];
                    if (void 0 === _[L]) {
                      var O = 4 * L;
                      (
                        x
                          ? x(I[O + 0], I[O + 1], I[O + 2], I[O + 3])
                          : r <= I[O + 2] &&
                            i <= I[O + 3] &&
                            o >= I[O + 0] &&
                            l >= I[O + 1]
                      )
                        ? ((_[L] = !0), m.push(T[L]))
                        : (_[L] = !1);
                    }
                  }
              }),
              (ms.prototype._forEachCell = function (r, i, o, l, h, m, _, x) {
                for (
                  var E = this._convertToCellCoord(r),
                    T = this._convertToCellCoord(i),
                    I = this._convertToCellCoord(o),
                    A = this._convertToCellCoord(l),
                    L = E;
                  L <= I;
                  L++
                )
                  for (var O = T; O <= A; O++) {
                    var F = this.d * O + L;
                    if (
                      (!x ||
                        x(
                          this._convertFromCellCoord(L),
                          this._convertFromCellCoord(O),
                          this._convertFromCellCoord(L + 1),
                          this._convertFromCellCoord(O + 1)
                        )) &&
                      h.call(this, r, i, o, l, F, m, _, x)
                    )
                      return;
                  }
              }),
              (ms.prototype._convertFromCellCoord = function (r) {
                return (r - this.padding) / this.scale;
              }),
              (ms.prototype._convertToCellCoord = function (r) {
                return Math.max(
                  0,
                  Math.min(
                    this.d - 1,
                    Math.floor(r * this.scale) + this.padding
                  )
                );
              }),
              (ms.prototype.toArrayBuffer = function () {
                if (this.arrayBuffer) return this.arrayBuffer;
                for (
                  var r = this.cells,
                    i = 3 + this.cells.length + 1 + 1,
                    o = 0,
                    l = 0;
                  l < this.cells.length;
                  l++
                )
                  o += this.cells[l].length;
                var h = new Int32Array(
                  i + o + this.keys.length + this.bboxes.length
                );
                (h[0] = this.extent), (h[1] = this.n), (h[2] = this.padding);
                for (var m = i, _ = 0; _ < r.length; _++) {
                  var x = r[_];
                  (h[3 + _] = m), h.set(x, m), (m += x.length);
                }
                return (
                  (h[3 + r.length] = m),
                  h.set(this.keys, m),
                  (h[3 + r.length + 1] = m += this.keys.length),
                  h.set(this.bboxes, m),
                  (m += this.bboxes.length),
                  h.buffer
                );
              });
            var Js = Ur(Ng);
            const $i = {};
            function lt(r, i, o = {}) {
              Object.defineProperty(r, "_classRegistryKey", {
                value: i,
                writeable: !1,
              }),
                ($i[i] = { klass: r, omit: o.omit || [] });
            }
            lt(Object, "Object"),
              (Js.serialize = function (r, i) {
                const o = r.toArrayBuffer();
                return i && i.push(o), { buffer: o };
              }),
              (Js.deserialize = function (r) {
                return new Js(r.buffer);
              }),
              Object.defineProperty(Js, "name", { value: "Grid" }),
              lt(Js, "Grid"),
              lt(gi, "Color"),
              lt(Error, "Error"),
              lt(Vs, "AJAXError"),
              lt(_o, "ResolvedImage"),
              lt(Tc, "StylePropertyFunction"),
              lt(Mu, "StyleExpression", { omit: ["_evaluator"] }),
              lt(Ec, "ZoomDependentExpression"),
              lt($h, "ZoomConstantExpression"),
              lt(Uo, "CompoundExpression", { omit: ["_evaluate"] });
            for (const r in Su)
              $i[Su[r]._classRegistryKey] || lt(Su[r], `Expression${r}`);
            function ku(r) {
              return (
                r &&
                typeof ArrayBuffer < "u" &&
                (r instanceof ArrayBuffer ||
                  (r.constructor && "ArrayBuffer" === r.constructor.name))
              );
            }
            function ea(r) {
              return Be.ImageBitmap && r instanceof Be.ImageBitmap;
            }
            function Fr(r, i) {
              if (
                null == r ||
                "boolean" == typeof r ||
                "number" == typeof r ||
                "string" == typeof r ||
                r instanceof Boolean ||
                r instanceof Number ||
                r instanceof String ||
                r instanceof Date ||
                r instanceof RegExp
              )
                return r;
              if (ku(r) || ea(r)) return i && i.push(r), r;
              if (ArrayBuffer.isView(r)) {
                const o = r;
                return i && i.push(o.buffer), o;
              }
              if (r instanceof Be.ImageData)
                return i && i.push(r.data.buffer), r;
              if (Array.isArray(r)) {
                const o = [];
                for (const l of r) o.push(Fr(l, i));
                return o;
              }
              if ("object" == typeof r) {
                const o = r.constructor,
                  l = o._classRegistryKey;
                if (!l)
                  throw new Error(
                    `can't serialize object of unregistered class ${l}`
                  );
                const h = o.serialize ? o.serialize(r, i) : {};
                if (!o.serialize) {
                  for (const m in r)
                    r.hasOwnProperty(m) &&
                      ($i[l].omit.indexOf(m) >= 0 || (h[m] = Fr(r[m], i)));
                  r instanceof Error && (h.message = r.message);
                }
                if (h.$name)
                  throw new Error(
                    "$name property is reserved for worker serialization logic."
                  );
                return "Object" !== l && (h.$name = l), h;
              }
              throw new Error("can't serialize object of type " + typeof r);
            }
            function Ga(r) {
              if (
                null == r ||
                "boolean" == typeof r ||
                "number" == typeof r ||
                "string" == typeof r ||
                r instanceof Boolean ||
                r instanceof Number ||
                r instanceof String ||
                r instanceof Date ||
                r instanceof RegExp ||
                ku(r) ||
                ea(r) ||
                ArrayBuffer.isView(r) ||
                r instanceof Be.ImageData
              )
                return r;
              if (Array.isArray(r)) return r.map(Ga);
              if ("object" == typeof r) {
                const i = r.$name || "Object",
                  { klass: o } = $i[i];
                if (!o)
                  throw new Error(`can't deserialize unregistered class ${i}`);
                if (o.deserialize) return o.deserialize(r);
                const l = Object.create(o.prototype);
                for (const h of Object.keys(r))
                  "$name" !== h && (l[h] = Ga(r[h]));
                return l;
              }
              throw new Error("can't deserialize object of type " + typeof r);
            }
            const at_Latin_1_Supplement = (r) => r >= 128 && r <= 255,
              at_Arabic = (r) => r >= 1536 && r <= 1791,
              at_Arabic_Supplement = (r) => r >= 1872 && r <= 1919,
              at_Arabic_Extended_A = (r) => r >= 2208 && r <= 2303,
              at_Hangul_Jamo = (r) => r >= 4352 && r <= 4607,
              at_Unified_Canadian_Aboriginal_Syllabics = (r) =>
                r >= 5120 && r <= 5759,
              at_Khmer = (r) => r >= 6016 && r <= 6143,
              at_Unified_Canadian_Aboriginal_Syllabics_Extended = (r) =>
                r >= 6320 && r <= 6399,
              at_General_Punctuation = (r) => r >= 8192 && r <= 8303,
              at_Letterlike_Symbols = (r) => r >= 8448 && r <= 8527,
              at_Number_Forms = (r) => r >= 8528 && r <= 8591,
              at_Miscellaneous_Technical = (r) => r >= 8960 && r <= 9215,
              at_Control_Pictures = (r) => r >= 9216 && r <= 9279,
              at_Optical_Character_Recognition = (r) => r >= 9280 && r <= 9311,
              at_Enclosed_Alphanumerics = (r) => r >= 9312 && r <= 9471,
              at_Geometric_Shapes = (r) => r >= 9632 && r <= 9727,
              at_Miscellaneous_Symbols = (r) => r >= 9728 && r <= 9983,
              at_Miscellaneous_Symbols_and_Arrows = (r) =>
                r >= 11008 && r <= 11263,
              at_CJK_Radicals_Supplement = (r) => r >= 11904 && r <= 12031,
              at_Kangxi_Radicals = (r) => r >= 12032 && r <= 12255,
              at_Ideographic_Description_Characters = (r) =>
                r >= 12272 && r <= 12287,
              at_CJK_Symbols_and_Punctuation = (r) => r >= 12288 && r <= 12351,
              at_Hiragana = (r) => r >= 12352 && r <= 12447,
              at_Katakana = (r) => r >= 12448 && r <= 12543,
              at_Bopomofo = (r) => r >= 12544 && r <= 12591,
              at_Hangul_Compatibility_Jamo = (r) => r >= 12592 && r <= 12687,
              at_Kanbun = (r) => r >= 12688 && r <= 12703,
              at_Bopomofo_Extended = (r) => r >= 12704 && r <= 12735,
              at_CJK_Strokes = (r) => r >= 12736 && r <= 12783,
              at_Katakana_Phonetic_Extensions = (r) => r >= 12784 && r <= 12799,
              at_Enclosed_CJK_Letters_and_Months = (r) =>
                r >= 12800 && r <= 13055,
              at_CJK_Compatibility = (r) => r >= 13056 && r <= 13311,
              at_CJK_Unified_Ideographs_Extension_A = (r) =>
                r >= 13312 && r <= 19903,
              at_Yijing_Hexagram_Symbols = (r) => r >= 19904 && r <= 19967,
              at_CJK_Unified_Ideographs = (r) => r >= 19968 && r <= 40959,
              at_Yi_Syllables = (r) => r >= 40960 && r <= 42127,
              at_Yi_Radicals = (r) => r >= 42128 && r <= 42191,
              at_Hangul_Jamo_Extended_A = (r) => r >= 43360 && r <= 43391,
              at_Hangul_Syllables = (r) => r >= 44032 && r <= 55215,
              at_Hangul_Jamo_Extended_B = (r) => r >= 55216 && r <= 55295,
              at_Private_Use_Area = (r) => r >= 57344 && r <= 63743,
              at_CJK_Compatibility_Ideographs = (r) => r >= 63744 && r <= 64255,
              at_Arabic_Presentation_Forms_A = (r) => r >= 64336 && r <= 65023,
              at_Vertical_Forms = (r) => r >= 65040 && r <= 65055,
              at_CJK_Compatibility_Forms = (r) => r >= 65072 && r <= 65103,
              at_Small_Form_Variants = (r) => r >= 65104 && r <= 65135,
              at_Arabic_Presentation_Forms_B = (r) => r >= 65136 && r <= 65279,
              at_Halfwidth_and_Fullwidth_Forms = (r) =>
                r >= 65280 && r <= 65519;
            function Qh(r) {
              for (const i of r) if (Ic(i.charCodeAt(0))) return !0;
              return !1;
            }
            function $f(r) {
              for (const i of r) if (!Ru(i.charCodeAt(0))) return !1;
              return !0;
            }
            function Ru(r) {
              return !(
                at_Arabic(r) ||
                at_Arabic_Supplement(r) ||
                at_Arabic_Extended_A(r) ||
                at_Arabic_Presentation_Forms_A(r) ||
                at_Arabic_Presentation_Forms_B(r)
              );
            }
            function Ic(r) {
              return !(
                746 !== r &&
                747 !== r &&
                (r < 4352 ||
                  !(
                    at_Bopomofo_Extended(r) ||
                    at_Bopomofo(r) ||
                    (at_CJK_Compatibility_Forms(r) &&
                      !(r >= 65097 && r <= 65103)) ||
                    at_CJK_Compatibility_Ideographs(r) ||
                    at_CJK_Compatibility(r) ||
                    at_CJK_Radicals_Supplement(r) ||
                    at_CJK_Strokes(r) ||
                    !(
                      !at_CJK_Symbols_and_Punctuation(r) ||
                      (r >= 12296 && r <= 12305) ||
                      (r >= 12308 && r <= 12319) ||
                      12336 === r
                    ) ||
                    at_CJK_Unified_Ideographs_Extension_A(r) ||
                    at_CJK_Unified_Ideographs(r) ||
                    at_Enclosed_CJK_Letters_and_Months(r) ||
                    at_Hangul_Compatibility_Jamo(r) ||
                    at_Hangul_Jamo_Extended_A(r) ||
                    at_Hangul_Jamo_Extended_B(r) ||
                    at_Hangul_Jamo(r) ||
                    at_Hangul_Syllables(r) ||
                    at_Hiragana(r) ||
                    at_Ideographic_Description_Characters(r) ||
                    at_Kanbun(r) ||
                    at_Kangxi_Radicals(r) ||
                    at_Katakana_Phonetic_Extensions(r) ||
                    (at_Katakana(r) && 12540 !== r) ||
                    !(
                      !at_Halfwidth_and_Fullwidth_Forms(r) ||
                      65288 === r ||
                      65289 === r ||
                      65293 === r ||
                      (r >= 65306 && r <= 65310) ||
                      65339 === r ||
                      65341 === r ||
                      65343 === r ||
                      (r >= 65371 && r <= 65503) ||
                      65507 === r ||
                      (r >= 65512 && r <= 65519)
                    ) ||
                    !(
                      !at_Small_Form_Variants(r) ||
                      (r >= 65112 && r <= 65118) ||
                      (r >= 65123 && r <= 65126)
                    ) ||
                    at_Unified_Canadian_Aboriginal_Syllabics(r) ||
                    at_Unified_Canadian_Aboriginal_Syllabics_Extended(r) ||
                    at_Vertical_Forms(r) ||
                    at_Yijing_Hexagram_Symbols(r) ||
                    at_Yi_Syllables(r) ||
                    at_Yi_Radicals(r)
                  ))
              );
            }
            function Jh(r) {
              return !(
                Ic(r) ||
                ((i = r),
                (at_Latin_1_Supplement(i) &&
                  (167 === i ||
                    169 === i ||
                    174 === i ||
                    177 === i ||
                    188 === i ||
                    189 === i ||
                    190 === i ||
                    215 === i ||
                    247 === i)) ||
                  (at_General_Punctuation(i) &&
                    (8214 === i ||
                      8224 === i ||
                      8225 === i ||
                      8240 === i ||
                      8241 === i ||
                      8251 === i ||
                      8252 === i ||
                      8258 === i ||
                      8263 === i ||
                      8264 === i ||
                      8265 === i ||
                      8273 === i)) ||
                  at_Letterlike_Symbols(i) ||
                  at_Number_Forms(i) ||
                  (at_Miscellaneous_Technical(i) &&
                    ((i >= 8960 && i <= 8967) ||
                      (i >= 8972 && i <= 8991) ||
                      (i >= 8996 && i <= 9e3) ||
                      9003 === i ||
                      (i >= 9085 && i <= 9114) ||
                      (i >= 9150 && i <= 9165) ||
                      9167 === i ||
                      (i >= 9169 && i <= 9179) ||
                      (i >= 9186 && i <= 9215))) ||
                  (at_Control_Pictures(i) && 9251 !== i) ||
                  at_Optical_Character_Recognition(i) ||
                  at_Enclosed_Alphanumerics(i) ||
                  at_Geometric_Shapes(i) ||
                  (at_Miscellaneous_Symbols(i) && !(i >= 9754 && i <= 9759)) ||
                  (at_Miscellaneous_Symbols_and_Arrows(i) &&
                    ((i >= 11026 && i <= 11055) ||
                      (i >= 11088 && i <= 11097) ||
                      (i >= 11192 && i <= 11243))) ||
                  at_CJK_Symbols_and_Punctuation(i) ||
                  at_Katakana(i) ||
                  at_Private_Use_Area(i) ||
                  at_CJK_Compatibility_Forms(i) ||
                  at_Small_Form_Variants(i) ||
                  at_Halfwidth_and_Fullwidth_Forms(i) ||
                  8734 === i ||
                  8756 === i ||
                  8757 === i ||
                  (i >= 9984 && i <= 10087) ||
                  (i >= 10102 && i <= 10131) ||
                  65532 === i ||
                  65533 === i)
              );
              var i;
            }
            function Ou(r) {
              return (
                (r >= 1424 && r <= 2303) ||
                at_Arabic_Presentation_Forms_A(r) ||
                at_Arabic_Presentation_Forms_B(r)
              );
            }
            function Hf(r, i) {
              return !(
                (!i && Ou(r)) ||
                (r >= 2304 && r <= 3583) ||
                (r >= 3840 && r <= 4255) ||
                at_Khmer(r)
              );
            }
            function xp(r) {
              for (const i of r) if (Ou(i.charCodeAt(0))) return !0;
              return !1;
            }
            const Mc = "deferred",
              Fu = "loading",
              Nu = "loaded";
            let qa = null,
              f = "unavailable",
              a = null;
            const u = function (r) {
              r &&
                "string" == typeof r &&
                r.indexOf("NetworkError") > -1 &&
                (f = "error"),
                qa && qa(r);
            };
            function g() {
              v.fire(
                new Ra("pluginStateChange", { pluginStatus: f, pluginURL: a })
              );
            }
            const v = new pc(),
              b = function () {
                return f;
              },
              D = function () {
                if (f !== Mc || !a)
                  throw new Error(
                    "rtl-text-plugin cannot be downloaded unless a pluginURL is specified"
                  );
                (f = Fu),
                  g(),
                  a &&
                    Tl({ url: a }, (r) => {
                      r ? u(r) : ((f = Nu), g());
                    });
              },
              S = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: () => f === Nu || null != S.applyArabicShaping,
                isLoading: () => f === Fu,
                setState(r) {
                  (f = r.pluginStatus), (a = r.pluginURL);
                },
                isParsed: () =>
                  null != S.applyArabicShaping &&
                  null != S.processBidirectionalText &&
                  null != S.processStyledBidirectionalText,
                getPluginURL: () => a,
              };
            class M {
              constructor(i, o) {
                (this.zoom = i),
                  o
                    ? ((this.now = o.now),
                      (this.fadeDuration = o.fadeDuration),
                      (this.transition = o.transition),
                      (this.pitch = o.pitch))
                    : ((this.now = 0),
                      (this.fadeDuration = 0),
                      (this.transition = {}),
                      (this.pitch = 0));
              }
              isSupportedScript(i) {
                return (function (o, l) {
                  for (const h of o) if (!Hf(h.charCodeAt(0), l)) return !1;
                  return !0;
                })(i, S.isLoaded());
              }
            }
            class R {
              constructor(i, o) {
                (this.property = i),
                  (this.value = o),
                  (this.expression = (function (l, h) {
                    if (Iu(l)) return new Tc(l, h);
                    if (Zo(l)) {
                      const m = Fl(l, h);
                      if ("error" === m.result)
                        throw new Error(
                          m.value
                            .map((_) => `${_.key}: ${_.message}`)
                            .join(", ")
                        );
                      return m.value;
                    }
                    {
                      let m = l;
                      return (
                        "string" == typeof l &&
                          "color" === h.type &&
                          (m = gi.parse(l)),
                        { kind: "constant", evaluate: () => m }
                      );
                    }
                  })(
                    void 0 === o ? i.specification.default : o,
                    i.specification
                  ));
              }
              isDataDriven() {
                return (
                  "source" === this.expression.kind ||
                  "composite" === this.expression.kind
                );
              }
              possiblyEvaluate(i, o, l) {
                return this.property.possiblyEvaluate(this, i, o, l);
              }
            }
            class k {
              constructor(i) {
                (this.property = i), (this.value = new R(i, void 0));
              }
              transitioned(i, o) {
                return new H(
                  this.property,
                  this.value,
                  o,
                  pi({}, i.transition, this.transition),
                  i.now
                );
              }
              untransitioned() {
                return new H(this.property, this.value, null, {}, 0);
              }
            }
            class z {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(
                    i.defaultTransitionablePropertyValues
                  ));
              }
              getValue(i) {
                return $r(this._values[i].value.value);
              }
              setValue(i, o) {
                this._values.hasOwnProperty(i) ||
                  (this._values[i] = new k(this._values[i].property)),
                  (this._values[i].value = new R(
                    this._values[i].property,
                    null === o ? void 0 : $r(o)
                  ));
              }
              getTransition(i) {
                return $r(this._values[i].transition);
              }
              setTransition(i, o) {
                this._values.hasOwnProperty(i) ||
                  (this._values[i] = new k(this._values[i].property)),
                  (this._values[i].transition = $r(o) || void 0);
              }
              serialize() {
                const i = {};
                for (const o of Object.keys(this._values)) {
                  const l = this.getValue(o);
                  void 0 !== l && (i[o] = l);
                  const h = this.getTransition(o);
                  void 0 !== h && (i[`${o}-transition`] = h);
                }
                return i;
              }
              transitioned(i, o) {
                const l = new q(this._properties);
                for (const h of Object.keys(this._values))
                  l._values[h] = this._values[h].transitioned(i, o._values[h]);
                return l;
              }
              untransitioned() {
                const i = new q(this._properties);
                for (const o of Object.keys(this._values))
                  i._values[o] = this._values[o].untransitioned();
                return i;
              }
            }
            class H {
              constructor(i, o, l, h, m) {
                const _ = h.delay || 0,
                  x = h.duration || 0;
                (m = m || 0),
                  (this.property = i),
                  (this.value = o),
                  (this.begin = m + _),
                  (this.end = this.begin + x),
                  i.specification.transition &&
                    (h.delay || h.duration) &&
                    (this.prior = l);
              }
              possiblyEvaluate(i, o, l) {
                const h = i.now || 0,
                  m = this.value.possiblyEvaluate(i, o, l),
                  _ = this.prior;
                if (_) {
                  if (h > this.end) return (this.prior = null), m;
                  if (this.value.isDataDriven()) return (this.prior = null), m;
                  if (h < this.begin) return _.possiblyEvaluate(i, o, l);
                  {
                    const x = (h - this.begin) / (this.end - this.begin);
                    return this.property.interpolate(
                      _.possiblyEvaluate(i, o, l),
                      m,
                      cu(x)
                    );
                  }
                }
                return m;
              }
            }
            class q {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(
                    i.defaultTransitioningPropertyValues
                  ));
              }
              possiblyEvaluate(i, o, l) {
                const h = new Y(this._properties);
                for (const m of Object.keys(this._values))
                  h._values[m] = this._values[m].possiblyEvaluate(i, o, l);
                return h;
              }
              hasTransition() {
                for (const i of Object.keys(this._values))
                  if (this._values[i].prior) return !0;
                return !1;
              }
            }
            class X {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(i.defaultPropertyValues));
              }
              getValue(i) {
                return $r(this._values[i].value);
              }
              setValue(i, o) {
                this._values[i] = new R(
                  this._values[i].property,
                  null === o ? void 0 : $r(o)
                );
              }
              serialize() {
                const i = {};
                for (const o of Object.keys(this._values)) {
                  const l = this.getValue(o);
                  void 0 !== l && (i[o] = l);
                }
                return i;
              }
              possiblyEvaluate(i, o, l) {
                const h = new Y(this._properties);
                for (const m of Object.keys(this._values))
                  h._values[m] = this._values[m].possiblyEvaluate(i, o, l);
                return h;
              }
            }
            class Z {
              constructor(i, o, l) {
                (this.property = i), (this.value = o), (this.parameters = l);
              }
              isConstant() {
                return "constant" === this.value.kind;
              }
              constantOr(i) {
                return "constant" === this.value.kind ? this.value.value : i;
              }
              evaluate(i, o, l, h) {
                return this.property.evaluate(
                  this.value,
                  this.parameters,
                  i,
                  o,
                  l,
                  h
                );
              }
            }
            class Y {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(
                    i.defaultPossiblyEvaluatedValues
                  ));
              }
              get(i) {
                return this._values[i];
              }
            }
            class B {
              constructor(i) {
                this.specification = i;
              }
              possiblyEvaluate(i, o) {
                return i.expression.evaluate(o);
              }
              interpolate(i, o, l) {
                const h = Pi[this.specification.type];
                return h ? h(i, o, l) : i;
              }
            }
            class W {
              constructor(i, o) {
                (this.specification = i), (this.overrides = o);
              }
              possiblyEvaluate(i, o, l, h) {
                return new Z(
                  this,
                  "constant" === i.expression.kind ||
                  "camera" === i.expression.kind
                    ? {
                        kind: "constant",
                        value: i.expression.evaluate(o, null, {}, l, h),
                      }
                    : i.expression,
                  o
                );
              }
              interpolate(i, o, l) {
                if ("constant" !== i.value.kind || "constant" !== o.value.kind)
                  return i;
                if (void 0 === i.value.value || void 0 === o.value.value)
                  return new Z(
                    this,
                    { kind: "constant", value: void 0 },
                    i.parameters
                  );
                const h = Pi[this.specification.type];
                return h
                  ? new Z(
                      this,
                      {
                        kind: "constant",
                        value: h(i.value.value, o.value.value, l),
                      },
                      i.parameters
                    )
                  : i;
              }
              evaluate(i, o, l, h, m, _) {
                return "constant" === i.kind
                  ? i.value
                  : i.evaluate(o, l, h, m, _);
              }
            }
            class ee {
              constructor(i) {
                this.specification = i;
              }
              possiblyEvaluate(i, o, l, h) {
                return !!i.expression.evaluate(o, null, {}, l, h);
              }
              interpolate() {
                return !1;
              }
            }
            class te {
              constructor(i) {
                (this.properties = i),
                  (this.defaultPropertyValues = {}),
                  (this.defaultTransitionablePropertyValues = {}),
                  (this.defaultTransitioningPropertyValues = {}),
                  (this.defaultPossiblyEvaluatedValues = {}),
                  (this.overridableProperties = []);
                const o = new M(0, {});
                for (const l in i) {
                  const h = i[l];
                  h.specification.overridable &&
                    this.overridableProperties.push(l);
                  const m = (this.defaultPropertyValues[l] = new R(h, void 0)),
                    _ = (this.defaultTransitionablePropertyValues[l] = new k(
                      h
                    ));
                  (this.defaultTransitioningPropertyValues[l] =
                    _.untransitioned()),
                    (this.defaultPossiblyEvaluatedValues[l] =
                      m.possiblyEvaluate(o));
                }
              }
            }
            function he(r, i) {
              return (
                256 * (r = tn(Math.floor(r), 0, 255)) +
                tn(Math.floor(i), 0, 255)
              );
            }
            lt(W, "DataDrivenProperty"),
              lt(B, "DataConstantProperty"),
              lt(ee, "ColorRampProperty");
            const de = {
              Int8: Int8Array,
              Uint8: Uint8Array,
              Int16: Int16Array,
              Uint16: Uint16Array,
              Int32: Int32Array,
              Uint32: Uint32Array,
              Float32: Float32Array,
            };
            class ue {
              constructor(i, o) {
                (this._structArray = i),
                  (this._pos1 = o * this.size),
                  (this._pos2 = this._pos1 / 2),
                  (this._pos4 = this._pos1 / 4),
                  (this._pos8 = this._pos1 / 8);
              }
            }
            class _e {
              constructor() {
                (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
              }
              static serialize(i, o) {
                return (
                  i._trim(),
                  o && ((i.isTransferred = !0), o.push(i.arrayBuffer)),
                  { length: i.length, arrayBuffer: i.arrayBuffer }
                );
              }
              static deserialize(i) {
                const o = Object.create(this.prototype);
                return (
                  (o.arrayBuffer = i.arrayBuffer),
                  (o.length = i.length),
                  (o.capacity = i.arrayBuffer.byteLength / o.bytesPerElement),
                  o._refreshViews(),
                  o
                );
              }
              _trim() {
                this.length !== this.capacity &&
                  ((this.capacity = this.length),
                  (this.arrayBuffer = this.arrayBuffer.slice(
                    0,
                    this.length * this.bytesPerElement
                  )),
                  this._refreshViews());
              }
              clear() {
                this.length = 0;
              }
              resize(i) {
                this.reserve(i), (this.length = i);
              }
              reserve(i) {
                if (i > this.capacity) {
                  (this.capacity = Math.max(
                    i,
                    Math.floor(5 * this.capacity),
                    128
                  )),
                    (this.arrayBuffer = new ArrayBuffer(
                      this.capacity * this.bytesPerElement
                    ));
                  const o = this.uint8;
                  this._refreshViews(), o && this.uint8.set(o);
                }
              }
              _refreshViews() {
                throw new Error(
                  "_refreshViews() must be implemented by each concrete StructArray layout"
                );
              }
              destroy() {
                (this.int8 =
                  this.uint8 =
                  this.int16 =
                  this.uint16 =
                  this.int32 =
                  this.uint32 =
                  this.float32 =
                    null),
                  (this.arrayBuffer = null);
              }
            }
            function ge(r, i = 1) {
              let o = 0,
                l = 0;
              return {
                members: r.map((h) => {
                  const m = de[h.type].BYTES_PER_ELEMENT,
                    _ = (o = Te(o, Math.max(i, m))),
                    x = h.components || 1;
                  return (
                    (l = Math.max(l, m)),
                    (o += m * x),
                    { name: h.name, type: h.type, components: x, offset: _ }
                  );
                }),
                size: Te(o, Math.max(l, i)),
                alignment: i,
              };
            }
            function Te(r, i) {
              return Math.ceil(r / i) * i;
            }
            class Ge extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o) {
                const l = this.length;
                return this.resize(l + 1), this.emplace(l, i, o);
              }
              emplace(i, o, l) {
                const h = 2 * i;
                return (this.int16[h + 0] = o), (this.int16[h + 1] = l), i;
              }
            }
            (Ge.prototype.bytesPerElement = 4), lt(Ge, "StructArrayLayout2i4");
            class be extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, i, o, l);
              }
              emplace(i, o, l, h) {
                const m = 3 * i;
                return (
                  (this.int16[m + 0] = o),
                  (this.int16[m + 1] = l),
                  (this.int16[m + 2] = h),
                  i
                );
              }
            }
            (be.prototype.bytesPerElement = 6), lt(be, "StructArrayLayout3i6");
            class Le extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 4 * i;
                return (
                  (this.int16[_ + 0] = o),
                  (this.int16[_ + 1] = l),
                  (this.int16[_ + 2] = h),
                  (this.int16[_ + 3] = m),
                  i
                );
              }
            }
            (Le.prototype.bytesPerElement = 8), lt(Le, "StructArrayLayout4i8");
            class Se extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x) {
                const E = this.length;
                return this.resize(E + 1), this.emplace(E, i, o, l, h, m, _, x);
              }
              emplace(i, o, l, h, m, _, x, E) {
                const T = 6 * i,
                  I = 12 * i,
                  A = 3 * i;
                return (
                  (this.int16[T + 0] = o),
                  (this.int16[T + 1] = l),
                  (this.uint8[I + 4] = h),
                  (this.uint8[I + 5] = m),
                  (this.uint8[I + 6] = _),
                  (this.uint8[I + 7] = x),
                  (this.float32[A + 2] = E),
                  i
                );
              }
            }
            (Se.prototype.bytesPerElement = 12),
              lt(Se, "StructArrayLayout2i4ub1f12");
            class je extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 4 * i;
                return (
                  (this.float32[_ + 0] = o),
                  (this.float32[_ + 1] = l),
                  (this.float32[_ + 2] = h),
                  (this.float32[_ + 3] = m),
                  i
                );
              }
            }
            (je.prototype.bytesPerElement = 16),
              lt(je, "StructArrayLayout4f16");
            class we extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, i, o, l, h, m);
              }
              emplace(i, o, l, h, m, _) {
                const x = 6 * i,
                  E = 3 * i;
                return (
                  (this.uint16[x + 0] = o),
                  (this.uint16[x + 1] = l),
                  (this.uint16[x + 2] = h),
                  (this.uint16[x + 3] = m),
                  (this.float32[E + 2] = _),
                  i
                );
              }
            }
            (we.prototype.bytesPerElement = 12),
              lt(we, "StructArrayLayout4ui1f12");
            class ke extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 4 * i;
                return (
                  (this.uint16[_ + 0] = o),
                  (this.uint16[_ + 1] = l),
                  (this.uint16[_ + 2] = h),
                  (this.uint16[_ + 3] = m),
                  i
                );
              }
            }
            (ke.prototype.bytesPerElement = 8), lt(ke, "StructArrayLayout4ui8");
            class He extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _) {
                const x = this.length;
                return this.resize(x + 1), this.emplace(x, i, o, l, h, m, _);
              }
              emplace(i, o, l, h, m, _, x) {
                const E = 6 * i;
                return (
                  (this.int16[E + 0] = o),
                  (this.int16[E + 1] = l),
                  (this.int16[E + 2] = h),
                  (this.int16[E + 3] = m),
                  (this.int16[E + 4] = _),
                  (this.int16[E + 5] = x),
                  i
                );
              }
            }
            (He.prototype.bytesPerElement = 12),
              lt(He, "StructArrayLayout6i12");
            class Ne extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x, E, T, I, A, L) {
                const O = this.length;
                return (
                  this.resize(O + 1),
                  this.emplace(O, i, o, l, h, m, _, x, E, T, I, A, L)
                );
              }
              emplace(i, o, l, h, m, _, x, E, T, I, A, L, O) {
                const F = 12 * i;
                return (
                  (this.int16[F + 0] = o),
                  (this.int16[F + 1] = l),
                  (this.int16[F + 2] = h),
                  (this.int16[F + 3] = m),
                  (this.uint16[F + 4] = _),
                  (this.uint16[F + 5] = x),
                  (this.uint16[F + 6] = E),
                  (this.uint16[F + 7] = T),
                  (this.int16[F + 8] = I),
                  (this.int16[F + 9] = A),
                  (this.int16[F + 10] = L),
                  (this.int16[F + 11] = O),
                  i
                );
              }
            }
            (Ne.prototype.bytesPerElement = 24),
              lt(Ne, "StructArrayLayout4i4ui4i24");
            class Xe extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _) {
                const x = this.length;
                return this.resize(x + 1), this.emplace(x, i, o, l, h, m, _);
              }
              emplace(i, o, l, h, m, _, x) {
                const E = 10 * i,
                  T = 5 * i;
                return (
                  (this.int16[E + 0] = o),
                  (this.int16[E + 1] = l),
                  (this.int16[E + 2] = h),
                  (this.float32[T + 2] = m),
                  (this.float32[T + 3] = _),
                  (this.float32[T + 4] = x),
                  i
                );
              }
            }
            (Xe.prototype.bytesPerElement = 20),
              lt(Xe, "StructArrayLayout3i3f20");
            class mt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(i) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, i);
              }
              emplace(i, o) {
                return (this.uint32[1 * i + 0] = o), i;
              }
            }
            (mt.prototype.bytesPerElement = 4), lt(mt, "StructArrayLayout1ul4");
            class It extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x, E, T, I, A, L, O) {
                const F = this.length;
                return (
                  this.resize(F + 1),
                  this.emplace(F, i, o, l, h, m, _, x, E, T, I, A, L, O)
                );
              }
              emplace(i, o, l, h, m, _, x, E, T, I, A, L, O, F) {
                const V = 20 * i,
                  G = 10 * i;
                return (
                  (this.int16[V + 0] = o),
                  (this.int16[V + 1] = l),
                  (this.int16[V + 2] = h),
                  (this.int16[V + 3] = m),
                  (this.int16[V + 4] = _),
                  (this.float32[G + 3] = x),
                  (this.float32[G + 4] = E),
                  (this.float32[G + 5] = T),
                  (this.float32[G + 6] = I),
                  (this.int16[V + 14] = A),
                  (this.uint32[G + 8] = L),
                  (this.uint16[V + 18] = O),
                  (this.uint16[V + 19] = F),
                  i
                );
              }
            }
            (It.prototype.bytesPerElement = 40),
              lt(It, "StructArrayLayout5i4f1i1ul2ui40");
            class dt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x) {
                const E = this.length;
                return this.resize(E + 1), this.emplace(E, i, o, l, h, m, _, x);
              }
              emplace(i, o, l, h, m, _, x, E) {
                const T = 8 * i;
                return (
                  (this.int16[T + 0] = o),
                  (this.int16[T + 1] = l),
                  (this.int16[T + 2] = h),
                  (this.int16[T + 4] = m),
                  (this.int16[T + 5] = _),
                  (this.int16[T + 6] = x),
                  (this.int16[T + 7] = E),
                  i
                );
              }
            }
            (dt.prototype.bytesPerElement = 16),
              lt(dt, "StructArrayLayout3i2i2i16");
            class Dt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, i, o, l, h, m);
              }
              emplace(i, o, l, h, m, _) {
                const x = 4 * i,
                  E = 8 * i;
                return (
                  (this.float32[x + 0] = o),
                  (this.float32[x + 1] = l),
                  (this.float32[x + 2] = h),
                  (this.int16[E + 6] = m),
                  (this.int16[E + 7] = _),
                  i
                );
              }
            }
            (Dt.prototype.bytesPerElement = 16),
              lt(Dt, "StructArrayLayout2f1f2i16");
            class Kt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 12 * i,
                  x = 3 * i;
                return (
                  (this.uint8[_ + 0] = o),
                  (this.uint8[_ + 1] = l),
                  (this.float32[x + 1] = h),
                  (this.float32[x + 2] = m),
                  i
                );
              }
            }
            (Kt.prototype.bytesPerElement = 12),
              lt(Kt, "StructArrayLayout2ub2f12");
            class Ht extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, i, o, l);
              }
              emplace(i, o, l, h) {
                const m = 3 * i;
                return (
                  (this.float32[m + 0] = o),
                  (this.float32[m + 1] = l),
                  (this.float32[m + 2] = h),
                  i
                );
              }
            }
            (Ht.prototype.bytesPerElement = 12),
              lt(Ht, "StructArrayLayout3f12");
            class _t extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, i, o, l);
              }
              emplace(i, o, l, h) {
                const m = 3 * i;
                return (
                  (this.uint16[m + 0] = o),
                  (this.uint16[m + 1] = l),
                  (this.uint16[m + 2] = h),
                  i
                );
              }
            }
            (_t.prototype.bytesPerElement = 6), lt(_t, "StructArrayLayout3ui6");
            class en extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                I,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le
              ) {
                const ae = this.length;
                return (
                  this.resize(ae + 1),
                  this.emplace(
                    ae,
                    i,
                    o,
                    l,
                    h,
                    m,
                    _,
                    x,
                    E,
                    T,
                    I,
                    A,
                    L,
                    O,
                    F,
                    V,
                    G,
                    K,
                    oe,
                    J,
                    re,
                    le
                  )
                );
              }
              emplace(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                I,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le,
                ae
              ) {
                const De = 30 * i,
                  xe = 15 * i,
                  Pe = 60 * i;
                return (
                  (this.int16[De + 0] = o),
                  (this.int16[De + 1] = l),
                  (this.int16[De + 2] = h),
                  (this.float32[xe + 2] = m),
                  (this.float32[xe + 3] = _),
                  (this.uint16[De + 8] = x),
                  (this.uint16[De + 9] = E),
                  (this.uint32[xe + 5] = T),
                  (this.uint32[xe + 6] = I),
                  (this.uint32[xe + 7] = A),
                  (this.uint16[De + 16] = L),
                  (this.uint16[De + 17] = O),
                  (this.uint16[De + 18] = F),
                  (this.float32[xe + 10] = V),
                  (this.float32[xe + 11] = G),
                  (this.uint8[Pe + 48] = K),
                  (this.uint8[Pe + 49] = oe),
                  (this.uint8[Pe + 50] = J),
                  (this.uint32[xe + 13] = re),
                  (this.int16[De + 28] = le),
                  (this.uint8[Pe + 58] = ae),
                  i
                );
              }
            }
            (en.prototype.bytesPerElement = 60),
              lt(en, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
            class On extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                I,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le,
                ae,
                De,
                xe,
                Pe,
                $e,
                Ie,
                Fe,
                Re,
                Ve
              ) {
                const qe = this.length;
                return (
                  this.resize(qe + 1),
                  this.emplace(
                    qe,
                    i,
                    o,
                    l,
                    h,
                    m,
                    _,
                    x,
                    E,
                    T,
                    I,
                    A,
                    L,
                    O,
                    F,
                    V,
                    G,
                    K,
                    oe,
                    J,
                    re,
                    le,
                    ae,
                    De,
                    xe,
                    Pe,
                    $e,
                    Ie,
                    Fe,
                    Re,
                    Ve
                  )
                );
              }
              emplace(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                I,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le,
                ae,
                De,
                xe,
                Pe,
                $e,
                Ie,
                Fe,
                Re,
                Ve,
                qe
              ) {
                const Me = 38 * i,
                  tt = 19 * i;
                return (
                  (this.int16[Me + 0] = o),
                  (this.int16[Me + 1] = l),
                  (this.int16[Me + 2] = h),
                  (this.float32[tt + 2] = m),
                  (this.float32[tt + 3] = _),
                  (this.int16[Me + 8] = x),
                  (this.int16[Me + 9] = E),
                  (this.int16[Me + 10] = T),
                  (this.int16[Me + 11] = I),
                  (this.int16[Me + 12] = A),
                  (this.int16[Me + 13] = L),
                  (this.uint16[Me + 14] = O),
                  (this.uint16[Me + 15] = F),
                  (this.uint16[Me + 16] = V),
                  (this.uint16[Me + 17] = G),
                  (this.uint16[Me + 18] = K),
                  (this.uint16[Me + 19] = oe),
                  (this.uint16[Me + 20] = J),
                  (this.uint16[Me + 21] = re),
                  (this.uint16[Me + 22] = le),
                  (this.uint16[Me + 23] = ae),
                  (this.uint16[Me + 24] = De),
                  (this.uint16[Me + 25] = xe),
                  (this.uint16[Me + 26] = Pe),
                  (this.uint16[Me + 27] = $e),
                  (this.uint16[Me + 28] = Ie),
                  (this.uint32[tt + 15] = Fe),
                  (this.float32[tt + 16] = Re),
                  (this.float32[tt + 17] = Ve),
                  (this.float32[tt + 18] = qe),
                  i
                );
              }
            }
            (On.prototype.bytesPerElement = 76),
              lt(On, "StructArrayLayout3i2f6i15ui1ul3f76");
            class _n extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, i);
              }
              emplace(i, o) {
                return (this.float32[1 * i + 0] = o), i;
              }
            }
            (_n.prototype.bytesPerElement = 4), lt(_n, "StructArrayLayout1f4");
            class Sn extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, i, o, l, h, m);
              }
              emplace(i, o, l, h, m, _) {
                const x = 5 * i;
                return (
                  (this.float32[x + 0] = o),
                  (this.float32[x + 1] = l),
                  (this.float32[x + 2] = h),
                  (this.float32[x + 3] = m),
                  (this.float32[x + 4] = _),
                  i
                );
              }
            }
            (Sn.prototype.bytesPerElement = 20),
              lt(Sn, "StructArrayLayout5f20");
            class Hi extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 6 * i;
                return (
                  (this.uint32[3 * i + 0] = o),
                  (this.uint16[_ + 2] = l),
                  (this.uint16[_ + 3] = h),
                  (this.uint16[_ + 4] = m),
                  i
                );
              }
            }
            (Hi.prototype.bytesPerElement = 12),
              lt(Hi, "StructArrayLayout1ul3ui12");
            class vi extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o) {
                const l = this.length;
                return this.resize(l + 1), this.emplace(l, i, o);
              }
              emplace(i, o, l) {
                const h = 2 * i;
                return (this.uint16[h + 0] = o), (this.uint16[h + 1] = l), i;
              }
            }
            (vi.prototype.bytesPerElement = 4), lt(vi, "StructArrayLayout2ui4");
            class Er extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, i);
              }
              emplace(i, o) {
                return (this.uint16[1 * i + 0] = o), i;
              }
            }
            (Er.prototype.bytesPerElement = 2), lt(Er, "StructArrayLayout1ui2");
            class Ko extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o) {
                const l = this.length;
                return this.resize(l + 1), this.emplace(l, i, o);
              }
              emplace(i, o, l) {
                const h = 2 * i;
                return (this.float32[h + 0] = o), (this.float32[h + 1] = l), i;
              }
            }
            (Ko.prototype.bytesPerElement = 8), lt(Ko, "StructArrayLayout2f8");
            class Hn extends ue {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
              }
              get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get x1() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get y1() {
                return this._structArray.float32[this._pos4 + 4];
              }
              get x2() {
                return this._structArray.float32[this._pos4 + 5];
              }
              get y2() {
                return this._structArray.float32[this._pos4 + 6];
              }
              get padding() {
                return this._structArray.int16[this._pos2 + 14];
              }
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
            }
            Hn.prototype.size = 40;
            class Pn extends It {
              get(i) {
                return new Hn(this, i);
              }
            }
            lt(Pn, "CollisionBoxArray");
            class hn extends ue {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
              }
              get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
              }
              get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
              }
              get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
              }
              get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
              }
              get segment() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
              }
              get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
              }
              get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
              }
              get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
              }
              set placedOrientation(i) {
                this._structArray.uint8[this._pos1 + 49] = i;
              }
              get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
              }
              set hidden(i) {
                this._structArray.uint8[this._pos1 + 50] = i;
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
              }
              set crossTileID(i) {
                this._structArray.uint32[this._pos4 + 13] = i;
              }
              get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
              }
              get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
              }
              set flipState(i) {
                this._structArray.uint8[this._pos1 + 58] = i;
              }
            }
            hn.prototype.size = 60;
            class si extends en {
              get(i) {
                return new hn(this, i);
              }
            }
            lt(si, "PlacedSymbolArray");
            class Tr extends ue {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
              }
              get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
              }
              get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
              }
              get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
              }
              get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
              }
              get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13];
              }
              get key() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
              }
              get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
              get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20];
              }
              get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21];
              }
              get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22];
              }
              get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23];
              }
              get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
              }
              get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25];
              }
              get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
              }
              get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27];
              }
              get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28];
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15];
              }
              set crossTileID(i) {
                this._structArray.uint32[this._pos4 + 15] = i;
              }
              get textOffset0() {
                return this._structArray.float32[this._pos4 + 16];
              }
              get textOffset1() {
                return this._structArray.float32[this._pos4 + 17];
              }
              get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18];
              }
            }
            Tr.prototype.size = 76;
            class Fn extends On {
              get(i) {
                return new Tr(this, i);
              }
            }
            lt(Fn, "SymbolInstanceArray");
            class Gi extends _n {
              getoffsetX(i) {
                return this.float32[1 * i + 0];
              }
            }
            lt(Gi, "GlyphOffsetArray");
            class zu extends Ge {
              getx(i) {
                return this.int16[2 * i + 0];
              }
              gety(i) {
                return this.int16[2 * i + 1];
              }
            }
            lt(zu, "SymbolLineVertexArray");
            class ta extends ue {
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
              }
              get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
              }
            }
            ta.prototype.size = 12;
            class Bl extends Hi {
              get(i) {
                return new ta(this, i);
              }
            }
            lt(Bl, "FeatureIndexArray");
            class Nr extends vi {
              geta_centroid_pos0(i) {
                return this.uint16[2 * i + 0];
              }
              geta_centroid_pos1(i) {
                return this.uint16[2 * i + 1];
              }
            }
            lt(Nr, "FillExtrusionCentroidArray");
            const na = ge([
                { name: "a_pattern", components: 4, type: "Uint16" },
                { name: "a_pixel_ratio", components: 1, type: "Float32" },
              ]),
              Wa = ge([{ name: "a_dash", components: 4, type: "Uint16" }]);
            var Vl = { exports: {} },
              Pc = function (r, i) {
                var o, l, h, m, _, x, E, T;
                for (
                  l = r.length - (o = 3 & r.length),
                    h = i,
                    _ = 3432918353,
                    x = 461845907,
                    T = 0;
                  T < l;

                )
                  (E =
                    (255 & r.charCodeAt(T)) |
                    ((255 & r.charCodeAt(++T)) << 8) |
                    ((255 & r.charCodeAt(++T)) << 16) |
                    ((255 & r.charCodeAt(++T)) << 24)),
                    ++T,
                    (h =
                      27492 +
                      (65535 &
                        (m =
                          (5 *
                            (65535 &
                              (h =
                                ((h ^= E =
                                  ((65535 &
                                    (E =
                                      ((E =
                                        ((65535 & E) * _ +
                                          ((((E >>> 16) * _) & 65535) << 16)) &
                                        4294967295) <<
                                        15) |
                                      (E >>> 17))) *
                                    x +
                                    ((((E >>> 16) * x) & 65535) << 16)) &
                                  4294967295) <<
                                  13) |
                                (h >>> 19))) +
                            (((5 * (h >>> 16)) & 65535) << 16)) &
                          4294967295)) +
                      (((58964 + (m >>> 16)) & 65535) << 16));
                switch (((E = 0), o)) {
                  case 3:
                    E ^= (255 & r.charCodeAt(T + 2)) << 16;
                  case 2:
                    E ^= (255 & r.charCodeAt(T + 1)) << 8;
                  case 1:
                    h ^= E =
                      ((65535 &
                        (E =
                          ((E =
                            ((65535 & (E ^= 255 & r.charCodeAt(T))) * _ +
                              ((((E >>> 16) * _) & 65535) << 16)) &
                            4294967295) <<
                            15) |
                          (E >>> 17))) *
                        x +
                        ((((E >>> 16) * x) & 65535) << 16)) &
                      4294967295;
                }
                return (
                  (h ^= r.length),
                  (h =
                    (2246822507 * (65535 & (h ^= h >>> 16)) +
                      (((2246822507 * (h >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (h =
                    (3266489909 * (65535 & (h ^= h >>> 13)) +
                      (((3266489909 * (h >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (h ^= h >>> 16) >>> 0
                );
              },
              Vu = function (r, i) {
                for (var o, l = r.length, h = i ^ l, m = 0; l >= 4; )
                  (o =
                    1540483477 *
                      (65535 &
                        (o =
                          (255 & r.charCodeAt(m)) |
                          ((255 & r.charCodeAt(++m)) << 8) |
                          ((255 & r.charCodeAt(++m)) << 16) |
                          ((255 & r.charCodeAt(++m)) << 24))) +
                    (((1540483477 * (o >>> 16)) & 65535) << 16)),
                    (h =
                      (1540483477 * (65535 & h) +
                        (((1540483477 * (h >>> 16)) & 65535) << 16)) ^
                      (o =
                        1540483477 * (65535 & (o ^= o >>> 24)) +
                        (((1540483477 * (o >>> 16)) & 65535) << 16))),
                    (l -= 4),
                    ++m;
                switch (l) {
                  case 3:
                    h ^= (255 & r.charCodeAt(m + 2)) << 16;
                  case 2:
                    h ^= (255 & r.charCodeAt(m + 1)) << 8;
                  case 1:
                    h =
                      1540483477 * (65535 & (h ^= 255 & r.charCodeAt(m))) +
                      (((1540483477 * (h >>> 16)) & 65535) << 16);
                }
                return (
                  (h =
                    1540483477 * (65535 & (h ^= h >>> 13)) +
                    (((1540483477 * (h >>> 16)) & 65535) << 16)),
                  (h ^= h >>> 15) >>> 0
                );
              };
            (Vl.exports = Pc),
              (Vl.exports.murmur3 = Pc),
              (Vl.exports.murmur2 = Vu);
            var jl = Ur(Vl.exports);
            class ed {
              constructor() {
                (this.ids = []), (this.positions = []), (this.indexed = !1);
              }
              add(i, o, l, h) {
                this.ids.push(wp(i)), this.positions.push(o, l, h);
              }
              getPositions(i) {
                const o = wp(i);
                let l = 0,
                  h = this.ids.length - 1;
                for (; l < h; ) {
                  const _ = (l + h) >> 1;
                  this.ids[_] >= o ? (h = _) : (l = _ + 1);
                }
                const m = [];
                for (; this.ids[l] === o; )
                  m.push({
                    index: this.positions[3 * l],
                    start: this.positions[3 * l + 1],
                    end: this.positions[3 * l + 2],
                  }),
                    l++;
                return m;
              }
              static serialize(i, o) {
                const l = new Float64Array(i.ids),
                  h = new Uint32Array(i.positions);
                return (
                  Ul(l, h, 0, l.length - 1),
                  o && o.push(l.buffer, h.buffer),
                  { ids: l, positions: h }
                );
              }
              static deserialize(i) {
                const o = new ed();
                return (
                  (o.ids = i.ids),
                  (o.positions = i.positions),
                  (o.indexed = !0),
                  o
                );
              }
            }
            function wp(r) {
              const i = +r;
              return !isNaN(i) &&
                Number.MIN_SAFE_INTEGER <= i &&
                i <= Number.MAX_SAFE_INTEGER
                ? i
                : jl(String(r));
            }
            function Ul(r, i, o, l) {
              for (; o < l; ) {
                const h = r[(o + l) >> 1];
                let m = o - 1,
                  _ = l + 1;
                for (;;) {
                  do {
                    m++;
                  } while (r[m] < h);
                  do {
                    _--;
                  } while (r[_] > h);
                  if (m >= _) break;
                  Gf(r, m, _),
                    Gf(i, 3 * m, 3 * _),
                    Gf(i, 3 * m + 1, 3 * _ + 1),
                    Gf(i, 3 * m + 2, 3 * _ + 2);
                }
                _ - o < l - _
                  ? (Ul(r, i, o, _), (o = _ + 1))
                  : (Ul(r, i, _ + 1, l), (l = _));
              }
            }
            function Gf(r, i, o) {
              const l = r[i];
              (r[i] = r[o]), (r[o] = l);
            }
            lt(ed, "FeaturePositionMap");
            class Za {
              constructor(i) {
                (this.gl = i.gl), (this.initialized = !1);
              }
              fetchUniformLocation(i, o) {
                return (
                  this.location ||
                    this.initialized ||
                    ((this.location = this.gl.getUniformLocation(i, o)),
                    (this.initialized = !0)),
                  !!this.location
                );
              }
            }
            class sn extends Za {
              constructor(i) {
                super(i), (this.current = 0);
              }
              set(i, o, l) {
                this.fetchUniformLocation(i, o) &&
                  this.current !== l &&
                  ((this.current = l), this.gl.uniform1f(this.location, l));
              }
            }
            class fv extends Za {
              constructor(i) {
                super(i), (this.current = [0, 0, 0, 0]);
              }
              set(i, o, l) {
                this.fetchUniformLocation(i, o) &&
                  ((l[0] === this.current[0] &&
                    l[1] === this.current[1] &&
                    l[2] === this.current[2] &&
                    l[3] === this.current[3]) ||
                    ((this.current = l),
                    this.gl.uniform4f(this.location, l[0], l[1], l[2], l[3])));
              }
            }
            class mv extends Za {
              constructor(i) {
                super(i), (this.current = gi.transparent);
              }
              set(i, o, l) {
                this.fetchUniformLocation(i, o) &&
                  ((l.r === this.current.r &&
                    l.g === this.current.g &&
                    l.b === this.current.b &&
                    l.a === this.current.a) ||
                    ((this.current = l),
                    this.gl.uniform4f(this.location, l.r, l.g, l.b, l.a)));
              }
            }
            const mb = new Float32Array(16),
              gb = new Float32Array(9),
              _b = new Float32Array(4);
            function zg(r) {
              return [he(255 * r.r, 255 * r.g), he(255 * r.b, 255 * r.a)];
            }
            class Ep {
              constructor(i, o, l) {
                (this.value = i),
                  (this.uniformNames = o.map((h) => `u_${h}`)),
                  (this.type = l);
              }
              setUniform(i, o, l, h, m) {
                o.set(i, m, h.constantOr(this.value));
              }
              getBinding(i, o) {
                return "color" === this.type ? new mv(i) : new sn(i);
              }
            }
            class ia {
              constructor(i, o) {
                (this.uniformNames = o.map((l) => `u_${l}`)),
                  (this.pattern = null),
                  (this.pixelRatio = 1);
              }
              setConstantPatternPositions(i) {
                (this.pixelRatio = i.pixelRatio || 1),
                  (this.pattern = i.tl.concat(i.br));
              }
              setUniform(i, o, l, h, m) {
                const _ =
                  "u_pattern" === m || "u_dash" === m
                    ? this.pattern
                    : "u_pixel_ratio" === m
                    ? this.pixelRatio
                    : null;
                _ && o.set(i, m, _);
              }
              getBinding(i, o) {
                return "u_pattern" === o || "u_dash" === o
                  ? new fv(i)
                  : new sn(i);
              }
            }
            class $l {
              constructor(i, o, l, h) {
                (this.expression = i),
                  (this.type = l),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = o.map((m) => ({
                    name: `a_${m}`,
                    type: "Float32",
                    components: "color" === l ? 2 : 1,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new h());
              }
              populatePaintArray(i, o, l, h, m, _) {
                const x = this.paintVertexArray.length,
                  E = this.expression.evaluate(new M(0), o, {}, m, h, _);
                this.paintVertexArray.resize(i), this._setPaintValue(x, i, E);
              }
              updatePaintArray(i, o, l, h, m) {
                const _ = this.expression.evaluate(
                  { zoom: 0 },
                  l,
                  h,
                  void 0,
                  m
                );
                this._setPaintValue(i, o, _);
              }
              _setPaintValue(i, o, l) {
                if ("color" === this.type) {
                  const h = zg(l);
                  for (let m = i; m < o; m++)
                    this.paintVertexArray.emplace(m, h[0], h[1]);
                } else {
                  for (let h = i; h < o; h++)
                    this.paintVertexArray.emplace(h, l);
                  this.maxValue = Math.max(this.maxValue, Math.abs(l));
                }
              }
              upload(i) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = i.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class ra {
              constructor(i, o, l, h, m, _) {
                (this.expression = i),
                  (this.uniformNames = o.map((x) => `u_${x}_t`)),
                  (this.type = l),
                  (this.useIntegerZoom = h),
                  (this.zoom = m),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = o.map((x) => ({
                    name: `a_${x}`,
                    type: "Float32",
                    components: "color" === l ? 4 : 2,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new _());
              }
              populatePaintArray(i, o, l, h, m, _) {
                const x = this.expression.evaluate(
                    new M(this.zoom),
                    o,
                    {},
                    m,
                    h,
                    _
                  ),
                  E = this.expression.evaluate(
                    new M(this.zoom + 1),
                    o,
                    {},
                    m,
                    h,
                    _
                  ),
                  T = this.paintVertexArray.length;
                this.paintVertexArray.resize(i),
                  this._setPaintValue(T, i, x, E);
              }
              updatePaintArray(i, o, l, h, m) {
                const _ = this.expression.evaluate(
                    { zoom: this.zoom },
                    l,
                    h,
                    void 0,
                    m
                  ),
                  x = this.expression.evaluate(
                    { zoom: this.zoom + 1 },
                    l,
                    h,
                    void 0,
                    m
                  );
                this._setPaintValue(i, o, _, x);
              }
              _setPaintValue(i, o, l, h) {
                if ("color" === this.type) {
                  const m = zg(l),
                    _ = zg(h);
                  for (let x = i; x < o; x++)
                    this.paintVertexArray.emplace(x, m[0], m[1], _[0], _[1]);
                } else {
                  for (let m = i; m < o; m++)
                    this.paintVertexArray.emplace(m, l, h);
                  this.maxValue = Math.max(
                    this.maxValue,
                    Math.abs(l),
                    Math.abs(h)
                  );
                }
              }
              upload(i) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = i.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
              setUniform(i, o, l, h, m) {
                const _ = this.useIntegerZoom ? Math.floor(l.zoom) : l.zoom,
                  x = tn(
                    this.expression.interpolationFactor(
                      _,
                      this.zoom,
                      this.zoom + 1
                    ),
                    0,
                    1
                  );
                o.set(i, m, x);
              }
              getBinding(i, o) {
                return new sn(i);
              }
            }
            class Yn {
              constructor(i, o, l, h, m) {
                (this.expression = i),
                  (this.layerId = m),
                  (this.paintVertexAttributes = (
                    "array" === l ? Wa : na
                  ).members);
                for (let _ = 0; _ < o.length; ++_);
                this.paintVertexArray = new h();
              }
              populatePaintArray(i, o, l) {
                const h = this.paintVertexArray.length;
                this.paintVertexArray.resize(i),
                  this._setPaintValues(
                    h,
                    i,
                    o.patterns && o.patterns[this.layerId],
                    l
                  );
              }
              updatePaintArray(i, o, l, h, m, _) {
                this._setPaintValues(
                  i,
                  o,
                  l.patterns && l.patterns[this.layerId],
                  _
                );
              }
              _setPaintValues(i, o, l, h) {
                if (!h || !l) return;
                const m = h[l];
                if (!m) return;
                const { tl: _, br: x, pixelRatio: E } = m;
                for (let T = i; T < o; T++)
                  this.paintVertexArray.emplace(T, _[0], _[1], x[0], x[1], E);
              }
              upload(i) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer = i.createVertexBuffer(
                    this.paintVertexArray,
                    this.paintVertexAttributes,
                    this.expression.isStateDependent
                  ));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class oa {
              constructor(i, o, l = () => !0) {
                (this.binders = {}), (this._buffers = []);
                const h = [];
                for (const m in i.paint._values) {
                  if (!l(m)) continue;
                  const _ = i.paint.get(m);
                  if (!(_ instanceof Z && bc(_.property.specification)))
                    continue;
                  const x = gv(m, i.type),
                    E = _.value,
                    T = _.property.specification.type,
                    I = !!_.property.useIntegerZoom,
                    A = "line-dasharray" === m || m.endsWith("pattern"),
                    L =
                      "line-dasharray" === m &&
                      "constant" !== i.layout.get("line-cap").value.kind;
                  if ("constant" !== E.kind || L)
                    if ("source" === E.kind || L || A) {
                      const O = qf(m, T, "source");
                      (this.binders[m] = A
                        ? new Yn(E, x, T, O, i.id)
                        : new $l(E, x, T, O)),
                        h.push(`/a_${m}`);
                    } else {
                      const O = qf(m, T, "composite");
                      (this.binders[m] = new ra(E, x, T, I, o, O)),
                        h.push(`/z_${m}`);
                    }
                  else
                    (this.binders[m] = A
                      ? new ia(E.value, x)
                      : new Ep(E.value, x, T)),
                      h.push(`/u_${m}`);
                }
                this.cacheKey = h.sort().join("");
              }
              getMaxValue(i) {
                const o = this.binders[i];
                return o instanceof $l || o instanceof ra ? o.maxValue : 0;
              }
              populatePaintArrays(i, o, l, h, m, _) {
                for (const x in this.binders) {
                  const E = this.binders[x];
                  (E instanceof $l || E instanceof ra || E instanceof Yn) &&
                    E.populatePaintArray(i, o, l, h, m, _);
                }
              }
              setConstantPatternPositions(i) {
                for (const o in this.binders) {
                  const l = this.binders[o];
                  l instanceof ia && l.setConstantPatternPositions(i);
                }
              }
              updatePaintArrays(i, o, l, h, m, _) {
                let x = !1;
                for (const E in i) {
                  const T = o.getPositions(E);
                  for (const I of T) {
                    const A = l.feature(I.index);
                    for (const L in this.binders) {
                      const O = this.binders[L];
                      if (
                        (O instanceof $l ||
                          O instanceof ra ||
                          O instanceof Yn) &&
                        !0 === O.expression.isStateDependent
                      ) {
                        const F = h.paint.get(L);
                        (O.expression = F.value),
                          O.updatePaintArray(I.start, I.end, A, i[E], m, _),
                          (x = !0);
                      }
                    }
                  }
                }
                return x;
              }
              defines() {
                const i = [];
                for (const o in this.binders) {
                  const l = this.binders[o];
                  (l instanceof Ep || l instanceof ia) &&
                    i.push(
                      ...l.uniformNames.map((h) => `#define HAS_UNIFORM_${h}`)
                    );
                }
                return i;
              }
              getBinderAttributes() {
                const i = [];
                for (const o in this.binders) {
                  const l = this.binders[o];
                  if (l instanceof $l || l instanceof ra || l instanceof Yn)
                    for (let h = 0; h < l.paintVertexAttributes.length; h++)
                      i.push(l.paintVertexAttributes[h].name);
                }
                return i;
              }
              getBinderUniforms() {
                const i = [];
                for (const o in this.binders) {
                  const l = this.binders[o];
                  if (l instanceof Ep || l instanceof ia || l instanceof ra)
                    for (const h of l.uniformNames) i.push(h);
                }
                return i;
              }
              getPaintVertexBuffers() {
                return this._buffers;
              }
              getUniforms(i) {
                const o = [];
                for (const l in this.binders) {
                  const h = this.binders[l];
                  if (h instanceof Ep || h instanceof ia || h instanceof ra)
                    for (const m of h.uniformNames)
                      o.push({
                        name: m,
                        property: l,
                        binding: h.getBinding(i, m),
                      });
                }
                return o;
              }
              setUniforms(i, o, l, h, m) {
                for (const { name: _, property: x, binding: E } of l)
                  this.binders[x].setUniform(i, E, m, h.get(x), _);
              }
              updatePaintBuffers() {
                this._buffers = [];
                for (const i in this.binders) {
                  const o = this.binders[i];
                  (o instanceof $l || o instanceof ra || o instanceof Yn) &&
                    o.paintVertexBuffer &&
                    this._buffers.push(o.paintVertexBuffer);
                }
              }
              upload(i) {
                for (const o in this.binders) {
                  const l = this.binders[o];
                  (l instanceof $l || l instanceof ra || l instanceof Yn) &&
                    l.upload(i);
                }
                this.updatePaintBuffers();
              }
              destroy() {
                for (const i in this.binders) {
                  const o = this.binders[i];
                  (o instanceof $l || o instanceof ra || o instanceof Yn) &&
                    o.destroy();
                }
              }
            }
            class gs {
              constructor(i, o, l = () => !0) {
                this.programConfigurations = {};
                for (const h of i)
                  this.programConfigurations[h.id] = new oa(h, o, l);
                (this.needsUpload = !1),
                  (this._featureMap = new ed()),
                  (this._bufferOffset = 0);
              }
              populatePaintArrays(i, o, l, h, m, _, x) {
                for (const E in this.programConfigurations)
                  this.programConfigurations[E].populatePaintArrays(
                    i,
                    o,
                    h,
                    m,
                    _,
                    x
                  );
                void 0 !== o.id &&
                  this._featureMap.add(o.id, l, this._bufferOffset, i),
                  (this._bufferOffset = i),
                  (this.needsUpload = !0);
              }
              updatePaintArrays(i, o, l, h, m) {
                for (const _ of l)
                  this.needsUpload =
                    this.programConfigurations[_.id].updatePaintArrays(
                      i,
                      this._featureMap,
                      o,
                      _,
                      h,
                      m
                    ) || this.needsUpload;
              }
              get(i) {
                return this.programConfigurations[i];
              }
              upload(i) {
                if (this.needsUpload) {
                  for (const o in this.programConfigurations)
                    this.programConfigurations[o].upload(i);
                  this.needsUpload = !1;
                }
              }
              destroy() {
                for (const i in this.programConfigurations)
                  this.programConfigurations[i].destroy();
              }
            }
            const yb = {
              "text-opacity": ["opacity"],
              "icon-opacity": ["opacity"],
              "text-color": ["fill_color"],
              "icon-color": ["fill_color"],
              "text-halo-color": ["halo_color"],
              "icon-halo-color": ["halo_color"],
              "text-halo-blur": ["halo_blur"],
              "icon-halo-blur": ["halo_blur"],
              "text-halo-width": ["halo_width"],
              "icon-halo-width": ["halo_width"],
              "line-gap-width": ["gapwidth"],
              "line-pattern": ["pattern", "pixel_ratio"],
              "fill-pattern": ["pattern", "pixel_ratio"],
              "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
              "line-dasharray": ["dash"],
            };
            function gv(r, i) {
              return yb[r] || [r.replace(`${i}-`, "").replace(/-/g, "_")];
            }
            const So = {
                "line-pattern": { source: we, composite: we },
                "fill-pattern": { source: we, composite: we },
                "fill-extrusion-pattern": { source: we, composite: we },
                "line-dasharray": { source: ke, composite: ke },
              },
              Xa = {
                color: { source: Ko, composite: je },
                number: { source: _n, composite: Ko },
              };
            function qf(r, i, o) {
              const l = So[r];
              return (l && l[o]) || Xa[i][o];
            }
            lt(Ep, "ConstantBinder"),
              lt(ia, "PatternConstantBinder"),
              lt($l, "SourceExpressionBinder"),
              lt(Yn, "PatternCompositeBinder"),
              lt(ra, "CompositeExpressionBinder"),
              lt(oa, "ProgramConfiguration", { omit: ["_buffers"] }),
              lt(gs, "ProgramConfigurationSet");
            const td = "-transition";
            class Kr extends pc {
              constructor(i, o) {
                if (
                  (super(),
                  (this.id = i.id),
                  (this.type = i.type),
                  (this._featureFilter = {
                    filter: () => !0,
                    needGeometry: !1,
                    needFeature: !1,
                  }),
                  (this._filterCompiled = !1),
                  "custom" !== i.type &&
                    ((this.metadata = i.metadata),
                    (this.minzoom = i.minzoom),
                    (this.maxzoom = i.maxzoom),
                    "background" !== i.type &&
                      "sky" !== i.type &&
                      ((this.source = i.source),
                      (this.sourceLayer = i["source-layer"]),
                      (this.filter = i.filter)),
                    o.layout && (this._unevaluatedLayout = new X(o.layout)),
                    o.paint))
                ) {
                  this._transitionablePaint = new z(o.paint);
                  for (const l in i.paint)
                    this.setPaintProperty(l, i.paint[l], { validate: !1 });
                  for (const l in i.layout)
                    this.setLayoutProperty(l, i.layout[l], { validate: !1 });
                  (this._transitioningPaint =
                    this._transitionablePaint.untransitioned()),
                    (this.paint = new Y(o.paint));
                }
              }
              getLayoutProperty(i) {
                return "visibility" === i
                  ? this.visibility
                  : this._unevaluatedLayout.getValue(i);
              }
              setLayoutProperty(i, o, l = {}) {
                (null != o &&
                  this._validate(
                    Xo,
                    `layers.${this.id}.layout.${i}`,
                    i,
                    o,
                    l
                  )) ||
                  ("visibility" !== i
                    ? this._unevaluatedLayout.setValue(i, o)
                    : (this.visibility = o));
              }
              getPaintProperty(i) {
                return xl(i, td)
                  ? this._transitionablePaint.getTransition(i.slice(0, -11))
                  : this._transitionablePaint.getValue(i);
              }
              setPaintProperty(i, o, l = {}) {
                if (
                  null != o &&
                  this._validate(Sc, `layers.${this.id}.paint.${i}`, i, o, l)
                )
                  return !1;
                if (xl(i, td))
                  return (
                    this._transitionablePaint.setTransition(
                      i.slice(0, -11),
                      o || void 0
                    ),
                    !1
                  );
                {
                  const h = this._transitionablePaint._values[i],
                    m = h.value.isDataDriven(),
                    _ = h.value;
                  this._transitionablePaint.setValue(i, o),
                    this._handleSpecialPaintPropertyUpdate(i);
                  const x = this._transitionablePaint._values[i].value,
                    E = x.isDataDriven(),
                    T = xl(i, "pattern") || "line-dasharray" === i;
                  return (
                    E ||
                    m ||
                    T ||
                    this._handleOverridablePaintPropertyUpdate(i, _, x)
                  );
                }
              }
              _handleSpecialPaintPropertyUpdate(i) {}
              getProgramIds() {
                return null;
              }
              getProgramConfiguration(i) {
                return null;
              }
              _handleOverridablePaintPropertyUpdate(i, o, l) {
                return !1;
              }
              isHidden(i) {
                return (
                  !!(this.minzoom && i < this.minzoom) ||
                  !!(this.maxzoom && i >= this.maxzoom) ||
                  "none" === this.visibility
                );
              }
              updateTransitions(i) {
                this._transitioningPaint =
                  this._transitionablePaint.transitioned(
                    i,
                    this._transitioningPaint
                  );
              }
              hasTransition() {
                return this._transitioningPaint.hasTransition();
              }
              recalculate(i, o) {
                this._unevaluatedLayout &&
                  (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                    i,
                    void 0,
                    o
                  )),
                  (this.paint = this._transitioningPaint.possiblyEvaluate(
                    i,
                    void 0,
                    o
                  ));
              }
              serialize() {
                const i = {
                  id: this.id,
                  type: this.type,
                  source: this.source,
                  "source-layer": this.sourceLayer,
                  metadata: this.metadata,
                  minzoom: this.minzoom,
                  maxzoom: this.maxzoom,
                  filter: this.filter,
                  layout:
                    this._unevaluatedLayout &&
                    this._unevaluatedLayout.serialize(),
                  paint:
                    this._transitionablePaint &&
                    this._transitionablePaint.serialize(),
                };
                return (
                  this.visibility &&
                    ((i.layout = i.layout || {}),
                    (i.layout.visibility = this.visibility)),
                  Ns(
                    i,
                    (o, l) =>
                      !(
                        void 0 === o ||
                        ("layout" === l && !Object.keys(o).length) ||
                        ("paint" === l && !Object.keys(o).length)
                      )
                  )
                );
              }
              _validate(i, o, l, h, m = {}) {
                return (
                  (!m || !1 !== m.validate) &&
                  Lu(
                    this,
                    i.call(Yh, {
                      key: o,
                      layerType: this.type,
                      objectKey: l,
                      value: h,
                      styleSpec: Ae,
                      style: { glyphs: !0, sprite: !0 },
                    })
                  )
                );
              }
              is3D() {
                return !1;
              }
              isSky() {
                return !1;
              }
              isTileClipped() {
                return !1;
              }
              hasOffscreenPass() {
                return !1;
              }
              resize() {}
              isStateDependent() {
                for (const i in this.paint._values) {
                  const o = this.paint.get(i);
                  if (
                    o instanceof Z &&
                    bc(o.property.specification) &&
                    ("source" === o.value.kind ||
                      "composite" === o.value.kind) &&
                    o.value.isStateDependent
                  )
                    return !0;
                }
                return !1;
              }
              compileFilter() {
                this._filterCompiled ||
                  ((this._featureFilter = Pu(this.filter)),
                  (this._filterCompiled = !0));
              }
              invalidateCompiledFilter() {
                this._filterCompiled = !1;
              }
              dynamicFilter() {
                return this._featureFilter.dynamicFilter;
              }
              dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
              }
            }
            const Bg = ge([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              _v = ge([
                { name: "a_pos_3", components: 3, type: "Int16" },
                { name: "a_pos_normal_3", components: 3, type: "Int16" },
              ]);
            class xi {
              constructor(i = []) {
                this.segments = i;
              }
              prepareSegment(i, o, l, h) {
                let m = this.segments[this.segments.length - 1];
                return (
                  i > xi.MAX_VERTEX_ARRAY_LENGTH &&
                    Wn(
                      `Max vertices per segment is ${xi.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${i}`
                    ),
                  (!m ||
                    m.vertexLength + i > xi.MAX_VERTEX_ARRAY_LENGTH ||
                    m.sortKey !== h) &&
                    ((m = {
                      vertexOffset: o.length,
                      primitiveOffset: l.length,
                      vertexLength: 0,
                      primitiveLength: 0,
                    }),
                    void 0 !== h && (m.sortKey = h),
                    this.segments.push(m)),
                  m
                );
              }
              get() {
                return this.segments;
              }
              destroy() {
                for (const i of this.segments)
                  for (const o in i.vaos) i.vaos[o].destroy();
              }
              static simpleSegment(i, o, l, h) {
                return new xi([
                  {
                    vertexOffset: i,
                    primitiveOffset: o,
                    vertexLength: l,
                    primitiveLength: h,
                    vaos: {},
                    sortKey: 0,
                  },
                ]);
              }
            }
            (xi.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
              lt(xi, "SegmentVector");
            var wt = 8192;
            class Lc {
              constructor(i, o) {
                i &&
                  (o
                    ? this.setSouthWest(i).setNorthEast(o)
                    : 4 === i.length
                    ? this.setSouthWest([i[0], i[1]]).setNorthEast([i[2], i[3]])
                    : this.setSouthWest(i[0]).setNorthEast(i[1]));
              }
              setNorthEast(i) {
                return (
                  (this._ne =
                    i instanceof Ln ? new Ln(i.lng, i.lat) : Ln.convert(i)),
                  this
                );
              }
              setSouthWest(i) {
                return (
                  (this._sw =
                    i instanceof Ln ? new Ln(i.lng, i.lat) : Ln.convert(i)),
                  this
                );
              }
              extend(i) {
                const o = this._sw,
                  l = this._ne;
                let h, m;
                if (i instanceof Ln) (h = i), (m = i);
                else {
                  if (!(i instanceof Lc))
                    return Array.isArray(i)
                      ? 4 === i.length || i.every(Array.isArray)
                        ? this.extend(Lc.convert(i))
                        : this.extend(Ln.convert(i))
                      : "object" == typeof i &&
                        null !== i &&
                        i.hasOwnProperty("lat") &&
                        (i.hasOwnProperty("lon") || i.hasOwnProperty("lng"))
                      ? this.extend(Ln.convert(i))
                      : this;
                  if (((h = i._sw), (m = i._ne), !h || !m)) return this;
                }
                return (
                  o || l
                    ? ((o.lng = Math.min(h.lng, o.lng)),
                      (o.lat = Math.min(h.lat, o.lat)),
                      (l.lng = Math.max(m.lng, l.lng)),
                      (l.lat = Math.max(m.lat, l.lat)))
                    : ((this._sw = new Ln(h.lng, h.lat)),
                      (this._ne = new Ln(m.lng, m.lat))),
                  this
                );
              }
              getCenter() {
                return new Ln(
                  (this._sw.lng + this._ne.lng) / 2,
                  (this._sw.lat + this._ne.lat) / 2
                );
              }
              getSouthWest() {
                return this._sw;
              }
              getNorthEast() {
                return this._ne;
              }
              getNorthWest() {
                return new Ln(this.getWest(), this.getNorth());
              }
              getSouthEast() {
                return new Ln(this.getEast(), this.getSouth());
              }
              getWest() {
                return this._sw.lng;
              }
              getSouth() {
                return this._sw.lat;
              }
              getEast() {
                return this._ne.lng;
              }
              getNorth() {
                return this._ne.lat;
              }
              toArray() {
                return [this._sw.toArray(), this._ne.toArray()];
              }
              toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
              }
              isEmpty() {
                return !(this._sw && this._ne);
              }
              contains(i) {
                const { lng: o, lat: l } = Ln.convert(i);
                let h = this._sw.lng <= o && o <= this._ne.lng;
                return (
                  this._sw.lng > this._ne.lng &&
                    (h = this._sw.lng >= o && o >= this._ne.lng),
                  this._sw.lat <= l && l <= this._ne.lat && h
                );
              }
              static convert(i) {
                return !i || i instanceof Lc ? i : new Lc(i);
              }
            }
            var nd = 1e-6,
              Qn = typeof Float32Array < "u" ? Float32Array : Array;
            function Tp() {
              var r = new Qn(9);
              return (
                Qn != Float32Array &&
                  ((r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[5] = 0),
                  (r[6] = 0),
                  (r[7] = 0)),
                (r[0] = 1),
                (r[4] = 1),
                (r[8] = 1),
                r
              );
            }
            function kc(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = i[4],
                E = i[5],
                T = i[6],
                I = i[7],
                A = i[8],
                L = o[0],
                O = o[1],
                F = o[2],
                V = o[3],
                G = o[4],
                K = o[5],
                oe = o[6],
                J = o[7],
                re = o[8];
              return (
                (r[0] = L * l + O * _ + F * T),
                (r[1] = L * h + O * x + F * I),
                (r[2] = L * m + O * E + F * A),
                (r[3] = V * l + G * _ + K * T),
                (r[4] = V * h + G * x + K * I),
                (r[5] = V * m + G * E + K * A),
                (r[6] = oe * l + J * _ + re * T),
                (r[7] = oe * h + J * x + re * I),
                (r[8] = oe * m + J * E + re * A),
                r
              );
            }
            function sa(r) {
              return (
                (r[0] = 1),
                (r[1] = 0),
                (r[2] = 0),
                (r[3] = 0),
                (r[4] = 0),
                (r[5] = 1),
                (r[6] = 0),
                (r[7] = 0),
                (r[8] = 0),
                (r[9] = 0),
                (r[10] = 1),
                (r[11] = 0),
                (r[12] = 0),
                (r[13] = 0),
                (r[14] = 0),
                (r[15] = 1),
                r
              );
            }
            function Dp(r, i) {
              var o = i[0],
                l = i[1],
                h = i[2],
                m = i[3],
                _ = i[4],
                x = i[5],
                E = i[6],
                T = i[7],
                I = i[8],
                A = i[9],
                L = i[10],
                O = i[11],
                F = i[12],
                V = i[13],
                G = i[14],
                K = i[15],
                oe = o * x - l * _,
                J = o * E - h * _,
                re = o * T - m * _,
                le = l * E - h * x,
                ae = l * T - m * x,
                De = h * T - m * E,
                xe = I * V - A * F,
                Pe = I * G - L * F,
                $e = I * K - O * F,
                Ie = A * G - L * V,
                Fe = A * K - O * V,
                Re = L * K - O * G,
                Ve = oe * Re - J * Fe + re * Ie + le * $e - ae * Pe + De * xe;
              return Ve
                ? ((r[0] = (x * Re - E * Fe + T * Ie) * (Ve = 1 / Ve)),
                  (r[1] = (h * Fe - l * Re - m * Ie) * Ve),
                  (r[2] = (V * De - G * ae + K * le) * Ve),
                  (r[3] = (L * ae - A * De - O * le) * Ve),
                  (r[4] = (E * $e - _ * Re - T * Pe) * Ve),
                  (r[5] = (o * Re - h * $e + m * Pe) * Ve),
                  (r[6] = (G * re - F * De - K * J) * Ve),
                  (r[7] = (I * De - L * re + O * J) * Ve),
                  (r[8] = (_ * Fe - x * $e + T * xe) * Ve),
                  (r[9] = (l * $e - o * Fe - m * xe) * Ve),
                  (r[10] = (F * ae - V * re + K * oe) * Ve),
                  (r[11] = (A * re - I * ae - O * oe) * Ve),
                  (r[12] = (x * Pe - _ * Ie - E * xe) * Ve),
                  (r[13] = (o * Ie - l * Pe + h * xe) * Ve),
                  (r[14] = (V * J - F * le - G * oe) * Ve),
                  (r[15] = (I * le - A * J + L * oe) * Ve),
                  r)
                : null;
            }
            function Rc(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = i[4],
                E = i[5],
                T = i[6],
                I = i[7],
                A = i[8],
                L = i[9],
                O = i[10],
                F = i[11],
                V = i[12],
                G = i[13],
                K = i[14],
                oe = i[15],
                J = o[0],
                re = o[1],
                le = o[2],
                ae = o[3];
              return (
                (r[0] = J * l + re * x + le * A + ae * V),
                (r[1] = J * h + re * E + le * L + ae * G),
                (r[2] = J * m + re * T + le * O + ae * K),
                (r[3] = J * _ + re * I + le * F + ae * oe),
                (r[4] =
                  (J = o[4]) * l +
                  (re = o[5]) * x +
                  (le = o[6]) * A +
                  (ae = o[7]) * V),
                (r[5] = J * h + re * E + le * L + ae * G),
                (r[6] = J * m + re * T + le * O + ae * K),
                (r[7] = J * _ + re * I + le * F + ae * oe),
                (r[8] =
                  (J = o[8]) * l +
                  (re = o[9]) * x +
                  (le = o[10]) * A +
                  (ae = o[11]) * V),
                (r[9] = J * h + re * E + le * L + ae * G),
                (r[10] = J * m + re * T + le * O + ae * K),
                (r[11] = J * _ + re * I + le * F + ae * oe),
                (r[12] =
                  (J = o[12]) * l +
                  (re = o[13]) * x +
                  (le = o[14]) * A +
                  (ae = o[15]) * V),
                (r[13] = J * h + re * E + le * L + ae * G),
                (r[14] = J * m + re * T + le * O + ae * K),
                (r[15] = J * _ + re * I + le * F + ae * oe),
                r
              );
            }
            function id(r, i, o) {
              var l,
                h,
                m,
                _,
                x,
                E,
                T,
                I,
                A,
                L,
                O,
                F,
                V = o[0],
                G = o[1],
                K = o[2];
              return (
                i === r
                  ? ((r[12] = i[0] * V + i[4] * G + i[8] * K + i[12]),
                    (r[13] = i[1] * V + i[5] * G + i[9] * K + i[13]),
                    (r[14] = i[2] * V + i[6] * G + i[10] * K + i[14]),
                    (r[15] = i[3] * V + i[7] * G + i[11] * K + i[15]))
                  : ((h = i[1]),
                    (m = i[2]),
                    (_ = i[3]),
                    (x = i[4]),
                    (E = i[5]),
                    (T = i[6]),
                    (I = i[7]),
                    (A = i[8]),
                    (L = i[9]),
                    (O = i[10]),
                    (F = i[11]),
                    (r[0] = l = i[0]),
                    (r[1] = h),
                    (r[2] = m),
                    (r[3] = _),
                    (r[4] = x),
                    (r[5] = E),
                    (r[6] = T),
                    (r[7] = I),
                    (r[8] = A),
                    (r[9] = L),
                    (r[10] = O),
                    (r[11] = F),
                    (r[12] = l * V + x * G + A * K + i[12]),
                    (r[13] = h * V + E * G + L * K + i[13]),
                    (r[14] = m * V + T * G + O * K + i[14]),
                    (r[15] = _ * V + I * G + F * K + i[15])),
                r
              );
            }
            function Oc(r, i, o) {
              var l = o[0],
                h = o[1],
                m = o[2];
              return (
                (r[0] = i[0] * l),
                (r[1] = i[1] * l),
                (r[2] = i[2] * l),
                (r[3] = i[3] * l),
                (r[4] = i[4] * h),
                (r[5] = i[5] * h),
                (r[6] = i[6] * h),
                (r[7] = i[7] * h),
                (r[8] = i[8] * m),
                (r[9] = i[9] * m),
                (r[10] = i[10] * m),
                (r[11] = i[11] * m),
                (r[12] = i[12]),
                (r[13] = i[13]),
                (r[14] = i[14]),
                (r[15] = i[15]),
                r
              );
            }
            function Wf(r, i, o) {
              var l = Math.sin(o),
                h = Math.cos(o),
                m = i[4],
                _ = i[5],
                x = i[6],
                E = i[7],
                T = i[8],
                I = i[9],
                A = i[10],
                L = i[11];
              return (
                i !== r &&
                  ((r[0] = i[0]),
                  (r[1] = i[1]),
                  (r[2] = i[2]),
                  (r[3] = i[3]),
                  (r[12] = i[12]),
                  (r[13] = i[13]),
                  (r[14] = i[14]),
                  (r[15] = i[15])),
                (r[4] = m * h + T * l),
                (r[5] = _ * h + I * l),
                (r[6] = x * h + A * l),
                (r[7] = E * h + L * l),
                (r[8] = T * h - m * l),
                (r[9] = I * h - _ * l),
                (r[10] = A * h - x * l),
                (r[11] = L * h - E * l),
                r
              );
            }
            function Cp(r, i, o) {
              var l = Math.sin(o),
                h = Math.cos(o),
                m = i[0],
                _ = i[1],
                x = i[2],
                E = i[3],
                T = i[8],
                I = i[9],
                A = i[10],
                L = i[11];
              return (
                i !== r &&
                  ((r[4] = i[4]),
                  (r[5] = i[5]),
                  (r[6] = i[6]),
                  (r[7] = i[7]),
                  (r[12] = i[12]),
                  (r[13] = i[13]),
                  (r[14] = i[14]),
                  (r[15] = i[15])),
                (r[0] = m * h - T * l),
                (r[1] = _ * h - I * l),
                (r[2] = x * h - A * l),
                (r[3] = E * h - L * l),
                (r[8] = m * l + T * h),
                (r[9] = _ * l + I * h),
                (r[10] = x * l + A * h),
                (r[11] = E * l + L * h),
                r
              );
            }
            function Vg(r, i) {
              return (
                (r[0] = i[0]),
                (r[1] = 0),
                (r[2] = 0),
                (r[3] = 0),
                (r[4] = 0),
                (r[5] = i[1]),
                (r[6] = 0),
                (r[7] = 0),
                (r[8] = 0),
                (r[9] = 0),
                (r[10] = i[2]),
                (r[11] = 0),
                (r[12] = 0),
                (r[13] = 0),
                (r[14] = 0),
                (r[15] = 1),
                r
              );
            }
            function Sp(r, i, o) {
              var l,
                h,
                m,
                _ = o[0],
                x = o[1],
                E = o[2],
                T = Math.hypot(_, x, E);
              return T < nd
                ? null
                : ((_ *= T = 1 / T),
                  (x *= T),
                  (E *= T),
                  (l = Math.sin(i)),
                  (h = Math.cos(i)),
                  (r[0] = _ * _ * (m = 1 - h) + h),
                  (r[1] = x * _ * m + E * l),
                  (r[2] = E * _ * m - x * l),
                  (r[3] = 0),
                  (r[4] = _ * x * m - E * l),
                  (r[5] = x * x * m + h),
                  (r[6] = E * x * m + _ * l),
                  (r[7] = 0),
                  (r[8] = _ * E * m + x * l),
                  (r[9] = x * E * m - _ * l),
                  (r[10] = E * E * m + h),
                  (r[11] = 0),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[14] = 0),
                  (r[15] = 1),
                  r);
            }
            Math.hypot ||
              (Math.hypot = function () {
                for (var r = 0, i = arguments.length; i--; )
                  r += arguments[i] * arguments[i];
                return Math.sqrt(r);
              });
            var Ip = Rc;
            function jg() {
              var r = new Qn(3);
              return (
                Qn != Float32Array && ((r[0] = 0), (r[1] = 0), (r[2] = 0)), r
              );
            }
            function ju(r) {
              var i = new Qn(3);
              return (i[0] = r[0]), (i[1] = r[1]), (i[2] = r[2]), i;
            }
            function Fc(r) {
              return Math.hypot(r[0], r[1], r[2]);
            }
            function Ka(r, i, o) {
              var l = new Qn(3);
              return (l[0] = r), (l[1] = i), (l[2] = o), l;
            }
            function Ya(r, i, o) {
              return (
                (r[0] = i[0] + o[0]),
                (r[1] = i[1] + o[1]),
                (r[2] = i[2] + o[2]),
                r
              );
            }
            function Zf(r, i, o) {
              return (
                (r[0] = i[0] - o[0]),
                (r[1] = i[1] - o[1]),
                (r[2] = i[2] - o[2]),
                r
              );
            }
            function Ug(r, i, o) {
              return (
                (r[0] = i[0] * o[0]),
                (r[1] = i[1] * o[1]),
                (r[2] = i[2] * o[2]),
                r
              );
            }
            function Uu(r, i, o) {
              return (
                (r[0] = Math.min(i[0], o[0])),
                (r[1] = Math.min(i[1], o[1])),
                (r[2] = Math.min(i[2], o[2])),
                r
              );
            }
            function Qa(r, i, o) {
              return (
                (r[0] = Math.max(i[0], o[0])),
                (r[1] = Math.max(i[1], o[1])),
                (r[2] = Math.max(i[2], o[2])),
                r
              );
            }
            function ur(r, i, o) {
              return (r[0] = i[0] * o), (r[1] = i[1] * o), (r[2] = i[2] * o), r;
            }
            function rd(r, i, o, l) {
              return (
                (r[0] = i[0] + o[0] * l),
                (r[1] = i[1] + o[1] * l),
                (r[2] = i[2] + o[2] * l),
                r
              );
            }
            function Mt(r, i) {
              var o = i[0],
                l = i[1],
                h = i[2],
                m = o * o + l * l + h * h;
              return (
                m > 0 && (m = 1 / Math.sqrt(m)),
                (r[0] = i[0] * m),
                (r[1] = i[1] * m),
                (r[2] = i[2] * m),
                r
              );
            }
            function Io(r, i) {
              return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
            }
            function Xf(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = o[0],
                x = o[1],
                E = o[2];
              return (
                (r[0] = h * E - m * x),
                (r[1] = m * _ - l * E),
                (r[2] = l * x - h * _),
                r
              );
            }
            function Jn(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = o[3] * l + o[7] * h + o[11] * m + o[15];
              return (
                (r[0] =
                  (o[0] * l + o[4] * h + o[8] * m + o[12]) / (_ = _ || 1)),
                (r[1] = (o[1] * l + o[5] * h + o[9] * m + o[13]) / _),
                (r[2] = (o[2] * l + o[6] * h + o[10] * m + o[14]) / _),
                r
              );
            }
            function $u(r, i, o) {
              var l = o[0],
                h = o[1],
                m = o[2],
                _ = i[0],
                x = i[1],
                E = i[2],
                T = h * E - m * x,
                I = m * _ - l * E,
                A = l * x - h * _,
                L = h * A - m * I,
                O = m * T - l * A,
                F = l * I - h * T,
                V = 2 * o[3];
              return (
                (I *= V),
                (A *= V),
                (O *= 2),
                (F *= 2),
                (r[0] = _ + (T *= V) + (L *= 2)),
                (r[1] = x + I + O),
                (r[2] = E + A + F),
                r
              );
            }
            var od,
              _s = Zf,
              yv = Ug,
              Kf = Fc;
            function sd(r, i, o) {
              return (
                (r[0] = i[0] * o),
                (r[1] = i[1] * o),
                (r[2] = i[2] * o),
                (r[3] = i[3] * o),
                r
              );
            }
            function Yf(r, i) {
              var o = i[0],
                l = i[1],
                h = i[2],
                m = i[3],
                _ = o * o + l * l + h * h + m * m;
              return (
                _ > 0 && (_ = 1 / Math.sqrt(_)),
                (r[0] = o * _),
                (r[1] = l * _),
                (r[2] = h * _),
                (r[3] = m * _),
                r
              );
            }
            function aa(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3];
              return (
                (r[0] = o[0] * l + o[4] * h + o[8] * m + o[12] * _),
                (r[1] = o[1] * l + o[5] * h + o[9] * m + o[13] * _),
                (r[2] = o[2] * l + o[6] * h + o[10] * m + o[14] * _),
                (r[3] = o[3] * l + o[7] * h + o[11] * m + o[15] * _),
                r
              );
            }
            function $g() {
              var r = new Qn(4);
              return (
                Qn != Float32Array && ((r[0] = 0), (r[1] = 0), (r[2] = 0)),
                (r[3] = 1),
                r
              );
            }
            function Qf(r) {
              return (r[0] = 0), (r[1] = 0), (r[2] = 0), (r[3] = 1), r;
            }
            function Hu(r, i, o) {
              o *= 0.5;
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = Math.sin(o),
                E = Math.cos(o);
              return (
                (r[0] = l * E + _ * x),
                (r[1] = h * E + m * x),
                (r[2] = m * E - h * x),
                (r[3] = _ * E - l * x),
                r
              );
            }
            function ad(r, i, o) {
              o *= 0.5;
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = Math.sin(o),
                E = Math.cos(o);
              return (
                (r[0] = l * E - m * x),
                (r[1] = h * E + _ * x),
                (r[2] = m * E + l * x),
                (r[3] = _ * E - h * x),
                r
              );
            }
            jg(),
              (od = new Qn(4)),
              Qn != Float32Array &&
                ((od[0] = 0), (od[1] = 0), (od[2] = 0), (od[3] = 0));
            var Hg = Yf;
            jg(), Ka(1, 0, 0), Ka(0, 1, 0), $g(), $g(), Tp();
            const vv = ge([
                { type: "Float32", name: "a_globe_pos", components: 3 },
                { type: "Float32", name: "a_uv", components: 2 },
              ]),
              { members: Gg } = vv,
              Nc = ge([{ name: "a_pos_3", components: 3, type: "Int16" }]);
            var Ja = ge([{ name: "a_pos", type: "Int16", components: 2 }]);
            class Jf {
              constructor(i, o) {
                (this.pos = i), (this.dir = o);
              }
              intersectsPlane(i, o, l) {
                const h = Io(o, this.dir);
                if (Math.abs(h) < 1e-6) return !1;
                const m =
                  ((i[0] - this.pos[0]) * o[0] +
                    (i[1] - this.pos[1]) * o[1] +
                    (i[2] - this.pos[2]) * o[2]) /
                  h;
                return (
                  (l[0] = this.pos[0] + this.dir[0] * m),
                  (l[1] = this.pos[1] + this.dir[1] * m),
                  (l[2] = this.pos[2] + this.dir[2] * m),
                  !0
                );
              }
              closestPointOnSphere(i, o, l) {
                if (
                  ((V = (O = this.pos)[0]),
                  (G = O[1]),
                  (K = O[2]),
                  (oe = (F = i)[0]),
                  (J = F[1]),
                  (re = F[2]),
                  (Math.abs(V - oe) <=
                    nd * Math.max(1, Math.abs(V), Math.abs(oe)) &&
                    Math.abs(G - J) <=
                      nd * Math.max(1, Math.abs(G), Math.abs(J)) &&
                    Math.abs(K - re) <=
                      nd * Math.max(1, Math.abs(K), Math.abs(re))) ||
                    0 === o)
                )
                  return (l[0] = l[1] = l[2] = 0), !1;
                var O, F, V, G, K, oe, J, re;
                const [h, m, _] = this.dir,
                  x = this.pos[0] - i[0],
                  E = this.pos[1] - i[1],
                  T = this.pos[2] - i[2],
                  I = h * h + m * m + _ * _,
                  A = 2 * (x * h + E * m + T * _),
                  L = A * A - 4 * I * (x * x + E * E + T * T - o * o);
                if (L < 0) {
                  const O = Math.max(-A / 2, 0),
                    F = x + h * O,
                    V = E + m * O,
                    G = T + _ * O,
                    K = Math.hypot(F, V, G);
                  return (
                    (l[0] = (F * o) / K),
                    (l[1] = (V * o) / K),
                    (l[2] = (G * o) / K),
                    !1
                  );
                }
                {
                  const O = (-A - Math.sqrt(L)) / (2 * I);
                  if (O < 0) {
                    const F = Math.hypot(x, E, T);
                    return (
                      (l[0] = (x * o) / F),
                      (l[1] = (E * o) / F),
                      (l[2] = (T * o) / F),
                      !1
                    );
                  }
                  return (
                    (l[0] = x + h * O),
                    (l[1] = E + m * O),
                    (l[2] = T + _ * O),
                    !0
                  );
                }
              }
            }
            class qg {
              constructor(i, o, l, h, m) {
                (this.TL = i),
                  (this.TR = o),
                  (this.BR = l),
                  (this.BL = h),
                  (this.horizon = m);
              }
              static fromInvProjectionMatrix(i, o, l) {
                const h = [-1, 1, 1],
                  m = [1, 1, 1],
                  _ = [1, -1, 1],
                  x = [-1, -1, 1],
                  E = Jn(h, h, i),
                  T = Jn(m, m, i),
                  I = Jn(_, _, i),
                  A = Jn(x, x, i);
                return new qg(E, T, I, A, o / l);
              }
            }
            class Mp {
              constructor(i, o) {
                (this.points = i), (this.planes = o);
              }
              static fromInvProjectionMatrix(i, o, l, h) {
                const m = Math.pow(2, l),
                  _ = [
                    [-1, 1, -1, 1],
                    [1, 1, -1, 1],
                    [1, -1, -1, 1],
                    [-1, -1, -1, 1],
                    [-1, 1, 1, 1],
                    [1, 1, 1, 1],
                    [1, -1, 1, 1],
                    [-1, -1, 1, 1],
                  ].map((E) => {
                    const T = aa([], E, i),
                      I = (1 / T[3] / o) * m;
                    return (
                      ((A = T)[0] =
                        (L = T)[0] * (O = [I, I, h ? 1 / T[3] : I, I])[0]),
                      (A[1] = L[1] * O[1]),
                      (A[2] = L[2] * O[2]),
                      (A[3] = L[3] * O[3]),
                      A
                    );
                    var A, L, O;
                  }),
                  x = [
                    [0, 1, 2],
                    [6, 5, 4],
                    [0, 3, 7],
                    [2, 1, 5],
                    [3, 2, 6],
                    [0, 4, 5],
                  ].map((E) => {
                    const T = Mt(
                        [],
                        Xf(
                          [],
                          _s([], _[E[0]], _[E[1]]),
                          _s([], _[E[2]], _[E[1]])
                        )
                      ),
                      I = -Io(T, _[E[1]]);
                    return T.concat(I);
                  });
                return new Mp(_, x);
              }
            }
            class zr {
              static fromPoints(i) {
                const o = [1 / 0, 1 / 0, 1 / 0],
                  l = [-1 / 0, -1 / 0, -1 / 0];
                for (const h of i) Uu(o, o, h), Qa(l, l, h);
                return new zr(o, l);
              }
              static applyTransform(i, o) {
                const l = i.getCorners();
                for (let h = 0; h < l.length; ++h) Jn(l[h], l[h], o);
                return zr.fromPoints(l);
              }
              constructor(i, o) {
                (this.min = i),
                  (this.max = o),
                  (this.center = ur([], Ya([], this.min, this.max), 0.5));
              }
              quadrant(i) {
                const o = [i % 2 == 0, i < 2],
                  l = ju(this.min),
                  h = ju(this.max);
                for (let m = 0; m < o.length; m++)
                  (l[m] = o[m] ? this.min[m] : this.center[m]),
                    (h[m] = o[m] ? this.center[m] : this.max[m]);
                return (h[2] = this.max[2]), new zr(l, h);
              }
              distanceX(i) {
                return (
                  Math.max(Math.min(this.max[0], i[0]), this.min[0]) - i[0]
                );
              }
              distanceY(i) {
                return (
                  Math.max(Math.min(this.max[1], i[1]), this.min[1]) - i[1]
                );
              }
              distanceZ(i) {
                return (
                  Math.max(Math.min(this.max[2], i[2]), this.min[2]) - i[2]
                );
              }
              getCorners() {
                const i = this.min,
                  o = this.max;
                return [
                  [i[0], i[1], i[2]],
                  [o[0], i[1], i[2]],
                  [o[0], o[1], i[2]],
                  [i[0], o[1], i[2]],
                  [i[0], i[1], o[2]],
                  [o[0], i[1], o[2]],
                  [o[0], o[1], o[2]],
                  [i[0], o[1], o[2]],
                ];
              }
              intersects(i) {
                const o = this.getCorners();
                let l = !0;
                for (let h = 0; h < i.planes.length; h++) {
                  const m = i.planes[h];
                  let _ = 0;
                  for (let x = 0; x < o.length; x++)
                    _ += Io(m, o[x]) + m[3] >= 0;
                  if (0 === _) return 0;
                  _ !== o.length && (l = !1);
                }
                if (l) return 2;
                for (let h = 0; h < 3; h++) {
                  let m = Number.MAX_VALUE,
                    _ = -Number.MAX_VALUE;
                  for (let x = 0; x < i.points.length; x++) {
                    const E = i.points[x][h] - this.min[h];
                    (m = Math.min(m, E)), (_ = Math.max(_, E));
                  }
                  if (_ < 0 || m > this.max[h] - this.min[h]) return 0;
                }
                return 1;
              }
            }
            const la = wt / Math.PI / 2,
              Gu = [64, 32, 16],
              Yo = -la,
              Mo = la,
              vb = [
                new zr([Yo, Yo, Yo], [Mo, Mo, Mo]),
                new zr([Yo, Yo, Yo], [0, 0, Mo]),
                new zr([0, Yo, Yo], [Mo, 0, Mo]),
                new zr([Yo, 0, Yo], [0, Mo, Mo]),
                new zr([0, 0, Yo], [Mo, Mo, Mo]),
              ];
            function ld(r) {
              return (r * la) / pd;
            }
            function bv(r, i, o, l = !0) {
              const h = ur([], r._camera.position, r.worldSize),
                m = [i, o, 1, 1];
              aa(m, m, r.pixelMatrixInverse), sd(m, m, 1 / m[3]);
              const _ = Mt([], _s([], m, h)),
                x = r.globeMatrix,
                E = [x[12], x[13], x[14]],
                T = _s([], E, h),
                I = Fc(T),
                A = Mt([], T),
                L = r.worldSize / (2 * Math.PI),
                O = Io(A, _),
                F = Math.asin(L / I);
              if (F < Math.acos(O)) {
                if (!l) return null;
                const $e = [],
                  Ie = [];
                ur($e, _, I / O),
                  Mt(Ie, _s(Ie, $e, T)),
                  Mt(_, Ya(_, T, ur(_, Ie, Math.tan(F) * I)));
              }
              const V = [];
              new Jf(h, _).closestPointOnSphere(E, L, V);
              const G = Mt([], as(x, 0)),
                K = Mt([], as(x, 1)),
                oe = Mt([], as(x, 2)),
                J = Io(G, V),
                re = Io(K, V),
                le = Io(oe, V),
                ae = zi(Math.asin(-re / L));
              let De = zi(Math.atan2(J, le));
              De =
                r.center.lng +
                (function ($e, Ie) {
                  const Fe = ((Ie - $e + 180) % 360) - 180;
                  return Fe < -180 ? Fe + 360 : Fe;
                })(r.center.lng, De);
              const xe = ua(De),
                Pe = tn(ai(ae), 0, 1);
              return new Zu(xe, Pe);
            }
            class wv {
              constructor(i, o, l) {
                (this.a = _s([], i, l)),
                  (this.b = _s([], o, l)),
                  (this.center = l);
                const h = Mt([], this.a),
                  m = Mt([], this.b);
                this.angle = Math.acos(Io(h, m));
              }
            }
            function em(r, i) {
              if (0 === r.angle) return null;
              let o;
              return (
                (o =
                  0 === r.a[i]
                    ? (1 / r.angle) * 0.5 * Math.PI
                    : (1 / r.angle) *
                      Math.atan(
                        r.b[i] / r.a[i] / Math.sin(r.angle) -
                          1 / Math.tan(r.angle)
                      )),
                o < 0 || o > 1
                  ? null
                  : (function (l, h, m, _) {
                      const x = Math.sin(m);
                      return (
                        l * (Math.sin((1 - _) * m) / x) +
                        h * (Math.sin(_ * m) / x)
                      );
                    })(r.a[i], r.b[i], r.angle, tn(o, 0, 1)) + r.center[i]
              );
            }
            function Qo(r) {
              if (r.z <= 1) return vb[r.z + 2 * r.y + r.x];
              const i = Xg(tm(r));
              return zr.fromPoints(i);
            }
            function qu(r, i, o) {
              return ur(r, r, 1 - o), rd(r, r, i, o);
            }
            function Ev(r, i) {
              const o = Ji(i.zoom);
              if (0 === o) return Qo(r);
              const l = tm(r),
                h = Xg(l),
                m = ua(l.getWest()) * i.worldSize,
                _ = ua(l.getEast()) * i.worldSize,
                x = ai(l.getNorth()) * i.worldSize,
                E = ai(l.getSouth()) * i.worldSize,
                T = [m, x, 0],
                I = [_, x, 0],
                A = [m, E, 0],
                L = [_, E, 0],
                O = Dp([], i.globeMatrix);
              return (
                Jn(T, T, O),
                Jn(I, I, O),
                Jn(A, A, O),
                Jn(L, L, O),
                (h[0] = qu(h[0], A, o)),
                (h[1] = qu(h[1], L, o)),
                (h[2] = qu(h[2], I, o)),
                (h[3] = qu(h[3], T, o)),
                zr.fromPoints(h)
              );
            }
            function Ap(r, i, o) {
              for (const l of r) Jn(l, l, i), ur(l, l, o);
            }
            function tm({ x: r, y: i, z: o }) {
              const l = 1 / (1 << o),
                h = new Ln(ao(r * l), qi((i + 1) * l)),
                m = new Ln(ao((r + 1) * l), qi(i * l));
              return new Lc(h, m);
            }
            function Xg(r) {
              const i = Qt(r.getNorth()),
                o = Qt(r.getSouth()),
                l = Math.cos(i),
                h = Math.cos(o),
                m = Math.sin(i),
                _ = Math.sin(o),
                x = r.getWest(),
                E = r.getEast();
              return [cd(h, _, x), cd(h, _, E), cd(l, m, E), cd(l, m, x)];
            }
            function cd(r, i, o, l = la) {
              return (
                (o = Qt(o)), [r * Math.sin(o) * l, -i * l, r * Math.cos(o) * l]
              );
            }
            function ud(r, i, o) {
              return cd(Math.cos(Qt(r)), Math.sin(Qt(r)), i, o);
            }
            function hd(r, i, o, l) {
              const h = 1 << o.z,
                m = (r / wt + o.x) / h;
              return ud(qi((i / wt + o.y) / h), ao(m), l);
            }
            function dd({ min: r, max: i }) {
              return 16383 / Math.max(i[0] - r[0], i[1] - r[1], i[2] - r[2]);
            }
            const Pp = new Float64Array(16);
            function Wu(r) {
              const i = dd(r),
                o = Vg(Pp, [i, i, i]);
              return id(
                o,
                o,
                (((l = [])[0] = -(h = r.min)[0]),
                (l[1] = -h[1]),
                (l[2] = -h[2]),
                l)
              );
              var l, h;
            }
            function Lp(r) {
              const i =
                ((l = r.min),
                ((o = Pp)[0] = 1),
                (o[1] = 0),
                (o[2] = 0),
                (o[3] = 0),
                (o[4] = 0),
                (o[5] = 1),
                (o[6] = 0),
                (o[7] = 0),
                (o[8] = 0),
                (o[9] = 0),
                (o[10] = 1),
                (o[11] = 0),
                (o[12] = l[0]),
                (o[13] = l[1]),
                (o[14] = l[2]),
                (o[15] = 1),
                o);
              var o, l;
              const h = 1 / dd(r);
              return Oc(i, i, [h, h, h]);
            }
            function nm(r, i, o, l, h) {
              const m = (function (E) {
                  const T = wt / (2 * Math.PI);
                  return E / (2 * Math.PI) / T;
                })(o),
                _ = [r, i, -o / (2 * Math.PI)],
                x = sa(new Float64Array(16));
              return (
                id(x, x, _),
                Oc(x, x, [m, m, m]),
                Wf(x, x, Qt(-h)),
                Cp(x, x, Qt(-l)),
                x
              );
            }
            function Ji(r) {
              return Ma(5, 6, r);
            }
            function Kg(r, i) {
              const o = ud(i.lat, i.lng);
              return (
                (_ = (h = Zf(
                  [],
                  (function (F) {
                    const V = ud(F._center.lat, F._center.lng);
                    let G = Xf([], Ka(0, 1, 0), V);
                    const K = Sp([], -F.angle, V);
                    (G = Jn(G, G, K)), Sp(K, -F._pitch, G);
                    const oe = Mt([], V);
                    return (
                      ur(
                        oe,
                        oe,
                        ld(F.cameraToCenterDistance / F.pixelsPerMeter)
                      ),
                      Jn(oe, oe, K),
                      Ya([], V, oe)
                    );
                  })(r),
                  o
                ))[0]),
                (x = h[1]),
                (E = h[2]),
                (T = (m = o)[0]),
                (I = m[1]),
                (A = m[2]),
                (O =
                  (L =
                    Math.sqrt(_ * _ + x * x + E * E) *
                    Math.sqrt(T * T + I * I + A * A)) && Io(h, m) / L),
                Math.acos(Math.min(Math.max(O, -1), 1))
              );
              var h, m, _, x, E, T, I, A, L, O;
            }
            function im(r, i) {
              return Kg(r, i) > (Math.PI / 2) * 1.01;
            }
            const Yg = Qt(85),
              Qg = Math.cos(Yg),
              rm = Math.sin(Yg),
              pd = 6371008.8,
              Jg = 2 * Math.PI * pd;
            class Hl {
              constructor(i, o) {
                if (isNaN(i) || isNaN(o))
                  throw new Error(`Invalid LngLat object: (${i}, ${o})`);
                if (
                  ((this.lng = +i),
                  (this.lat = +o),
                  this.lat > 90 || this.lat < -90)
                )
                  throw new Error(
                    "Invalid LngLat latitude value: must be between -90 and 90"
                  );
              }
              wrap() {
                return new Hl(Tn(this.lng, -180, 180), this.lat);
              }
              toArray() {
                return [this.lng, this.lat];
              }
              toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
              }
              distanceTo(i) {
                const o = Math.PI / 180,
                  l = this.lat * o,
                  h = i.lat * o,
                  m =
                    Math.sin(l) * Math.sin(h) +
                    Math.cos(l) *
                      Math.cos(h) *
                      Math.cos((i.lng - this.lng) * o);
                return pd * Math.acos(Math.min(m, 1));
              }
              toBounds(i = 0) {
                const o = (360 * i) / 40075017,
                  l = o / Math.cos((Math.PI / 180) * this.lat);
                return new Lc(
                  new Hl(this.lng - l, this.lat - o),
                  new Hl(this.lng + l, this.lat + o)
                );
              }
              toEcef(i) {
                const o = ld(i);
                return ud(this.lat, this.lng, la + o);
              }
              static convert(i) {
                if (i instanceof Hl) return i;
                if (Array.isArray(i) && (2 === i.length || 3 === i.length))
                  return new Hl(Number(i[0]), Number(i[1]));
                if (!Array.isArray(i) && "object" == typeof i && null !== i)
                  return new Hl(
                    Number("lng" in i ? i.lng : i.lon),
                    Number(i.lat)
                  );
                throw new Error(
                  "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]"
                );
              }
            }
            var Ln = Hl;
            function om(r) {
              return Jg * Math.cos((r * Math.PI) / 180);
            }
            function ua(r) {
              return (180 + r) / 360;
            }
            function ai(r) {
              return (
                (180 -
                  (180 / Math.PI) *
                    Math.log(Math.tan(Math.PI / 4 + (r * Math.PI) / 360))) /
                360
              );
            }
            function Ao(r, i) {
              return r / om(i);
            }
            function ao(r) {
              return 360 * r - 180;
            }
            function qi(r) {
              return (
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * r) * Math.PI) / 180)) -
                90
              );
            }
            function Dr(r, i) {
              return r * om(qi(i));
            }
            const Si = 85.051129;
            function sm(r) {
              return 1 / Math.cos((r * Math.PI) / 180);
            }
            class Zu {
              constructor(i, o, l = 0) {
                (this.x = +i), (this.y = +o), (this.z = +l);
              }
              static fromLngLat(i, o = 0) {
                const l = Ln.convert(i);
                return new Zu(ua(l.lng), ai(l.lat), Ao(o, l.lat));
              }
              toLngLat() {
                return new Ln(ao(this.x), qi(this.y));
              }
              toAltitude() {
                return Dr(this.z, this.y);
              }
              meterInMercatorCoordinateUnits() {
                return (1 / Jg) * sm(qi(this.y));
              }
            }
            function am(r, i, o, l, h, m, _, x, E) {
              const T = (i + l) / 2,
                I = (o + h) / 2,
                A = new nt(T, I);
              x(A),
                (function (L, O, F, V, G, K) {
                  const oe = F - G,
                    J = V - K;
                  return (
                    Math.abs((V - O) * oe - (F - L) * J) / Math.hypot(oe, J)
                  );
                })(A.x, A.y, m.x, m.y, _.x, _.y) >= E
                  ? (am(r, i, o, T, I, m, A, x, E),
                    am(r, T, I, l, h, A, _, x, E))
                  : r.push(_);
            }
            function lm(r, i, o) {
              let l = r[0],
                h = l.x,
                m = l.y;
              i(l);
              const _ = [l];
              for (let x = 1; x < r.length; x++) {
                const E = r[x],
                  { x: T, y: I } = E;
                i(E), am(_, h, m, T, I, l, E, i, o), (h = T), (m = I), (l = E);
              }
              return _;
            }
            function cm(r, i, o, l) {
              if (l(i, o)) {
                const h = i.add(o)._mult(0.5);
                cm(r, i, h, l), cm(r, h, o, l);
              } else r.push(o);
            }
            function e_(r, i) {
              let o = r[0];
              const l = [o];
              for (let h = 1; h < r.length; h++) {
                const m = r[h];
                cm(l, o, m, i), (o = m);
              }
              return l;
            }
            const um = Math.pow(2, 14) - 1,
              hm = -um - 1;
            function Tv(r, i) {
              const o = Math.round(r.x * i),
                l = Math.round(r.y * i);
              return (
                (r.x = tn(o, hm, um)),
                (r.y = tn(l, hm, um)),
                (o < r.x || o > r.x + 1 || l < r.y || l > r.y + 1) &&
                  Wn(
                    "Geometry exceeds allowed extent, reduce your vector tile buffer size"
                  ),
                r
              );
            }
            function el(r, i, o) {
              const l = r.loadGeometry(),
                h = r.extent,
                m = wt / h;
              if (i && o && o.projection.isReprojectedInTileSpace) {
                const _ = 1 << i.z,
                  { scale: x, x: E, y: T, projection: I } = o,
                  A = (L) => {
                    const O = ao((i.x + L.x / h) / _),
                      F = qi((i.y + L.y / h) / _),
                      V = I.project(O, F);
                    (L.x = (V.x * x - E) * h), (L.y = (V.y * x - T) * h);
                  };
                for (let L = 0; L < l.length; L++)
                  if (1 !== r.type) l[L] = lm(l[L], A, 1);
                  else {
                    const O = [];
                    for (const F of l[L])
                      F.x < 0 ||
                        F.x >= h ||
                        F.y < 0 ||
                        F.y >= h ||
                        (A(F), O.push(F));
                    l[L] = O;
                  }
              }
              for (const _ of l) for (const x of _) Tv(x, m);
              return l;
            }
            function tl(r, i) {
              return {
                type: r.type,
                id: r.id,
                properties: r.properties,
                geometry: i ? el(r) : [],
              };
            }
            function Xu(r, i, o, l, h) {
              r.emplaceBack(2 * i + (l + 1) / 2, 2 * o + (h + 1) / 2);
            }
            function kp(r, i, o) {
              r.emplaceBack(
                i.x,
                i.y,
                i.z,
                16384 * o[0],
                16384 * o[1],
                16384 * o[2]
              );
            }
            class Rp {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.hasPattern = !1),
                  (this.projection = i.projection),
                  (this.layoutVertexArray = new Ge()),
                  (this.indexArray = new _t()),
                  (this.segments = new xi()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id));
              }
              populate(i, o, l, h) {
                const m = this.layers[0],
                  _ = [];
                let x = null;
                "circle" === m.type && (x = m.layout.get("circle-sort-key"));
                for (const {
                  feature: T,
                  id: I,
                  index: A,
                  sourceLayerIndex: L,
                } of i) {
                  const O = this.layers[0]._featureFilter.needGeometry,
                    F = tl(T, O);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      F,
                      l
                    )
                  )
                    continue;
                  const V = x ? x.evaluate(F, {}, l) : void 0,
                    G = {
                      id: I,
                      properties: T.properties,
                      type: T.type,
                      sourceLayerIndex: L,
                      index: A,
                      geometry: O ? F.geometry : el(T, l, h),
                      patterns: {},
                      sortKey: V,
                    };
                  _.push(G);
                }
                x && _.sort((T, I) => T.sortKey - I.sortKey);
                let E = null;
                "globe" === h.projection.name &&
                  ((this.globeExtVertexArray = new He()), (E = h.projection));
                for (const T of _) {
                  const { geometry: I, index: A, sourceLayerIndex: L } = T,
                    O = i[A].feature;
                  this.addFeature(T, I, A, o.availableImages, l, E),
                    o.featureIndex.insert(O, I, A, L, this.index);
                }
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    Bg.members
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  this.globeExtVertexArray &&
                    (this.globeExtVertexBuffer = i.createVertexBuffer(
                      this.globeExtVertexArray,
                      _v.members
                    ))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy());
              }
              addFeature(i, o, l, h, m, _) {
                for (const x of o)
                  for (const E of x) {
                    const T = E.x,
                      I = E.y;
                    if (T < 0 || T >= wt || I < 0 || I >= wt) continue;
                    if (_) {
                      const O = _.projectTilePoint(T, I, m),
                        F = _.upVector(m, T, I),
                        V = this.globeExtVertexArray;
                      kp(V, O, F), kp(V, O, F), kp(V, O, F), kp(V, O, F);
                    }
                    const A = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                        i.sortKey
                      ),
                      L = A.vertexLength;
                    Xu(this.layoutVertexArray, T, I, -1, -1),
                      Xu(this.layoutVertexArray, T, I, 1, -1),
                      Xu(this.layoutVertexArray, T, I, 1, 1),
                      Xu(this.layoutVertexArray, T, I, -1, 1),
                      this.indexArray.emplaceBack(L, L + 1, L + 2),
                      this.indexArray.emplaceBack(L, L + 2, L + 3),
                      (A.vertexLength += 4),
                      (A.primitiveLength += 2);
                  }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  {},
                  h,
                  m
                );
              }
            }
            function t_(r, i) {
              for (let o = 0; o < r.length; o++) if (nl(i, r[o])) return !0;
              for (let o = 0; o < i.length; o++) if (nl(r, i[o])) return !0;
              return !!md(r, i);
            }
            function fd(r, i, o) {
              return !!nl(r, i) || !!Op(i, r, o);
            }
            function n_(r, i) {
              if (1 === r.length) return zc(i, r[0]);
              for (let o = 0; o < i.length; o++) {
                const l = i[o];
                for (let h = 0; h < l.length; h++) if (nl(r, l[h])) return !0;
              }
              for (let o = 0; o < r.length; o++) if (zc(i, r[o])) return !0;
              for (let o = 0; o < i.length; o++) if (md(r, i[o])) return !0;
              return !1;
            }
            function Dv(r, i, o) {
              if (r.length > 1) {
                if (md(r, i)) return !0;
                for (let l = 0; l < i.length; l++)
                  if (Op(i[l], r, o)) return !0;
              }
              for (let l = 0; l < r.length; l++) if (Op(r[l], i, o)) return !0;
              return !1;
            }
            function md(r, i) {
              if (0 === r.length || 0 === i.length) return !1;
              for (let o = 0; o < r.length - 1; o++) {
                const l = r[o],
                  h = r[o + 1];
                for (let m = 0; m < i.length - 1; m++)
                  if (dm(l, h, i[m], i[m + 1])) return !0;
              }
              return !1;
            }
            function dm(r, i, o, l) {
              return no(r, o, l) !== no(i, o, l) && no(r, i, o) !== no(r, i, l);
            }
            function Op(r, i, o) {
              const l = o * o;
              if (1 === i.length) return r.distSqr(i[0]) < l;
              for (let h = 1; h < i.length; h++)
                if (Cv(r, i[h - 1], i[h]) < l) return !0;
              return !1;
            }
            function Cv(r, i, o) {
              const l = i.distSqr(o);
              if (0 === l) return r.distSqr(i);
              const h =
                ((r.x - i.x) * (o.x - i.x) + (r.y - i.y) * (o.y - i.y)) / l;
              return r.distSqr(
                h < 0 ? i : h > 1 ? o : o.sub(i)._mult(h)._add(i)
              );
            }
            function zc(r, i) {
              let o,
                l,
                h,
                m = !1;
              for (let _ = 0; _ < r.length; _++) {
                o = r[_];
                for (let x = 0, E = o.length - 1; x < o.length; E = x++)
                  (l = o[x]),
                    (h = o[E]),
                    l.y > i.y != h.y > i.y &&
                      i.x < ((h.x - l.x) * (i.y - l.y)) / (h.y - l.y) + l.x &&
                      (m = !m);
              }
              return m;
            }
            function nl(r, i) {
              let o = !1;
              for (let l = 0, h = r.length - 1; l < r.length; h = l++) {
                const m = r[l],
                  _ = r[h];
                m.y > i.y != _.y > i.y &&
                  i.x < ((_.x - m.x) * (i.y - m.y)) / (_.y - m.y) + m.x &&
                  (o = !o);
              }
              return o;
            }
            function pm(r, i, o, l, h) {
              for (const _ of r)
                if (i <= _.x && o <= _.y && l >= _.x && h >= _.y) return !0;
              const m = [
                new nt(i, o),
                new nt(i, h),
                new nt(l, h),
                new nt(l, o),
              ];
              if (r.length > 2) for (const _ of m) if (nl(r, _)) return !0;
              for (let _ = 0; _ < r.length - 1; _++)
                if (Sv(r[_], r[_ + 1], m)) return !0;
              return !1;
            }
            function Sv(r, i, o) {
              const l = o[0],
                h = o[2];
              if (
                (r.x < l.x && i.x < l.x) ||
                (r.x > h.x && i.x > h.x) ||
                (r.y < l.y && i.y < l.y) ||
                (r.y > h.y && i.y > h.y)
              )
                return !1;
              const m = no(r, i, o[0]);
              return (
                m !== no(r, i, o[1]) ||
                m !== no(r, i, o[2]) ||
                m !== no(r, i, o[3])
              );
            }
            function Gl(r, i, o) {
              const l = i.paint.get(r).value;
              return "constant" === l.kind
                ? l.value
                : o.programConfigurations.get(i.id).getMaxValue(r);
            }
            function Fp(r) {
              return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
            }
            function i_(r, i, o, l, h) {
              if (!i[0] && !i[1]) return r;
              const m = nt.convert(i)._mult(h);
              "viewport" === o && m._rotate(-l);
              const _ = [];
              for (let x = 0; x < r.length; x++) _.push(r[x].sub(m));
              return _;
            }
            function r_(r, i, o, l) {
              const h = nt.convert(r)._mult(l);
              return "viewport" === i && h._rotate(-o), h;
            }
            lt(Rp, "CircleBucket", { omit: ["layers"] });
            const Iv = new te({
              "circle-sort-key": new W(Ae.layout_circle["circle-sort-key"]),
            });
            var Mv = {
              paint: new te({
                "circle-radius": new W(Ae.paint_circle["circle-radius"]),
                "circle-color": new W(Ae.paint_circle["circle-color"]),
                "circle-blur": new W(Ae.paint_circle["circle-blur"]),
                "circle-opacity": new W(Ae.paint_circle["circle-opacity"]),
                "circle-translate": new B(Ae.paint_circle["circle-translate"]),
                "circle-translate-anchor": new B(
                  Ae.paint_circle["circle-translate-anchor"]
                ),
                "circle-pitch-scale": new B(
                  Ae.paint_circle["circle-pitch-scale"]
                ),
                "circle-pitch-alignment": new B(
                  Ae.paint_circle["circle-pitch-alignment"]
                ),
                "circle-stroke-width": new W(
                  Ae.paint_circle["circle-stroke-width"]
                ),
                "circle-stroke-color": new W(
                  Ae.paint_circle["circle-stroke-color"]
                ),
                "circle-stroke-opacity": new W(
                  Ae.paint_circle["circle-stroke-opacity"]
                ),
              }),
              layout: Iv,
            };
            function o_(r, i, o, l, h, m, _, x, E) {
              if (m && r.queryGeometry.isAboveHorizon) return !1;
              m && (E *= r.pixelToTileUnitsFactor);
              const T = r.tileID.canonical,
                I = o.projection.upVectorScale(
                  T,
                  o.center.lat,
                  o.worldSize
                ).metersToTile;
              for (const A of i)
                for (const L of A) {
                  const O = L.add(x),
                    F =
                      h && o.elevation
                        ? o.elevation.exaggeration() *
                          h.getElevationAt(O.x, O.y, !0)
                        : 0,
                    V = o.projection.projectTilePoint(O.x, O.y, T);
                  if (F > 0) {
                    const J = o.projection.upVector(T, O.x, O.y);
                    (V.x += J[0] * I * F),
                      (V.y += J[1] * I * F),
                      (V.z += J[2] * I * F);
                  }
                  const G = m ? O : s_(V.x, V.y, V.z, l),
                    K = m
                      ? r.tilespaceRays.map((J) => fm(J, F))
                      : r.queryGeometry.screenGeometry,
                    oe = aa([], [V.x, V.y, V.z, 1], l);
                  if (
                    (!_ && m
                      ? (E *= oe[3] / o.cameraToCenterDistance)
                      : _ && !m && (E *= o.cameraToCenterDistance / oe[3]),
                    m)
                  ) {
                    const J = qi((L.y / wt + T.y) / (1 << T.z));
                    E /= o.projection.pixelsPerMeter(J, 1) / Ao(1, J);
                  }
                  if (fd(K, G, E)) return !0;
                }
              return !1;
            }
            function s_(r, i, o, l) {
              const h = aa([], [r, i, o, 1], l);
              return new nt(h[0] / h[3], h[1] / h[3]);
            }
            const Np = Ka(0, 0, 0),
              a_ = Ka(0, 0, 1);
            function fm(r, i) {
              const o = jg();
              return (
                (Np[2] = i), r.intersectsPlane(Np, a_, o), new nt(o[0], o[1])
              );
            }
            class l_ extends Rp {}
            function c_(r, { width: i, height: o }, l, h) {
              if (h) {
                if (h instanceof Uint8ClampedArray)
                  h = new Uint8Array(h.buffer);
                else if (h.length !== i * o * l)
                  throw new RangeError("mismatched image size");
              } else h = new Uint8Array(i * o * l);
              return (r.width = i), (r.height = o), (r.data = h), r;
            }
            function mm(r, i, o) {
              const { width: l, height: h } = i;
              (l === r.width && h === r.height) ||
                (zp(
                  r,
                  i,
                  { x: 0, y: 0 },
                  { x: 0, y: 0 },
                  {
                    width: Math.min(r.width, l),
                    height: Math.min(r.height, h),
                  },
                  o
                ),
                (r.width = l),
                (r.height = h),
                (r.data = i.data));
            }
            function zp(r, i, o, l, h, m) {
              if (0 === h.width || 0 === h.height) return i;
              if (
                h.width > r.width ||
                h.height > r.height ||
                o.x > r.width - h.width ||
                o.y > r.height - h.height
              )
                throw new RangeError(
                  "out of range source coordinates for image copy"
                );
              if (
                h.width > i.width ||
                h.height > i.height ||
                l.x > i.width - h.width ||
                l.y > i.height - h.height
              )
                throw new RangeError(
                  "out of range destination coordinates for image copy"
                );
              const _ = r.data,
                x = i.data;
              for (let E = 0; E < h.height; E++) {
                const T = ((o.y + E) * r.width + o.x) * m,
                  I = ((l.y + E) * i.width + l.x) * m;
                for (let A = 0; A < h.width * m; A++) x[I + A] = _[T + A];
              }
              return i;
            }
            lt(l_, "HeatmapBucket", { omit: ["layers"] });
            class Yr {
              constructor(i, o) {
                c_(this, i, 1, o);
              }
              resize(i) {
                mm(this, new Yr(i), 1);
              }
              clone() {
                return new Yr(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(i, o, l, h, m) {
                zp(i, o, l, h, m, 1);
              }
            }
            class Qr {
              constructor(i, o) {
                c_(this, i, 4, o);
              }
              resize(i) {
                mm(this, new Qr(i), 4);
              }
              replace(i, o) {
                o
                  ? this.data.set(i)
                  : (this.data =
                      i instanceof Uint8ClampedArray
                        ? new Uint8Array(i.buffer)
                        : i);
              }
              clone() {
                return new Qr(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(i, o, l, h, m) {
                zp(i, o, l, h, m, 4);
              }
            }
            lt(Yr, "AlphaImage"), lt(Qr, "RGBAImage");
            var u_ = {
              paint: new te({
                "heatmap-radius": new W(Ae.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new W(Ae.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new B(
                  Ae.paint_heatmap["heatmap-intensity"]
                ),
                "heatmap-color": new ee(Ae.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new B(Ae.paint_heatmap["heatmap-opacity"]),
              }),
            };
            function gm(r) {
              const i = {},
                o = r.resolution || 256,
                l = r.clips ? r.clips.length : 1,
                h = r.image || new Qr({ width: o, height: l }),
                m = (_, x, E) => {
                  i[r.evaluationKey] = E;
                  const T = r.expression.evaluate(i);
                  (h.data[_ + x + 0] = Math.floor((255 * T.r) / T.a)),
                    (h.data[_ + x + 1] = Math.floor((255 * T.g) / T.a)),
                    (h.data[_ + x + 2] = Math.floor((255 * T.b) / T.a)),
                    (h.data[_ + x + 3] = Math.floor(255 * T.a));
                };
              if (r.clips)
                for (let _ = 0, x = 0; _ < l; ++_, x += 4 * o)
                  for (let E = 0, T = 0; E < o; E++, T += 4) {
                    const I = E / (o - 1),
                      { start: A, end: L } = r.clips[_];
                    m(x, T, A * (1 - I) + L * I);
                  }
              else
                for (let _ = 0, x = 0; _ < o; _++, x += 4) m(0, x, _ / (o - 1));
              return h;
            }
            var bb = {
              paint: new te({
                "hillshade-illumination-direction": new B(
                  Ae.paint_hillshade["hillshade-illumination-direction"]
                ),
                "hillshade-illumination-anchor": new B(
                  Ae.paint_hillshade["hillshade-illumination-anchor"]
                ),
                "hillshade-exaggeration": new B(
                  Ae.paint_hillshade["hillshade-exaggeration"]
                ),
                "hillshade-shadow-color": new B(
                  Ae.paint_hillshade["hillshade-shadow-color"]
                ),
                "hillshade-highlight-color": new B(
                  Ae.paint_hillshade["hillshade-highlight-color"]
                ),
                "hillshade-accent-color": new B(
                  Ae.paint_hillshade["hillshade-accent-color"]
                ),
              }),
            };
            const Bp = ge([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              { members: Av } = Bp;
            var Vp = { exports: {} };
            function gd(r, i, o) {
              o = o || 2;
              var l,
                h,
                m,
                _,
                x,
                E,
                T,
                I = i && i.length,
                A = I ? i[0] * o : r.length,
                L = _m(r, 0, A, o, !0),
                O = [];
              if (!L || L.next === L.prev) return O;
              if (
                (I &&
                  (L = (function (V, G, K, oe) {
                    var J,
                      re,
                      le,
                      ae = [];
                    for (J = 0, re = G.length; J < re; J++)
                      (le = _m(
                        V,
                        G[J] * oe,
                        J < re - 1 ? G[J + 1] * oe : V.length,
                        oe,
                        !1
                      )) === le.next && (le.steiner = !0),
                        ae.push(d_(le));
                    for (ae.sort(vm), J = 0; J < ae.length; J++)
                      K = xm(ae[J], K);
                    return K;
                  })(r, i, L, o)),
                r.length > 80 * o)
              ) {
                (l = m = r[0]), (h = _ = r[1]);
                for (var F = o; F < A; F += o)
                  (x = r[F]) < l && (l = x),
                    (E = r[F + 1]) < h && (h = E),
                    x > m && (m = x),
                    E > _ && (_ = E);
                T = 0 !== (T = Math.max(m - l, _ - h)) ? 32767 / T : 0;
              }
              return Ku(L, O, o, l, h, T, 0), O;
            }
            function _m(r, i, o, l, h) {
              var m, _;
              if (h === wm(r, i, o, l) > 0)
                for (m = i; m < o; m += l) _ = Lv(m, r[m], r[m + 1], _);
              else for (m = o - l; m >= i; m -= l) _ = Lv(m, r[m], r[m + 1], _);
              return _ && Qu(_, _.next) && (xd(_), (_ = _.next)), _;
            }
            function il(r, i) {
              if (!r) return r;
              i || (i = r);
              var o,
                l = r;
              do {
                if (
                  ((o = !1),
                  l.steiner || (!Qu(l, l.next) && 0 !== li(l.prev, l, l.next)))
                )
                  l = l.next;
                else {
                  if ((xd(l), (l = i = l.prev) === l.next)) break;
                  o = !0;
                }
              } while (o || l !== i);
              return i;
            }
            function Ku(r, i, o, l, h, m, _) {
              if (r) {
                !_ &&
                  m &&
                  (function (I, A, L, O) {
                    var F = I;
                    do {
                      0 === F.z && (F.z = bm(F.x, F.y, A, L, O)),
                        (F.prevZ = F.prev),
                        (F.nextZ = F.next),
                        (F = F.next);
                    } while (F !== I);
                    (F.prevZ.nextZ = null),
                      (F.prevZ = null),
                      (function (V) {
                        var G,
                          K,
                          oe,
                          J,
                          re,
                          le,
                          ae,
                          De,
                          xe = 1;
                        do {
                          for (K = V, V = null, re = null, le = 0; K; ) {
                            for (
                              le++, oe = K, ae = 0, G = 0;
                              G < xe && (ae++, (oe = oe.nextZ));
                              G++
                            );
                            for (De = xe; ae > 0 || (De > 0 && oe); )
                              0 !== ae && (0 === De || !oe || K.z <= oe.z)
                                ? ((J = K), (K = K.nextZ), ae--)
                                : ((J = oe), (oe = oe.nextZ), De--),
                                re ? (re.nextZ = J) : (V = J),
                                (J.prevZ = re),
                                (re = J);
                            K = oe;
                          }
                          (re.nextZ = null), (xe *= 2);
                        } while (le > 1);
                      })(F);
                  })(r, l, h, m);
                for (var x, E, T = r; r.prev !== r.next; )
                  if (((x = r.prev), (E = r.next), m ? Up(r, l, h, m) : jp(r)))
                    i.push((x.i / o) | 0),
                      i.push((r.i / o) | 0),
                      i.push((E.i / o) | 0),
                      xd(r),
                      (r = E.next),
                      (T = E.next);
                  else if ((r = E) === T) {
                    _
                      ? 1 === _
                        ? Ku((r = h_(il(r), i, o)), i, o, l, h, m, 2)
                        : 2 === _ && ym(r, i, o, l, h, m)
                      : Ku(il(r), i, o, l, h, m, 1);
                    break;
                  }
              }
            }
            function jp(r) {
              var i = r.prev,
                o = r,
                l = r.next;
              if (li(i, o, l) >= 0) return !1;
              for (
                var h = i.x,
                  m = o.x,
                  _ = l.x,
                  x = i.y,
                  E = o.y,
                  T = l.y,
                  I = h < m ? (h < _ ? h : _) : m < _ ? m : _,
                  A = x < E ? (x < T ? x : T) : E < T ? E : T,
                  L = h > m ? (h > _ ? h : _) : m > _ ? m : _,
                  O = x > E ? (x > T ? x : T) : E > T ? E : T,
                  F = l.next;
                F !== i;

              ) {
                if (
                  F.x >= I &&
                  F.x <= L &&
                  F.y >= A &&
                  F.y <= O &&
                  Yu(h, x, m, E, _, T, F.x, F.y) &&
                  li(F.prev, F, F.next) >= 0
                )
                  return !1;
                F = F.next;
              }
              return !0;
            }
            function Up(r, i, o, l) {
              var h = r.prev,
                m = r,
                _ = r.next;
              if (li(h, m, _) >= 0) return !1;
              for (
                var x = h.x,
                  E = m.x,
                  T = _.x,
                  I = h.y,
                  A = m.y,
                  L = _.y,
                  O = x < E ? (x < T ? x : T) : E < T ? E : T,
                  F = I < A ? (I < L ? I : L) : A < L ? A : L,
                  V = x > E ? (x > T ? x : T) : E > T ? E : T,
                  G = I > A ? (I > L ? I : L) : A > L ? A : L,
                  K = bm(O, F, i, o, l),
                  oe = bm(V, G, i, o, l),
                  J = r.prevZ,
                  re = r.nextZ;
                J && J.z >= K && re && re.z <= oe;

              ) {
                if (
                  (J.x >= O &&
                    J.x <= V &&
                    J.y >= F &&
                    J.y <= G &&
                    J !== h &&
                    J !== _ &&
                    Yu(x, I, E, A, T, L, J.x, J.y) &&
                    li(J.prev, J, J.next) >= 0) ||
                  ((J = J.prevZ),
                  re.x >= O &&
                    re.x <= V &&
                    re.y >= F &&
                    re.y <= G &&
                    re !== h &&
                    re !== _ &&
                    Yu(x, I, E, A, T, L, re.x, re.y) &&
                    li(re.prev, re, re.next) >= 0)
                )
                  return !1;
                re = re.nextZ;
              }
              for (; J && J.z >= K; ) {
                if (
                  J.x >= O &&
                  J.x <= V &&
                  J.y >= F &&
                  J.y <= G &&
                  J !== h &&
                  J !== _ &&
                  Yu(x, I, E, A, T, L, J.x, J.y) &&
                  li(J.prev, J, J.next) >= 0
                )
                  return !1;
                J = J.prevZ;
              }
              for (; re && re.z <= oe; ) {
                if (
                  re.x >= O &&
                  re.x <= V &&
                  re.y >= F &&
                  re.y <= G &&
                  re !== h &&
                  re !== _ &&
                  Yu(x, I, E, A, T, L, re.x, re.y) &&
                  li(re.prev, re, re.next) >= 0
                )
                  return !1;
                re = re.nextZ;
              }
              return !0;
            }
            function h_(r, i, o) {
              var l = r;
              do {
                var h = l.prev,
                  m = l.next.next;
                !Qu(h, m) &&
                  yd(h, l, l.next, m) &&
                  vd(h, m) &&
                  vd(m, h) &&
                  (i.push((h.i / o) | 0),
                  i.push((l.i / o) | 0),
                  i.push((m.i / o) | 0),
                  xd(l),
                  xd(l.next),
                  (l = r = m)),
                  (l = l.next);
              } while (l !== r);
              return il(l);
            }
            function ym(r, i, o, l, h, m) {
              var _ = r;
              do {
                for (var x = _.next.next; x !== _.prev; ) {
                  if (_.i !== x.i && Pv(_, x)) {
                    var E = p_(_, x);
                    return (
                      (_ = il(_, _.next)),
                      (E = il(E, E.next)),
                      Ku(_, i, o, l, h, m, 0),
                      void Ku(E, i, o, l, h, m, 0)
                    );
                  }
                  x = x.next;
                }
                _ = _.next;
              } while (_ !== r);
            }
            function vm(r, i) {
              return r.x - i.x;
            }
            function xm(r, i) {
              var o = (function (h, m) {
                var _,
                  x = m,
                  E = h.x,
                  T = h.y,
                  I = -1 / 0;
                do {
                  if (T <= x.y && T >= x.next.y && x.next.y !== x.y) {
                    var A =
                      x.x + ((T - x.y) * (x.next.x - x.x)) / (x.next.y - x.y);
                    if (
                      A <= E &&
                      A > I &&
                      ((I = A), (_ = x.x < x.next.x ? x : x.next), A === E)
                    )
                      return _;
                  }
                  x = x.next;
                } while (x !== m);
                if (!_) return null;
                var L,
                  O = _,
                  F = _.x,
                  V = _.y,
                  G = 1 / 0;
                x = _;
                do {
                  E >= x.x &&
                    x.x >= F &&
                    E !== x.x &&
                    Yu(T < V ? E : I, T, F, V, T < V ? I : E, T, x.x, x.y) &&
                    ((L = Math.abs(T - x.y) / (E - x.x)),
                    vd(x, h) &&
                      (L < G ||
                        (L === G &&
                          (x.x > _.x || (x.x === _.x && _d(_, x))))) &&
                      ((_ = x), (G = L))),
                    (x = x.next);
                } while (x !== O);
                return _;
              })(r, i);
              if (!o) return i;
              var l = p_(o, r);
              return il(l, l.next), il(o, o.next);
            }
            function _d(r, i) {
              return li(r.prev, r, i.prev) < 0 && li(i.next, r, r.next) < 0;
            }
            function bm(r, i, o, l, h) {
              return (
                (r =
                  1431655765 &
                  ((r =
                    858993459 &
                    ((r =
                      252645135 &
                      ((r = 16711935 & ((r = ((r - o) * h) | 0) | (r << 8))) |
                        (r << 4))) |
                      (r << 2))) |
                    (r << 1))) |
                ((i =
                  1431655765 &
                  ((i =
                    858993459 &
                    ((i =
                      252645135 &
                      ((i = 16711935 & ((i = ((i - l) * h) | 0) | (i << 8))) |
                        (i << 4))) |
                      (i << 2))) |
                    (i << 1))) <<
                  1)
              );
            }
            function d_(r) {
              var i = r,
                o = r;
              do {
                (i.x < o.x || (i.x === o.x && i.y < o.y)) && (o = i),
                  (i = i.next);
              } while (i !== r);
              return o;
            }
            function Yu(r, i, o, l, h, m, _, x) {
              return (
                (h - _) * (i - x) >= (r - _) * (m - x) &&
                (r - _) * (l - x) >= (o - _) * (i - x) &&
                (o - _) * (m - x) >= (h - _) * (l - x)
              );
            }
            function Pv(r, i) {
              return (
                r.next.i !== i.i &&
                r.prev.i !== i.i &&
                !(function (o, l) {
                  var h = o;
                  do {
                    if (
                      h.i !== o.i &&
                      h.next.i !== o.i &&
                      h.i !== l.i &&
                      h.next.i !== l.i &&
                      yd(h, h.next, o, l)
                    )
                      return !0;
                    h = h.next;
                  } while (h !== o);
                  return !1;
                })(r, i) &&
                ((vd(r, i) &&
                  vd(i, r) &&
                  (function (o, l) {
                    var h = o,
                      m = !1,
                      _ = (o.x + l.x) / 2,
                      x = (o.y + l.y) / 2;
                    do {
                      h.y > x != h.next.y > x &&
                        h.next.y !== h.y &&
                        _ <
                          ((h.next.x - h.x) * (x - h.y)) / (h.next.y - h.y) +
                            h.x &&
                        (m = !m),
                        (h = h.next);
                    } while (h !== o);
                    return m;
                  })(r, i) &&
                  (li(r.prev, r, i.prev) || li(r, i.prev, i))) ||
                  (Qu(r, i) &&
                    li(r.prev, r, r.next) > 0 &&
                    li(i.prev, i, i.next) > 0))
              );
            }
            function li(r, i, o) {
              return (i.y - r.y) * (o.x - i.x) - (i.x - r.x) * (o.y - i.y);
            }
            function Qu(r, i) {
              return r.x === i.x && r.y === i.y;
            }
            function yd(r, i, o, l) {
              var h = ha(li(r, i, o)),
                m = ha(li(r, i, l)),
                _ = ha(li(o, l, r)),
                x = ha(li(o, l, i));
              return (
                (h !== m && _ !== x) ||
                !(0 !== h || !Ju(r, o, i)) ||
                !(0 !== m || !Ju(r, l, i)) ||
                !(0 !== _ || !Ju(o, r, l)) ||
                !(0 !== x || !Ju(o, i, l))
              );
            }
            function Ju(r, i, o) {
              return (
                i.x <= Math.max(r.x, o.x) &&
                i.x >= Math.min(r.x, o.x) &&
                i.y <= Math.max(r.y, o.y) &&
                i.y >= Math.min(r.y, o.y)
              );
            }
            function ha(r) {
              return r > 0 ? 1 : r < 0 ? -1 : 0;
            }
            function vd(r, i) {
              return li(r.prev, r, r.next) < 0
                ? li(r, i, r.next) >= 0 && li(r, r.prev, i) >= 0
                : li(r, i, r.prev) < 0 || li(r, r.next, i) < 0;
            }
            function p_(r, i) {
              var o = new bd(r.i, r.x, r.y),
                l = new bd(i.i, i.x, i.y),
                h = r.next,
                m = i.prev;
              return (
                (r.next = i),
                (i.prev = r),
                (o.next = h),
                (h.prev = o),
                (l.next = o),
                (o.prev = l),
                (m.next = l),
                (l.prev = m),
                l
              );
            }
            function Lv(r, i, o, l) {
              var h = new bd(r, i, o);
              return (
                l
                  ? ((h.next = l.next),
                    (h.prev = l),
                    (l.next.prev = h),
                    (l.next = h))
                  : ((h.prev = h), (h.next = h)),
                h
              );
            }
            function xd(r) {
              (r.next.prev = r.prev),
                (r.prev.next = r.next),
                r.prevZ && (r.prevZ.nextZ = r.nextZ),
                r.nextZ && (r.nextZ.prevZ = r.prevZ);
            }
            function bd(r, i, o) {
              (this.i = r),
                (this.x = i),
                (this.y = o),
                (this.prev = null),
                (this.next = null),
                (this.z = 0),
                (this.prevZ = null),
                (this.nextZ = null),
                (this.steiner = !1);
            }
            function wm(r, i, o, l) {
              for (var h = 0, m = i, _ = o - l; m < o; m += l)
                (h += (r[_] - r[m]) * (r[m + 1] + r[_ + 1])), (_ = m);
              return h;
            }
            (Vp.exports = gd),
              (Vp.exports.default = gd),
              (gd.deviation = function (r, i, o, l) {
                var h = i && i.length,
                  m = Math.abs(wm(r, 0, h ? i[0] * o : r.length, o));
                if (h)
                  for (var _ = 0, x = i.length; _ < x; _++)
                    m -= Math.abs(
                      wm(r, i[_] * o, _ < x - 1 ? i[_ + 1] * o : r.length, o)
                    );
                var E = 0;
                for (_ = 0; _ < l.length; _ += 3) {
                  var T = l[_] * o,
                    I = l[_ + 1] * o,
                    A = l[_ + 2] * o;
                  E += Math.abs(
                    (r[T] - r[A]) * (r[I + 1] - r[T + 1]) -
                      (r[T] - r[I]) * (r[A + 1] - r[T + 1])
                  );
                }
                return 0 === m && 0 === E ? 0 : Math.abs((E - m) / m);
              }),
              (gd.flatten = function (r) {
                for (
                  var i = r[0][0].length,
                    o = { vertices: [], holes: [], dimensions: i },
                    l = 0,
                    h = 0;
                  h < r.length;
                  h++
                ) {
                  for (var m = 0; m < r[h].length; m++)
                    for (var _ = 0; _ < i; _++) o.vertices.push(r[h][m][_]);
                  h > 0 && o.holes.push((l += r[h - 1].length));
                }
                return o;
              });
            var $p = Ur(Vp.exports);
            function Hp(r, i, o, l, h) {
              Gp(r, i, o || 0, l || r.length - 1, h || f_);
            }
            function Gp(r, i, o, l, h) {
              for (; l > o; ) {
                if (l - o > 600) {
                  var m = l - o + 1,
                    _ = i - o + 1,
                    x = Math.log(m),
                    E = 0.5 * Math.exp((2 * x) / 3),
                    T =
                      0.5 *
                      Math.sqrt((x * E * (m - E)) / m) *
                      (_ - m / 2 < 0 ? -1 : 1);
                  Gp(
                    r,
                    i,
                    Math.max(o, Math.floor(i - (_ * E) / m + T)),
                    Math.min(l, Math.floor(i + ((m - _) * E) / m + T)),
                    h
                  );
                }
                var I = r[i],
                  A = o,
                  L = l;
                for (eh(r, o, i), h(r[l], I) > 0 && eh(r, o, l); A < L; ) {
                  for (eh(r, A, L), A++, L--; h(r[A], I) < 0; ) A++;
                  for (; h(r[L], I) > 0; ) L--;
                }
                0 === h(r[o], I) ? eh(r, o, L) : eh(r, ++L, l),
                  L <= i && (o = L + 1),
                  i <= L && (l = L - 1);
              }
            }
            function eh(r, i, o) {
              var l = r[i];
              (r[i] = r[o]), (r[o] = l);
            }
            function f_(r, i) {
              return r < i ? -1 : r > i ? 1 : 0;
            }
            function qp(r, i) {
              const o = r.length;
              if (o <= 1) return [r];
              const l = [];
              let h, m;
              for (let _ = 0; _ < o; _++) {
                const x = uu(r[_]);
                0 !== x &&
                  ((r[_].area = Math.abs(x)),
                  void 0 === m && (m = x < 0),
                  m === x < 0 ? (h && l.push(h), (h = [r[_]])) : h.push(r[_]));
              }
              if ((h && l.push(h), i > 1))
                for (let _ = 0; _ < l.length; _++)
                  l[_].length <= i ||
                    (Hp(l[_], i, 1, l[_].length - 1, m_),
                    (l[_] = l[_].slice(0, i)));
              return l;
            }
            function m_(r, i) {
              return i.area - r.area;
            }
            function Em(r, i, o) {
              const l = o.patternDependencies;
              let h = !1;
              for (const m of i) {
                const _ = m.paint.get(`${r}-pattern`);
                _.isConstant() || (h = !0);
                const x = _.constantOr(null);
                x && ((h = !0), (l[x] = !0));
              }
              return h;
            }
            function Tm(r, i, o, l, h) {
              const m = h.patternDependencies;
              for (const _ of i) {
                const x = _.paint.get(`${r}-pattern`).value;
                if ("constant" !== x.kind) {
                  let E = x.evaluate({ zoom: l }, o, {}, h.availableImages);
                  (E = E && E.name ? E.name : E),
                    (m[E] = !0),
                    (o.patterns[_.id] = E);
                }
              }
              return o;
            }
            class Wp {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.layoutVertexArray = new Ge()),
                  (this.indexArray = new _t()),
                  (this.indexArray2 = new vi()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.segments = new xi()),
                  (this.segments2 = new xi()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id)),
                  (this.projection = i.projection);
              }
              populate(i, o, l, h) {
                this.hasPattern = Em("fill", this.layers, o);
                const m = this.layers[0].layout.get("fill-sort-key"),
                  _ = [];
                for (const {
                  feature: x,
                  id: E,
                  index: T,
                  sourceLayerIndex: I,
                } of i) {
                  const A = this.layers[0]._featureFilter.needGeometry,
                    L = tl(x, A);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      L,
                      l
                    )
                  )
                    continue;
                  const O = m
                      ? m.evaluate(L, {}, l, o.availableImages)
                      : void 0,
                    F = {
                      id: E,
                      properties: x.properties,
                      type: x.type,
                      sourceLayerIndex: I,
                      index: T,
                      geometry: A ? L.geometry : el(x, l, h),
                      patterns: {},
                      sortKey: O,
                    };
                  _.push(F);
                }
                m && _.sort((x, E) => x.sortKey - E.sortKey);
                for (const x of _) {
                  const { geometry: E, index: T, sourceLayerIndex: I } = x;
                  if (this.hasPattern) {
                    const A = Tm("fill", this.layers, x, this.zoom, o);
                    this.patternFeatures.push(A);
                  } else this.addFeature(x, E, T, l, {}, o.availableImages);
                  o.featureIndex.insert(i[T].feature, E, T, I, this.index);
                }
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              addFeatures(i, o, l, h, m) {
                for (const _ of this.patternFeatures)
                  this.addFeature(_, _.geometry, _.index, o, l, h);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    Av
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  (this.indexBuffer2 = i.createIndexBuffer(this.indexArray2))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.indexBuffer2.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.segments2.destroy());
              }
              addFeature(i, o, l, h, m, _ = []) {
                for (const x of qp(o, 500)) {
                  let E = 0;
                  for (const F of x) E += F.length;
                  const T = this.segments.prepareSegment(
                      E,
                      this.layoutVertexArray,
                      this.indexArray
                    ),
                    I = T.vertexLength,
                    A = [],
                    L = [];
                  for (const F of x) {
                    if (0 === F.length) continue;
                    F !== x[0] && L.push(A.length / 2);
                    const V = this.segments2.prepareSegment(
                        F.length,
                        this.layoutVertexArray,
                        this.indexArray2
                      ),
                      G = V.vertexLength;
                    this.layoutVertexArray.emplaceBack(F[0].x, F[0].y),
                      this.indexArray2.emplaceBack(G + F.length - 1, G),
                      A.push(F[0].x),
                      A.push(F[0].y);
                    for (let K = 1; K < F.length; K++)
                      this.layoutVertexArray.emplaceBack(F[K].x, F[K].y),
                        this.indexArray2.emplaceBack(G + K - 1, G + K),
                        A.push(F[K].x),
                        A.push(F[K].y);
                    (V.vertexLength += F.length),
                      (V.primitiveLength += F.length);
                  }
                  const O = $p(A, L);
                  for (let F = 0; F < O.length; F += 3)
                    this.indexArray.emplaceBack(
                      I + O[F],
                      I + O[F + 1],
                      I + O[F + 2]
                    );
                  (T.vertexLength += E), (T.primitiveLength += O.length / 3);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  m,
                  _,
                  h
                );
              }
            }
            lt(Wp, "FillBucket", { omit: ["layers", "patternFeatures"] });
            const kv = new te({
              "fill-sort-key": new W(Ae.layout_fill["fill-sort-key"]),
            });
            var Rv = {
              paint: new te({
                "fill-antialias": new B(Ae.paint_fill["fill-antialias"]),
                "fill-opacity": new W(Ae.paint_fill["fill-opacity"]),
                "fill-color": new W(Ae.paint_fill["fill-color"]),
                "fill-outline-color": new W(
                  Ae.paint_fill["fill-outline-color"]
                ),
                "fill-translate": new B(Ae.paint_fill["fill-translate"]),
                "fill-translate-anchor": new B(
                  Ae.paint_fill["fill-translate-anchor"]
                ),
                "fill-pattern": new W(Ae.paint_fill["fill-pattern"]),
              }),
              layout: kv,
            };
            const ql = ge([
                { name: "a_pos_normal_ed", components: 4, type: "Int16" },
              ]),
              wd = ge([
                { name: "a_centroid_pos", components: 2, type: "Uint16" },
              ]),
              Ov = ge([
                { name: "a_pos_3", components: 3, type: "Int16" },
                { name: "a_pos_normal_3", components: 3, type: "Int16" },
              ]),
              { members: wb } = ql;
            var Dm = {},
              Eb = is,
              Fv = Ed;
            function Ed(r, i, o, l, h) {
              (this.properties = {}),
                (this.extent = o),
                (this.type = 0),
                (this._pbf = r),
                (this._geometry = -1),
                (this._keys = l),
                (this._values = h),
                r.readFields(g_, this, i);
            }
            function g_(r, i, o) {
              1 == r
                ? (i.id = o.readVarint())
                : 2 == r
                ? (function (l, h) {
                    for (var m = l.readVarint() + l.pos; l.pos < m; ) {
                      var _ = h._keys[l.readVarint()],
                        x = h._values[l.readVarint()];
                      h.properties[_] = x;
                    }
                  })(o, i)
                : 3 == r
                ? (i.type = o.readVarint())
                : 4 == r && (i._geometry = o.pos);
            }
            function Nv(r) {
              for (
                var i, o, l = 0, h = 0, m = r.length, _ = m - 1;
                h < m;
                _ = h++
              )
                l += ((o = r[_]).x - (i = r[h]).x) * (i.y + o.y);
              return l;
            }
            (Ed.types = ["Unknown", "Point", "LineString", "Polygon"]),
              (Ed.prototype.loadGeometry = function () {
                var r = this._pbf;
                r.pos = this._geometry;
                for (
                  var i,
                    o = r.readVarint() + r.pos,
                    l = 1,
                    h = 0,
                    m = 0,
                    _ = 0,
                    x = [];
                  r.pos < o;

                ) {
                  if (h <= 0) {
                    var E = r.readVarint();
                    (l = 7 & E), (h = E >> 3);
                  }
                  if ((h--, 1 === l || 2 === l))
                    (m += r.readSVarint()),
                      (_ += r.readSVarint()),
                      1 === l && (i && x.push(i), (i = [])),
                      i.push(new Eb(m, _));
                  else {
                    if (7 !== l) throw new Error("unknown command " + l);
                    i && i.push(i[0].clone());
                  }
                }
                return i && x.push(i), x;
              }),
              (Ed.prototype.bbox = function () {
                var r = this._pbf;
                r.pos = this._geometry;
                for (
                  var i = r.readVarint() + r.pos,
                    o = 1,
                    l = 0,
                    h = 0,
                    m = 0,
                    _ = 1 / 0,
                    x = -1 / 0,
                    E = 1 / 0,
                    T = -1 / 0;
                  r.pos < i;

                ) {
                  if (l <= 0) {
                    var I = r.readVarint();
                    (o = 7 & I), (l = I >> 3);
                  }
                  if ((l--, 1 === o || 2 === o))
                    (h += r.readSVarint()) < _ && (_ = h),
                      h > x && (x = h),
                      (m += r.readSVarint()) < E && (E = m),
                      m > T && (T = m);
                  else if (7 !== o) throw new Error("unknown command " + o);
                }
                return [_, E, x, T];
              }),
              (Ed.prototype.toGeoJSON = function (r, i, o) {
                var l,
                  h,
                  m = this.extent * Math.pow(2, o),
                  _ = this.extent * r,
                  x = this.extent * i,
                  E = this.loadGeometry(),
                  T = Ed.types[this.type];
                function I(O) {
                  for (var F = 0; F < O.length; F++) {
                    var V = O[F];
                    O[F] = [
                      (360 * (V.x + _)) / m - 180,
                      (360 / Math.PI) *
                        Math.atan(
                          Math.exp(
                            ((180 - (360 * (V.y + x)) / m) * Math.PI) / 180
                          )
                        ) -
                        90,
                    ];
                  }
                }
                switch (this.type) {
                  case 1:
                    var A = [];
                    for (l = 0; l < E.length; l++) A[l] = E[l][0];
                    I((E = A));
                    break;
                  case 2:
                    for (l = 0; l < E.length; l++) I(E[l]);
                    break;
                  case 3:
                    for (
                      E = (function (O) {
                        var F = O.length;
                        if (F <= 1) return [O];
                        for (var V, G, K = [], oe = 0; oe < F; oe++) {
                          var J = Nv(O[oe]);
                          0 !== J &&
                            (void 0 === G && (G = J < 0),
                            G === J < 0
                              ? (V && K.push(V), (V = [O[oe]]))
                              : V.push(O[oe]));
                        }
                        return V && K.push(V), K;
                      })(E),
                        l = 0;
                      l < E.length;
                      l++
                    )
                      for (h = 0; h < E[l].length; h++) I(E[l][h]);
                }
                1 === E.length ? (E = E[0]) : (T = "Multi" + T);
                var L = {
                  type: "Feature",
                  geometry: { type: T, coordinates: E },
                  properties: this.properties,
                };
                return "id" in this && (L.id = this.id), L;
              });
            var zv = Fv,
              __ = y_;
            function y_(r, i) {
              (this.version = 1),
                (this.name = null),
                (this.extent = 4096),
                (this.length = 0),
                (this._pbf = r),
                (this._keys = []),
                (this._values = []),
                (this._features = []),
                r.readFields(Cm, this, i),
                (this.length = this._features.length);
            }
            function Cm(r, i, o) {
              15 === r
                ? (i.version = o.readVarint())
                : 1 === r
                ? (i.name = o.readString())
                : 5 === r
                ? (i.extent = o.readVarint())
                : 2 === r
                ? i._features.push(o.pos)
                : 3 === r
                ? i._keys.push(o.readString())
                : 4 === r &&
                  i._values.push(
                    (function (l) {
                      for (
                        var h = null, m = l.readVarint() + l.pos;
                        l.pos < m;

                      ) {
                        var _ = l.readVarint() >> 3;
                        h =
                          1 === _
                            ? l.readString()
                            : 2 === _
                            ? l.readFloat()
                            : 3 === _
                            ? l.readDouble()
                            : 4 === _
                            ? l.readVarint64()
                            : 5 === _
                            ? l.readVarint()
                            : 6 === _
                            ? l.readSVarint()
                            : 7 === _
                            ? l.readBoolean()
                            : null;
                      }
                      return h;
                    })(o)
                  );
            }
            y_.prototype.feature = function (r) {
              if (r < 0 || r >= this._features.length)
                throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[r];
              var i = this._pbf.readVarint() + this._pbf.pos;
              return new zv(
                this._pbf,
                i,
                this.extent,
                this._keys,
                this._values
              );
            };
            var rl = __;
            function Td(r, i, o) {
              if (3 === r) {
                var l = new rl(o, o.readVarint() + o.pos);
                l.length && (i[l.name] = l);
              }
            }
            var Zp = (Dm.VectorTile = function (r, i) {
                this.layers = r.readFields(Td, {}, i);
              }),
              Dd = (Dm.VectorTileFeature = Fv);
            function Cd(r, i, o, l) {
              const h = [],
                m =
                  0 === l
                    ? (_, x, E, T, I, A) => {
                        _.push(new nt(A, E + ((A - x) / (T - x)) * (I - E)));
                      }
                    : (_, x, E, T, I, A) => {
                        _.push(new nt(x + ((A - E) / (I - E)) * (T - x), A));
                      };
              for (const _ of r) {
                const x = [];
                for (const E of _) {
                  if (E.length <= 2) continue;
                  const T = [];
                  for (let L = 0; L < E.length - 1; L++) {
                    const O = E[L].x,
                      F = E[L].y,
                      V = E[L + 1].x,
                      G = E[L + 1].y,
                      K = 0 === l ? O : F,
                      oe = 0 === l ? V : G;
                    K < i
                      ? oe > i && m(T, O, F, V, G, i)
                      : K > o
                      ? oe < o && m(T, O, F, V, G, o)
                      : T.push(E[L]),
                      oe < i && K >= i && m(T, O, F, V, G, i),
                      oe > o && K <= o && m(T, O, F, V, G, o);
                  }
                  let I = E[E.length - 1];
                  const A = 0 === l ? I.x : I.y;
                  A >= i && A <= o && T.push(I),
                    T.length &&
                      ((I = T[T.length - 1]),
                      (T[0].x === I.x && T[0].y === I.y) || T.push(T[0]),
                      x.push(T));
                }
                x.length && h.push(x);
              }
              return h;
            }
            Dm.VectorTileLayer = __;
            const Tb = Dd.types,
              Db = Math.pow(2, 13);
            function Xp(r, i, o, l, h, m, _, x) {
              r.emplaceBack(
                (i << 1) + _,
                (o << 1) + m,
                (Math.floor(l * Db) << 1) + h,
                Math.round(x)
              );
            }
            function Bc(r, i, o) {
              r.emplaceBack(
                i.x,
                i.y,
                i.z,
                16384 * o[0],
                16384 * o[1],
                16384 * o[2]
              );
            }
            class Kp {
              constructor() {
                (this.acc = new nt(0, 0)), (this.polyCount = []);
              }
              startRing(i) {
                (this.currentPolyCount = { edges: 0, top: 0 }),
                  this.polyCount.push(this.currentPolyCount),
                  this.min ||
                    ((this.min = new nt(i.x, i.y)),
                    (this.max = new nt(i.x, i.y)));
              }
              append(i, o) {
                this.currentPolyCount.edges++, this.acc._add(i);
                const l = this.min,
                  h = this.max;
                i.x < l.x ? (l.x = i.x) : i.x > h.x && (h.x = i.x),
                  i.y < l.y ? (l.y = i.y) : i.y > h.y && (h.y = i.y),
                  ((0 === i.x || i.x === wt) && i.x === o.x) !=
                    ((0 === i.y || i.y === wt) && i.y === o.y) &&
                    this.processBorderOverlap(i, o),
                  o.x < 0 != i.x < 0 &&
                    this.addBorderIntersection(
                      0,
                      ln(o.y, i.y, (0 - o.x) / (i.x - o.x))
                    ),
                  o.x > wt != i.x > wt &&
                    this.addBorderIntersection(
                      1,
                      ln(o.y, i.y, (wt - o.x) / (i.x - o.x))
                    ),
                  o.y < 0 != i.y < 0 &&
                    this.addBorderIntersection(
                      2,
                      ln(o.x, i.x, (0 - o.y) / (i.y - o.y))
                    ),
                  o.y > wt != i.y > wt &&
                    this.addBorderIntersection(
                      3,
                      ln(o.x, i.x, (wt - o.y) / (i.y - o.y))
                    );
              }
              addBorderIntersection(i, o) {
                this.borders ||
                  (this.borders = [
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                  ]);
                const l = this.borders[i];
                o < l[0] && (l[0] = o), o > l[1] && (l[1] = o);
              }
              processBorderOverlap(i, o) {
                if (i.x === o.x) {
                  if (i.y === o.y) return;
                  const l = 0 === i.x ? 0 : 1;
                  this.addBorderIntersection(l, o.y),
                    this.addBorderIntersection(l, i.y);
                } else {
                  const l = 0 === i.y ? 2 : 3;
                  this.addBorderIntersection(l, o.x),
                    this.addBorderIntersection(l, i.x);
                }
              }
              centroid() {
                const i = this.polyCount.reduce((o, l) => o + l.edges, 0);
                return 0 !== i ? this.acc.div(i)._round() : new nt(0, 0);
              }
              span() {
                return new nt(this.max.x - this.min.x, this.max.y - this.min.y);
              }
              intersectsCount() {
                return this.borders.reduce(
                  (i, o) => i + +(o[0] !== Number.MAX_VALUE),
                  0
                );
              }
            }
            class Yp {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.canonical = i.canonical),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.hasPattern = !1),
                  (this.edgeRadius = 0),
                  (this.projection = i.projection),
                  (this.layoutVertexArray = new Le()),
                  (this.centroidVertexArray = new Nr()),
                  (this.indexArray = new _t()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.segments = new xi()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id)),
                  (this.enableTerrain = i.enableTerrain);
              }
              populate(i, o, l, h) {
                (this.features = []),
                  (this.hasPattern = Em("fill-extrusion", this.layers, o)),
                  (this.featuresOnBorder = []),
                  (this.borders = [[], [], [], []]),
                  (this.borderDoneWithNeighborZ = [-1, -1, -1, -1]),
                  (this.tileToMeter = (function (m) {
                    const _ = Math.exp(Math.PI * (1 - (m.y / (1 << m.z)) * 2));
                    return (80150034 * _) / (_ * _ + 1) / wt / (1 << m.z);
                  })(l)),
                  (this.edgeRadius =
                    this.layers[0].layout.get("fill-extrusion-edge-radius") /
                    this.tileToMeter);
                for (const {
                  feature: m,
                  id: _,
                  index: x,
                  sourceLayerIndex: E,
                } of i) {
                  const T = this.layers[0]._featureFilter.needGeometry,
                    I = tl(m, T);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      I,
                      l
                    )
                  )
                    continue;
                  const A = {
                      id: _,
                      sourceLayerIndex: E,
                      index: x,
                      geometry: T ? I.geometry : el(m, l, h),
                      properties: m.properties,
                      type: m.type,
                      patterns: {},
                    },
                    L = this.layoutVertexArray.length;
                  this.hasPattern
                    ? this.features.push(
                        Tm("fill-extrusion", this.layers, A, this.zoom, o)
                      )
                    : this.addFeature(
                        A,
                        A.geometry,
                        x,
                        l,
                        {},
                        o.availableImages,
                        h
                      ),
                    o.featureIndex.insert(m, A.geometry, x, E, this.index, L);
                }
                this.sortBorders();
              }
              addFeatures(i, o, l, h, m) {
                for (const _ of this.features) {
                  const { geometry: x } = _;
                  this.addFeature(_, x, _.index, o, l, h, m);
                }
                this.sortBorders();
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    wb
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  this.layoutVertexExtArray &&
                    (this.layoutVertexExtBuffer = i.createVertexBuffer(
                      this.layoutVertexExtArray,
                      Ov.members,
                      !0
                    ))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              uploadCentroid(i) {
                0 !== this.centroidVertexArray.length &&
                  (this.centroidVertexBuffer
                    ? this.needsCentroidUpdate &&
                      this.centroidVertexBuffer.updateData(
                        this.centroidVertexArray
                      )
                    : (this.centroidVertexBuffer = i.createVertexBuffer(
                        this.centroidVertexArray,
                        wd.members,
                        !0
                      )),
                  (this.needsCentroidUpdate = !1));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.centroidVertexBuffer &&
                    this.centroidVertexBuffer.destroy(),
                  this.layoutVertexExtBuffer &&
                    this.layoutVertexExtBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              addFeature(i, o, l, h, m, _, x) {
                const E = [new nt(0, 0), new nt(wt, wt)],
                  T = x.projection,
                  I = "globe" === T.name,
                  A = this.enableTerrain && !I ? new Kp() : null,
                  L = "Polygon" === Tb[i.type];
                I &&
                  !this.layoutVertexExtArray &&
                  (this.layoutVertexExtArray = new He());
                const O = qp(o, 500);
                for (let K = O.length - 1; K >= 0; K--) {
                  const oe = O[K];
                  (0 === oe.length ||
                    (F = oe[0]).every((J) => J.x <= 0) ||
                    F.every((J) => J.x >= wt) ||
                    F.every((J) => J.y <= 0) ||
                    F.every((J) => J.y >= wt)) &&
                    O.splice(K, 1);
                }
                var F;
                let V;
                if (I) V = Sd(O, E, h);
                else {
                  V = [];
                  for (const K of O) V.push({ polygon: K, bounds: E });
                }
                const G = L ? this.edgeRadius : 0;
                for (const { polygon: K, bounds: oe } of V) {
                  let J = 0,
                    re = 0;
                  for (const ae of K)
                    L && !ae[0].equals(ae[ae.length - 1]) && ae.push(ae[0]),
                      (re += L ? ae.length - 1 : ae.length);
                  const le = this.segments.prepareSegment(
                    (L ? 5 : 4) * re,
                    this.layoutVertexArray,
                    this.indexArray
                  );
                  if (L) {
                    const ae = [],
                      De = [];
                    J = le.vertexLength;
                    for (const Pe of K) {
                      let $e, Ie;
                      Pe.length && Pe !== K[0] && De.push(ae.length / 2),
                        ($e = Pe[1].sub(Pe[0])._perp()._unit());
                      for (let Fe = 1; Fe < Pe.length; Fe++) {
                        const Re = Pe[Fe],
                          Ve = Pe[Fe === Pe.length - 1 ? 1 : Fe + 1];
                        let { x: qe, y: Me } = Re;
                        if (G) {
                          Ie = Ve.sub(Re)._perp()._unit();
                          const tt = $e.add(Ie)._unit(),
                            pt =
                              G * Math.min(4, 1 / ($e.x * tt.x + $e.y * tt.y));
                          (qe += pt * tt.x), (Me += pt * tt.y), ($e = Ie);
                        }
                        Xp(this.layoutVertexArray, qe, Me, 0, 0, 1, 1, 0),
                          le.vertexLength++,
                          ae.push(Re.x, Re.y),
                          I &&
                            Bc(
                              this.layoutVertexExtArray,
                              T.projectTilePoint(qe, Me, h),
                              T.upVector(h, qe, Me)
                            );
                      }
                    }
                    const xe = $p(ae, De);
                    for (let Pe = 0; Pe < xe.length; Pe += 3)
                      this.indexArray.emplaceBack(
                        J + xe[Pe],
                        J + xe[Pe + 2],
                        J + xe[Pe + 1]
                      ),
                        le.primitiveLength++;
                  }
                  for (const ae of K) {
                    A && ae.length && A.startRing(ae[0]);
                    let De,
                      xe,
                      Pe,
                      $e = ae.length > 4 && w_(ae[ae.length - 2], ae[0], ae[1]),
                      Ie = G ? v_(ae[ae.length - 2], ae[0], ae[1], G) : 0;
                    xe = ae[1].sub(ae[0])._perp()._unit();
                    let Fe = !0;
                    for (let Re = 1, Ve = 0; Re < ae.length; Re++) {
                      let qe = ae[Re - 1],
                        Me = ae[Re];
                      const tt = ae[Re === ae.length - 1 ? 1 : Re + 1];
                      if (
                        (A && L && A.currentPolyCount.top++, b_(Me, qe, oe))
                      ) {
                        G && ((xe = tt.sub(Me)._perp()._unit()), (Fe = !Fe));
                        continue;
                      }
                      A && A.append(Me, qe);
                      const pt = Me.sub(qe)._perp(),
                        rt = pt.x / (Math.abs(pt.x) + Math.abs(pt.y)),
                        Lt = pt.y > 0 ? 1 : 0,
                        Ke = qe.dist(Me);
                      if ((Ve + Ke > 32768 && (Ve = 0), G)) {
                        Pe = tt.sub(Me)._perp()._unit();
                        let At = x_(qe, Me, tt, Bv(xe, Pe), G);
                        isNaN(At) && (At = 0);
                        const Et = Me.sub(qe)._unit();
                        (qe = qe.add(Et.mult(Ie))._round()),
                          (Me = Me.add(Et.mult(-At))._round()),
                          (Ie = At),
                          (xe = Pe);
                      }
                      const bt = le.vertexLength,
                        Pt = ae.length > 4 && w_(qe, Me, tt);
                      let Yt = E_(Ve, $e, Fe);
                      if (
                        (Xp(
                          this.layoutVertexArray,
                          qe.x,
                          qe.y,
                          rt,
                          Lt,
                          0,
                          0,
                          Yt
                        ),
                        Xp(
                          this.layoutVertexArray,
                          qe.x,
                          qe.y,
                          rt,
                          Lt,
                          0,
                          1,
                          Yt
                        ),
                        (Ve += Ke),
                        (Yt = E_(Ve, Pt, !Fe)),
                        ($e = Pt),
                        Xp(
                          this.layoutVertexArray,
                          Me.x,
                          Me.y,
                          rt,
                          Lt,
                          0,
                          0,
                          Yt
                        ),
                        Xp(
                          this.layoutVertexArray,
                          Me.x,
                          Me.y,
                          rt,
                          Lt,
                          0,
                          1,
                          Yt
                        ),
                        (le.vertexLength += 4),
                        this.indexArray.emplaceBack(bt + 0, bt + 1, bt + 2),
                        this.indexArray.emplaceBack(bt + 1, bt + 3, bt + 2),
                        (le.primitiveLength += 2),
                        G)
                      ) {
                        const At = J + (1 === Re ? ae.length - 2 : Re - 2),
                          Et = 1 === Re ? J : At + 1;
                        if (
                          (this.indexArray.emplaceBack(bt + 1, At, bt + 3),
                          this.indexArray.emplaceBack(At, Et, bt + 3),
                          (le.primitiveLength += 2),
                          void 0 === De && (De = bt),
                          !b_(tt, ae[Re], oe))
                        ) {
                          const In =
                            Re === ae.length - 1 ? De : le.vertexLength;
                          this.indexArray.emplaceBack(bt + 2, bt + 3, In),
                            this.indexArray.emplaceBack(bt + 3, In + 1, In),
                            this.indexArray.emplaceBack(bt + 3, Et, In + 1),
                            (le.primitiveLength += 3);
                        }
                        Fe = !Fe;
                      }
                      if (I) {
                        const At = this.layoutVertexExtArray,
                          Et = T.projectTilePoint(qe.x, qe.y, h),
                          In = T.projectTilePoint(Me.x, Me.y, h),
                          Nt = T.upVector(h, qe.x, qe.y),
                          kt = T.upVector(h, Me.x, Me.y);
                        Bc(At, Et, Nt),
                          Bc(At, Et, Nt),
                          Bc(At, In, kt),
                          Bc(At, In, kt);
                      }
                    }
                    L && (J += ae.length - 1);
                  }
                }
                if (A && A.polyCount.length > 0) {
                  if (A.borders) {
                    A.vertexArrayOffset = this.centroidVertexArray.length;
                    const K = A.borders,
                      oe = this.featuresOnBorder.push(A) - 1;
                    for (let J = 0; J < 4; J++)
                      K[J][0] !== Number.MAX_VALUE && this.borders[J].push(oe);
                  }
                  this.encodeCentroid(A.borders ? void 0 : A.centroid(), A);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  m,
                  _,
                  h
                );
              }
              sortBorders() {
                for (let i = 0; i < 4; i++)
                  this.borders[i].sort(
                    (o, l) =>
                      this.featuresOnBorder[o].borders[i][0] -
                      this.featuresOnBorder[l].borders[i][0]
                  );
              }
              encodeCentroid(i, o, l = !0) {
                let h, m;
                if (i)
                  if (0 !== i.y) {
                    const x = o.span()._mult(this.tileToMeter);
                    (h =
                      (Math.max(i.x, 1) << 3) +
                      Math.min(7, Math.round(x.x / 10))),
                      (m =
                        (Math.max(i.y, 1) << 3) +
                        Math.min(7, Math.round(x.y / 10)));
                  } else (h = Math.ceil(7 * (i.x + 450))), (m = 0);
                else (h = 0), (m = +l);
                let _ = l
                  ? this.centroidVertexArray.length
                  : o.vertexArrayOffset;
                for (const x of o.polyCount) {
                  l &&
                    this.centroidVertexArray.resize(
                      this.centroidVertexArray.length + 4 * x.edges + x.top
                    );
                  for (let E = 0; E < x.top; E++)
                    this.centroidVertexArray.emplace(_++, h, m);
                  for (let E = 0; E < 2 * x.edges; E++)
                    this.centroidVertexArray.emplace(_++, 0, m),
                      this.centroidVertexArray.emplace(_++, h, m);
                }
              }
            }
            function Bv(r, i) {
              const o = r.add(i)._unit();
              return r.x * o.x + r.y * o.y;
            }
            function v_(r, i, o, l) {
              const h = i.sub(r)._perp()._unit(),
                m = o.sub(i)._perp()._unit();
              return x_(r, i, o, Bv(h, m), l);
            }
            function x_(r, i, o, l, h) {
              const m = Math.sqrt(1 - l * l);
              return Math.min(r.dist(i) / 3, i.dist(o) / 3, (h * m) / l);
            }
            function b_(r, i, o) {
              return (
                (r.x < o[0].x && i.x < o[0].x) ||
                (r.x > o[1].x && i.x > o[1].x) ||
                (r.y < o[0].y && i.y < o[0].y) ||
                (r.y > o[1].y && i.y > o[1].y)
              );
            }
            function w_(r, i, o) {
              if (
                r.x < 0 ||
                r.x >= wt ||
                i.x < 0 ||
                i.x >= wt ||
                o.x < 0 ||
                o.x >= wt
              )
                return !1;
              const l = o.sub(i),
                h = l.perp(),
                m = r.sub(i);
              return (
                (l.x * m.x + l.y * m.y) /
                  Math.sqrt((l.x * l.x + l.y * l.y) * (m.x * m.x + m.y * m.y)) >
                  -0.866 && h.x * m.x + h.y * m.y < 0
              );
            }
            function E_(r, i, o) {
              const l = i ? 2 | r : -3 & r;
              return o ? 1 | l : -2 & l;
            }
            function Sm() {
              const r = Math.PI / 32,
                i = Math.tan(r),
                o = pd;
              return o * Math.sqrt(1 + 2 * i * i) - o;
            }
            function Sd(r, i, o) {
              const l = 1 << o.z,
                h = ao(o.x / l),
                m = ao((o.x + 1) / l),
                _ = qi(o.y / l),
                x = qi((o.y + 1) / l);
              return (function (E, T, I, A, L = 0, O) {
                const F = [];
                if (!E.length || !I || !A) return F;
                const V = (ae, De) => {
                    for (const xe of ae) F.push({ polygon: xe, bounds: De });
                  },
                  G = Math.ceil(Math.log2(I)),
                  K = Math.ceil(Math.log2(A)),
                  oe = G - K,
                  J = [];
                for (let ae = 0; ae < Math.abs(oe); ae++)
                  J.push(oe > 0 ? 0 : 1);
                for (let ae = 0; ae < Math.min(G, K); ae++)
                  J.push(0), J.push(1);
                let re = E;
                if (
                  ((re = Cd(re, T[0].y - L, T[1].y + L, 1)),
                  (re = Cd(re, T[0].x - L, T[1].x + L, 0)),
                  !re.length)
                )
                  return F;
                const le = [];
                for (
                  J.length
                    ? le.push({ polygons: re, bounds: T, depth: 0 })
                    : V(re, T);
                  le.length;

                ) {
                  const ae = le.pop(),
                    De = ae.depth,
                    xe = J[De],
                    Pe = ae.bounds[0],
                    $e = ae.bounds[1],
                    Ie = 0 === xe ? Pe.x : Pe.y,
                    Fe = 0 === xe ? $e.x : $e.y,
                    Re = O ? O(xe, Ie, Fe) : 0.5 * (Ie + Fe),
                    Ve = Cd(ae.polygons, Ie - L, Re + L, xe),
                    qe = Cd(ae.polygons, Re - L, Fe + L, xe);
                  if (Ve.length) {
                    const Me = [
                      Pe,
                      new nt(0 === xe ? Re : $e.x, 1 === xe ? Re : $e.y),
                    ];
                    J.length > De + 1
                      ? le.push({ polygons: Ve, bounds: Me, depth: De + 1 })
                      : V(Ve, Me);
                  }
                  if (qe.length) {
                    const Me = [
                      new nt(0 === xe ? Re : Pe.x, 1 === xe ? Re : Pe.y),
                      $e,
                    ];
                    J.length > De + 1
                      ? le.push({ polygons: qe, bounds: Me, depth: De + 1 })
                      : V(qe, Me);
                  }
                }
                return F;
              })(
                r,
                i,
                Math.ceil((m - h) / 11.25),
                Math.ceil((_ - x) / 11.25),
                1,
                (E, T, I) => {
                  if (0 === E) return 0.5 * (T + I);
                  {
                    const A = qi((o.y + T / wt) / l);
                    return (
                      (ai(0.5 * (qi((o.y + I / wt) / l) + A)) * l - o.y) * wt
                    );
                  }
                }
              );
            }
            lt(Yp, "FillExtrusionBucket", { omit: ["layers", "features"] }),
              lt(Kp, "PartMetadata");
            const Vv = new te({
              "fill-extrusion-edge-radius": new B(
                Ae["layout_fill-extrusion"]["fill-extrusion-edge-radius"]
              ),
            });
            var Im = {
              paint: new te({
                "fill-extrusion-opacity": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-opacity"]
                ),
                "fill-extrusion-color": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-color"]
                ),
                "fill-extrusion-translate": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-translate"]
                ),
                "fill-extrusion-translate-anchor": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]
                ),
                "fill-extrusion-pattern": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-pattern"]
                ),
                "fill-extrusion-height": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-height"]
                ),
                "fill-extrusion-base": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-base"]
                ),
                "fill-extrusion-vertical-gradient": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]
                ),
                "fill-extrusion-ambient-occlusion-intensity": new B(
                  Ae["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-intensity"
                  ]
                ),
                "fill-extrusion-ambient-occlusion-radius": new B(
                  Ae["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-radius"
                  ]
                ),
                "fill-extrusion-rounded-roof": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]
                ),
              }),
              layout: Vv,
            };
            function T_(r, i, o) {
              var l = (2 * Math.PI * 6378137) / 256 / Math.pow(2, o);
              return [
                r * l - (2 * Math.PI * 6378137) / 2,
                i * l - (2 * Math.PI * 6378137) / 2,
              ];
            }
            class bi {
              constructor(i, o, l) {
                (this.z = i),
                  (this.x = o),
                  (this.y = l),
                  (this.key = th(0, i, i, o, l));
              }
              equals(i) {
                return this.z === i.z && this.x === i.x && this.y === i.y;
              }
              url(i, o) {
                const l =
                    ((_ = this.y),
                    (x = this.z),
                    (E = T_(
                      256 * (m = this.x),
                      256 * (_ = Math.pow(2, x) - _ - 1),
                      x
                    )),
                    (T = T_(256 * (m + 1), 256 * (_ + 1), x)),
                    E[0] + "," + E[1] + "," + T[0] + "," + T[1]),
                  h = (function (m, _, x) {
                    let E,
                      T = "";
                    for (let I = m; I > 0; I--)
                      (E = 1 << (I - 1)),
                        (T += (_ & E ? 1 : 0) + (x & E ? 2 : 0));
                    return T;
                  })(this.z, this.x, this.y);
                var m, _, x, E, T;
                return i[(this.x + this.y) % i.length]
                  .replace(
                    "{prefix}",
                    (this.x % 16).toString(16) + (this.y % 16).toString(16)
                  )
                  .replace(/{z}/g, String(this.z))
                  .replace(/{x}/g, String(this.x))
                  .replace(
                    /{y}/g,
                    String(
                      "tms" === o ? Math.pow(2, this.z) - this.y - 1 : this.y
                    )
                  )
                  .replace("{quadkey}", h)
                  .replace("{bbox-epsg-3857}", l);
              }
              toString() {
                return `${this.z}/${this.x}/${this.y}`;
              }
            }
            class D_ {
              constructor(i, o) {
                (this.wrap = i),
                  (this.canonical = o),
                  (this.key = th(i, o.z, o.z, o.x, o.y));
              }
            }
            class Br {
              constructor(i, o, l, h, m) {
                (this.overscaledZ = i),
                  (this.wrap = o),
                  (this.canonical = new bi(l, +h, +m)),
                  (this.key =
                    0 === o && i === l
                      ? this.canonical.key
                      : th(o, i, l, h, m));
              }
              equals(i) {
                return (
                  this.overscaledZ === i.overscaledZ &&
                  this.wrap === i.wrap &&
                  this.canonical.equals(i.canonical)
                );
              }
              scaledTo(i) {
                const o = this.canonical.z - i;
                return i > this.canonical.z
                  ? new Br(
                      i,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    )
                  : new Br(
                      i,
                      this.wrap,
                      i,
                      this.canonical.x >> o,
                      this.canonical.y >> o
                    );
              }
              calculateScaledKey(i, o = !0) {
                if (this.overscaledZ === i && o) return this.key;
                if (i > this.canonical.z)
                  return th(
                    this.wrap * +o,
                    i,
                    this.canonical.z,
                    this.canonical.x,
                    this.canonical.y
                  );
                {
                  const l = this.canonical.z - i;
                  return th(
                    this.wrap * +o,
                    i,
                    i,
                    this.canonical.x >> l,
                    this.canonical.y >> l
                  );
                }
              }
              isChildOf(i) {
                if (i.wrap !== this.wrap) return !1;
                const o = this.canonical.z - i.canonical.z;
                return (
                  0 === i.overscaledZ ||
                  (i.overscaledZ < this.overscaledZ &&
                    i.canonical.x === this.canonical.x >> o &&
                    i.canonical.y === this.canonical.y >> o)
                );
              }
              children(i) {
                if (this.overscaledZ >= i)
                  return [
                    new Br(
                      this.overscaledZ + 1,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    ),
                  ];
                const o = this.canonical.z + 1,
                  l = 2 * this.canonical.x,
                  h = 2 * this.canonical.y;
                return [
                  new Br(o, this.wrap, o, l, h),
                  new Br(o, this.wrap, o, l + 1, h),
                  new Br(o, this.wrap, o, l, h + 1),
                  new Br(o, this.wrap, o, l + 1, h + 1),
                ];
              }
              isLessThan(i) {
                return (
                  this.wrap < i.wrap ||
                  (!(this.wrap > i.wrap) &&
                    (this.overscaledZ < i.overscaledZ ||
                      (!(this.overscaledZ > i.overscaledZ) &&
                        (this.canonical.x < i.canonical.x ||
                          (!(this.canonical.x > i.canonical.x) &&
                            this.canonical.y < i.canonical.y)))))
                );
              }
              wrapped() {
                return new Br(
                  this.overscaledZ,
                  0,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              unwrapTo(i) {
                return new Br(
                  this.overscaledZ,
                  i,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
              }
              toUnwrapped() {
                return new D_(this.wrap, this.canonical);
              }
              toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
              }
            }
            function th(r, i, o, l, h) {
              const m = 1 << Math.min(o, 22);
              let _ = m * (h % m) + (l % m);
              return (
                r &&
                  o < 22 &&
                  (_ +=
                    m *
                    m *
                    ((r < 0 ? -2 * r - 1 : 2 * r) % (1 << (2 * (22 - o))))),
                16 * (32 * _ + o) + (i - o)
              );
            }
            lt(bi, "CanonicalTileID"),
              lt(Br, "OverscaledTileID", { omit: ["projMatrix"] });
            class Vc extends nt {
              constructor(i, o, l) {
                super(i, o), (this.z = l);
              }
            }
            function Id(r, i) {
              return r.x * i.x + r.y * i.y;
            }
            function C_(r, i) {
              if (1 === r.length) {
                let o = 0;
                const l = i[o++];
                let h;
                for (; !h || l.equals(h); )
                  if (((h = i[o++]), !h)) return 1 / 0;
                for (; o < i.length; o++) {
                  const m = i[o],
                    _ = r[0],
                    x = h.sub(l),
                    E = m.sub(l),
                    T = _.sub(l),
                    I = Id(x, x),
                    A = Id(x, E),
                    L = Id(E, E),
                    O = Id(T, x),
                    F = Id(T, E),
                    V = I * L - A * A,
                    G = (L * O - A * F) / V,
                    K = (I * F - A * O) / V,
                    oe = l.z * (1 - G - K) + h.z * G + m.z * K;
                  if (isFinite(oe)) return oe;
                }
                return 1 / 0;
              }
              {
                let o = 1 / 0;
                for (const l of i) o = Math.min(o, l.z);
                return o;
              }
            }
            function S_(r, i, o, l, h, m, _, x) {
              const E = _ * h.getElevationAt(r, i, !0, !0),
                T = 0 !== m[0],
                I = T
                  ? 0 === m[1]
                    ? _ * (m[0] / 7 - 450)
                    : _ *
                      (function (A, L, O) {
                        const F = Math.floor(L[0] / 8),
                          V = Math.floor(L[1] / 8),
                          G = 10 * (L[0] - 8 * F),
                          K = 10 * (L[1] - 8 * V),
                          oe = A.getElevationAt(F, V, !0, !0),
                          J = A.getMeterToDEM(O),
                          re = Math.floor(0.5 * (G * J - 1)),
                          le = Math.floor(0.5 * (K * J - 1)),
                          ae = A.tileCoordToPixel(F, V),
                          De = 2 * re + 1,
                          xe = 2 * le + 1,
                          Pe =
                            ((pt = De),
                            (rt = xe),
                            [
                              (qe = A).getElevationAtPixel(
                                (Me = ae.x - re),
                                (tt = ae.y - le),
                                !0
                              ),
                              qe.getElevationAtPixel(Me + rt, tt, !0),
                              qe.getElevationAtPixel(Me, tt + rt, !0),
                              qe.getElevationAtPixel(Me + pt, tt + rt, !0),
                            ]),
                          $e = Math.abs(Pe[0] - Pe[1]),
                          Ie = Math.abs(Pe[2] - Pe[3]),
                          Fe =
                            Math.abs(Pe[0] - Pe[2]) + Math.abs(Pe[1] - Pe[3]),
                          Re = Math.min(0.25, (0.5 * J * ($e + Ie)) / De),
                          Ve = Math.min(0.25, (0.5 * J * Fe) / xe);
                        var qe, Me, tt, pt, rt;
                        return oe + Math.max(Re * G, Ve * K);
                      })(h, m, x)
                  : E;
              return {
                base: E + (0 === o) ? -1 : o,
                top: T ? Math.max(I + l, E + o + 2) : E + l,
              };
            }
            const jv = ge(
                [
                  { name: "a_pos_normal", components: 2, type: "Int16" },
                  { name: "a_data", components: 4, type: "Uint8" },
                  { name: "a_linesofar", components: 1, type: "Float32" },
                ],
                4
              ),
              { members: Uv } = jv,
              Cb = ge([{ name: "a_packed", components: 4, type: "Float32" }]),
              { members: Sb } = Cb,
              Md = Dd.types,
              I_ = Math.cos((Math.PI / 180) * 37.5);
            class Ad {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.projection = i.projection),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.lineClipsArray = []),
                  (this.gradients = {}),
                  this.layers.forEach((o) => {
                    this.gradients[o.id] = {};
                  }),
                  (this.layoutVertexArray = new Se()),
                  (this.layoutVertexArray2 = new je()),
                  (this.indexArray = new _t()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.segments = new xi()),
                  (this.maxLineLength = 0),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id));
              }
              populate(i, o, l, h) {
                this.hasPattern = Em("line", this.layers, o);
                const m = this.layers[0].layout.get("line-sort-key"),
                  _ = [];
                for (const {
                  feature: I,
                  id: A,
                  index: L,
                  sourceLayerIndex: O,
                } of i) {
                  const F = this.layers[0]._featureFilter.needGeometry,
                    V = tl(I, F);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      V,
                      l
                    )
                  )
                    continue;
                  const G = m ? m.evaluate(V, {}, l) : void 0,
                    K = {
                      id: A,
                      properties: I.properties,
                      type: I.type,
                      sourceLayerIndex: O,
                      index: L,
                      geometry: F ? V.geometry : el(I, l, h),
                      patterns: {},
                      sortKey: G,
                    };
                  _.push(K);
                }
                m && _.sort((I, A) => I.sortKey - A.sortKey);
                const { lineAtlas: x, featureIndex: E } = o,
                  T = this.addConstantDashes(x);
                for (const I of _) {
                  const { geometry: A, index: L, sourceLayerIndex: O } = I;
                  if ((T && this.addFeatureDashes(I, x), this.hasPattern)) {
                    const F = Tm("line", this.layers, I, this.zoom, o);
                    this.patternFeatures.push(F);
                  } else
                    this.addFeature(I, A, L, l, x.positions, o.availableImages);
                  E.insert(i[L].feature, A, L, O, this.index);
                }
              }
              addConstantDashes(i) {
                let o = !1;
                for (const l of this.layers) {
                  const h = l.paint.get("line-dasharray").value,
                    m = l.layout.get("line-cap").value;
                  if ("constant" !== h.kind || "constant" !== m.kind) o = !0;
                  else {
                    const _ = m.value,
                      x = h.value;
                    if (!x) continue;
                    i.addDash(x, _);
                  }
                }
                return o;
              }
              addFeatureDashes(i, o) {
                const l = this.zoom;
                for (const h of this.layers) {
                  const m = h.paint.get("line-dasharray").value,
                    _ = h.layout.get("line-cap").value;
                  if ("constant" === m.kind && "constant" === _.kind) continue;
                  let x, E;
                  if ("constant" === m.kind) {
                    if (((x = m.value), !x)) continue;
                  } else x = m.evaluate({ zoom: l }, i);
                  (E =
                    "constant" === _.kind
                      ? _.value
                      : _.evaluate({ zoom: l }, i)),
                    o.addDash(x, E),
                    (i.patterns[h.id] = o.getKey(x, E));
                }
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              addFeatures(i, o, l, h, m) {
                for (const _ of this.patternFeatures)
                  this.addFeature(_, _.geometry, _.index, o, l, h);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  (0 !== this.layoutVertexArray2.length &&
                    (this.layoutVertexBuffer2 = i.createVertexBuffer(
                      this.layoutVertexArray2,
                      Sb
                    )),
                  (this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    Uv
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              lineFeatureClips(i) {
                if (
                  i.properties &&
                  i.properties.hasOwnProperty("mapbox_clip_start") &&
                  i.properties.hasOwnProperty("mapbox_clip_end")
                )
                  return {
                    start: +i.properties.mapbox_clip_start,
                    end: +i.properties.mapbox_clip_end,
                  };
              }
              addFeature(i, o, l, h, m, _) {
                const x = this.layers[0].layout,
                  E = x.get("line-join").evaluate(i, {}),
                  T = x.get("line-cap").evaluate(i, {}),
                  I = x.get("line-miter-limit"),
                  A = x.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(i);
                for (const L of o) this.addLine(L, i, E, T, I, A);
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  m,
                  _,
                  h
                );
              }
              addLine(i, o, l, h, m, _) {
                if (
                  ((this.distance = 0),
                  (this.scaledDistance = 0),
                  (this.totalDistance = 0),
                  (this.lineSoFar = 0),
                  this.lineClips)
                ) {
                  this.lineClipsArray.push(this.lineClips);
                  for (let K = 0; K < i.length - 1; K++)
                    this.totalDistance += i[K].dist(i[K + 1]);
                  this.updateScaledDistance(),
                    (this.maxLineLength = Math.max(
                      this.maxLineLength,
                      this.totalDistance
                    ));
                }
                const x = "Polygon" === Md[o.type];
                let E = i.length;
                for (; E >= 2 && i[E - 1].equals(i[E - 2]); ) E--;
                let T = 0;
                for (; T < E - 1 && i[T].equals(i[T + 1]); ) T++;
                if (E < (x ? 3 : 2)) return;
                "bevel" === l && (m = 1.05);
                const I =
                    this.overscaling <= 16
                      ? (15 * wt) / (512 * this.overscaling)
                      : 0,
                  A = this.segments.prepareSegment(
                    10 * E,
                    this.layoutVertexArray,
                    this.indexArray
                  );
                let L, O, F, V, G;
                (this.e1 = this.e2 = -1),
                  x && ((L = i[E - 2]), (G = i[T].sub(L)._unit()._perp()));
                for (let K = T; K < E; K++) {
                  if (
                    ((F = K === E - 1 ? (x ? i[T + 1] : void 0) : i[K + 1]),
                    F && i[K].equals(F))
                  )
                    continue;
                  G && (V = G),
                    L && (O = L),
                    (L = i[K]),
                    (G = F ? F.sub(L)._unit()._perp() : V),
                    (V = V || G);
                  let oe = V.add(G);
                  (0 === oe.x && 0 === oe.y) || oe._unit();
                  const J = V.x * G.x + V.y * G.y,
                    re = oe.x * G.x + oe.y * G.y,
                    le = 0 !== re ? 1 / re : 1 / 0,
                    ae = 2 * Math.sqrt(2 - 2 * re),
                    De = re < I_ && O && F,
                    xe = V.x * G.y - V.y * G.x > 0;
                  if (De && K > T) {
                    const Ie = L.dist(O);
                    if (Ie > 2 * I) {
                      const Fe = L.sub(
                        L.sub(O)
                          ._mult(I / Ie)
                          ._round()
                      );
                      this.updateDistance(O, Fe),
                        this.addCurrentVertex(Fe, V, 0, 0, A),
                        (O = Fe);
                    }
                  }
                  const Pe = O && F;
                  let $e = Pe ? l : x ? "butt" : h;
                  if (
                    (Pe &&
                      "round" === $e &&
                      (le < _ ? ($e = "miter") : le <= 2 && ($e = "fakeround")),
                    "miter" === $e && le > m && ($e = "bevel"),
                    "bevel" === $e &&
                      (le > 2 && ($e = "flipbevel"), le < m && ($e = "miter")),
                    O && this.updateDistance(O, L),
                    "miter" === $e)
                  )
                    oe._mult(le), this.addCurrentVertex(L, oe, 0, 0, A);
                  else if ("flipbevel" === $e) {
                    if (le > 100) oe = G.mult(-1);
                    else {
                      const Ie = (le * V.add(G).mag()) / V.sub(G).mag();
                      oe._perp()._mult(Ie * (xe ? -1 : 1));
                    }
                    this.addCurrentVertex(L, oe, 0, 0, A),
                      this.addCurrentVertex(L, oe.mult(-1), 0, 0, A);
                  } else if ("bevel" === $e || "fakeround" === $e) {
                    const Ie = -Math.sqrt(le * le - 1),
                      Fe = xe ? Ie : 0,
                      Re = xe ? 0 : Ie;
                    if (
                      (O && this.addCurrentVertex(L, V, Fe, Re, A),
                      "fakeround" === $e)
                    ) {
                      const Ve = Math.round((180 * ae) / Math.PI / 20);
                      for (let qe = 1; qe < Ve; qe++) {
                        let Me = qe / Ve;
                        if (0.5 !== Me) {
                          const pt = Me - 0.5;
                          Me +=
                            Me *
                            pt *
                            (Me - 1) *
                            ((1.0904 +
                              J * (J * (3.55645 - 1.43519 * J) - 3.2452)) *
                              pt *
                              pt +
                              (0.848013 + J * (0.215638 * J - 1.06021)));
                        }
                        const tt = G.sub(V)
                          ._mult(Me)
                          ._add(V)
                          ._unit()
                          ._mult(xe ? -1 : 1);
                        this.addHalfVertex(L, tt.x, tt.y, !1, xe, 0, A);
                      }
                    }
                    F && this.addCurrentVertex(L, G, -Fe, -Re, A);
                  } else if ("butt" === $e)
                    this.addCurrentVertex(L, oe, 0, 0, A);
                  else if ("square" === $e) {
                    const Ie = O ? 1 : -1;
                    O || this.addCurrentVertex(L, oe, Ie, Ie, A),
                      this.addCurrentVertex(L, oe, 0, 0, A),
                      O && this.addCurrentVertex(L, oe, Ie, Ie, A);
                  } else
                    "round" === $e &&
                      (O &&
                        (this.addCurrentVertex(L, V, 0, 0, A),
                        this.addCurrentVertex(L, V, 1, 1, A, !0)),
                      F &&
                        (this.addCurrentVertex(L, G, -1, -1, A, !0),
                        this.addCurrentVertex(L, G, 0, 0, A)));
                  if (De && K < E - 1) {
                    const Ie = L.dist(F);
                    if (Ie > 2 * I) {
                      const Fe = L.add(
                        F.sub(L)
                          ._mult(I / Ie)
                          ._round()
                      );
                      this.updateDistance(L, Fe),
                        this.addCurrentVertex(Fe, G, 0, 0, A),
                        (L = Fe);
                    }
                  }
                }
              }
              addCurrentVertex(i, o, l, h, m, _ = !1) {
                const x = o.y * h - o.x,
                  E = -o.y - o.x * h;
                this.addHalfVertex(
                  i,
                  o.x + o.y * l,
                  o.y - o.x * l,
                  _,
                  !1,
                  l,
                  m
                ),
                  this.addHalfVertex(i, x, E, _, !0, -h, m);
              }
              addHalfVertex({ x: i, y: o }, l, h, m, _, x, E) {
                this.layoutVertexArray.emplaceBack(
                  (i << 1) + (m ? 1 : 0),
                  (o << 1) + (_ ? 1 : 0),
                  Math.round(63 * l) + 128,
                  Math.round(63 * h) + 128,
                  1 + (0 === x ? 0 : x < 0 ? -1 : 1),
                  0,
                  this.lineSoFar
                ),
                  this.lineClips &&
                    this.layoutVertexArray2.emplaceBack(
                      this.scaledDistance,
                      this.lineClipsArray.length,
                      this.lineClips.start,
                      this.lineClips.end
                    );
                const T = E.vertexLength++;
                this.e1 >= 0 &&
                  this.e2 >= 0 &&
                  (this.indexArray.emplaceBack(this.e1, this.e2, T),
                  E.primitiveLength++),
                  _ ? (this.e2 = T) : (this.e1 = T);
              }
              updateScaledDistance() {
                if (this.lineClips) {
                  const i =
                    this.totalDistance /
                    (this.lineClips.end - this.lineClips.start);
                  (this.scaledDistance = this.distance / this.totalDistance),
                    (this.lineSoFar = i * this.lineClips.start + this.distance);
                } else this.lineSoFar = this.distance;
              }
              updateDistance(i, o) {
                (this.distance += i.dist(o)), this.updateScaledDistance();
              }
            }
            lt(Ad, "LineBucket", { omit: ["layers", "patternFeatures"] });
            const M_ = new te({
              "line-cap": new W(Ae.layout_line["line-cap"]),
              "line-join": new W(Ae.layout_line["line-join"]),
              "line-miter-limit": new B(Ae.layout_line["line-miter-limit"]),
              "line-round-limit": new B(Ae.layout_line["line-round-limit"]),
              "line-sort-key": new W(Ae.layout_line["line-sort-key"]),
            });
            var Mm = {
              paint: new te({
                "line-opacity": new W(Ae.paint_line["line-opacity"]),
                "line-color": new W(Ae.paint_line["line-color"]),
                "line-translate": new B(Ae.paint_line["line-translate"]),
                "line-translate-anchor": new B(
                  Ae.paint_line["line-translate-anchor"]
                ),
                "line-width": new W(Ae.paint_line["line-width"]),
                "line-gap-width": new W(Ae.paint_line["line-gap-width"]),
                "line-offset": new W(Ae.paint_line["line-offset"]),
                "line-blur": new W(Ae.paint_line["line-blur"]),
                "line-dasharray": new W(Ae.paint_line["line-dasharray"]),
                "line-pattern": new W(Ae.paint_line["line-pattern"]),
                "line-gradient": new ee(Ae.paint_line["line-gradient"]),
                "line-trim-offset": new B(Ae.paint_line["line-trim-offset"]),
              }),
              layout: M_,
            };
            const A_ = new (class extends W {
              possiblyEvaluate(r, i) {
                return (
                  (i = new M(Math.floor(i.zoom), {
                    now: i.now,
                    fadeDuration: i.fadeDuration,
                    transition: i.transition,
                  })),
                  super.possiblyEvaluate(r, i)
                );
              }
              evaluate(r, i, o, l) {
                return (
                  (i = pi({}, i, { zoom: Math.floor(i.zoom) })),
                  super.evaluate(r, i, o, l)
                );
              }
            })(Mm.paint.properties["line-width"].specification);
            function Am(r, i) {
              return i > 0 ? i + 2 * r : r;
            }
            A_.useIntegerZoom = !0;
            const P_ = ge(
                [
                  { name: "a_pos_offset", components: 4, type: "Int16" },
                  { name: "a_tex_size", components: 4, type: "Uint16" },
                  { name: "a_pixeloffset", components: 4, type: "Int16" },
                ],
                4
              ),
              Pm = ge(
                [
                  { name: "a_globe_anchor", components: 3, type: "Int16" },
                  { name: "a_globe_normal", components: 3, type: "Float32" },
                ],
                4
              ),
              Ib = ge(
                [{ name: "a_projected_pos", components: 4, type: "Float32" }],
                4
              );
            ge([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
            const $v = ge([
                { name: "a_placed", components: 2, type: "Uint8" },
                { name: "a_shift", components: 2, type: "Float32" },
              ]),
              Lm = ge([
                { name: "a_size_scale", components: 1, type: "Float32" },
                { name: "a_padding", components: 2, type: "Float32" },
              ]);
            ge([
              { type: "Int16", name: "projectedAnchorX" },
              { type: "Int16", name: "projectedAnchorY" },
              { type: "Int16", name: "projectedAnchorZ" },
              { type: "Int16", name: "tileAnchorX" },
              { type: "Int16", name: "tileAnchorY" },
              { type: "Float32", name: "x1" },
              { type: "Float32", name: "y1" },
              { type: "Float32", name: "x2" },
              { type: "Float32", name: "y2" },
              { type: "Int16", name: "padding" },
              { type: "Uint32", name: "featureIndex" },
              { type: "Uint16", name: "sourceLayerIndex" },
              { type: "Uint16", name: "bucketIndex" },
            ]);
            const km = ge(
                [
                  { name: "a_pos", components: 3, type: "Int16" },
                  { name: "a_anchor_pos", components: 2, type: "Int16" },
                  { name: "a_extrude", components: 2, type: "Int16" },
                ],
                4
              ),
              L_ = ge(
                [
                  { name: "a_pos_2f", components: 2, type: "Float32" },
                  { name: "a_radius", components: 1, type: "Float32" },
                  { name: "a_flags", components: 2, type: "Int16" },
                ],
                4
              );
            ge([{ name: "triangle", components: 3, type: "Uint16" }]),
              ge([
                { type: "Int16", name: "projectedAnchorX" },
                { type: "Int16", name: "projectedAnchorY" },
                { type: "Int16", name: "projectedAnchorZ" },
                { type: "Float32", name: "tileAnchorX" },
                { type: "Float32", name: "tileAnchorY" },
                { type: "Uint16", name: "glyphStartIndex" },
                { type: "Uint16", name: "numGlyphs" },
                { type: "Uint32", name: "vertexStartIndex" },
                { type: "Uint32", name: "lineStartIndex" },
                { type: "Uint32", name: "lineLength" },
                { type: "Uint16", name: "segment" },
                { type: "Uint16", name: "lowerSize" },
                { type: "Uint16", name: "upperSize" },
                { type: "Float32", name: "lineOffsetX" },
                { type: "Float32", name: "lineOffsetY" },
                { type: "Uint8", name: "writingMode" },
                { type: "Uint8", name: "placedOrientation" },
                { type: "Uint8", name: "hidden" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Int16", name: "associatedIconIndex" },
                { type: "Uint8", name: "flipState" },
              ]),
              ge([
                { type: "Int16", name: "projectedAnchorX" },
                { type: "Int16", name: "projectedAnchorY" },
                { type: "Int16", name: "projectedAnchorZ" },
                { type: "Float32", name: "tileAnchorX" },
                { type: "Float32", name: "tileAnchorY" },
                { type: "Int16", name: "rightJustifiedTextSymbolIndex" },
                { type: "Int16", name: "centerJustifiedTextSymbolIndex" },
                { type: "Int16", name: "leftJustifiedTextSymbolIndex" },
                { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
                { type: "Int16", name: "placedIconSymbolIndex" },
                { type: "Int16", name: "verticalPlacedIconSymbolIndex" },
                { type: "Uint16", name: "key" },
                { type: "Uint16", name: "textBoxStartIndex" },
                { type: "Uint16", name: "textBoxEndIndex" },
                { type: "Uint16", name: "verticalTextBoxStartIndex" },
                { type: "Uint16", name: "verticalTextBoxEndIndex" },
                { type: "Uint16", name: "iconBoxStartIndex" },
                { type: "Uint16", name: "iconBoxEndIndex" },
                { type: "Uint16", name: "verticalIconBoxStartIndex" },
                { type: "Uint16", name: "verticalIconBoxEndIndex" },
                { type: "Uint16", name: "featureIndex" },
                { type: "Uint16", name: "numHorizontalGlyphVertices" },
                { type: "Uint16", name: "numVerticalGlyphVertices" },
                { type: "Uint16", name: "numIconVertices" },
                { type: "Uint16", name: "numVerticalIconVertices" },
                { type: "Uint16", name: "useRuntimeCollisionCircles" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Float32", components: 2, name: "textOffset" },
                { type: "Float32", name: "collisionCircleDiameter" },
              ]),
              ge([{ type: "Float32", name: "offsetX" }]),
              ge([
                { type: "Int16", name: "x" },
                { type: "Int16", name: "y" },
              ]);
            const ys = 128;
            function Pd(r, i) {
              const { expression: o } = i;
              if ("constant" === o.kind)
                return {
                  kind: "constant",
                  layoutSize: o.evaluate(new M(r + 1)),
                };
              if ("source" === o.kind) return { kind: "source" };
              {
                const { zoomStops: l, interpolationType: h } = o;
                let m = 0;
                for (; m < l.length && l[m] <= r; ) m++;
                m = Math.max(0, m - 1);
                let _ = m;
                for (; _ < l.length && l[_] < r + 1; ) _++;
                _ = Math.min(l.length - 1, _);
                const x = l[m],
                  E = l[_];
                return "composite" === o.kind
                  ? {
                      kind: "composite",
                      minZoom: x,
                      maxZoom: E,
                      interpolationType: h,
                    }
                  : {
                      kind: "camera",
                      minZoom: x,
                      maxZoom: E,
                      minSize: o.evaluate(new M(x)),
                      maxSize: o.evaluate(new M(E)),
                      interpolationType: h,
                    };
              }
            }
            function jc(
              r,
              { uSize: i, uSizeT: o },
              { lowerSize: l, upperSize: h }
            ) {
              return "source" === r.kind
                ? l / ys
                : "composite" === r.kind
                ? ln(l / ys, h / ys, o)
                : i;
            }
            function nh(r, i) {
              let o = 0,
                l = 0;
              if ("constant" === r.kind) l = r.layoutSize;
              else if ("source" !== r.kind) {
                const { interpolationType: h, minZoom: m, maxZoom: _ } = r,
                  x = h ? tn(so.interpolationFactor(h, i, m, _), 0, 1) : 0;
                "camera" === r.kind
                  ? (l = ln(r.minSize, r.maxSize, x))
                  : (o = x);
              }
              return { uSizeT: o, uSize: l };
            }
            var Rm = Object.freeze({
              __proto__: null,
              SIZE_PACK_FACTOR: ys,
              evaluateSizeForFeature: jc,
              evaluateSizeForZoom: nh,
              getSizeData: Pd,
            });
            function Qp(r, i, o) {
              return (
                r.sections.forEach((l) => {
                  l.text = (function (h, m, _) {
                    const x = m.layout.get("text-transform").evaluate(_, {});
                    return (
                      "uppercase" === x
                        ? (h = h.toLocaleUpperCase())
                        : "lowercase" === x && (h = h.toLocaleLowerCase()),
                      S.applyArabicShaping && (h = S.applyArabicShaping(h)),
                      h
                    );
                  })(l.text, i, o);
                }),
                r
              );
            }
            const da = {
              "!": "\ufe15",
              "#": "\uff03",
              $: "\uff04",
              "%": "\uff05",
              "&": "\uff06",
              "(": "\ufe35",
              ")": "\ufe36",
              "*": "\uff0a",
              "+": "\uff0b",
              ",": "\ufe10",
              "-": "\ufe32",
              ".": "\u30fb",
              "/": "\uff0f",
              ":": "\ufe13",
              ";": "\ufe14",
              "<": "\ufe3f",
              "=": "\uff1d",
              ">": "\ufe40",
              "?": "\ufe16",
              "@": "\uff20",
              "[": "\ufe47",
              "\\": "\uff3c",
              "]": "\ufe48",
              "^": "\uff3e",
              _: "\ufe33",
              "`": "\uff40",
              "{": "\ufe37",
              "|": "\u2015",
              "}": "\ufe38",
              "~": "\uff5e",
              "\xa2": "\uffe0",
              "\xa3": "\uffe1",
              "\xa5": "\uffe5",
              "\xa6": "\uffe4",
              "\xac": "\uffe2",
              "\xaf": "\uffe3",
              "\u2013": "\ufe32",
              "\u2014": "\ufe31",
              "\u2018": "\ufe43",
              "\u2019": "\ufe44",
              "\u201c": "\ufe41",
              "\u201d": "\ufe42",
              "\u2026": "\ufe19",
              "\u2027": "\u30fb",
              "\u20a9": "\uffe6",
              "\u3001": "\ufe11",
              "\u3002": "\ufe12",
              "\u3008": "\ufe3f",
              "\u3009": "\ufe40",
              "\u300a": "\ufe3d",
              "\u300b": "\ufe3e",
              "\u300c": "\ufe41",
              "\u300d": "\ufe42",
              "\u300e": "\ufe43",
              "\u300f": "\ufe44",
              "\u3010": "\ufe3b",
              "\u3011": "\ufe3c",
              "\u3014": "\ufe39",
              "\u3015": "\ufe3a",
              "\u3016": "\ufe17",
              "\u3017": "\ufe18",
              "\uff01": "\ufe15",
              "\uff08": "\ufe35",
              "\uff09": "\ufe36",
              "\uff0c": "\ufe10",
              "\uff0d": "\ufe32",
              "\uff0e": "\u30fb",
              "\uff1a": "\ufe13",
              "\uff1b": "\ufe14",
              "\uff1c": "\ufe3f",
              "\uff1e": "\ufe40",
              "\uff1f": "\ufe16",
              "\uff3b": "\ufe47",
              "\uff3d": "\ufe48",
              "\uff3f": "\ufe33",
              "\uff5b": "\ufe37",
              "\uff5c": "\u2015",
              "\uff5d": "\ufe38",
              "\uff5f": "\ufe35",
              "\uff60": "\ufe36",
              "\uff61": "\ufe12",
              "\uff62": "\ufe41",
              "\uff63": "\ufe42",
              "\u2190": "\u2191",
              "\u2192": "\u2193",
            };
            function k_(r) {
              return (
                "\ufe36" === r ||
                "\ufe48" === r ||
                "\ufe38" === r ||
                "\ufe44" === r ||
                "\ufe42" === r ||
                "\ufe3e" === r ||
                "\ufe3c" === r ||
                "\ufe3a" === r ||
                "\ufe18" === r ||
                "\ufe40" === r ||
                "\ufe10" === r ||
                "\ufe13" === r ||
                "\ufe14" === r ||
                "\uff40" === r ||
                "\uffe3" === r ||
                "\ufe11" === r ||
                "\ufe12" === r
              );
            }
            function Om(r) {
              return (
                "\ufe35" === r ||
                "\ufe47" === r ||
                "\ufe37" === r ||
                "\ufe43" === r ||
                "\ufe41" === r ||
                "\ufe3d" === r ||
                "\ufe3b" === r ||
                "\ufe39" === r ||
                "\ufe17" === r ||
                "\ufe3f" === r
              );
            }
            var R_ = yn,
              O_ = function (r, i, o, l, h) {
                var m,
                  _,
                  x = 8 * h - l - 1,
                  E = (1 << x) - 1,
                  T = E >> 1,
                  I = -7,
                  A = o ? h - 1 : 0,
                  L = o ? -1 : 1,
                  O = r[i + A];
                for (
                  A += L, m = O & ((1 << -I) - 1), O >>= -I, I += x;
                  I > 0;
                  m = 256 * m + r[i + A], A += L, I -= 8
                );
                for (
                  _ = m & ((1 << -I) - 1), m >>= -I, I += l;
                  I > 0;
                  _ = 256 * _ + r[i + A], A += L, I -= 8
                );
                if (0 === m) m = 1 - T;
                else {
                  if (m === E) return _ ? NaN : (1 / 0) * (O ? -1 : 1);
                  (_ += Math.pow(2, l)), (m -= T);
                }
                return (O ? -1 : 1) * _ * Math.pow(2, m - l);
              },
              Fm = function (r, i, o, l, h, m) {
                var _,
                  x,
                  E,
                  T = 8 * m - h - 1,
                  I = (1 << T) - 1,
                  A = I >> 1,
                  L = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                  O = l ? 0 : m - 1,
                  F = l ? 1 : -1,
                  V = i < 0 || (0 === i && 1 / i < 0) ? 1 : 0;
                for (
                  i = Math.abs(i),
                    isNaN(i) || i === 1 / 0
                      ? ((x = isNaN(i) ? 1 : 0), (_ = I))
                      : ((_ = Math.floor(Math.log(i) / Math.LN2)),
                        i * (E = Math.pow(2, -_)) < 1 && (_--, (E *= 2)),
                        (i += _ + A >= 1 ? L / E : L * Math.pow(2, 1 - A)) *
                          E >=
                          2 && (_++, (E /= 2)),
                        _ + A >= I
                          ? ((x = 0), (_ = I))
                          : _ + A >= 1
                          ? ((x = (i * E - 1) * Math.pow(2, h)), (_ += A))
                          : ((x = i * Math.pow(2, A - 1) * Math.pow(2, h)),
                            (_ = 0)));
                  h >= 8;
                  r[o + O] = 255 & x, O += F, x /= 256, h -= 8
                );
                for (
                  _ = (_ << h) | x, T += h;
                  T > 0;
                  r[o + O] = 255 & _, O += F, _ /= 256, T -= 8
                );
                r[o + O - F] |= 128 * V;
              };
            function yn(r) {
              (this.buf =
                ArrayBuffer.isView && ArrayBuffer.isView(r)
                  ? r
                  : new Uint8Array(r || 0)),
                (this.pos = 0),
                (this.type = 0),
                (this.length = this.buf.length);
            }
            (yn.Varint = 0), (yn.Fixed64 = 1), (yn.Bytes = 2), (yn.Fixed32 = 5);
            var Nm = 4294967296,
              F_ = 1 / Nm,
              N_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
            function ol(r) {
              return r.type === yn.Bytes ? r.readVarint() + r.pos : r.pos + 1;
            }
            function z_(r, i, o) {
              var l =
                i <= 16383
                  ? 1
                  : i <= 2097151
                  ? 2
                  : i <= 268435455
                  ? 3
                  : Math.floor(Math.log(i) / (7 * Math.LN2));
              o.realloc(l);
              for (var h = o.pos - 1; h >= r; h--) o.buf[h + l] = o.buf[h];
            }
            function B_(r, i) {
              for (var o = 0; o < r.length; o++) i.writeVarint(r[o]);
            }
            function Hv(r, i) {
              for (var o = 0; o < r.length; o++) i.writeSVarint(r[o]);
            }
            function V_(r, i) {
              for (var o = 0; o < r.length; o++) i.writeFloat(r[o]);
            }
            function Mb(r, i) {
              for (var o = 0; o < r.length; o++) i.writeDouble(r[o]);
            }
            function Gv(r, i) {
              for (var o = 0; o < r.length; o++) i.writeBoolean(r[o]);
            }
            function Jp(r, i) {
              for (var o = 0; o < r.length; o++) i.writeFixed32(r[o]);
            }
            function qv(r, i) {
              for (var o = 0; o < r.length; o++) i.writeSFixed32(r[o]);
            }
            function ih(r, i) {
              for (var o = 0; o < r.length; o++) i.writeFixed64(r[o]);
            }
            function sl(r, i) {
              for (var o = 0; o < r.length; o++) i.writeSFixed64(r[o]);
            }
            function ef(r, i) {
              return (
                (r[i] | (r[i + 1] << 8) | (r[i + 2] << 16)) +
                16777216 * r[i + 3]
              );
            }
            function Ld(r, i, o) {
              (r[o] = i),
                (r[o + 1] = i >>> 8),
                (r[o + 2] = i >>> 16),
                (r[o + 3] = i >>> 24);
            }
            function rh(r, i) {
              return (
                (r[i] | (r[i + 1] << 8) | (r[i + 2] << 16)) + (r[i + 3] << 24)
              );
            }
            yn.prototype = {
              destroy: function () {
                this.buf = null;
              },
              readFields: function (r, i, o) {
                for (o = o || this.length; this.pos < o; ) {
                  var l = this.readVarint(),
                    h = l >> 3,
                    m = this.pos;
                  (this.type = 7 & l),
                    r(h, i, this),
                    this.pos === m && this.skip(l);
                }
                return i;
              },
              readMessage: function (r, i) {
                return this.readFields(r, i, this.readVarint() + this.pos);
              },
              readFixed32: function () {
                var r = ef(this.buf, this.pos);
                return (this.pos += 4), r;
              },
              readSFixed32: function () {
                var r = rh(this.buf, this.pos);
                return (this.pos += 4), r;
              },
              readFixed64: function () {
                var r =
                  ef(this.buf, this.pos) + ef(this.buf, this.pos + 4) * Nm;
                return (this.pos += 8), r;
              },
              readSFixed64: function () {
                var r =
                  ef(this.buf, this.pos) + rh(this.buf, this.pos + 4) * Nm;
                return (this.pos += 8), r;
              },
              readFloat: function () {
                var r = O_(this.buf, this.pos, !0, 23, 4);
                return (this.pos += 4), r;
              },
              readDouble: function () {
                var r = O_(this.buf, this.pos, !0, 52, 8);
                return (this.pos += 8), r;
              },
              readVarint: function (r) {
                var i,
                  o,
                  l = this.buf;
                return (
                  (i = 127 & (o = l[this.pos++])),
                  o < 128
                    ? i
                    : ((i |= (127 & (o = l[this.pos++])) << 7),
                      o < 128
                        ? i
                        : ((i |= (127 & (o = l[this.pos++])) << 14),
                          o < 128
                            ? i
                            : ((i |= (127 & (o = l[this.pos++])) << 21),
                              o < 128
                                ? i
                                : (function (h, m, _) {
                                    var x,
                                      E,
                                      T = _.buf;
                                    if (
                                      ((x = (112 & (E = T[_.pos++])) >> 4),
                                      E < 128 ||
                                        ((x |= (127 & (E = T[_.pos++])) << 3),
                                        E < 128) ||
                                        ((x |= (127 & (E = T[_.pos++])) << 10),
                                        E < 128) ||
                                        ((x |= (127 & (E = T[_.pos++])) << 17),
                                        E < 128) ||
                                        ((x |= (127 & (E = T[_.pos++])) << 24),
                                        E < 128) ||
                                        ((x |= (1 & (E = T[_.pos++])) << 31),
                                        E < 128))
                                    )
                                      return (function Wl(r, i, o) {
                                        return o
                                          ? 4294967296 * i + (r >>> 0)
                                          : 4294967296 * (i >>> 0) + (r >>> 0);
                                      })(h, x, m);
                                    throw new Error(
                                      "Expected varint not more than 10 bytes"
                                    );
                                  })(
                                    (i |= (15 & (o = l[this.pos])) << 28),
                                    r,
                                    this
                                  ))))
                );
              },
              readVarint64: function () {
                return this.readVarint(!0);
              },
              readSVarint: function () {
                var r = this.readVarint();
                return r % 2 == 1 ? (r + 1) / -2 : r / 2;
              },
              readBoolean: function () {
                return Boolean(this.readVarint());
              },
              readString: function () {
                var r = this.readVarint() + this.pos,
                  i = this.pos;
                return (
                  (this.pos = r),
                  r - i >= 12 && N_
                    ? N_.decode(this.buf.subarray(i, r))
                    : (function (o, l, h) {
                        for (var m = "", _ = l; _ < h; ) {
                          var x,
                            E,
                            T,
                            I = o[_],
                            A = null,
                            L = I > 239 ? 4 : I > 223 ? 3 : I > 191 ? 2 : 1;
                          if (_ + L > h) break;
                          1 === L
                            ? I < 128 && (A = I)
                            : 2 === L
                            ? 128 == (192 & (x = o[_ + 1])) &&
                              (A = ((31 & I) << 6) | (63 & x)) <= 127 &&
                              (A = null)
                            : 3 === L
                            ? ((E = o[_ + 2]),
                              128 == (192 & (x = o[_ + 1])) &&
                                128 == (192 & E) &&
                                ((A =
                                  ((15 & I) << 12) |
                                  ((63 & x) << 6) |
                                  (63 & E)) <= 2047 ||
                                  (A >= 55296 && A <= 57343)) &&
                                (A = null))
                            : 4 === L &&
                              ((E = o[_ + 2]),
                              (T = o[_ + 3]),
                              128 == (192 & (x = o[_ + 1])) &&
                                128 == (192 & E) &&
                                128 == (192 & T) &&
                                ((A =
                                  ((15 & I) << 18) |
                                  ((63 & x) << 12) |
                                  ((63 & E) << 6) |
                                  (63 & T)) <= 65535 ||
                                  A >= 1114112) &&
                                (A = null)),
                            null === A
                              ? ((A = 65533), (L = 1))
                              : A > 65535 &&
                                ((A -= 65536),
                                (m += String.fromCharCode(
                                  ((A >>> 10) & 1023) | 55296
                                )),
                                (A = 56320 | (1023 & A))),
                            (m += String.fromCharCode(A)),
                            (_ += L);
                        }
                        return m;
                      })(this.buf, i, r)
                );
              },
              readBytes: function () {
                var r = this.readVarint() + this.pos,
                  i = this.buf.subarray(this.pos, r);
                return (this.pos = r), i;
              },
              readPackedVarint: function (r, i) {
                if (this.type !== yn.Bytes) return r.push(this.readVarint(i));
                var o = ol(this);
                for (r = r || []; this.pos < o; ) r.push(this.readVarint(i));
                return r;
              },
              readPackedSVarint: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readSVarint());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readSVarint());
                return r;
              },
              readPackedBoolean: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readBoolean());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readBoolean());
                return r;
              },
              readPackedFloat: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readFloat());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readFloat());
                return r;
              },
              readPackedDouble: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readDouble());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readDouble());
                return r;
              },
              readPackedFixed32: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readFixed32());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readFixed32());
                return r;
              },
              readPackedSFixed32: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readSFixed32());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readSFixed32());
                return r;
              },
              readPackedFixed64: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readFixed64());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readFixed64());
                return r;
              },
              readPackedSFixed64: function (r) {
                if (this.type !== yn.Bytes) return r.push(this.readSFixed64());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readSFixed64());
                return r;
              },
              skip: function (r) {
                var i = 7 & r;
                if (i === yn.Varint) for (; this.buf[this.pos++] > 127; );
                else if (i === yn.Bytes)
                  this.pos = this.readVarint() + this.pos;
                else if (i === yn.Fixed32) this.pos += 4;
                else {
                  if (i !== yn.Fixed64)
                    throw new Error("Unimplemented type: " + i);
                  this.pos += 8;
                }
              },
              writeTag: function (r, i) {
                this.writeVarint((r << 3) | i);
              },
              realloc: function (r) {
                for (var i = this.length || 16; i < this.pos + r; ) i *= 2;
                if (i !== this.length) {
                  var o = new Uint8Array(i);
                  o.set(this.buf), (this.buf = o), (this.length = i);
                }
              },
              finish: function () {
                return (
                  (this.length = this.pos),
                  (this.pos = 0),
                  this.buf.subarray(0, this.length)
                );
              },
              writeFixed32: function (r) {
                this.realloc(4), Ld(this.buf, r, this.pos), (this.pos += 4);
              },
              writeSFixed32: function (r) {
                this.realloc(4), Ld(this.buf, r, this.pos), (this.pos += 4);
              },
              writeFixed64: function (r) {
                this.realloc(8),
                  Ld(this.buf, -1 & r, this.pos),
                  Ld(this.buf, Math.floor(r * F_), this.pos + 4),
                  (this.pos += 8);
              },
              writeSFixed64: function (r) {
                this.realloc(8),
                  Ld(this.buf, -1 & r, this.pos),
                  Ld(this.buf, Math.floor(r * F_), this.pos + 4),
                  (this.pos += 8);
              },
              writeVarint: function (r) {
                (r = +r || 0) > 268435455 || r < 0
                  ? (function (i, o) {
                      var l, h, m, x;
                      if (
                        (i >= 0
                          ? ((l = i % 4294967296 | 0),
                            (h = (i / 4294967296) | 0))
                          : ((h = ~(-i / 4294967296)),
                            4294967295 ^ (l = ~(-i % 4294967296))
                              ? (l = (l + 1) | 0)
                              : ((l = 0), (h = (h + 1) | 0))),
                        i >= 0x10000000000000000 || i < -0x10000000000000000)
                      )
                        throw new Error(
                          "Given varint doesn't fit into 10 bytes"
                        );
                      o.realloc(10),
                        (m = l),
                        ((x = o).buf[x.pos++] = (127 & m) | 128),
                        (m >>>= 7),
                        (x.buf[x.pos++] = (127 & m) | 128),
                        (m >>>= 7),
                        (x.buf[x.pos++] = (127 & m) | 128),
                        (m >>>= 7),
                        (x.buf[x.pos++] = (127 & m) | 128),
                        (x.buf[x.pos] = 127 & (m >>>= 7)),
                        (function (m, _) {
                          var x = (7 & m) << 4;
                          (_.buf[_.pos++] |= x | ((m >>>= 3) ? 128 : 0)),
                            m &&
                              ((_.buf[_.pos++] =
                                (127 & m) | ((m >>>= 7) ? 128 : 0)),
                              m &&
                                ((_.buf[_.pos++] =
                                  (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                m &&
                                  ((_.buf[_.pos++] =
                                    (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                  m &&
                                    ((_.buf[_.pos++] =
                                      (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                    m && (_.buf[_.pos++] = 127 & m)))));
                        })(h, o);
                    })(r, this)
                  : (this.realloc(4),
                    (this.buf[this.pos++] = (127 & r) | (r > 127 ? 128 : 0)),
                    r <= 127 ||
                      ((this.buf[this.pos++] =
                        (127 & (r >>>= 7)) | (r > 127 ? 128 : 0)),
                      r <= 127 ||
                        ((this.buf[this.pos++] =
                          (127 & (r >>>= 7)) | (r > 127 ? 128 : 0)),
                        r <= 127 || (this.buf[this.pos++] = (r >>> 7) & 127))));
              },
              writeSVarint: function (r) {
                this.writeVarint(r < 0 ? 2 * -r - 1 : 2 * r);
              },
              writeBoolean: function (r) {
                this.writeVarint(Boolean(r));
              },
              writeString: function (r) {
                (r = String(r)), this.realloc(4 * r.length), this.pos++;
                var i = this.pos;
                this.pos = (function (l, h, m) {
                  for (var _, x, E = 0; E < h.length; E++) {
                    if ((_ = h.charCodeAt(E)) > 55295 && _ < 57344) {
                      if (!x) {
                        _ > 56319 || E + 1 === h.length
                          ? ((l[m++] = 239), (l[m++] = 191), (l[m++] = 189))
                          : (x = _);
                        continue;
                      }
                      if (_ < 56320) {
                        (l[m++] = 239), (l[m++] = 191), (l[m++] = 189), (x = _);
                        continue;
                      }
                      (_ = ((x - 55296) << 10) | (_ - 56320) | 65536),
                        (x = null);
                    } else
                      x &&
                        ((l[m++] = 239),
                        (l[m++] = 191),
                        (l[m++] = 189),
                        (x = null));
                    _ < 128
                      ? (l[m++] = _)
                      : (_ < 2048
                          ? (l[m++] = (_ >> 6) | 192)
                          : (_ < 65536
                              ? (l[m++] = (_ >> 12) | 224)
                              : ((l[m++] = (_ >> 18) | 240),
                                (l[m++] = ((_ >> 12) & 63) | 128)),
                            (l[m++] = ((_ >> 6) & 63) | 128)),
                        (l[m++] = (63 & _) | 128));
                  }
                  return m;
                })(this.buf, r, this.pos);
                var o = this.pos - i;
                o >= 128 && z_(i, o, this),
                  (this.pos = i - 1),
                  this.writeVarint(o),
                  (this.pos += o);
              },
              writeFloat: function (r) {
                this.realloc(4),
                  Fm(this.buf, r, this.pos, !0, 23, 4),
                  (this.pos += 4);
              },
              writeDouble: function (r) {
                this.realloc(8),
                  Fm(this.buf, r, this.pos, !0, 52, 8),
                  (this.pos += 8);
              },
              writeBytes: function (r) {
                var i = r.length;
                this.writeVarint(i), this.realloc(i);
                for (var o = 0; o < i; o++) this.buf[this.pos++] = r[o];
              },
              writeRawMessage: function (r, i) {
                this.pos++;
                var o = this.pos;
                r(i, this);
                var l = this.pos - o;
                l >= 128 && z_(o, l, this),
                  (this.pos = o - 1),
                  this.writeVarint(l),
                  (this.pos += l);
              },
              writeMessage: function (r, i, o) {
                this.writeTag(r, yn.Bytes), this.writeRawMessage(i, o);
              },
              writePackedVarint: function (r, i) {
                i.length && this.writeMessage(r, B_, i);
              },
              writePackedSVarint: function (r, i) {
                i.length && this.writeMessage(r, Hv, i);
              },
              writePackedBoolean: function (r, i) {
                i.length && this.writeMessage(r, Gv, i);
              },
              writePackedFloat: function (r, i) {
                i.length && this.writeMessage(r, V_, i);
              },
              writePackedDouble: function (r, i) {
                i.length && this.writeMessage(r, Mb, i);
              },
              writePackedFixed32: function (r, i) {
                i.length && this.writeMessage(r, Jp, i);
              },
              writePackedSFixed32: function (r, i) {
                i.length && this.writeMessage(r, qv, i);
              },
              writePackedFixed64: function (r, i) {
                i.length && this.writeMessage(r, ih, i);
              },
              writePackedSFixed64: function (r, i) {
                i.length && this.writeMessage(r, sl, i);
              },
              writeBytesField: function (r, i) {
                this.writeTag(r, yn.Bytes), this.writeBytes(i);
              },
              writeFixed32Field: function (r, i) {
                this.writeTag(r, yn.Fixed32), this.writeFixed32(i);
              },
              writeSFixed32Field: function (r, i) {
                this.writeTag(r, yn.Fixed32), this.writeSFixed32(i);
              },
              writeFixed64Field: function (r, i) {
                this.writeTag(r, yn.Fixed64), this.writeFixed64(i);
              },
              writeSFixed64Field: function (r, i) {
                this.writeTag(r, yn.Fixed64), this.writeSFixed64(i);
              },
              writeVarintField: function (r, i) {
                this.writeTag(r, yn.Varint), this.writeVarint(i);
              },
              writeSVarintField: function (r, i) {
                this.writeTag(r, yn.Varint), this.writeSVarint(i);
              },
              writeStringField: function (r, i) {
                this.writeTag(r, yn.Bytes), this.writeString(i);
              },
              writeFloatField: function (r, i) {
                this.writeTag(r, yn.Fixed32), this.writeFloat(i);
              },
              writeDoubleField: function (r, i) {
                this.writeTag(r, yn.Fixed64), this.writeDouble(i);
              },
              writeBooleanField: function (r, i) {
                this.writeVarintField(r, Boolean(i));
              },
            };
            var kd = Ur(R_);
            function Wv(r, i, o) {
              (i.glyphs = []), 1 === r && o.readMessage(Bm, i);
            }
            function Bm(r, i, o) {
              if (3 === r) {
                const {
                  id: l,
                  bitmap: h,
                  width: m,
                  height: _,
                  left: x,
                  top: E,
                  advance: T,
                } = o.readMessage(Zv, {});
                i.glyphs.push({
                  id: l,
                  bitmap: new Yr({ width: m + 6, height: _ + 6 }, h),
                  metrics: { width: m, height: _, left: x, top: E, advance: T },
                });
              } else 4 === r ? (i.ascender = o.readSVarint()) : 5 === r && (i.descender = o.readSVarint());
            }
            function Zv(r, i, o) {
              1 === r
                ? (i.id = o.readVarint())
                : 2 === r
                ? (i.bitmap = o.readBytes())
                : 3 === r
                ? (i.width = o.readVarint())
                : 4 === r
                ? (i.height = o.readVarint())
                : 5 === r
                ? (i.left = o.readSVarint())
                : 6 === r
                ? (i.top = o.readSVarint())
                : 7 === r && (i.advance = o.readVarint());
            }
            function Rd(r) {
              let i = 0,
                o = 0;
              for (const _ of r) (i += _.w * _.h), (o = Math.max(o, _.w));
              r.sort((_, x) => x.h - _.h);
              const l = [
                {
                  x: 0,
                  y: 0,
                  w: Math.max(Math.ceil(Math.sqrt(i / 0.95)), o),
                  h: 1 / 0,
                },
              ];
              let h = 0,
                m = 0;
              for (const _ of r)
                for (let x = l.length - 1; x >= 0; x--) {
                  const E = l[x];
                  if (!(_.w > E.w || _.h > E.h)) {
                    if (
                      ((_.x = E.x),
                      (_.y = E.y),
                      (m = Math.max(m, _.y + _.h)),
                      (h = Math.max(h, _.x + _.w)),
                      _.w === E.w && _.h === E.h)
                    ) {
                      const T = l.pop();
                      x < l.length && (l[x] = T);
                    } else
                      _.h === E.h
                        ? ((E.x += _.w), (E.w -= _.w))
                        : _.w === E.w
                        ? ((E.y += _.h), (E.h -= _.h))
                        : (l.push({
                            x: E.x + _.w,
                            y: E.y,
                            w: E.w - _.w,
                            h: _.h,
                          }),
                          (E.y += _.h),
                          (E.h -= _.h));
                    break;
                  }
                }
              return { w: h, h: m, fill: i / (h * m) || 0 };
            }
            class Od {
              constructor(
                i,
                {
                  pixelRatio: o,
                  version: l,
                  stretchX: h,
                  stretchY: m,
                  content: _,
                }
              ) {
                (this.paddedRect = i),
                  (this.pixelRatio = o),
                  (this.stretchX = h),
                  (this.stretchY = m),
                  (this.content = _),
                  (this.version = l);
              }
              get tl() {
                return [this.paddedRect.x + 1, this.paddedRect.y + 1];
              }
              get br() {
                return [
                  this.paddedRect.x + this.paddedRect.w - 1,
                  this.paddedRect.y + this.paddedRect.h - 1,
                ];
              }
              get displaySize() {
                return [
                  (this.paddedRect.w - 2) / this.pixelRatio,
                  (this.paddedRect.h - 2) / this.pixelRatio,
                ];
              }
            }
            class Uc {
              constructor(i, o) {
                const l = {},
                  h = {};
                this.haveRenderCallbacks = [];
                const m = [];
                this.addImages(i, l, m), this.addImages(o, h, m);
                const { w: _, h: x } = Rd(m),
                  E = new Qr({ width: _ || 1, height: x || 1 });
                for (const T in i) {
                  const I = i[T],
                    A = l[T].paddedRect;
                  Qr.copy(
                    I.data,
                    E,
                    { x: 0, y: 0 },
                    { x: A.x + 1, y: A.y + 1 },
                    I.data
                  );
                }
                for (const T in o) {
                  const I = o[T],
                    A = h[T].paddedRect,
                    L = A.x + 1,
                    O = A.y + 1,
                    F = I.data.width,
                    V = I.data.height;
                  Qr.copy(I.data, E, { x: 0, y: 0 }, { x: L, y: O }, I.data),
                    Qr.copy(
                      I.data,
                      E,
                      { x: 0, y: V - 1 },
                      { x: L, y: O - 1 },
                      { width: F, height: 1 }
                    ),
                    Qr.copy(
                      I.data,
                      E,
                      { x: 0, y: 0 },
                      { x: L, y: O + V },
                      { width: F, height: 1 }
                    ),
                    Qr.copy(
                      I.data,
                      E,
                      { x: F - 1, y: 0 },
                      { x: L - 1, y: O },
                      { width: 1, height: V }
                    ),
                    Qr.copy(
                      I.data,
                      E,
                      { x: 0, y: 0 },
                      { x: L + F, y: O },
                      { width: 1, height: V }
                    );
                }
                (this.image = E),
                  (this.iconPositions = l),
                  (this.patternPositions = h);
              }
              addImages(i, o, l) {
                for (const h in i) {
                  const m = i[h],
                    _ = {
                      x: 0,
                      y: 0,
                      w: m.data.width + 2,
                      h: m.data.height + 2,
                    };
                  l.push(_),
                    (o[h] = new Od(_, m)),
                    m.hasRenderCallback && this.haveRenderCallbacks.push(h);
                }
              }
              patchUpdatedImages(i, o) {
                (this.haveRenderCallbacks = this.haveRenderCallbacks.filter(
                  (l) => i.hasImage(l)
                )),
                  i.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for (const l in i.updatedImages)
                  this.patchUpdatedImage(
                    this.iconPositions[l],
                    i.getImage(l),
                    o
                  ),
                    this.patchUpdatedImage(
                      this.patternPositions[l],
                      i.getImage(l),
                      o
                    );
              }
              patchUpdatedImage(i, o, l) {
                if (!i || !o || i.version === o.version) return;
                i.version = o.version;
                const [h, m] = i.tl;
                l.update(o.data, void 0, { x: h, y: m });
              }
            }
            lt(Od, "ImagePosition"), lt(Uc, "ImageAtlas");
            const Po = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
            class Fd {
              constructor() {
                (this.scale = 1),
                  (this.fontStack = ""),
                  (this.imageName = null);
              }
              static forText(i, o) {
                const l = new Fd();
                return (l.scale = i || 1), (l.fontStack = o), l;
              }
              static forImage(i) {
                const o = new Fd();
                return (o.imageName = i), o;
              }
            }
            class oh {
              constructor() {
                (this.text = ""),
                  (this.sectionIndex = []),
                  (this.sections = []),
                  (this.imageSectionID = null);
              }
              static fromFeature(i, o) {
                const l = new oh();
                for (let h = 0; h < i.sections.length; h++) {
                  const m = i.sections[h];
                  m.image ? l.addImageSection(m) : l.addTextSection(m, o);
                }
                return l;
              }
              length() {
                return this.text.length;
              }
              getSection(i) {
                return this.sections[this.sectionIndex[i]];
              }
              getSections() {
                return this.sections;
              }
              getSectionIndex(i) {
                return this.sectionIndex[i];
              }
              getCharCode(i) {
                return this.text.charCodeAt(i);
              }
              verticalizePunctuation(i) {
                this.text = (function (o, l) {
                  let h = "";
                  for (let m = 0; m < o.length; m++) {
                    const _ = o.charCodeAt(m + 1) || null,
                      x = o.charCodeAt(m - 1) || null;
                    h +=
                      (!l &&
                        ((_ && Jh(_) && !da[o[m + 1]]) ||
                          (x && Jh(x) && !da[o[m - 1]]))) ||
                      !da[o[m]]
                        ? o[m]
                        : da[o[m]];
                  }
                  return h;
                })(this.text, i);
              }
              trim() {
                let i = 0;
                for (
                  let l = 0;
                  l < this.text.length && nf[this.text.charCodeAt(l)];
                  l++
                )
                  i++;
                let o = this.text.length;
                for (
                  let l = this.text.length - 1;
                  l >= 0 && l >= i && nf[this.text.charCodeAt(l)];
                  l--
                )
                  o--;
                (this.text = this.text.substring(i, o)),
                  (this.sectionIndex = this.sectionIndex.slice(i, o));
              }
              substring(i, o) {
                const l = new oh();
                return (
                  (l.text = this.text.substring(i, o)),
                  (l.sectionIndex = this.sectionIndex.slice(i, o)),
                  (l.sections = this.sections),
                  l
                );
              }
              toString() {
                return this.text;
              }
              getMaxScale() {
                return this.sectionIndex.reduce(
                  (i, o) => Math.max(i, this.sections[o].scale),
                  0
                );
              }
              addTextSection(i, o) {
                (this.text += i.text),
                  this.sections.push(Fd.forText(i.scale, i.fontStack || o));
                const l = this.sections.length - 1;
                for (let h = 0; h < i.text.length; ++h)
                  this.sectionIndex.push(l);
              }
              addImageSection(i) {
                const o = i.image ? i.image.name : "";
                if (0 === o.length)
                  return void Wn(
                    "Can't add FormattedSection with an empty image."
                  );
                const l = this.getNextImageSectionCharCode();
                l
                  ? ((this.text += String.fromCharCode(l)),
                    this.sections.push(Fd.forImage(o)),
                    this.sectionIndex.push(this.sections.length - 1))
                  : Wn("Reached maximum number of images 6401");
              }
              getNextImageSectionCharCode() {
                return this.imageSectionID
                  ? this.imageSectionID >= 63743
                    ? null
                    : ++this.imageSectionID
                  : ((this.imageSectionID = 57344), this.imageSectionID);
              }
            }
            function Vm(r, i, o, l, h, m, _, x, E, T, I, A, L, O, F) {
              const V = oh.fromFeature(r, h);
              A === Po.vertical && V.verticalizePunctuation(L);
              let G = [];
              const K = (function (ae, De, xe, Pe, $e, Ie) {
                  if (!ae) return [];
                  const Fe = [],
                    Re = (function (tt, pt, rt, Lt, Ke, bt) {
                      let Pt = 0;
                      for (let Yt = 0; Yt < tt.length(); Yt++) {
                        const At = tt.getSection(Yt);
                        Pt += $c(tt.getCharCode(Yt), At, Lt, Ke, pt, bt);
                      }
                      return Pt / Math.max(1, Math.ceil(Pt / rt));
                    })(ae, De, xe, Pe, $e, Ie),
                    Ve = ae.text.indexOf("\u200b") >= 0;
                  let qe = 0;
                  for (let tt = 0; tt < ae.length(); tt++) {
                    const pt = ae.getSection(tt),
                      rt = ae.getCharCode(tt);
                    if (
                      (nf[rt] || (qe += $c(rt, pt, Pe, $e, De, Ie)),
                      tt < ae.length() - 1)
                    ) {
                      const Lt = !(
                        (Me = rt) < 11904 ||
                        !(
                          at_Bopomofo_Extended(Me) ||
                          at_Bopomofo(Me) ||
                          at_CJK_Compatibility_Forms(Me) ||
                          at_CJK_Compatibility_Ideographs(Me) ||
                          at_CJK_Compatibility(Me) ||
                          at_CJK_Radicals_Supplement(Me) ||
                          at_CJK_Strokes(Me) ||
                          at_CJK_Symbols_and_Punctuation(Me) ||
                          at_CJK_Unified_Ideographs_Extension_A(Me) ||
                          at_CJK_Unified_Ideographs(Me) ||
                          at_Enclosed_CJK_Letters_and_Months(Me) ||
                          at_Halfwidth_and_Fullwidth_Forms(Me) ||
                          at_Hiragana(Me) ||
                          at_Ideographic_Description_Characters(Me) ||
                          at_Kangxi_Radicals(Me) ||
                          at_Katakana_Phonetic_Extensions(Me) ||
                          at_Katakana(Me) ||
                          at_Vertical_Forms(Me) ||
                          at_Yi_Radicals(Me) ||
                          at_Yi_Syllables(Me)
                        )
                      );
                      (Xv[rt] || Lt || pt.imageName) &&
                        Fe.push(
                          U_(
                            tt + 1,
                            qe,
                            Re,
                            Fe,
                            Kv(rt, ae.getCharCode(tt + 1), Lt && Ve),
                            !1
                          )
                        );
                    }
                  }
                  var Me;
                  return Yv(U_(ae.length(), qe, Re, Fe, 0, !0));
                })(V, T, m, i, l, O),
                {
                  processBidirectionalText: oe,
                  processStyledBidirectionalText: J,
                } = S;
              if (oe && 1 === V.sections.length) {
                const ae = oe(V.toString(), K);
                for (const De of ae) {
                  const xe = new oh();
                  (xe.text = De), (xe.sections = V.sections);
                  for (let Pe = 0; Pe < De.length; Pe++)
                    xe.sectionIndex.push(0);
                  G.push(xe);
                }
              } else if (J) {
                const ae = J(V.text, V.sectionIndex, K);
                for (const De of ae) {
                  const xe = new oh();
                  (xe.text = De[0]),
                    (xe.sectionIndex = De[1]),
                    (xe.sections = V.sections),
                    G.push(xe);
                }
              } else
                G = (function (ae, De) {
                  const xe = [],
                    Pe = ae.text;
                  let $e = 0;
                  for (const Ie of De) xe.push(ae.substring($e, Ie)), ($e = Ie);
                  return (
                    $e < Pe.length && xe.push(ae.substring($e, Pe.length)), xe
                  );
                })(V, K);
              const re = [],
                le = {
                  positionedLines: re,
                  text: V.toString(),
                  top: I[1],
                  bottom: I[1],
                  left: I[0],
                  right: I[0],
                  writingMode: A,
                  iconsInText: !1,
                  verticalizable: !1,
                  hasBaseline: !1,
                };
              return (
                (function (ae, De, xe, Pe, $e, Ie, Fe, Re, Ve, qe, Me, tt) {
                  let pt = 0,
                    rt = 0,
                    Lt = 0;
                  const Ke = "right" === Re ? 1 : "left" === Re ? 0 : 0.5;
                  let bt = !1;
                  for (const Nt of $e) {
                    const kt = Nt.getSections();
                    for (const kn of kt) {
                      if (kn.imageName) continue;
                      const zn = De[kn.fontStack];
                      if (
                        zn &&
                        ((bt =
                          void 0 !== zn.ascender && void 0 !== zn.descender),
                        !bt)
                      )
                        break;
                    }
                    if (!bt) break;
                  }
                  let Pt = 0;
                  for (const Nt of $e) {
                    Nt.trim();
                    const kt = Nt.getMaxScale(),
                      kn = 24 * (kt - 1),
                      zn = { positionedGlyphs: [], lineOffset: 0 };
                    ae.positionedLines[Pt] = zn;
                    const Bn = zn.positionedGlyphs;
                    let vn = 0;
                    if (!Nt.length()) {
                      (rt += Ie), ++Pt;
                      continue;
                    }
                    let Kn = 0,
                      ci = 0;
                    for (let Vn = 0; Vn < Nt.length(); Vn++) {
                      const Ii = Nt.getSection(Vn),
                        Ei = Nt.getSectionIndex(Vn),
                        ti = Nt.getCharCode(Vn);
                      let dn = Ii.scale,
                        ui = null,
                        jn = null,
                        hr = null,
                        Ti = 24,
                        er = 0;
                      const Wi = !(
                        Ve === Po.horizontal ||
                        (!Me && !Ic(ti)) ||
                        (Me &&
                          (nf[ti] ||
                            ((Yt = ti),
                            at_Arabic(Yt) ||
                              at_Arabic_Supplement(Yt) ||
                              at_Arabic_Extended_A(Yt) ||
                              at_Arabic_Presentation_Forms_A(Yt) ||
                              at_Arabic_Presentation_Forms_B(Yt))))
                      );
                      if (Ii.imageName) {
                        const Vr = Pe[Ii.imageName];
                        if (!Vr) continue;
                        (hr = Ii.imageName),
                          (ae.iconsInText = ae.iconsInText || !0),
                          (jn = Vr.paddedRect);
                        const Zi = Vr.displaySize;
                        (dn = (24 * dn) / tt),
                          (ui = {
                            width: Zi[0],
                            height: Zi[1],
                            left: 1,
                            top: -3,
                            advance: Wi ? Zi[1] : Zi[0],
                            localGlyph: !1,
                          }),
                          (er = bt
                            ? -ui.height * dn
                            : 24 * kt - 17 - Zi[1] * dn),
                          (Ti = ui.advance);
                        const Ds = (Wi ? Zi[0] : Zi[1]) * dn - 24 * kt;
                        Ds > 0 && Ds > vn && (vn = Ds);
                      } else {
                        const Vr = xe[Ii.fontStack];
                        if (!Vr) continue;
                        Vr[ti] && (jn = Vr[ti]);
                        const Zi = De[Ii.fontStack];
                        if (!Zi) continue;
                        const Ds = Zi.glyphs[ti];
                        if (!Ds) continue;
                        if (
                          ((ui = Ds.metrics), (Ti = 8203 !== ti ? 24 : 0), bt)
                        ) {
                          const ul =
                              void 0 !== Zi.ascender
                                ? Math.abs(Zi.ascender)
                                : 0,
                            Cs =
                              void 0 !== Zi.descender
                                ? Math.abs(Zi.descender)
                                : 0,
                            _f = (ul + Cs) * dn;
                          Kn < _f && ((Kn = _f), (ci = ((ul - Cs) / 2) * dn)),
                            (er = -ul * dn);
                        } else er = 24 * (kt - dn) - 17;
                      }
                      Wi
                        ? ((ae.verticalizable = !0),
                          Bn.push({
                            glyph: ti,
                            imageName: hr,
                            x: pt,
                            y: rt + er,
                            vertical: Wi,
                            scale: dn,
                            localGlyph: ui.localGlyph,
                            fontStack: Ii.fontStack,
                            sectionIndex: Ei,
                            metrics: ui,
                            rect: jn,
                          }),
                          (pt += Ti * dn + qe))
                        : (Bn.push({
                            glyph: ti,
                            imageName: hr,
                            x: pt,
                            y: rt + er,
                            vertical: Wi,
                            scale: dn,
                            localGlyph: ui.localGlyph,
                            fontStack: Ii.fontStack,
                            sectionIndex: Ei,
                            metrics: ui,
                            rect: jn,
                          }),
                          (pt += ui.advance * dn + qe));
                    }
                    0 !== Bn.length &&
                      ((Lt = Math.max(pt - qe, Lt)),
                      bt
                        ? jm(Bn, Ke, vn, ci, (Ie * kt) / 2)
                        : jm(Bn, Ke, vn, 0, Ie / 2)),
                      (pt = 0);
                    const wi = Ie * kt + vn;
                    (zn.lineOffset = Math.max(vn, kn)), (rt += wi), ++Pt;
                  }
                  var Yt;
                  const At = rt,
                    { horizontalAlign: Et, verticalAlign: In } = $_(Fe);
                  (function (Nt, kt, kn, zn, Bn, vn) {
                    const Kn = (kt - kn) * Bn,
                      ci = -vn * zn;
                    for (const wi of Nt)
                      for (const Vn of wi.positionedGlyphs)
                        (Vn.x += Kn), (Vn.y += ci);
                  })(ae.positionedLines, Ke, Et, In, Lt, At),
                    (ae.top += -In * At),
                    (ae.bottom = ae.top + At),
                    (ae.left += -Et * Lt),
                    (ae.right = ae.left + Lt),
                    (ae.hasBaseline = bt);
                })(le, i, o, l, G, _, x, E, A, T, L, F),
                !(function (ae) {
                  for (const De of ae)
                    if (0 !== De.positionedGlyphs.length) return !1;
                  return !0;
                })(re) && le
              );
            }
            const nf = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
              Xv = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0,
              };
            function $c(r, i, o, l, h, m) {
              if (i.imageName) {
                const _ = l[i.imageName];
                return _ ? (_.displaySize[0] * i.scale * 24) / m + h : 0;
              }
              {
                const _ = o[i.fontStack],
                  x = _ && _.glyphs[r];
                return x ? x.metrics.advance * i.scale + h : 0;
              }
            }
            function pa(r, i, o, l) {
              const h = Math.pow(r - i, 2);
              return l ? (r < i ? h / 2 : 2 * h) : h + Math.abs(o) * o;
            }
            function Kv(r, i, o) {
              let l = 0;
              return (
                10 === r && (l -= 1e4),
                o && (l += 150),
                (40 !== r && 65288 !== r) || (l += 50),
                (41 !== i && 65289 !== i) || (l += 50),
                l
              );
            }
            function U_(r, i, o, l, h, m) {
              let _ = null,
                x = pa(i, o, h, m);
              for (const E of l) {
                const T = pa(i - E.x, o, h, m) + E.badness;
                T <= x && ((_ = E), (x = T));
              }
              return { index: r, x: i, priorBreak: _, badness: x };
            }
            function Yv(r) {
              return r ? Yv(r.priorBreak).concat(r.index) : [];
            }
            function $_(r) {
              let i = 0.5,
                o = 0.5;
              switch (r) {
                case "right":
                case "top-right":
                case "bottom-right":
                  i = 1;
                  break;
                case "left":
                case "top-left":
                case "bottom-left":
                  i = 0;
              }
              switch (r) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                  o = 1;
                  break;
                case "top":
                case "top-right":
                case "top-left":
                  o = 0;
              }
              return { horizontalAlign: i, verticalAlign: o };
            }
            function jm(r, i, o, l, h) {
              if (!(i || o || l || h)) return;
              const m = r.length - 1,
                _ = r[m],
                x = (_.x + _.metrics.advance * _.scale) * i;
              for (let E = 0; E <= m; E++) (r[E].x -= x), (r[E].y += o + l + h);
            }
            function Ab(r, i, o) {
              const { horizontalAlign: l, verticalAlign: h } = $_(o),
                m = i[0] - r.displaySize[0] * l,
                _ = i[1] - r.displaySize[1] * h;
              return {
                image: r,
                top: _,
                bottom: _ + r.displaySize[1],
                left: m,
                right: m + r.displaySize[0],
              };
            }
            function Um(r, i, o, l, h, m) {
              const _ = r.image;
              let x;
              if (_.content) {
                const G = _.content,
                  K = _.pixelRatio || 1;
                x = [
                  G[0] / K,
                  G[1] / K,
                  _.displaySize[0] - G[2] / K,
                  _.displaySize[1] - G[3] / K,
                ];
              }
              const E = i.left * m,
                T = i.right * m;
              let I, A, L, O;
              "width" === o || "both" === o
                ? ((O = h[0] + E - l[3]), (A = h[0] + T + l[1]))
                : ((O = h[0] + (E + T - _.displaySize[0]) / 2),
                  (A = O + _.displaySize[0]));
              const F = i.top * m,
                V = i.bottom * m;
              return (
                "height" === o || "both" === o
                  ? ((I = h[1] + F - l[0]), (L = h[1] + V + l[2]))
                  : ((I = h[1] + (F + V - _.displaySize[1]) / 2),
                    (L = I + _.displaySize[1])),
                {
                  image: _,
                  top: I,
                  right: A,
                  bottom: L,
                  left: O,
                  collisionPadding: x,
                }
              );
            }
            class Zl extends nt {
              constructor(i, o, l, h, m) {
                super(i, o),
                  (this.angle = h),
                  (this.z = l),
                  void 0 !== m && (this.segment = m);
              }
              clone() {
                return new Zl(this.x, this.y, this.z, this.angle, this.segment);
              }
            }
            function $m(r, i, o, l, h) {
              if (void 0 === i.segment) return !0;
              let m = i,
                _ = i.segment + 1,
                x = 0;
              for (; x > -o / 2; ) {
                if ((_--, _ < 0)) return !1;
                (x -= r[_].dist(m)), (m = r[_]);
              }
              (x += r[_].dist(r[_ + 1])), _++;
              const E = [];
              let T = 0;
              for (; x < o / 2; ) {
                const I = r[_],
                  A = r[_ + 1];
                if (!A) return !1;
                let L = r[_ - 1].angleTo(I) - I.angleTo(A);
                for (
                  L = Math.abs(((L + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
                    E.push({ distance: x, angleDelta: L }),
                    T += L;
                  x - E[0].distance > l;

                )
                  T -= E.shift().angleDelta;
                if (T > h) return !1;
                _++, (x += I.dist(A));
              }
              return !0;
            }
            function H_(r) {
              let i = 0;
              for (let o = 0; o < r.length - 1; o++) i += r[o].dist(r[o + 1]);
              return i;
            }
            function Hm(r, i, o) {
              return r ? 0.6 * i * o : 0;
            }
            function G_(r, i) {
              return Math.max(
                r ? r.right - r.left : 0,
                i ? i.right - i.left : 0
              );
            }
            function Qv(r, i, o, l, h, m) {
              const _ = Hm(o, h, m),
                x = G_(o, l) * m;
              let E = 0;
              const T = H_(r) / 2;
              for (let I = 0; I < r.length - 1; I++) {
                const A = r[I],
                  L = r[I + 1],
                  O = A.dist(L);
                if (E + O > T) {
                  const F = (T - E) / O,
                    V = ln(A.x, L.x, F),
                    G = ln(A.y, L.y, F),
                    K = new Zl(V, G, 0, L.angleTo(A), I);
                  return !_ || $m(r, K, x, _, i) ? K : void 0;
                }
                E += O;
              }
            }
            function vs(r, i, o, l, h, m, _, x, E) {
              const T = Hm(l, m, _),
                I = G_(l, h),
                A = I * _,
                L =
                  0 === r[0].x || r[0].x === E || 0 === r[0].y || r[0].y === E;
              return (
                i - A < i / 4 && (i = A + i / 4),
                q_(
                  r,
                  L ? ((i / 2) * x) % i : ((I / 2 + 2 * m) * _ * x) % i,
                  i,
                  T,
                  o,
                  A,
                  L,
                  !1,
                  E
                )
              );
            }
            function q_(r, i, o, l, h, m, _, x, E) {
              const T = m / 2,
                I = H_(r);
              let A = 0,
                L = i - o,
                O = [];
              for (let F = 0; F < r.length - 1; F++) {
                const V = r[F],
                  G = r[F + 1],
                  K = V.dist(G),
                  oe = G.angleTo(V);
                for (; L + o < A + K; ) {
                  L += o;
                  const J = (L - A) / K,
                    re = ln(V.x, G.x, J),
                    le = ln(V.y, G.y, J);
                  if (
                    re >= 0 &&
                    re < E &&
                    le >= 0 &&
                    le < E &&
                    L - T >= 0 &&
                    L + T <= I
                  ) {
                    const ae = new Zl(re, le, 0, oe, F);
                    ae._round(), (l && !$m(r, ae, m, l, h)) || O.push(ae);
                  }
                }
                A += K;
              }
              return (
                x || O.length || _ || (O = q_(r, A / 2, o, l, h, m, _, !0, E)),
                O
              );
            }
            function Gm(r, i, o, l, h) {
              const m = [];
              for (let _ = 0; _ < r.length; _++) {
                const x = r[_];
                let E;
                for (let T = 0; T < x.length - 1; T++) {
                  let I = x[T],
                    A = x[T + 1];
                  (I.x < i && A.x < i) ||
                    (I.x < i
                      ? (I = new nt(
                          i,
                          I.y + ((i - I.x) / (A.x - I.x)) * (A.y - I.y)
                        )._round())
                      : A.x < i &&
                        (A = new nt(
                          i,
                          I.y + ((i - I.x) / (A.x - I.x)) * (A.y - I.y)
                        )._round()),
                    (I.y < o && A.y < o) ||
                      (I.y < o
                        ? (I = new nt(
                            I.x + ((o - I.y) / (A.y - I.y)) * (A.x - I.x),
                            o
                          )._round())
                        : A.y < o &&
                          (A = new nt(
                            I.x + ((o - I.y) / (A.y - I.y)) * (A.x - I.x),
                            o
                          )._round()),
                      (I.x >= l && A.x >= l) ||
                        (I.x >= l
                          ? (I = new nt(
                              l,
                              I.y + ((l - I.x) / (A.x - I.x)) * (A.y - I.y)
                            )._round())
                          : A.x >= l &&
                            (A = new nt(
                              l,
                              I.y + ((l - I.x) / (A.x - I.x)) * (A.y - I.y)
                            )._round()),
                        (I.y >= h && A.y >= h) ||
                          (I.y >= h
                            ? (I = new nt(
                                I.x + ((h - I.y) / (A.y - I.y)) * (A.x - I.x),
                                h
                              )._round())
                            : A.y >= h &&
                              (A = new nt(
                                I.x + ((h - I.y) / (A.y - I.y)) * (A.x - I.x),
                                h
                              )._round()),
                          (E && I.equals(E[E.length - 1])) ||
                            ((E = [I]), m.push(E)),
                          E.push(A)))));
                }
              }
              return m;
            }
            lt(Zl, "Anchor");
            const Nd = 1e20;
            function W_(r, i, o, l, h, m, _, x, E) {
              for (let T = i; T < i + l; T++) Z_(r, o * m + T, m, h, _, x, E);
              for (let T = o; T < o + h; T++) Z_(r, T * m + i, 1, l, _, x, E);
            }
            function Z_(r, i, o, l, h, m, _) {
              (m[0] = 0), (_[0] = -Nd), (_[1] = Nd), (h[0] = r[i]);
              for (let x = 1, E = 0, T = 0; x < l; x++) {
                h[x] = r[i + x * o];
                const I = x * x;
                do {
                  const A = m[E];
                  T = (h[x] - h[A] + I - A * A) / (x - A) / 2;
                } while (T <= _[E] && --E > -1);
                E++, (m[E] = x), (_[E] = T), (_[E + 1] = Nd);
              }
              for (let x = 0, E = 0; x < l; x++) {
                for (; _[E + 1] < x; ) E++;
                const T = m[E],
                  I = x - T;
                r[i + x * o] = h[T] + I * I;
              }
            }
            const rf = { none: 0, ideographs: 1, all: 2 };
            class sh {
              constructor(i, o, l) {
                (this.requestManager = i),
                  (this.localGlyphMode = o),
                  (this.localFontFamily = l),
                  (this.entries = {}),
                  (this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} });
              }
              setURL(i) {
                this.url = i;
              }
              getGlyphs(i, o) {
                const l = [];
                for (const h in i)
                  for (const m of i[h]) l.push({ stack: h, id: m });
                Ai(
                  l,
                  ({ stack: h, id: m }, _) => {
                    let x = this.entries[h];
                    x ||
                      (x = this.entries[h] =
                        {
                          glyphs: {},
                          requests: {},
                          ranges: {},
                          ascender: void 0,
                          descender: void 0,
                        });
                    let E = x.glyphs[m];
                    if (void 0 !== E)
                      return void _(null, { stack: h, id: m, glyph: E });
                    if (((E = this._tinySDF(x, h, m)), E))
                      return (
                        (x.glyphs[m] = E),
                        void _(null, { stack: h, id: m, glyph: E })
                      );
                    const T = Math.floor(m / 256);
                    if (256 * T > 65535)
                      return void _(new Error("glyphs > 65535 not supported"));
                    if (x.ranges[T])
                      return void _(null, { stack: h, id: m, glyph: E });
                    let I = x.requests[T];
                    I ||
                      ((I = x.requests[T] = []),
                      sh.loadGlyphRange(
                        h,
                        T,
                        this.url,
                        this.requestManager,
                        (A, L) => {
                          if (L) {
                            (x.ascender = L.ascender),
                              (x.descender = L.descender);
                            for (const O in L.glyphs)
                              this._doesCharSupportLocalGlyph(+O) ||
                                (x.glyphs[+O] = L.glyphs[+O]);
                            x.ranges[T] = !0;
                          }
                          for (const O of I) O(A, L);
                          delete x.requests[T];
                        }
                      )),
                      I.push((A, L) => {
                        A
                          ? _(A)
                          : L &&
                            _(null, {
                              stack: h,
                              id: m,
                              glyph: L.glyphs[m] || null,
                            });
                      });
                  },
                  (h, m) => {
                    if (h) o(h);
                    else if (m) {
                      const _ = {};
                      for (const { stack: x, id: E, glyph: T } of m)
                        void 0 === _[x] && (_[x] = {}),
                          void 0 === _[x].glyphs && (_[x].glyphs = {}),
                          (_[x].glyphs[E] = T && {
                            id: T.id,
                            bitmap: T.bitmap.clone(),
                            metrics: T.metrics,
                          }),
                          (_[x].ascender = this.entries[x].ascender),
                          (_[x].descender = this.entries[x].descender);
                      o(null, _);
                    }
                  }
                );
              }
              _doesCharSupportLocalGlyph(i) {
                return (
                  this.localGlyphMode !== rf.none &&
                  (this.localGlyphMode === rf.all
                    ? !!this.localFontFamily
                    : !!this.localFontFamily &&
                      (at_CJK_Unified_Ideographs(i) ||
                        at_Hangul_Syllables(i) ||
                        at_Hiragana(i) ||
                        at_Katakana(i) ||
                        at_CJK_Symbols_and_Punctuation(i)))
                );
              }
              _tinySDF(i, o, l) {
                const h = this.localFontFamily;
                if (!h || !this._doesCharSupportLocalGlyph(l)) return;
                let m = i.tinySDF;
                if (!m) {
                  let V = "400";
                  /bold/i.test(o)
                    ? (V = "900")
                    : /medium/i.test(o)
                    ? (V = "500")
                    : /light/i.test(o) && (V = "200"),
                    (m = i.tinySDF =
                      new sh.TinySDF({
                        fontFamily: h,
                        fontWeight: V,
                        fontSize: 48,
                        buffer: 6,
                        radius: 16,
                      })),
                    (m.fontWeight = V);
                }
                if (this.localGlyphs[m.fontWeight][l])
                  return this.localGlyphs[m.fontWeight][l];
                const _ = String.fromCharCode(l),
                  {
                    data: x,
                    width: E,
                    height: T,
                    glyphWidth: I,
                    glyphHeight: A,
                    glyphLeft: L,
                    glyphTop: O,
                    glyphAdvance: F,
                  } = m.draw(_);
                return (this.localGlyphs[m.fontWeight][l] = {
                  id: l,
                  bitmap: new Yr({ width: E, height: T }, x),
                  metrics: {
                    width: I / 2,
                    height: A / 2,
                    left: L / 2,
                    top: O / 2 - 27,
                    advance: F / 2,
                    localGlyph: !0,
                  },
                });
              }
            }
            (sh.loadGlyphRange = function (r, i, o, l, h) {
              const m = 256 * i,
                _ = m + 255,
                x = l.transformRequest(
                  l
                    .normalizeGlyphsURL(o)
                    .replace("{fontstack}", r)
                    .replace("{range}", `${m}-${_}`),
                  Bs.Glyphs
                );
              Tl(x, (E, T) => {
                if (E) h(E);
                else if (T) {
                  const I = {},
                    A = new kd(T).readFields(Wv, {});
                  for (const L of A.glyphs) I[L.id] = L;
                  h(null, {
                    glyphs: I,
                    ascender: A.ascender,
                    descender: A.descender,
                  });
                }
              });
            }),
              (sh.TinySDF = class {
                constructor({
                  fontSize: r = 24,
                  buffer: i = 3,
                  radius: o = 8,
                  cutoff: l = 0.25,
                  fontFamily: h = "sans-serif",
                  fontWeight: m = "normal",
                  fontStyle: _ = "normal",
                } = {}) {
                  (this.buffer = i), (this.cutoff = l), (this.radius = o);
                  const x = (this.size = r + 4 * i),
                    E = this._createCanvas(x),
                    T = (this.ctx = E.getContext("2d", {
                      willReadFrequently: !0,
                    }));
                  (T.font = `${_} ${m} ${r}px ${h}`),
                    (T.textBaseline = "alphabetic"),
                    (T.textAlign = "left"),
                    (T.fillStyle = "black"),
                    (this.gridOuter = new Float64Array(x * x)),
                    (this.gridInner = new Float64Array(x * x)),
                    (this.f = new Float64Array(x)),
                    (this.z = new Float64Array(x + 1)),
                    (this.v = new Uint16Array(x));
                }
                _createCanvas(r) {
                  const i = document.createElement("canvas");
                  return (i.width = i.height = r), i;
                }
                draw(r) {
                  const {
                      width: i,
                      actualBoundingBoxAscent: o,
                      actualBoundingBoxDescent: l,
                      actualBoundingBoxLeft: h,
                      actualBoundingBoxRight: m,
                    } = this.ctx.measureText(r),
                    _ = Math.ceil(o),
                    x = Math.max(
                      0,
                      Math.min(this.size - this.buffer, Math.ceil(m - h))
                    ),
                    E = Math.min(this.size - this.buffer, _ + Math.ceil(l)),
                    T = x + 2 * this.buffer,
                    I = E + 2 * this.buffer,
                    A = Math.max(T * I, 0),
                    L = new Uint8ClampedArray(A),
                    O = {
                      data: L,
                      width: T,
                      height: I,
                      glyphWidth: x,
                      glyphHeight: E,
                      glyphTop: _,
                      glyphLeft: 0,
                      glyphAdvance: i,
                    };
                  if (0 === x || 0 === E) return O;
                  const {
                    ctx: F,
                    buffer: V,
                    gridInner: G,
                    gridOuter: K,
                  } = this;
                  F.clearRect(V, V, x, E), F.fillText(r, V, V + _);
                  const oe = F.getImageData(V, V, x, E);
                  K.fill(Nd, 0, A), G.fill(0, 0, A);
                  for (let J = 0; J < E; J++)
                    for (let re = 0; re < x; re++) {
                      const le = oe.data[4 * (J * x + re) + 3] / 255;
                      if (0 === le) continue;
                      const ae = (J + V) * T + re + V;
                      if (1 === le) (K[ae] = 0), (G[ae] = Nd);
                      else {
                        const De = 0.5 - le;
                        (K[ae] = De > 0 ? De * De : 0),
                          (G[ae] = De < 0 ? De * De : 0);
                      }
                    }
                  W_(K, 0, 0, T, I, T, this.f, this.v, this.z),
                    W_(G, V, V, x, E, T, this.f, this.v, this.z);
                  for (let J = 0; J < A; J++) {
                    const re = Math.sqrt(K[J]) - Math.sqrt(G[J]);
                    L[J] = Math.round(
                      255 - 255 * (re / this.radius + this.cutoff)
                    );
                  }
                  return O;
                }
              });
            function X_(r, i, o, l) {
              const h = [],
                m = r.image,
                _ = m.pixelRatio,
                x = m.paddedRect.w - 2,
                E = m.paddedRect.h - 2,
                T = r.right - r.left,
                I = r.bottom - r.top,
                A = m.stretchX || [[0, x]],
                L = m.stretchY || [[0, E]],
                O = (Ie, Fe) => Ie + Fe[1] - Fe[0],
                F = A.reduce(O, 0),
                V = L.reduce(O, 0),
                G = x - F,
                K = E - V;
              let oe = 0,
                J = F,
                re = 0,
                le = V,
                ae = 0,
                De = G,
                xe = 0,
                Pe = K;
              if (m.content && l) {
                const Ie = m.content;
                (oe = Gt(A, 0, Ie[0])),
                  (re = Gt(L, 0, Ie[1])),
                  (J = Gt(A, Ie[0], Ie[2])),
                  (le = Gt(L, Ie[1], Ie[3])),
                  (ae = Ie[0] - oe),
                  (xe = Ie[1] - re),
                  (De = Ie[2] - Ie[0] - J),
                  (Pe = Ie[3] - Ie[1] - le);
              }
              const $e = (Ie, Fe, Re, Ve) => {
                const qe = zd(Ie.stretch - oe, J, T, r.left),
                  Me = Bd(Ie.fixed - ae, De, Ie.stretch, F),
                  tt = zd(Fe.stretch - re, le, I, r.top),
                  pt = Bd(Fe.fixed - xe, Pe, Fe.stretch, V),
                  rt = zd(Re.stretch - oe, J, T, r.left),
                  Lt = Bd(Re.fixed - ae, De, Re.stretch, F),
                  Ke = zd(Ve.stretch - re, le, I, r.top),
                  bt = Bd(Ve.fixed - xe, Pe, Ve.stretch, V),
                  Pt = new nt(qe, tt),
                  Yt = new nt(rt, tt),
                  At = new nt(rt, Ke),
                  Et = new nt(qe, Ke),
                  In = new nt(Me / _, pt / _),
                  Nt = new nt(Lt / _, bt / _),
                  kt = (i * Math.PI) / 180;
                if (kt) {
                  const Bn = Math.sin(kt),
                    vn = Math.cos(kt),
                    Kn = [vn, -Bn, Bn, vn];
                  Pt._matMult(Kn),
                    Yt._matMult(Kn),
                    Et._matMult(Kn),
                    At._matMult(Kn);
                }
                const kn = Ie.stretch + Ie.fixed,
                  zn = Fe.stretch + Fe.fixed;
                return {
                  tl: Pt,
                  tr: Yt,
                  bl: Et,
                  br: At,
                  tex: {
                    x: m.paddedRect.x + 1 + kn,
                    y: m.paddedRect.y + 1 + zn,
                    w: Re.stretch + Re.fixed - kn,
                    h: Ve.stretch + Ve.fixed - zn,
                  },
                  writingMode: void 0,
                  glyphOffset: [0, 0],
                  sectionIndex: 0,
                  pixelOffsetTL: In,
                  pixelOffsetBR: Nt,
                  minFontScaleX: De / _ / T,
                  minFontScaleY: Pe / _ / I,
                  isSDF: o,
                };
              };
              if (l && (m.stretchX || m.stretchY)) {
                const Ie = ei(A, G, F),
                  Fe = ei(L, K, V);
                for (let Re = 0; Re < Ie.length - 1; Re++) {
                  const Ve = Ie[Re],
                    qe = Ie[Re + 1];
                  for (let Me = 0; Me < Fe.length - 1; Me++)
                    h.push($e(Ve, Fe[Me], qe, Fe[Me + 1]));
                }
              } else h.push($e({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: x + 1 }, { fixed: 0, stretch: E + 1 }));
              return h;
            }
            function Gt(r, i, o) {
              let l = 0;
              for (const h of r)
                l +=
                  Math.max(i, Math.min(o, h[1])) -
                  Math.max(i, Math.min(o, h[0]));
              return l;
            }
            function ei(r, i, o) {
              const l = [{ fixed: -1, stretch: 0 }];
              for (const [h, m] of r) {
                const _ = l[l.length - 1];
                l.push({ fixed: h - _.stretch, stretch: _.stretch }),
                  l.push({
                    fixed: h - _.stretch,
                    stretch: _.stretch + (m - h),
                  });
              }
              return l.push({ fixed: i + 1, stretch: o }), l;
            }
            function zd(r, i, o, l) {
              return (r / i) * o + l;
            }
            function Bd(r, i, o, l) {
              return r - (i * o) / l;
            }
            function Jv(r, i, o, l) {
              const h = i + r.positionedLines[l].lineOffset;
              return 0 === l
                ? o + h / 2
                : o + (h + (i + r.positionedLines[l - 1].lineOffset)) / 2;
            }
            class e0 {
              constructor(i = [], o = K_) {
                if (
                  ((this.data = i),
                  (this.length = this.data.length),
                  (this.compare = o),
                  this.length > 0)
                )
                  for (let l = (this.length >> 1) - 1; l >= 0; l--)
                    this._down(l);
              }
              push(i) {
                this.data.push(i), this.length++, this._up(this.length - 1);
              }
              pop() {
                if (0 === this.length) return;
                const i = this.data[0],
                  o = this.data.pop();
                return (
                  this.length--,
                  this.length > 0 && ((this.data[0] = o), this._down(0)),
                  i
                );
              }
              peek() {
                return this.data[0];
              }
              _up(i) {
                const { data: o, compare: l } = this,
                  h = o[i];
                for (; i > 0; ) {
                  const m = (i - 1) >> 1,
                    _ = o[m];
                  if (l(h, _) >= 0) break;
                  (o[i] = _), (i = m);
                }
                o[i] = h;
              }
              _down(i) {
                const { data: o, compare: l } = this,
                  h = this.length >> 1,
                  m = o[i];
                for (; i < h; ) {
                  let _ = 1 + (i << 1),
                    x = o[_];
                  const E = _ + 1;
                  if (
                    (E < this.length && l(o[E], x) < 0 && ((_ = E), (x = o[E])),
                    l(x, m) >= 0)
                  )
                    break;
                  (o[i] = x), (i = _);
                }
                o[i] = m;
              }
            }
            function K_(r, i) {
              return r < i ? -1 : r > i ? 1 : 0;
            }
            function t0(r, i = 1, o = !1) {
              let l = 1 / 0,
                h = 1 / 0,
                m = -1 / 0,
                _ = -1 / 0;
              const x = r[0];
              for (let O = 0; O < x.length; O++) {
                const F = x[O];
                (!O || F.x < l) && (l = F.x),
                  (!O || F.y < h) && (h = F.y),
                  (!O || F.x > m) && (m = F.x),
                  (!O || F.y > _) && (_ = F.y);
              }
              const E = Math.min(m - l, _ - h);
              let T = E / 2;
              const I = new e0([], Y_);
              if (0 === E) return new nt(l, h);
              for (let O = l; O < m; O += E)
                for (let F = h; F < _; F += E)
                  I.push(new lh(O + T, F + T, T, r));
              let A = (function (O) {
                  let F = 0,
                    V = 0,
                    G = 0;
                  const K = O[0];
                  for (
                    let oe = 0, J = K.length, re = J - 1;
                    oe < J;
                    re = oe++
                  ) {
                    const le = K[oe],
                      ae = K[re],
                      De = le.x * ae.y - ae.x * le.y;
                    (V += (le.x + ae.x) * De),
                      (G += (le.y + ae.y) * De),
                      (F += 3 * De);
                  }
                  return new lh(V / F, G / F, 0, O);
                })(r),
                L = I.length;
              for (; I.length; ) {
                const O = I.pop();
                (O.d > A.d || !A.d) &&
                  ((A = O),
                  o &&
                    console.log(
                      "found best %d after %d probes",
                      Math.round(1e4 * O.d) / 1e4,
                      L
                    )),
                  O.max - A.d <= i ||
                    ((T = O.h / 2),
                    I.push(new lh(O.p.x - T, O.p.y - T, T, r)),
                    I.push(new lh(O.p.x + T, O.p.y - T, T, r)),
                    I.push(new lh(O.p.x - T, O.p.y + T, T, r)),
                    I.push(new lh(O.p.x + T, O.p.y + T, T, r)),
                    (L += 4));
              }
              return (
                o &&
                  (console.log(`num probes: ${L}`),
                  console.log(`best distance: ${A.d}`)),
                A.p
              );
            }
            function Y_(r, i) {
              return i.max - r.max;
            }
            class lh {
              constructor(i, o, l, h) {
                (this.p = new nt(i, o)),
                  (this.h = l),
                  (this.d = (function (m, _) {
                    let x = !1,
                      E = 1 / 0;
                    for (let T = 0; T < _.length; T++) {
                      const I = _[T];
                      for (let A = 0, L = I.length, O = L - 1; A < L; O = A++) {
                        const F = I[A],
                          V = I[O];
                        F.y > m.y != V.y > m.y &&
                          m.x <
                            ((V.x - F.x) * (m.y - F.y)) / (V.y - F.y) + F.x &&
                          (x = !x),
                          (E = Math.min(E, Cv(m, F, V)));
                      }
                    }
                    return (x ? 1 : -1) * Math.sqrt(E);
                  })(this.p, h)),
                  (this.max = this.d + this.h * Math.SQRT2);
              }
            }
            const Q_ = Number.POSITIVE_INFINITY,
              J_ = Math.sqrt(2);
            function qm(r, [i, o]) {
              let l = 0,
                h = 0;
              if (o === Q_) {
                i < 0 && (i = 0);
                const m = i / J_;
                switch (r) {
                  case "top-right":
                  case "top-left":
                    h = m - 7;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                    h = 7 - m;
                    break;
                  case "bottom":
                    h = 7 - i;
                    break;
                  case "top":
                    h = i - 7;
                }
                switch (r) {
                  case "top-right":
                  case "bottom-right":
                    l = -m;
                    break;
                  case "top-left":
                  case "bottom-left":
                    l = m;
                    break;
                  case "left":
                    l = i;
                    break;
                  case "right":
                    l = -i;
                }
              } else {
                switch (((i = Math.abs(i)), (o = Math.abs(o)), r)) {
                  case "top-right":
                  case "top-left":
                  case "top":
                    h = o - 7;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                  case "bottom":
                    h = 7 - o;
                }
                switch (r) {
                  case "top-right":
                  case "bottom-right":
                  case "right":
                    l = -i;
                    break;
                  case "top-left":
                  case "bottom-left":
                  case "left":
                    l = i;
                }
              }
              return [l, h];
            }
            function Hc(r, i, o, l, h, m, _, x, E, T) {
              r.createArrays(),
                (r.tilePixelRatio = wt / (512 * r.overscaling)),
                (r.compareText = {}),
                (r.iconsNeedLinear = !1);
              const I = r.layers[0].layout,
                A = r.layers[0]._unevaluatedLayout._values,
                L = {};
              if ("composite" === r.textSizeData.kind) {
                const { minZoom: V, maxZoom: G } = r.textSizeData;
                L.compositeTextSizes = [
                  A["text-size"].possiblyEvaluate(new M(V), x),
                  A["text-size"].possiblyEvaluate(new M(G), x),
                ];
              }
              if ("composite" === r.iconSizeData.kind) {
                const { minZoom: V, maxZoom: G } = r.iconSizeData;
                L.compositeIconSizes = [
                  A["icon-size"].possiblyEvaluate(new M(V), x),
                  A["icon-size"].possiblyEvaluate(new M(G), x),
                ];
              }
              (L.layoutTextSize = A["text-size"].possiblyEvaluate(
                new M(E + 1),
                x
              )),
                (L.layoutIconSize = A["icon-size"].possiblyEvaluate(
                  new M(E + 1),
                  x
                )),
                (L.textMaxSize = A["text-size"].possiblyEvaluate(new M(18), x));
              const O =
                  "map" === I.get("text-rotation-alignment") &&
                  "point" !== I.get("symbol-placement"),
                F = I.get("text-size");
              for (const V of r.features) {
                const G = I.get("text-font").evaluate(V, {}, x).join(","),
                  K = F.evaluate(V, {}, x),
                  oe = L.layoutTextSize.evaluate(V, {}, x),
                  J =
                    (L.layoutIconSize.evaluate(V, {}, x),
                    { horizontal: {}, vertical: void 0 }),
                  re = V.text;
                let le,
                  ae = [0, 0];
                if (re) {
                  const Pe = re.toString(),
                    $e = 24 * I.get("text-letter-spacing").evaluate(V, {}, x),
                    Ie = 24 * I.get("text-line-height").evaluate(V, {}, x),
                    Fe = $f(Pe) ? $e : 0,
                    Re = I.get("text-anchor").evaluate(V, {}, x),
                    Ve = I.get("text-variable-anchor");
                  if (!Ve) {
                    const rt = I.get("text-radial-offset").evaluate(V, {}, x);
                    ae = rt
                      ? qm(Re, [24 * rt, Q_])
                      : I.get("text-offset")
                          .evaluate(V, {}, x)
                          .map((Lt) => 24 * Lt);
                  }
                  let qe = O
                    ? "center"
                    : I.get("text-justify").evaluate(V, {}, x);
                  const Me = "point" === I.get("symbol-placement"),
                    tt = Me
                      ? 24 * I.get("text-max-width").evaluate(V, {}, x)
                      : 1 / 0,
                    pt = (rt) => {
                      r.allowVerticalPlacement &&
                        Qh(Pe) &&
                        (J.vertical = Vm(
                          re,
                          i,
                          o,
                          h,
                          G,
                          tt,
                          Ie,
                          Re,
                          rt,
                          Fe,
                          ae,
                          Po.vertical,
                          !0,
                          oe,
                          K
                        ));
                    };
                  if (!O && Ve) {
                    const rt = "auto" === qe ? Ve.map((Ke) => Wm(Ke)) : [qe];
                    let Lt = !1;
                    for (let Ke = 0; Ke < rt.length; Ke++) {
                      const bt = rt[Ke];
                      if (!J.horizontal[bt])
                        if (Lt) J.horizontal[bt] = J.horizontal[0];
                        else {
                          const Pt = Vm(
                            re,
                            i,
                            o,
                            h,
                            G,
                            tt,
                            Ie,
                            "center",
                            bt,
                            Fe,
                            ae,
                            Po.horizontal,
                            !1,
                            oe,
                            K
                          );
                          Pt &&
                            ((J.horizontal[bt] = Pt),
                            (Lt = 1 === Pt.positionedLines.length));
                        }
                    }
                    pt("left");
                  } else {
                    if (
                      ("auto" === qe && (qe = Wm(Re)),
                      Me ||
                        I.get("text-writing-mode").indexOf("horizontal") >= 0 ||
                        !Qh(Pe))
                    ) {
                      const rt = Vm(
                        re,
                        i,
                        o,
                        h,
                        G,
                        tt,
                        Ie,
                        Re,
                        qe,
                        Fe,
                        ae,
                        Po.horizontal,
                        !1,
                        oe,
                        K
                      );
                      rt && (J.horizontal[qe] = rt);
                    }
                    pt(Me ? "left" : qe);
                  }
                }
                let De = !1;
                if (V.icon && V.icon.name) {
                  const Pe = l[V.icon.name];
                  Pe &&
                    ((le = Ab(
                      h[V.icon.name],
                      I.get("icon-offset").evaluate(V, {}, x),
                      I.get("icon-anchor").evaluate(V, {}, x)
                    )),
                    (De = Pe.sdf),
                    void 0 === r.sdfIcons
                      ? (r.sdfIcons = Pe.sdf)
                      : r.sdfIcons !== Pe.sdf &&
                        Wn(
                          "Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"
                        ),
                    (Pe.pixelRatio !== r.pixelRatio ||
                      0 !== I.get("icon-rotate").constantOr(1)) &&
                      (r.iconsNeedLinear = !0));
                }
                const xe = r0(J.horizontal) || J.vertical;
                r.iconsInText || (r.iconsInText = !!xe && xe.iconsInText),
                  (xe || le) && Zm(r, V, J, le, l, L, oe, 0, ae, De, _, x, T);
              }
              m && r.generateCollisionDebugBuffers(E, r.collisionBoxArray);
            }
            function Wm(r) {
              switch (r) {
                case "right":
                case "top-right":
                case "bottom-right":
                  return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                  return "left";
              }
              return "center";
            }
            function Zm(r, i, o, l, h, m, _, x, E, T, I, A, L) {
              let O = m.textMaxSize.evaluate(i, {}, A);
              void 0 === O && (O = _);
              const F = r.layers[0].layout,
                V = F.get("icon-offset").evaluate(i, {}, A),
                G = r0(o.horizontal) || o.vertical,
                K = "globe" === L.name,
                J = _ / 24,
                re = (r.tilePixelRatio * O) / 24,
                le =
                  ((Re = r.overscaling),
                  r.zoom > 18 && Re > 2 && (Re >>= 1),
                  Math.max(wt / (512 * Re), 1) * F.get("symbol-spacing")),
                ae = F.get("text-padding") * r.tilePixelRatio,
                De = F.get("icon-padding") * r.tilePixelRatio,
                xe = Qt(F.get("text-max-angle")),
                Pe =
                  "map" === F.get("text-rotation-alignment") &&
                  "point" !== F.get("symbol-placement"),
                $e =
                  "map" === F.get("icon-rotation-alignment") &&
                  "point" !== F.get("symbol-placement"),
                Ie = F.get("symbol-placement"),
                Fe = le / 2;
              var Re;
              const Ve = F.get("icon-text-fit");
              let qe;
              l &&
                "none" !== Ve &&
                (r.allowVerticalPlacement &&
                  o.vertical &&
                  (qe = Um(
                    l,
                    o.vertical,
                    Ve,
                    F.get("icon-text-fit-padding"),
                    V,
                    J
                  )),
                G && (l = Um(l, G, Ve, F.get("icon-text-fit-padding"), V, J)));
              const Me = (tt, pt, rt) => {
                if (pt.x < 0 || pt.x >= wt || pt.y < 0 || pt.y >= wt) return;
                let Lt = null;
                if (K) {
                  const {
                    x: Ke,
                    y: bt,
                    z: Pt,
                  } = L.projectTilePoint(pt.x, pt.y, rt);
                  Lt = {
                    anchor: new Zl(Ke, bt, Pt, 0, void 0),
                    up: L.upVector(rt, pt.x, pt.y),
                  };
                }
                !(function (
                  Ke,
                  bt,
                  Pt,
                  Yt,
                  At,
                  Et,
                  In,
                  Nt,
                  kt,
                  kn,
                  zn,
                  Bn,
                  vn,
                  Kn,
                  ci,
                  wi,
                  Vn,
                  Ii,
                  Ei,
                  ti,
                  dn,
                  ui,
                  jn,
                  hr,
                  Ti
                ) {
                  const er = Ke.addToLineVertexArray(bt, Yt);
                  let Wi,
                    Vr,
                    Zi,
                    Ds,
                    ul,
                    Cs,
                    _f,
                    mh = 0,
                    py = 0,
                    fy = 0,
                    yf = 0,
                    hg = -1,
                    Jo = -1;
                  const uo = {};
                  let Cr = jl("");
                  const Lo = Pt ? Pt.anchor : bt;
                  let gh = 0,
                    ho = 0;
                  if (
                    (void 0 ===
                    kt._unevaluatedLayout.getValue("text-radial-offset")
                      ? ([gh, ho] = kt.layout
                          .get("text-offset")
                          .evaluate(dn, {}, Ti)
                          .map((tr) => 24 * tr))
                      : ((gh =
                          24 *
                          kt.layout
                            .get("text-radial-offset")
                            .evaluate(dn, {}, Ti)),
                        (ho = Q_)),
                    Ke.allowVerticalPlacement && At.vertical)
                  ) {
                    const tr = At.vertical;
                    if (ci) (Cs = Km(tr)), Nt && (_f = Km(Nt));
                    else {
                      const nr =
                        kt.layout.get("text-rotate").evaluate(dn, {}, Ti) + 90;
                      (Zi = Xm(kn, Lo, bt, zn, Bn, vn, tr, Kn, nr, wi)),
                        Nt && (Ds = Xm(kn, Lo, bt, zn, Bn, vn, Nt, Ii, nr));
                    }
                  }
                  if (Et) {
                    const tr = kt.layout
                        .get("icon-rotate")
                        .evaluate(dn, {}, Ti),
                      nr = "none" !== kt.layout.get("icon-text-fit"),
                      va = X_(Et, tr, jn, nr),
                      Jl = Nt ? X_(Nt, tr, jn, nr) : void 0;
                    (Vr = Xm(kn, Lo, bt, zn, Bn, vn, Et, Ii, tr)),
                      (mh = 4 * va.length);
                    const Qc = Ke.iconSizeData;
                    let es = null;
                    "source" === Qc.kind
                      ? ((es = [
                          ys * kt.layout.get("icon-size").evaluate(dn, {}, Ti),
                        ]),
                        es[0] > Xl &&
                          Wn(
                            `${Ke.layerIds[0]}: Value for "icon-size" is >= ${Gc}. Reduce your "icon-size".`
                          ))
                      : "composite" === Qc.kind &&
                        ((es = [
                          ys * ui.compositeIconSizes[0].evaluate(dn, {}, Ti),
                          ys * ui.compositeIconSizes[1].evaluate(dn, {}, Ti),
                        ]),
                        (es[0] > Xl || es[1] > Xl) &&
                          Wn(
                            `${Ke.layerIds[0]}: Value for "icon-size" is >= ${Gc}. Reduce your "icon-size".`
                          )),
                      Ke.addSymbols(
                        Ke.icon,
                        va,
                        es,
                        ti,
                        Ei,
                        dn,
                        !1,
                        Pt,
                        bt,
                        er.lineStartIndex,
                        er.lineLength,
                        -1,
                        hr,
                        Ti
                      ),
                      (hg = Ke.icon.placedSymbolArray.length - 1),
                      Jl &&
                        ((py = 4 * Jl.length),
                        Ke.addSymbols(
                          Ke.icon,
                          Jl,
                          es,
                          ti,
                          Ei,
                          dn,
                          Po.vertical,
                          Pt,
                          bt,
                          er.lineStartIndex,
                          er.lineLength,
                          -1,
                          hr,
                          Ti
                        ),
                        (Jo = Ke.icon.placedSymbolArray.length - 1));
                  }
                  for (const tr in At.horizontal) {
                    const nr = At.horizontal[tr];
                    Wi ||
                      ((Cr = jl(nr.text)),
                      ci
                        ? (ul = Km(nr))
                        : (Wi = Xm(
                            kn,
                            Lo,
                            bt,
                            zn,
                            Bn,
                            vn,
                            nr,
                            Kn,
                            kt.layout.get("text-rotate").evaluate(dn, {}, Ti),
                            wi
                          )));
                    const va = 1 === nr.positionedLines.length;
                    if (
                      ((fy += n0(
                        Ke,
                        Pt,
                        bt,
                        nr,
                        In,
                        kt,
                        ci,
                        dn,
                        wi,
                        er,
                        At.vertical ? Po.horizontal : Po.horizontalOnly,
                        va ? Object.keys(At.horizontal) : [tr],
                        uo,
                        hg,
                        ui,
                        hr,
                        Ti
                      )),
                      va)
                    )
                      break;
                  }
                  At.vertical &&
                    (yf += n0(
                      Ke,
                      Pt,
                      bt,
                      At.vertical,
                      In,
                      kt,
                      ci,
                      dn,
                      wi,
                      er,
                      Po.vertical,
                      ["vertical"],
                      uo,
                      Jo,
                      ui,
                      hr,
                      Ti
                    ));
                  let Ss = -1;
                  const Ql = (tr, nr) => (tr ? Math.max(tr, nr) : nr);
                  (Ss = Ql(ul, Ss)), (Ss = Ql(Cs, Ss)), (Ss = Ql(_f, Ss));
                  const _h = Ss > -1 ? 1 : 0;
                  Ke.glyphOffsetArray.length >= fa.MAX_GLYPHS &&
                    Wn(
                      "Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"
                    ),
                    void 0 !== dn.sortKey &&
                      Ke.addToSortKeyRanges(
                        Ke.symbolInstances.length,
                        dn.sortKey
                      ),
                    Ke.symbolInstances.emplaceBack(
                      Lo.x,
                      Lo.y,
                      Lo.z,
                      bt.x,
                      bt.y,
                      uo.right >= 0 ? uo.right : -1,
                      uo.center >= 0 ? uo.center : -1,
                      uo.left >= 0 ? uo.left : -1,
                      uo.vertical >= 0 ? uo.vertical : -1,
                      hg,
                      Jo,
                      Cr,
                      void 0 !== Wi ? Wi : Ke.collisionBoxArray.length,
                      void 0 !== Wi ? Wi + 1 : Ke.collisionBoxArray.length,
                      void 0 !== Zi ? Zi : Ke.collisionBoxArray.length,
                      void 0 !== Zi ? Zi + 1 : Ke.collisionBoxArray.length,
                      void 0 !== Vr ? Vr : Ke.collisionBoxArray.length,
                      void 0 !== Vr ? Vr + 1 : Ke.collisionBoxArray.length,
                      Ds || Ke.collisionBoxArray.length,
                      Ds ? Ds + 1 : Ke.collisionBoxArray.length,
                      zn,
                      fy,
                      yf,
                      mh,
                      py,
                      _h,
                      0,
                      gh,
                      ho,
                      Ss
                    );
                })(
                  r,
                  pt,
                  Lt,
                  tt,
                  o,
                  l,
                  h,
                  qe,
                  r.layers[0],
                  r.collisionBoxArray,
                  i.index,
                  i.sourceLayerIndex,
                  r.index,
                  ae,
                  Pe,
                  E,
                  0,
                  De,
                  $e,
                  V,
                  i,
                  m,
                  T,
                  I,
                  A
                );
              };
              if ("line" === Ie)
                for (const tt of Gm(i.geometry, 0, 0, wt, wt)) {
                  const pt = vs(
                    tt,
                    le,
                    xe,
                    o.vertical || G,
                    l,
                    24,
                    re,
                    r.overscaling,
                    wt
                  );
                  for (const rt of pt)
                    (G && ey(r, G.text, Fe, rt)) || Me(tt, rt, A);
                }
              else if ("line-center" === Ie) {
                for (const tt of i.geometry)
                  if (tt.length > 1) {
                    const pt = Qv(tt, xe, o.vertical || G, l, 24, re);
                    pt && Me(tt, pt, A);
                  }
              } else if ("Polygon" === i.type)
                for (const tt of qp(i.geometry, 0)) {
                  const pt = t0(tt, 16);
                  Me(tt[0], new Zl(pt.x, pt.y, 0, 0, void 0), A);
                }
              else if ("LineString" === i.type)
                for (const tt of i.geometry)
                  Me(tt, new Zl(tt[0].x, tt[0].y, 0, 0, void 0), A);
              else if ("Point" === i.type)
                for (const tt of i.geometry)
                  for (const pt of tt)
                    Me([pt], new Zl(pt.x, pt.y, 0, 0, void 0), A);
            }
            const Gc = 255,
              Xl = Gc * ys;
            function n0(r, i, o, l, h, m, _, x, E, T, I, A, L, O, F, V, G) {
              const K = (function (re, le, ae, De, xe, Pe, $e, Ie) {
                  const Fe = [];
                  if (0 === le.positionedLines.length) return Fe;
                  const Re =
                      (De.layout.get("text-rotate").evaluate(Pe, {}) *
                        Math.PI) /
                      180,
                    Ve = (function (rt) {
                      const Lt = rt[0],
                        Ke = rt[1],
                        bt = Lt * Ke;
                      return bt > 0
                        ? [Lt, -Ke]
                        : bt < 0
                        ? [-Lt, Ke]
                        : 0 === Lt
                        ? [Ke, Lt]
                        : [Ke, -Lt];
                    })(ae);
                  let qe = Math.abs(le.top - le.bottom);
                  for (const rt of le.positionedLines) qe -= rt.lineOffset;
                  const Me = le.positionedLines.length,
                    tt = qe / Me;
                  let pt = le.top - ae[1];
                  for (let rt = 0; rt < Me; ++rt) {
                    const Lt = le.positionedLines[rt];
                    pt = Jv(le, tt, pt, rt);
                    for (const Ke of Lt.positionedGlyphs) {
                      if (!Ke.rect) continue;
                      const bt = Ke.rect || {};
                      let Pt = 4,
                        Yt = !0,
                        At = 1,
                        Et = 0;
                      if (Ke.imageName) {
                        const jn = $e[Ke.imageName];
                        if (!jn) continue;
                        if (jn.sdf) {
                          Wn(
                            "SDF images are not supported in formatted text and will be ignored."
                          );
                          continue;
                        }
                        (Yt = !1), (At = jn.pixelRatio), (Pt = 1 / At);
                      }
                      const In = (xe || Ie) && Ke.vertical,
                        Nt = (Ke.metrics.advance * Ke.scale) / 2,
                        kt = Ke.metrics,
                        kn = Ke.rect;
                      if (null === kn) continue;
                      Ie &&
                        le.verticalizable &&
                        (Et = Ke.imageName
                          ? Nt - (Ke.metrics.width * Ke.scale) / 2
                          : 0);
                      const zn = xe ? [Ke.x + Nt, Ke.y] : [0, 0];
                      let Bn = [0, 0],
                        vn = [0, 0],
                        Kn = !1;
                      xe ||
                        (In
                          ? ((vn = [Ke.x + Nt + Ve[0], Ke.y + Ve[1] - Et]),
                            (Kn = !0))
                          : (Bn = [Ke.x + Nt + ae[0], Ke.y + ae[1] - Et]));
                      const ci =
                          (kn.w * Ke.scale) / (At * (Ke.localGlyph ? 2 : 1)),
                        wi = (kn.h * Ke.scale) / (At * (Ke.localGlyph ? 2 : 1));
                      let Vn, Ii, Ei, ti;
                      if (In) {
                        const jn = Ke.y - pt,
                          hr = new nt(-Nt, Nt - jn),
                          Ti = -Math.PI / 2,
                          er = new nt(...vn);
                        (Vn = new nt(-Nt + Bn[0], Bn[1])),
                          Vn._rotateAround(Ti, hr)._add(er),
                          (Vn.x += -jn + Nt),
                          (Vn.y -= (kt.left - Pt) * Ke.scale);
                        const Wi = Ke.imageName
                            ? kt.advance * Ke.scale
                            : 24 * Ke.scale,
                          Vr = String.fromCharCode(Ke.glyph);
                        k_(Vr)
                          ? (Vn.x += (1 - Pt) * Ke.scale)
                          : Om(Vr)
                          ? (Vn.x +=
                              Wi - kt.height * Ke.scale + (-Pt - 1) * Ke.scale)
                          : (Vn.x +=
                              Ke.imageName ||
                              (kt.width + 2 * Pt === kn.w &&
                                kt.height + 2 * Pt === kn.h)
                                ? (Wi - wi) / 2
                                : (Wi - (kt.height + 2 * Pt) * Ke.scale) / 2),
                          (Ii = new nt(Vn.x, Vn.y - ci)),
                          (Ei = new nt(Vn.x + wi, Vn.y)),
                          (ti = new nt(Vn.x + wi, Vn.y - ci));
                      } else {
                        const jn = (kt.left - Pt) * Ke.scale - Nt + Bn[0],
                          hr = (-kt.top - Pt) * Ke.scale + Bn[1],
                          Ti = jn + ci,
                          er = hr + wi;
                        (Vn = new nt(jn, hr)),
                          (Ii = new nt(Ti, hr)),
                          (Ei = new nt(jn, er)),
                          (ti = new nt(Ti, er));
                      }
                      if (Re) {
                        let jn;
                        (jn = xe
                          ? new nt(0, 0)
                          : Kn
                          ? new nt(Ve[0], Ve[1])
                          : new nt(ae[0], ae[1])),
                          Vn._rotateAround(Re, jn),
                          Ii._rotateAround(Re, jn),
                          Ei._rotateAround(Re, jn),
                          ti._rotateAround(Re, jn);
                      }
                      const dn = new nt(0, 0),
                        ui = new nt(0, 0);
                      Fe.push({
                        tl: Vn,
                        tr: Ii,
                        bl: Ei,
                        br: ti,
                        tex: bt,
                        writingMode: le.writingMode,
                        glyphOffset: zn,
                        sectionIndex: Ke.sectionIndex,
                        isSDF: Yt,
                        pixelOffsetTL: dn,
                        pixelOffsetBR: ui,
                        minFontScaleX: 0,
                        minFontScaleY: 0,
                      });
                    }
                  }
                  return Fe;
                })(0, l, E, m, _, x, h, r.allowVerticalPlacement),
                oe = r.textSizeData;
              let J = null;
              "source" === oe.kind
                ? ((J = [ys * m.layout.get("text-size").evaluate(x, {}, G)]),
                  J[0] > Xl &&
                    Wn(
                      `${r.layerIds[0]}: Value for "text-size" is >= ${Gc}. Reduce your "text-size".`
                    ))
                : "composite" === oe.kind &&
                  ((J = [
                    ys * F.compositeTextSizes[0].evaluate(x, {}, G),
                    ys * F.compositeTextSizes[1].evaluate(x, {}, G),
                  ]),
                  (J[0] > Xl || J[1] > Xl) &&
                    Wn(
                      `${r.layerIds[0]}: Value for "text-size" is >= ${Gc}. Reduce your "text-size".`
                    )),
                r.addSymbols(
                  r.text,
                  K,
                  J,
                  E,
                  _,
                  x,
                  I,
                  i,
                  o,
                  T.lineStartIndex,
                  T.lineLength,
                  O,
                  V,
                  G
                );
              for (const re of A) L[re] = r.text.placedSymbolArray.length - 1;
              return 4 * K.length;
            }
            function r0(r) {
              for (const i in r) return r[i];
              return null;
            }
            function Xm(r, i, o, l, h, m, _, x, E, T) {
              let I = _.top,
                A = _.bottom,
                L = _.left,
                O = _.right;
              const F = _.collisionPadding;
              if (
                (F && ((L -= F[0]), (I -= F[1]), (O += F[2]), (A += F[3])), E)
              ) {
                const V = new nt(L, I),
                  G = new nt(O, I),
                  K = new nt(L, A),
                  oe = new nt(O, A),
                  J = Qt(E);
                let re = new nt(0, 0);
                T && (re = new nt(T[0], T[1])),
                  V._rotateAround(J, re),
                  G._rotateAround(J, re),
                  K._rotateAround(J, re),
                  oe._rotateAround(J, re),
                  (L = Math.min(V.x, G.x, K.x, oe.x)),
                  (O = Math.max(V.x, G.x, K.x, oe.x)),
                  (I = Math.min(V.y, G.y, K.y, oe.y)),
                  (A = Math.max(V.y, G.y, K.y, oe.y));
              }
              return (
                r.emplaceBack(i.x, i.y, i.z, o.x, o.y, L, I, O, A, x, l, h, m),
                r.length - 1
              );
            }
            function Km(r) {
              r.collisionPadding &&
                ((r.top -= r.collisionPadding[1]),
                (r.bottom += r.collisionPadding[3]));
              const i = r.bottom - r.top;
              return i > 0 ? Math.max(10, i) : null;
            }
            function ey(r, i, o, l) {
              const h = r.compareText;
              if (i in h) {
                const m = h[i];
                for (let _ = m.length - 1; _ >= 0; _--)
                  if (l.dist(m[_]) < o) return !0;
              } else h[i] = [];
              return h[i].push(l), !1;
            }
            function o0(r, i) {
              const o = r.fovAboveCenter,
                l = r.elevation ? r.elevation.getMinElevationBelowMSL() * i : 0,
                h =
                  (r._camera.position[2] * r.worldSize - l) /
                  Math.cos(r._pitch),
                m =
                  (Math.sin(o) * h) /
                  Math.sin(Math.max(Math.PI / 2 - r._pitch - o, 0.01)),
                _ = Math.sin(r._pitch) * m + h;
              return Math.min(1.01 * _, h * (1 / r._horizonShift));
            }
            function qc(r, i) {
              if (!i.isReprojectedInTileSpace)
                return {
                  scale: 1 << r.z,
                  x: r.x,
                  y: r.y,
                  x2: r.x + 1,
                  y2: r.y + 1,
                  projection: i,
                };
              const o = Math.pow(2, -r.z),
                l = r.x * o,
                h = (r.x + 1) * o,
                m = r.y * o,
                _ = (r.y + 1) * o,
                x = ao(l),
                E = ao(h),
                T = qi(m),
                I = qi(_),
                A = i.project(x, T),
                L = i.project(E, T),
                O = i.project(E, I),
                F = i.project(x, I);
              let V = Math.min(A.x, L.x, O.x, F.x),
                G = Math.min(A.y, L.y, O.y, F.y),
                K = Math.max(A.x, L.x, O.x, F.x),
                oe = Math.max(A.y, L.y, O.y, F.y);
              const J = o / 16;
              function re(ae, De, xe, Pe, $e, Ie) {
                const Fe = (xe + $e) / 2,
                  Re = (Pe + Ie) / 2,
                  Ve = i.project(ao(Fe), qi(Re)),
                  qe = Math.max(0, V - Ve.x, G - Ve.y, Ve.x - K, Ve.y - oe);
                (V = Math.min(V, Ve.x)),
                  (K = Math.max(K, Ve.x)),
                  (G = Math.min(G, Ve.y)),
                  (oe = Math.max(oe, Ve.y)),
                  qe > J &&
                    (re(ae, Ve, xe, Pe, Fe, Re), re(Ve, De, Fe, Re, $e, Ie));
              }
              re(A, L, l, m, h, m),
                re(L, O, h, m, h, _),
                re(O, F, h, _, l, _),
                re(F, A, l, _, l, m),
                (V -= J),
                (G -= J),
                (K += J),
                (oe += J);
              const le = 1 / Math.max(K - V, oe - G);
              return {
                scale: le,
                x: V * le,
                y: G * le,
                x2: K * le,
                y2: oe * le,
                projection: i,
              };
            }
            const uh = sa(new Float32Array(16));
            class Kl {
              constructor(i) {
                (this.spec = i),
                  (this.name = i.name),
                  (this.wrap = !1),
                  (this.requiresDraping = !1),
                  (this.supportsWorldCopies = !1),
                  (this.supportsTerrain = !1),
                  (this.supportsFog = !1),
                  (this.supportsFreeCamera = !1),
                  (this.zAxisUnit = "meters"),
                  (this.isReprojectedInTileSpace = !0),
                  (this.unsupportedLayers = ["custom"]),
                  (this.center = [0, 0]),
                  (this.range = [3.5, 7]);
              }
              project(i, o) {
                return { x: 0, y: 0, z: 0 };
              }
              unproject(i, o) {
                return new Ln(0, 0);
              }
              projectTilePoint(i, o, l) {
                return { x: i, y: o, z: 0 };
              }
              locationPoint(i, o, l = !0) {
                return i._coordinatePoint(i.locationCoordinate(o), l);
              }
              pixelsPerMeter(i, o) {
                return Ao(1, i) * o;
              }
              pixelSpaceConversion(i, o, l) {
                return 1;
              }
              farthestPixelDistance(i) {
                return o0(i, i.pixelsPerMeter);
              }
              pointCoordinate(i, o, l, h) {
                const m = i.horizonLineFromTop(!1),
                  _ = new nt(o, Math.max(m, l));
                return i.rayIntersectionCoordinate(
                  i.pointRayIntersection(_, h)
                );
              }
              pointCoordinate3D(i, o, l) {
                const h = new nt(o, l);
                if (i.elevation) return i.elevation.pointCoordinate(h);
                {
                  const m = this.pointCoordinate(i, h.x, h.y, 0);
                  return [m.x, m.y, m.z];
                }
              }
              isPointAboveHorizon(i, o) {
                if (i.elevation) return !this.pointCoordinate3D(i, o.x, o.y);
                const l = i.horizonLineFromTop();
                return o.y < l;
              }
              createInversionMatrix(i, o) {
                return uh;
              }
              createTileMatrix(i, o, l) {
                let h, m, _;
                const x = l.canonical,
                  E = sa(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                  const T = qc(x, this);
                  (h = 1),
                    (m = T.x + l.wrap * T.scale),
                    (_ = T.y),
                    Oc(E, E, [h / T.scale, h / T.scale, i.pixelsPerMeter / o]);
                } else (h = o / i.zoomScale(x.z)), (m = (x.x + Math.pow(2, x.z) * l.wrap) * h), (_ = x.y * h);
                return id(E, E, [m, _, 0]), Oc(E, E, [h / wt, h / wt, 1]), E;
              }
              upVector(i, o, l) {
                return [0, 0, 1];
              }
              upVectorScale(i, o, l) {
                return { metersToTile: 1 };
              }
            }
            class ty extends Kl {
              constructor(i) {
                super(i),
                  (this.range = [4, 7]),
                  (this.center = i.center || [-96, 37.5]);
                const [o, l] = (this.parallels = i.parallels || [29.5, 45.5]),
                  h = Math.sin(Qt(o));
                (this.n = (h + Math.sin(Qt(l))) / 2),
                  (this.c = 1 + h * (2 * this.n - h)),
                  (this.r0 = Math.sqrt(this.c) / this.n);
              }
              project(i, o) {
                const { n: l, c: h, r0: m } = this,
                  _ = Qt(i - this.center[0]),
                  x = Qt(o),
                  E = Math.sqrt(h - 2 * l * Math.sin(x)) / l;
                return {
                  x: E * Math.sin(_ * l),
                  y: E * Math.cos(_ * l) - m,
                  z: 0,
                };
              }
              unproject(i, o) {
                const { n: l, c: h, r0: m } = this,
                  _ = m + o;
                let x = Math.atan2(i, Math.abs(_)) * Math.sign(_);
                _ * l < 0 && (x -= Math.PI * Math.sign(i) * Math.sign(_));
                const E = Qt(this.center[0]) * l;
                x = Tn(x, -Math.PI - E, Math.PI - E);
                const T = tn(zi(x / l) + this.center[0], -180, 180),
                  I = Math.asin(
                    tn((h - (i * i + _ * _) * l * l) / (2 * l), -1, 1)
                  ),
                  A = tn(zi(I), -Si, Si);
                return new Ln(T, A);
              }
            }
            const Yl = 1.340264,
              Vd = -0.081106,
              hh = 893e-6,
              jd = 0.003796,
              of = Math.sqrt(3) / 2;
            class s0 extends Kl {
              project(i, o) {
                (o = (o / 180) * Math.PI), (i = (i / 180) * Math.PI);
                const l = Math.asin(of * Math.sin(o)),
                  h = l * l,
                  m = h * h * h;
                return {
                  x:
                    0.5 *
                    ((i * Math.cos(l)) /
                      (of * (Yl + 3 * Vd * h + m * (7 * hh + 9 * jd * h))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((l * (Yl + Vd * h + m * (hh + jd * h))) / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(i, o) {
                i = (2 * i - 0.5) * Math.PI;
                let l = (o = (2 * (1 - o) - 1) * Math.PI),
                  h = l * l,
                  m = h * h * h;
                for (
                  let I, A, L, O = 0;
                  O < 12 &&
                  ((A = l * (Yl + Vd * h + m * (hh + jd * h)) - o),
                  (L = Yl + 3 * Vd * h + m * (7 * hh + 9 * jd * h)),
                  (I = A / L),
                  (l = tn(l - I, -Math.PI / 3, Math.PI / 3)),
                  (h = l * l),
                  (m = h * h * h),
                  !(Math.abs(I) < 1e-12));
                  ++O
                );
                const _ =
                    (of * i * (Yl + 3 * Vd * h + m * (7 * hh + 9 * jd * h))) /
                    Math.cos(l),
                  x = Math.asin(Math.sin(l) / of),
                  E = tn((180 * _) / Math.PI, -180, 180),
                  T = tn((180 * x) / Math.PI, -Si, Si);
                return new Ln(E, T);
              }
            }
            class a0 extends Kl {
              constructor(i) {
                super(i), (this.wrap = !0), (this.supportsWorldCopies = !0);
              }
              project(i, o) {
                return { x: 0.5 + i / 360, y: 0.5 - o / 360, z: 0 };
              }
              unproject(i, o) {
                const l = 360 * (i - 0.5),
                  h = tn(360 * (0.5 - o), -Si, Si);
                return new Ln(l, h);
              }
            }
            const dh = Math.PI / 2;
            function Ud(r) {
              return Math.tan((dh + r) / 2);
            }
            class l0 extends Kl {
              constructor(i) {
                super(i), (this.center = i.center || [0, 30]);
                const [o, l] = (this.parallels = i.parallels || [30, 30]);
                let h = Qt(o),
                  m = Qt(l);
                (this.southernCenter = h + m < 0),
                  this.southernCenter && ((h = -h), (m = -m));
                const _ = Math.cos(h),
                  x = Ud(h);
                (this.n =
                  h === m
                    ? Math.sin(h)
                    : Math.log(_ / Math.cos(m)) / Math.log(Ud(m) / x)),
                  (this.f = (_ * Math.pow(Ud(h), this.n)) / this.n);
              }
              project(i, o) {
                (o = Qt(o)),
                  this.southernCenter && (o = -o),
                  (i = Qt(i - this.center[0]));
                const l = 1e-6,
                  { n: h, f: m } = this;
                m > 0
                  ? o < -dh + l && (o = -dh + l)
                  : o > dh - l && (o = dh - l);
                const _ = m / Math.pow(Ud(o), h);
                let x = _ * Math.sin(h * i),
                  E = m - _ * Math.cos(h * i);
                return (
                  (x = 0.5 * (x / Math.PI + 0.5)),
                  (E = 0.5 * (E / Math.PI + 0.5)),
                  { x, y: this.southernCenter ? E : 1 - E, z: 0 }
                );
              }
              unproject(i, o) {
                (i = (2 * i - 0.5) * Math.PI),
                  this.southernCenter && (o = 1 - o),
                  (o = (2 * (1 - o) - 0.5) * Math.PI);
                const { n: l, f: h } = this,
                  m = h - o,
                  _ = Math.sign(m),
                  x = Math.sign(l) * Math.sqrt(i * i + m * m);
                let E = Math.atan2(i, Math.abs(m)) * _;
                m * l < 0 && (E -= Math.PI * Math.sign(i) * _);
                const T = tn(zi(E / l) + this.center[0], -180, 180),
                  I = tn(
                    zi(2 * Math.atan(Math.pow(h / x, 1 / l)) - dh),
                    -Si,
                    Si
                  );
                return new Ln(T, this.southernCenter ? -I : I);
              }
            }
            class Ym extends Kl {
              constructor(i) {
                super(i),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0),
                  (this.supportsTerrain = !0),
                  (this.supportsFog = !0),
                  (this.supportsFreeCamera = !0),
                  (this.isReprojectedInTileSpace = !1),
                  (this.unsupportedLayers = []),
                  (this.range = null);
              }
              project(i, o) {
                return { x: ua(i), y: ai(o), z: 0 };
              }
              unproject(i, o) {
                const l = ao(i),
                  h = qi(o);
                return new Ln(l, h);
              }
            }
            const Qm = Qt(Si);
            class Jm extends Kl {
              project(i, o) {
                const l = (o = Qt(o)) * o,
                  h = l * l;
                return {
                  x:
                    0.5 *
                    (((i = Qt(i)) *
                      (0.8707 -
                        0.131979 * l +
                        h * (h * (0.003971 * l - 0.001529 * h) - 0.013791))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((o *
                        (1.007226 +
                          l *
                            (0.015085 +
                              h * (0.028874 * l - 0.044475 - 0.005916 * h)))) /
                        Math.PI +
                        1),
                  z: 0,
                };
              }
              unproject(i, o) {
                i = (2 * i - 0.5) * Math.PI;
                let l = (o = (2 * (1 - o) - 1) * Math.PI),
                  h = 25,
                  m = 0,
                  _ = l * l;
                do {
                  _ = l * l;
                  const T = _ * _;
                  (m =
                    (l *
                      (1.007226 +
                        _ *
                          (0.015085 +
                            T * (0.028874 * _ - 0.044475 - 0.005916 * T))) -
                      o) /
                    (1.007226 +
                      _ *
                        (0.045255 +
                          T * (0.259866 * _ - 0.311325 - 0.005916 * 11 * T)))),
                    (l = tn(l - m, -Qm, Qm));
                } while (Math.abs(m) > 1e-6 && --h > 0);
                _ = l * l;
                const x = tn(
                    zi(
                      i /
                        (0.8707 +
                          _ *
                            (_ *
                              (_ * _ * _ * (0.003971 - 0.001529 * _) -
                                0.013791) -
                              0.131979))
                    ),
                    -180,
                    180
                  ),
                  E = zi(l);
                return new Ln(x, E);
              }
            }
            const c0 = Qt(Si);
            class eg extends Kl {
              project(i, o) {
                (o = Qt(o)), (i = Qt(i));
                const l = Math.cos(o),
                  h = 2 / Math.PI,
                  m = Math.acos(l * Math.cos(i / 2)),
                  _ = Math.sin(m) / m,
                  x = 0.5 * (i * h + (2 * l * Math.sin(i / 2)) / _) || 0,
                  E = 0.5 * (o + Math.sin(o) / _) || 0;
                return {
                  x: 0.5 * (x / Math.PI + 0.5),
                  y: 1 - 0.5 * (E / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(i, o) {
                let l = (i = (2 * i - 0.5) * Math.PI),
                  h = (o = (2 * (1 - o) - 1) * Math.PI),
                  m = 25;
                const _ = 1e-6;
                let x = 0,
                  E = 0;
                do {
                  const T = Math.cos(h),
                    I = Math.sin(h),
                    A = 2 * I * T,
                    L = I * I,
                    O = T * T,
                    F = Math.cos(l / 2),
                    V = Math.sin(l / 2),
                    G = 2 * F * V,
                    K = V * V,
                    oe = 1 - O * F * F,
                    J = oe ? 1 / oe : 0,
                    re = oe ? Math.acos(T * F) * Math.sqrt(1 / oe) : 0,
                    le = 0.5 * (2 * re * T * V + (2 * l) / Math.PI) - i,
                    ae = 0.5 * (re * I + h) - o,
                    De = 0.5 * J * (O * K + re * T * F * L) + 1 / Math.PI,
                    xe = J * ((G * A) / 4 - re * I * V),
                    Pe = 0.125 * J * (A * V - re * I * O * G),
                    $e = 0.5 * J * (L * F + re * K * T) + 0.5,
                    Ie = xe * Pe - $e * De;
                  (x = (ae * xe - le * $e) / Ie),
                    (E = (le * Pe - ae * De) / Ie),
                    (l = tn(l - x, -Math.PI, Math.PI)),
                    (h = tn(h - E, -c0, c0));
                } while ((Math.abs(x) > _ || Math.abs(E) > _) && --m > 0);
                return new Ln(zi(l), zi(h));
              }
            }
            class ny extends Kl {
              constructor(i) {
                super(i),
                  (this.center = i.center || [0, 0]),
                  (this.parallels = i.parallels || [0, 0]),
                  (this.cosPhi = Math.max(
                    0.01,
                    Math.cos(Qt(this.parallels[0]))
                  )),
                  (this.scale =
                    1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi))),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0);
              }
              project(i, o) {
                const { scale: l, cosPhi: h } = this;
                return {
                  x: Qt(i) * h * l + 0.5,
                  y: (-Math.sin(Qt(o)) / h) * l + 0.5,
                  z: 0,
                };
              }
              unproject(i, o) {
                const { scale: l, cosPhi: h } = this,
                  m = -(o - 0.5) / l,
                  _ = tn(zi((i - 0.5) / l) / h, -180, 180),
                  x = Math.asin(tn(m * h, -1, 1)),
                  E = tn(zi(x), -Si, Si);
                return new Ln(_, E);
              }
            }
            class Pb extends Ym {
              constructor(i) {
                super(i),
                  (this.requiresDraping = !0),
                  (this.supportsWorldCopies = !1),
                  (this.supportsFog = !0),
                  (this.zAxisUnit = "pixels"),
                  (this.unsupportedLayers = ["debug"]),
                  (this.range = [3, 5]);
              }
              projectTilePoint(i, o, l) {
                const h = hd(i, o, l);
                return Jn(h, h, Wu(Qo(l))), { x: h[0], y: h[1], z: h[2] };
              }
              locationPoint(i, o) {
                const l = ud(o.lat, o.lng),
                  h = Mt([], l),
                  m = i.elevation
                    ? i.elevation.getAtPointOrZero(
                        i.locationCoordinate(o),
                        i._centerAltitude
                      )
                    : i._centerAltitude;
                rd(l, l, h, Ao(1, 0) * wt * m);
                const _ = sa(new Float64Array(16));
                return (
                  Rc(_, i.pixelMatrix, i.globeMatrix),
                  Jn(l, l, _),
                  new nt(l[0], l[1])
                );
              }
              pixelsPerMeter(i, o) {
                return Ao(1, 0) * o;
              }
              pixelSpaceConversion(i, o, l) {
                const h = Ao(1, i) * o,
                  m = ln(Ao(1, 45) * o, h, l);
                return this.pixelsPerMeter(i, o) / m;
              }
              createTileMatrix(i, o, l) {
                const h = Lp(Qo(l.canonical));
                return Rc(new Float64Array(16), i.globeMatrix, h);
              }
              createInversionMatrix(i, o) {
                const { center: l } = i,
                  h = Wu(Qo(o));
                return (
                  Cp(h, h, Qt(l.lng)),
                  Wf(h, h, Qt(l.lat)),
                  Oc(h, h, [
                    i._pixelsPerMercatorPixel,
                    i._pixelsPerMercatorPixel,
                    1,
                  ]),
                  Float32Array.from(h)
                );
              }
              pointCoordinate(i, o, l, h) {
                return bv(i, o, l, !0) || new Zu(0, 0);
              }
              pointCoordinate3D(i, o, l) {
                const h = this.pointCoordinate(i, o, l, 0);
                return [h.x, h.y, h.z];
              }
              isPointAboveHorizon(i, o) {
                return !bv(i, o.x, o.y, !1);
              }
              farthestPixelDistance(i) {
                const o = (function (h, m) {
                    const _ = h.cameraToCenterDistance,
                      x = h._centerAltitude * m,
                      E = h._camera,
                      T = h._camera.forward(),
                      I = Ya([], ur([], T, -_), [0, 0, x]),
                      A = h.worldSize / (2 * Math.PI),
                      L = [0, 0, -A],
                      O = h.width / h.height,
                      F = Math.tan(h.fovAboveCenter),
                      V = ur([], E.up(), F),
                      G = ur([], E.right(), F * O),
                      K = Mt([], Ya([], Ya([], T, V), G)),
                      oe = [];
                    let J;
                    if (new Jf(I, K).closestPointOnSphere(L, A, oe)) {
                      const re = Ya([], oe, L),
                        le = _s([], re, I);
                      J = Math.cos(h.fovAboveCenter) * Fc(le);
                    } else {
                      const re = _s([], I, L),
                        le = _s([], L, I);
                      Mt(le, le);
                      const ae = Fc(re) - A;
                      J = Math.sqrt(ae * (ae + 2 * A));
                      const De = Math.acos(J / (A + ae)) - Math.acos(Io(T, le));
                      J *= Math.cos(De);
                    }
                    return 1.01 * J;
                  })(i, this.pixelsPerMeter(i.center.lat, i.worldSize)),
                  l = Ji(i.zoom);
                if (l > 0) {
                  const h = o0(i, Ao(1, i.center.lat) * i.worldSize),
                    m = i.worldSize / (2 * Math.PI),
                    _ = (Math.max(i.width, i.height) / i.worldSize) * Math.PI;
                  return ln(o, h + m * (1 - Math.cos(_)), Math.pow(l, 10));
                }
                return o;
              }
              upVector(i, o, l) {
                return hd(o, l, i, 1);
              }
              upVectorScale(i) {
                return { metersToTile: ld(dd(Qo(i))) };
              }
            }
            function Ot(r) {
              const i = r.parallels,
                o = !!i && Math.abs(i[0] + i[1]) < 0.01;
              switch (r.name) {
                case "mercator":
                  return new Ym(r);
                case "equirectangular":
                  return new a0(r);
                case "naturalEarth":
                  return new Jm(r);
                case "equalEarth":
                  return new s0(r);
                case "winkelTripel":
                  return new eg(r);
                case "albers":
                  return o ? new ny(r) : new ty(r);
                case "lambertConformalConic":
                  return o ? new ny(r) : new l0(r);
                case "globe":
                  return new Pb(r);
              }
              throw new Error(`Invalid projection name: ${r.name}`);
            }
            const u0 = Dd.types,
              iy = [
                {
                  name: "a_fade_opacity",
                  components: 1,
                  type: "Uint8",
                  offset: 0,
                },
              ];
            function Wc(r, i, o, l, h, m, _, x, E, T, I, A, L) {
              const O = x ? Math.min(Xl, Math.round(x[0])) : 0,
                F = x ? Math.min(Xl, Math.round(x[1])) : 0;
              r.emplaceBack(
                i,
                o,
                Math.round(32 * l),
                Math.round(32 * h),
                m,
                _,
                (O << 1) + (E ? 1 : 0),
                F,
                16 * T,
                16 * I,
                256 * A,
                256 * L
              );
            }
            function lo(r, i, o, l, h, m, _) {
              r.emplaceBack(i, o, l, h, m, _);
            }
            function $d(r, i, o, l, h) {
              r.emplaceBack(i, o, l, h),
                r.emplaceBack(i, o, l, h),
                r.emplaceBack(i, o, l, h),
                r.emplaceBack(i, o, l, h);
            }
            function h0(r) {
              for (const i of r.sections) if (xp(i.text)) return !0;
              return !1;
            }
            class Hd {
              constructor(i) {
                (this.layoutVertexArray = new Ne()),
                  (this.indexArray = new _t()),
                  (this.programConfigurations = i),
                  (this.segments = new xi()),
                  (this.dynamicLayoutVertexArray = new je()),
                  (this.opacityVertexArray = new mt()),
                  (this.placedSymbolArray = new si()),
                  (this.globeExtVertexArray = new Xe());
              }
              isEmpty() {
                return (
                  0 === this.layoutVertexArray.length &&
                  0 === this.indexArray.length &&
                  0 === this.dynamicLayoutVertexArray.length &&
                  0 === this.opacityVertexArray.length
                );
              }
              upload(i, o, l, h) {
                this.isEmpty() ||
                  (l &&
                    ((this.layoutVertexBuffer = i.createVertexBuffer(
                      this.layoutVertexArray,
                      P_.members
                    )),
                    (this.indexBuffer = i.createIndexBuffer(
                      this.indexArray,
                      o
                    )),
                    (this.dynamicLayoutVertexBuffer = i.createVertexBuffer(
                      this.dynamicLayoutVertexArray,
                      Ib.members,
                      !0
                    )),
                    (this.opacityVertexBuffer = i.createVertexBuffer(
                      this.opacityVertexArray,
                      iy,
                      !0
                    )),
                    this.globeExtVertexArray.length > 0 &&
                      (this.globeExtVertexBuffer = i.createVertexBuffer(
                        this.globeExtVertexArray,
                        Pm.members,
                        !0
                      )),
                    (this.opacityVertexBuffer.itemSize = 1)),
                  (l || h) && this.programConfigurations.upload(i));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.dynamicLayoutVertexBuffer.destroy(),
                  this.opacityVertexBuffer.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy());
              }
            }
            lt(Hd, "SymbolBuffers");
            class bs {
              constructor(i, o, l) {
                (this.layoutVertexArray = new i()),
                  (this.layoutAttributes = o),
                  (this.indexArray = new l()),
                  (this.segments = new xi()),
                  (this.collisionVertexArray = new Kt()),
                  (this.collisionVertexArrayExt = new Ht());
              }
              upload(i) {
                (this.layoutVertexBuffer = i.createVertexBuffer(
                  this.layoutVertexArray,
                  this.layoutAttributes
                )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  (this.collisionVertexBuffer = i.createVertexBuffer(
                    this.collisionVertexArray,
                    $v.members,
                    !0
                  )),
                  (this.collisionVertexBufferExt = i.createVertexBuffer(
                    this.collisionVertexArrayExt,
                    Lm.members,
                    !0
                  ));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy(),
                  this.collisionVertexBuffer.destroy(),
                  this.collisionVertexBufferExt.destroy());
              }
            }
            lt(bs, "CollisionBuffers");
            class fa {
              constructor(i) {
                (this.collisionBoxArray = i.collisionBoxArray),
                  (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((_) => _.id)),
                  (this.index = i.index),
                  (this.pixelRatio = i.pixelRatio),
                  (this.sourceLayerIndex = i.sourceLayerIndex),
                  (this.hasPattern = !1),
                  (this.hasRTLText = !1),
                  (this.fullyClipped = !1),
                  (this.sortKeyRanges = []),
                  (this.collisionCircleArray = []),
                  (this.placementInvProjMatrix = sa([])),
                  (this.placementViewportMatrix = sa([]));
                const o = this.layers[0]._unevaluatedLayout._values;
                (this.textSizeData = Pd(this.zoom, o["text-size"])),
                  (this.iconSizeData = Pd(this.zoom, o["icon-size"]));
                const l = this.layers[0].layout,
                  h = l.get("symbol-sort-key"),
                  m = l.get("symbol-z-order");
                (this.canOverlap =
                  l.get("text-allow-overlap") ||
                  l.get("icon-allow-overlap") ||
                  l.get("text-ignore-placement") ||
                  l.get("icon-ignore-placement")),
                  (this.sortFeaturesByKey =
                    "viewport-y" !== m && void 0 !== h.constantOr(1)),
                  (this.sortFeaturesByY =
                    ("viewport-y" === m ||
                      ("auto" === m && !this.sortFeaturesByKey)) &&
                    this.canOverlap),
                  (this.writingModes = l
                    .get("text-writing-mode")
                    .map((_) => Po[_])),
                  (this.stateDependentLayerIds = this.layers
                    .filter((_) => _.isStateDependent())
                    .map((_) => _.id)),
                  (this.sourceID = i.sourceID),
                  (this.projection = i.projection);
              }
              createArrays() {
                (this.text = new Hd(
                  new gs(this.layers, this.zoom, (i) => /^text/.test(i))
                )),
                  (this.icon = new Hd(
                    new gs(this.layers, this.zoom, (i) => /^icon/.test(i))
                  )),
                  (this.glyphOffsetArray = new Gi()),
                  (this.lineVertexArray = new zu()),
                  (this.symbolInstances = new Fn());
              }
              calculateGlyphDependencies(i, o, l, h, m) {
                for (let _ = 0; _ < i.length; _++)
                  if (((o[i.charCodeAt(_)] = !0), h && m)) {
                    const x = da[i.charAt(_)];
                    x && (o[x.charCodeAt(0)] = !0);
                  }
              }
              populate(i, o, l, h) {
                const m = this.layers[0],
                  _ = m.layout,
                  x = "globe" === this.projection.name,
                  E = _.get("text-font"),
                  T = _.get("text-field"),
                  I = _.get("icon-image"),
                  A =
                    ("constant" !== T.value.kind ||
                      (T.value.value instanceof Rr &&
                        !T.value.value.isEmpty()) ||
                      T.value.value.toString().length > 0) &&
                    ("constant" !== E.value.kind || E.value.value.length > 0),
                  L =
                    "constant" !== I.value.kind ||
                    !!I.value.value ||
                    Object.keys(I.parameters).length > 0,
                  O = _.get("symbol-sort-key");
                if (((this.features = []), !A && !L)) return;
                const F = o.iconDependencies,
                  V = o.glyphDependencies,
                  G = o.availableImages,
                  K = new M(this.zoom);
                for (const {
                  feature: oe,
                  id: J,
                  index: re,
                  sourceLayerIndex: le,
                } of i) {
                  const ae = m._featureFilter.needGeometry,
                    De = tl(oe, ae);
                  if (!m._featureFilter.filter(K, De, l)) continue;
                  if (
                    (ae || (De.geometry = el(oe, l, h)),
                    x && 1 !== oe.type && l.z <= 5)
                  ) {
                    const Ie = De.geometry,
                      Fe = 0.98078528056,
                      Re = (Ve, qe) =>
                        Io(hd(Ve.x, Ve.y, l, 1), hd(qe.x, qe.y, l, 1)) < Fe;
                    for (let Ve = 0; Ve < Ie.length; Ve++)
                      Ie[Ve] = e_(Ie[Ve], Re);
                  }
                  let xe, Pe;
                  if (A) {
                    const Ie = m.getValueAndResolveTokens(
                        "text-field",
                        De,
                        l,
                        G
                      ),
                      Fe = Rr.factory(Ie);
                    h0(Fe) && (this.hasRTLText = !0),
                      (!this.hasRTLText ||
                        "unavailable" === b() ||
                        (this.hasRTLText && S.isParsed())) &&
                        (xe = Qp(Fe, m, De));
                  }
                  if (L) {
                    const Ie = m.getValueAndResolveTokens(
                      "icon-image",
                      De,
                      l,
                      G
                    );
                    Pe = Ie instanceof _o ? Ie : _o.fromString(Ie);
                  }
                  if (!xe && !Pe) continue;
                  const $e = this.sortFeaturesByKey
                    ? O.evaluate(De, {}, l)
                    : void 0;
                  if (
                    (this.features.push({
                      id: J,
                      text: xe,
                      icon: Pe,
                      index: re,
                      sourceLayerIndex: le,
                      geometry: De.geometry,
                      properties: oe.properties,
                      type: u0[oe.type],
                      sortKey: $e,
                    }),
                    Pe && (F[Pe.name] = !0),
                    xe)
                  ) {
                    const Ie = E.evaluate(De, {}, l).join(","),
                      Fe =
                        "map" === _.get("text-rotation-alignment") &&
                        "point" !== _.get("symbol-placement");
                    this.allowVerticalPlacement =
                      this.writingModes &&
                      this.writingModes.indexOf(Po.vertical) >= 0;
                    for (const Re of xe.sections)
                      if (Re.image) F[Re.image.name] = !0;
                      else {
                        const Ve = Qh(xe.toString()),
                          qe = Re.fontStack || Ie,
                          Me = (V[qe] = V[qe] || {});
                        this.calculateGlyphDependencies(
                          Re.text,
                          Me,
                          Fe,
                          this.allowVerticalPlacement,
                          Ve
                        );
                      }
                  }
                }
                "line" === _.get("symbol-placement") &&
                  (this.features = (function (oe) {
                    const J = {},
                      re = {},
                      le = [];
                    let ae = 0;
                    function De(Ie) {
                      le.push(oe[Ie]), ae++;
                    }
                    function xe(Ie, Fe, Re) {
                      const Ve = re[Ie];
                      return (
                        delete re[Ie],
                        (re[Fe] = Ve),
                        le[Ve].geometry[0].pop(),
                        (le[Ve].geometry[0] = le[Ve].geometry[0].concat(Re[0])),
                        Ve
                      );
                    }
                    function Pe(Ie, Fe, Re) {
                      const Ve = J[Fe];
                      return (
                        delete J[Fe],
                        (J[Ie] = Ve),
                        le[Ve].geometry[0].shift(),
                        (le[Ve].geometry[0] = Re[0].concat(le[Ve].geometry[0])),
                        Ve
                      );
                    }
                    function $e(Ie, Fe, Re) {
                      const Ve = Re ? Fe[0][Fe[0].length - 1] : Fe[0][0];
                      return `${Ie}:${Ve.x}:${Ve.y}`;
                    }
                    for (let Ie = 0; Ie < oe.length; Ie++) {
                      const Fe = oe[Ie],
                        Re = Fe.geometry,
                        Ve = Fe.text ? Fe.text.toString() : null;
                      if (!Ve) {
                        De(Ie);
                        continue;
                      }
                      const qe = $e(Ve, Re),
                        Me = $e(Ve, Re, !0);
                      if (qe in re && Me in J && re[qe] !== J[Me]) {
                        const tt = Pe(qe, Me, Re),
                          pt = xe(qe, Me, le[tt].geometry);
                        delete J[qe],
                          delete re[Me],
                          (re[$e(Ve, le[pt].geometry, !0)] = pt),
                          (le[tt].geometry = null);
                      } else
                        qe in re
                          ? xe(qe, Me, Re)
                          : Me in J
                          ? Pe(qe, Me, Re)
                          : (De(Ie), (J[qe] = ae - 1), (re[Me] = ae - 1));
                    }
                    return le.filter((Ie) => Ie.geometry);
                  })(this.features)),
                  this.sortFeaturesByKey &&
                    this.features.sort((oe, J) => oe.sortKey - J.sortKey);
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  (this.text.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.layers,
                    l,
                    h
                  ),
                  this.icon.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.layers,
                    l,
                    h
                  ));
              }
              isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.text.programConfigurations.needsUpload ||
                  this.icon.programConfigurations.needsUpload
                );
              }
              upload(i) {
                !this.uploaded &&
                  this.hasDebugData() &&
                  (this.textCollisionBox.upload(i),
                  this.iconCollisionBox.upload(i)),
                  this.text.upload(
                    i,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.text.programConfigurations.needsUpload
                  ),
                  this.icon.upload(
                    i,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.icon.programConfigurations.needsUpload
                  ),
                  (this.uploaded = !0);
              }
              destroyDebugData() {
                this.textCollisionBox.destroy(),
                  this.iconCollisionBox.destroy();
              }
              getProjection() {
                return (
                  this.projectionInstance ||
                    (this.projectionInstance = Ot(this.projection)),
                  this.projectionInstance
                );
              }
              destroy() {
                this.text.destroy(),
                  this.icon.destroy(),
                  this.hasDebugData() && this.destroyDebugData();
              }
              addToLineVertexArray(i, o) {
                const l = this.lineVertexArray.length;
                if (void 0 !== i.segment)
                  for (const { x: h, y: m } of o)
                    this.lineVertexArray.emplaceBack(h, m);
                return {
                  lineStartIndex: l,
                  lineLength: this.lineVertexArray.length - l,
                };
              }
              addSymbols(i, o, l, h, m, _, x, E, T, I, A, L, O, F) {
                const V = i.indexArray,
                  G = i.layoutVertexArray,
                  K = i.globeExtVertexArray,
                  oe = i.segments.prepareSegment(
                    4 * o.length,
                    G,
                    V,
                    this.canOverlap ? _.sortKey : void 0
                  ),
                  J = this.glyphOffsetArray.length,
                  re = oe.vertexLength,
                  le =
                    this.allowVerticalPlacement && x === Po.vertical
                      ? Math.PI / 2
                      : 0,
                  ae = _.text && _.text.sections;
                for (let xe = 0; xe < o.length; xe++) {
                  const {
                      tl: Pe,
                      tr: $e,
                      bl: Ie,
                      br: Fe,
                      tex: Re,
                      pixelOffsetTL: Ve,
                      pixelOffsetBR: qe,
                      minFontScaleX: Me,
                      minFontScaleY: tt,
                      glyphOffset: pt,
                      isSDF: rt,
                      sectionIndex: Lt,
                    } = o[xe],
                    Ke = oe.vertexLength,
                    bt = pt[1];
                  if (
                    (Wc(
                      G,
                      T.x,
                      T.y,
                      Pe.x,
                      bt + Pe.y,
                      Re.x,
                      Re.y,
                      l,
                      rt,
                      Ve.x,
                      Ve.y,
                      Me,
                      tt
                    ),
                    Wc(
                      G,
                      T.x,
                      T.y,
                      $e.x,
                      bt + $e.y,
                      Re.x + Re.w,
                      Re.y,
                      l,
                      rt,
                      qe.x,
                      Ve.y,
                      Me,
                      tt
                    ),
                    Wc(
                      G,
                      T.x,
                      T.y,
                      Ie.x,
                      bt + Ie.y,
                      Re.x,
                      Re.y + Re.h,
                      l,
                      rt,
                      Ve.x,
                      qe.y,
                      Me,
                      tt
                    ),
                    Wc(
                      G,
                      T.x,
                      T.y,
                      Fe.x,
                      bt + Fe.y,
                      Re.x + Re.w,
                      Re.y + Re.h,
                      l,
                      rt,
                      qe.x,
                      qe.y,
                      Me,
                      tt
                    ),
                    E)
                  ) {
                    const { x: Pt, y: Yt, z: At } = E.anchor,
                      [Et, In, Nt] = E.up;
                    lo(K, Pt, Yt, At, Et, In, Nt),
                      lo(K, Pt, Yt, At, Et, In, Nt),
                      lo(K, Pt, Yt, At, Et, In, Nt),
                      lo(K, Pt, Yt, At, Et, In, Nt),
                      $d(i.dynamicLayoutVertexArray, Pt, Yt, At, le);
                  } else $d(i.dynamicLayoutVertexArray, T.x, T.y, T.z, le);
                  V.emplaceBack(Ke, Ke + 1, Ke + 2),
                    V.emplaceBack(Ke + 1, Ke + 2, Ke + 3),
                    (oe.vertexLength += 4),
                    (oe.primitiveLength += 2),
                    this.glyphOffsetArray.emplaceBack(pt[0]),
                    (xe !== o.length - 1 && Lt === o[xe + 1].sectionIndex) ||
                      i.programConfigurations.populatePaintArrays(
                        G.length,
                        _,
                        _.index,
                        {},
                        O,
                        F,
                        ae && ae[Lt]
                      );
                }
                const De = E ? E.anchor : T;
                i.placedSymbolArray.emplaceBack(
                  De.x,
                  De.y,
                  De.z,
                  T.x,
                  T.y,
                  J,
                  this.glyphOffsetArray.length - J,
                  re,
                  I,
                  A,
                  T.segment,
                  l ? l[0] : 0,
                  l ? l[1] : 0,
                  h[0],
                  h[1],
                  x,
                  0,
                  !1,
                  0,
                  L,
                  0
                );
              }
              _commitLayoutVertex(i, o, l, h, m, _, x) {
                i.emplaceBack(o, l, h, m, _, Math.round(x.x), Math.round(x.y));
              }
              _addCollisionDebugVertices(i, o, l, h, m, _, x) {
                const E = l.segments.prepareSegment(
                    4,
                    l.layoutVertexArray,
                    l.indexArray
                  ),
                  T = E.vertexLength,
                  I = x.tileAnchorX,
                  A = x.tileAnchorY;
                for (let O = 0; O < 4; O++)
                  l.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                l.collisionVertexArrayExt.emplaceBack(
                  o,
                  -i.padding,
                  -i.padding
                ),
                  l.collisionVertexArrayExt.emplaceBack(
                    o,
                    i.padding,
                    -i.padding
                  ),
                  l.collisionVertexArrayExt.emplaceBack(
                    o,
                    i.padding,
                    i.padding
                  ),
                  l.collisionVertexArrayExt.emplaceBack(
                    o,
                    -i.padding,
                    i.padding
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    I,
                    A,
                    new nt(i.x1, i.y1)
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    I,
                    A,
                    new nt(i.x2, i.y1)
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    I,
                    A,
                    new nt(i.x2, i.y2)
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    I,
                    A,
                    new nt(i.x1, i.y2)
                  ),
                  (E.vertexLength += 4);
                const L = l.indexArray;
                L.emplaceBack(T, T + 1),
                  L.emplaceBack(T + 1, T + 2),
                  L.emplaceBack(T + 2, T + 3),
                  L.emplaceBack(T + 3, T),
                  (E.primitiveLength += 4);
              }
              _addTextDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceTextSize(i, _, o, x);
                  this._addCollisionDebugVertices(
                    E,
                    T,
                    this.textCollisionBox,
                    E.projectedAnchorX,
                    E.projectedAnchorY,
                    E.projectedAnchorZ,
                    _
                  );
                }
              }
              _addIconDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceIconSize(
                      i,
                      o,
                      _.placedIconSymbolIndex
                    );
                  this._addCollisionDebugVertices(
                    E,
                    T,
                    this.iconCollisionBox,
                    E.projectedAnchorX,
                    E.projectedAnchorY,
                    E.projectedAnchorZ,
                    _
                  );
                }
              }
              generateCollisionDebugBuffers(i, o) {
                this.hasDebugData() && this.destroyDebugData(),
                  (this.textCollisionBox = new bs(dt, km.members, vi)),
                  (this.iconCollisionBox = new bs(dt, km.members, vi));
                const l = nh(this.iconSizeData, i),
                  h = nh(this.textSizeData, i);
                for (let m = 0; m < this.symbolInstances.length; m++) {
                  const _ = this.symbolInstances.get(m);
                  this._addTextDebugCollisionBoxes(
                    h,
                    i,
                    o,
                    _.textBoxStartIndex,
                    _.textBoxEndIndex,
                    _
                  ),
                    this._addTextDebugCollisionBoxes(
                      h,
                      i,
                      o,
                      _.verticalTextBoxStartIndex,
                      _.verticalTextBoxEndIndex,
                      _
                    ),
                    this._addIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.iconBoxStartIndex,
                      _.iconBoxEndIndex,
                      _
                    ),
                    this._addIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.verticalIconBoxStartIndex,
                      _.verticalIconBoxEndIndex,
                      _
                    );
                }
              }
              getSymbolInstanceTextSize(i, o, l, h) {
                const m = this.text.placedSymbolArray.get(
                    o.rightJustifiedTextSymbolIndex >= 0
                      ? o.rightJustifiedTextSymbolIndex
                      : o.centerJustifiedTextSymbolIndex >= 0
                      ? o.centerJustifiedTextSymbolIndex
                      : o.leftJustifiedTextSymbolIndex >= 0
                      ? o.leftJustifiedTextSymbolIndex
                      : o.verticalPlacedTextSymbolIndex >= 0
                      ? o.verticalPlacedTextSymbolIndex
                      : h
                  ),
                  _ = jc(this.textSizeData, i, m) / 24;
                return this.tilePixelRatio * _;
              }
              getSymbolInstanceIconSize(i, o, l) {
                const h = this.icon.placedSymbolArray.get(l),
                  m = jc(this.iconSizeData, i, h);
                return this.tilePixelRatio * m;
              }
              _commitDebugCollisionVertexUpdate(i, o, l) {
                i.emplaceBack(o, -l, -l),
                  i.emplaceBack(o, l, -l),
                  i.emplaceBack(o, l, l),
                  i.emplaceBack(o, -l, l);
              }
              _updateTextDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceTextSize(i, _, o, x);
                  this._commitDebugCollisionVertexUpdate(
                    this.textCollisionBox.collisionVertexArrayExt,
                    T,
                    E.padding
                  );
                }
              }
              _updateIconDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceIconSize(i, o, _);
                  this._commitDebugCollisionVertexUpdate(
                    this.iconCollisionBox.collisionVertexArrayExt,
                    T,
                    E.padding
                  );
                }
              }
              updateCollisionDebugBuffers(i, o) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexArrayExt.clear(),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexArrayExt.clear();
                const l = nh(this.iconSizeData, i),
                  h = nh(this.textSizeData, i);
                for (let m = 0; m < this.symbolInstances.length; m++) {
                  const _ = this.symbolInstances.get(m);
                  this._updateTextDebugCollisionBoxes(
                    h,
                    i,
                    o,
                    _.textBoxStartIndex,
                    _.textBoxEndIndex,
                    _
                  ),
                    this._updateTextDebugCollisionBoxes(
                      h,
                      i,
                      o,
                      _.verticalTextBoxStartIndex,
                      _.verticalTextBoxEndIndex,
                      _
                    ),
                    this._updateIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.iconBoxStartIndex,
                      _.iconBoxEndIndex,
                      _.placedIconSymbolIndex
                    ),
                    this._updateIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.verticalIconBoxStartIndex,
                      _.verticalIconBoxEndIndex,
                      _.placedIconSymbolIndex
                    );
                }
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexBufferExt &&
                  this.textCollisionBox.collisionVertexBufferExt.updateData(
                    this.textCollisionBox.collisionVertexArrayExt
                  ),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexBufferExt &&
                    this.iconCollisionBox.collisionVertexBufferExt.updateData(
                      this.iconCollisionBox.collisionVertexArrayExt
                    );
              }
              _deserializeCollisionBoxesForSymbol(i, o, l, h, m, _, x, E, T) {
                const I = {};
                if (o < l) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(o);
                  (I.textBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (I.textFeatureIndex = le);
                }
                if (h < m) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(h);
                  (I.verticalTextBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (I.verticalTextFeatureIndex = le);
                }
                if (_ < x) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(_);
                  (I.iconBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (I.iconFeatureIndex = le);
                }
                if (E < T) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(E);
                  (I.verticalIconBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (I.verticalIconFeatureIndex = le);
                }
                return I;
              }
              deserializeCollisionBoxes(i) {
                this.collisionArrays = [];
                for (let o = 0; o < this.symbolInstances.length; o++) {
                  const l = this.symbolInstances.get(o);
                  this.collisionArrays.push(
                    this._deserializeCollisionBoxesForSymbol(
                      i,
                      l.textBoxStartIndex,
                      l.textBoxEndIndex,
                      l.verticalTextBoxStartIndex,
                      l.verticalTextBoxEndIndex,
                      l.iconBoxStartIndex,
                      l.iconBoxEndIndex,
                      l.verticalIconBoxStartIndex,
                      l.verticalIconBoxEndIndex
                    )
                  );
                }
              }
              hasTextData() {
                return this.text.segments.get().length > 0;
              }
              hasIconData() {
                return this.icon.segments.get().length > 0;
              }
              hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
              }
              hasTextCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.textCollisionBox.segments.get().length > 0
                );
              }
              hasIconCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.iconCollisionBox.segments.get().length > 0
                );
              }
              addIndicesForPlacedSymbol(i, o) {
                const l = i.placedSymbolArray.get(o),
                  h = l.vertexStartIndex + 4 * l.numGlyphs;
                for (let m = l.vertexStartIndex; m < h; m += 4)
                  i.indexArray.emplaceBack(m, m + 1, m + 2),
                    i.indexArray.emplaceBack(m + 1, m + 2, m + 3);
              }
              getSortedSymbolIndexes(i) {
                if (
                  this.sortedAngle === i &&
                  void 0 !== this.symbolInstanceIndexes
                )
                  return this.symbolInstanceIndexes;
                const o = Math.sin(i),
                  l = Math.cos(i),
                  h = [],
                  m = [],
                  _ = [];
                for (let x = 0; x < this.symbolInstances.length; ++x) {
                  _.push(x);
                  const E = this.symbolInstances.get(x);
                  h.push(0 | Math.round(o * E.tileAnchorX + l * E.tileAnchorY)),
                    m.push(E.featureIndex);
                }
                return _.sort((x, E) => h[x] - h[E] || m[E] - m[x]), _;
              }
              addToSortKeyRanges(i, o) {
                const l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                l && l.sortKey === o
                  ? (l.symbolInstanceEnd = i + 1)
                  : this.sortKeyRanges.push({
                      sortKey: o,
                      symbolInstanceStart: i,
                      symbolInstanceEnd: i + 1,
                    });
              }
              sortFeatures(i) {
                if (
                  this.sortFeaturesByY &&
                  this.sortedAngle !== i &&
                  !(
                    this.text.segments.get().length > 1 ||
                    this.icon.segments.get().length > 1
                  )
                ) {
                  (this.symbolInstanceIndexes = this.getSortedSymbolIndexes(i)),
                    (this.sortedAngle = i),
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    (this.featureSortOrder = []);
                  for (const o of this.symbolInstanceIndexes) {
                    const l = this.symbolInstances.get(o);
                    this.featureSortOrder.push(l.featureIndex);
                    const {
                      rightJustifiedTextSymbolIndex: h,
                      centerJustifiedTextSymbolIndex: m,
                      leftJustifiedTextSymbolIndex: _,
                      verticalPlacedTextSymbolIndex: x,
                      placedIconSymbolIndex: E,
                      verticalPlacedIconSymbolIndex: T,
                    } = l;
                    h >= 0 && this.addIndicesForPlacedSymbol(this.text, h),
                      m >= 0 &&
                        m !== h &&
                        this.addIndicesForPlacedSymbol(this.text, m),
                      _ >= 0 &&
                        _ !== m &&
                        _ !== h &&
                        this.addIndicesForPlacedSymbol(this.text, _),
                      x >= 0 && this.addIndicesForPlacedSymbol(this.text, x),
                      E >= 0 && this.addIndicesForPlacedSymbol(this.icon, E),
                      T >= 0 && this.addIndicesForPlacedSymbol(this.icon, T);
                  }
                  this.text.indexBuffer &&
                    this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer &&
                      this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
              }
            }
            lt(fa, "SymbolBucket", {
              omit: ["layers", "collisionBoxArray", "features", "compareText"],
            }),
              (fa.MAX_GLYPHS = 65535),
              (fa.addDynamicAttributes = $d);
            const ry = new te({
              "symbol-placement": new B(Ae.layout_symbol["symbol-placement"]),
              "symbol-spacing": new B(Ae.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new B(
                Ae.layout_symbol["symbol-avoid-edges"]
              ),
              "symbol-sort-key": new W(Ae.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new B(Ae.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new B(
                Ae.layout_symbol["icon-allow-overlap"]
              ),
              "icon-ignore-placement": new B(
                Ae.layout_symbol["icon-ignore-placement"]
              ),
              "icon-optional": new B(Ae.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new B(
                Ae.layout_symbol["icon-rotation-alignment"]
              ),
              "icon-size": new W(Ae.layout_symbol["icon-size"]),
              "icon-text-fit": new B(Ae.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new B(
                Ae.layout_symbol["icon-text-fit-padding"]
              ),
              "icon-image": new W(Ae.layout_symbol["icon-image"]),
              "icon-rotate": new W(Ae.layout_symbol["icon-rotate"]),
              "icon-padding": new B(Ae.layout_symbol["icon-padding"]),
              "icon-keep-upright": new B(Ae.layout_symbol["icon-keep-upright"]),
              "icon-offset": new W(Ae.layout_symbol["icon-offset"]),
              "icon-anchor": new W(Ae.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new B(
                Ae.layout_symbol["icon-pitch-alignment"]
              ),
              "text-pitch-alignment": new B(
                Ae.layout_symbol["text-pitch-alignment"]
              ),
              "text-rotation-alignment": new B(
                Ae.layout_symbol["text-rotation-alignment"]
              ),
              "text-field": new W(Ae.layout_symbol["text-field"]),
              "text-font": new W(Ae.layout_symbol["text-font"]),
              "text-size": new W(Ae.layout_symbol["text-size"]),
              "text-max-width": new W(Ae.layout_symbol["text-max-width"]),
              "text-line-height": new W(Ae.layout_symbol["text-line-height"]),
              "text-letter-spacing": new W(
                Ae.layout_symbol["text-letter-spacing"]
              ),
              "text-justify": new W(Ae.layout_symbol["text-justify"]),
              "text-radial-offset": new W(
                Ae.layout_symbol["text-radial-offset"]
              ),
              "text-variable-anchor": new B(
                Ae.layout_symbol["text-variable-anchor"]
              ),
              "text-anchor": new W(Ae.layout_symbol["text-anchor"]),
              "text-max-angle": new B(Ae.layout_symbol["text-max-angle"]),
              "text-writing-mode": new B(Ae.layout_symbol["text-writing-mode"]),
              "text-rotate": new W(Ae.layout_symbol["text-rotate"]),
              "text-padding": new B(Ae.layout_symbol["text-padding"]),
              "text-keep-upright": new B(Ae.layout_symbol["text-keep-upright"]),
              "text-transform": new W(Ae.layout_symbol["text-transform"]),
              "text-offset": new W(Ae.layout_symbol["text-offset"]),
              "text-allow-overlap": new B(
                Ae.layout_symbol["text-allow-overlap"]
              ),
              "text-ignore-placement": new B(
                Ae.layout_symbol["text-ignore-placement"]
              ),
              "text-optional": new B(Ae.layout_symbol["text-optional"]),
            });
            var Gd = {
              paint: new te({
                "icon-opacity": new W(Ae.paint_symbol["icon-opacity"]),
                "icon-color": new W(Ae.paint_symbol["icon-color"]),
                "icon-halo-color": new W(Ae.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new W(Ae.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new W(Ae.paint_symbol["icon-halo-blur"]),
                "icon-translate": new B(Ae.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new B(
                  Ae.paint_symbol["icon-translate-anchor"]
                ),
                "text-opacity": new W(Ae.paint_symbol["text-opacity"]),
                "text-color": new W(Ae.paint_symbol["text-color"], {
                  runtimeType: Hr,
                  getOverride: (r) => r.textColor,
                  hasOverride: (r) => !!r.textColor,
                }),
                "text-halo-color": new W(Ae.paint_symbol["text-halo-color"]),
                "text-halo-width": new W(Ae.paint_symbol["text-halo-width"]),
                "text-halo-blur": new W(Ae.paint_symbol["text-halo-blur"]),
                "text-translate": new B(Ae.paint_symbol["text-translate"]),
                "text-translate-anchor": new B(
                  Ae.paint_symbol["text-translate-anchor"]
                ),
              }),
              layout: ry,
            };
            class d0 {
              constructor(i) {
                (this.type = i.property.overrides
                  ? i.property.overrides.runtimeType
                  : Dn),
                  (this.defaultValue = i);
              }
              evaluate(i) {
                if (i.formattedSection) {
                  const o = this.defaultValue.property.overrides;
                  if (o && o.hasOverride(i.formattedSection))
                    return o.getOverride(i.formattedSection);
                }
                return i.feature && i.featureState
                  ? this.defaultValue.evaluate(i.feature, i.featureState)
                  : this.defaultValue.property.specification.default;
              }
              eachChild(i) {
                this.defaultValue.isConstant() ||
                  i(this.defaultValue.value._styleExpression.expression);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return null;
              }
            }
            lt(d0, "FormatSectionOverride", { omit: ["defaultValue"] });
            class qd extends Kr {
              constructor(i) {
                super(i, Gd);
              }
              recalculate(i, o) {
                super.recalculate(i, o),
                  "auto" === this.layout.get("icon-rotation-alignment") &&
                    (this.layout._values["icon-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-rotation-alignment") &&
                    (this.layout._values["text-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-pitch-alignment") &&
                    (this.layout._values["text-pitch-alignment"] =
                      this.layout.get("text-rotation-alignment")),
                  "auto" === this.layout.get("icon-pitch-alignment") &&
                    (this.layout._values["icon-pitch-alignment"] =
                      this.layout.get("icon-rotation-alignment"));
                const l = this.layout.get("text-writing-mode");
                if (l) {
                  const h = [];
                  for (const m of l) h.indexOf(m) < 0 && h.push(m);
                  this.layout._values["text-writing-mode"] = h;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                this._setPaintOverrides();
              }
              getValueAndResolveTokens(i, o, l, h) {
                const m = this.layout.get(i).evaluate(o, {}, l, h),
                  _ = this._unevaluatedLayout._values[i];
                return _.isDataDriven() || Zo(_.value) || !m
                  ? m
                  : ((x = o.properties),
                    m.replace(/{([^{}]+)}/g, (T, I) =>
                      I in x ? String(x[I]) : ""
                    ));
                var x;
              }
              createBucket(i) {
                return new fa(i);
              }
              queryRadius() {
                return 0;
              }
              queryIntersectsFeature() {
                return !1;
              }
              _setPaintOverrides() {
                for (const i of Gd.paint.overridableProperties) {
                  if (!qd.hasPaintOverride(this.layout, i)) continue;
                  const o = this.paint.get(i),
                    l = new d0(o),
                    h = new Mu(l, o.property.specification);
                  let m = null;
                  (m =
                    "constant" === o.value.kind || "source" === o.value.kind
                      ? new $h("source", h)
                      : new Ec(
                          "composite",
                          h,
                          o.value.zoomStops,
                          o.value._interpolationType
                        )),
                    (this.paint._values[i] = new Z(
                      o.property,
                      m,
                      o.parameters
                    ));
                }
              }
              _handleOverridablePaintPropertyUpdate(i, o, l) {
                return (
                  !(!this.layout || o.isDataDriven() || l.isDataDriven()) &&
                  qd.hasPaintOverride(this.layout, i)
                );
              }
              static hasPaintOverride(i, o) {
                const l = i.get("text-field"),
                  h = Gd.paint.properties[o];
                let m = !1;
                const _ = (x) => {
                  for (const E of x)
                    if (h.overrides && h.overrides.hasOverride(E))
                      return void (m = !0);
                };
                if ("constant" === l.value.kind && l.value.value instanceof Rr)
                  _(l.value.value.sections);
                else if ("source" === l.value.kind) {
                  const x = (T) => {
                      m ||
                        (T instanceof Cl && pn(T.value) === _u
                          ? _(T.value.sections)
                          : T instanceof yo
                          ? _(T.sections)
                          : T.eachChild(x));
                    },
                    E = l.value;
                  E._styleExpression && x(E._styleExpression.expression);
                }
                return m;
              }
              getProgramConfiguration(i) {
                return new oa(this, i);
              }
            }
            var Lb = {
                paint: new te({
                  "background-color": new B(
                    Ae.paint_background["background-color"]
                  ),
                  "background-pattern": new B(
                    Ae.paint_background["background-pattern"]
                  ),
                  "background-opacity": new B(
                    Ae.paint_background["background-opacity"]
                  ),
                }),
              },
              sf = {
                paint: new te({
                  "raster-opacity": new B(Ae.paint_raster["raster-opacity"]),
                  "raster-hue-rotate": new B(
                    Ae.paint_raster["raster-hue-rotate"]
                  ),
                  "raster-brightness-min": new B(
                    Ae.paint_raster["raster-brightness-min"]
                  ),
                  "raster-brightness-max": new B(
                    Ae.paint_raster["raster-brightness-max"]
                  ),
                  "raster-saturation": new B(
                    Ae.paint_raster["raster-saturation"]
                  ),
                  "raster-contrast": new B(Ae.paint_raster["raster-contrast"]),
                  "raster-resampling": new B(
                    Ae.paint_raster["raster-resampling"]
                  ),
                  "raster-fade-duration": new B(
                    Ae.paint_raster["raster-fade-duration"]
                  ),
                }),
              };
            class af extends Kr {
              constructor(i) {
                super(i, {}), (this.implementation = i);
              }
              is3D() {
                return "3d" === this.implementation.renderingMode;
              }
              hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
              }
              isLayerDraped() {
                return void 0 !== this.implementation.renderToTile;
              }
              shouldRedrape() {
                return (
                  !!this.implementation.shouldRerenderTiles &&
                  this.implementation.shouldRerenderTiles()
                );
              }
              recalculate() {}
              updateTransitions() {}
              hasTransition() {
                return !1;
              }
              serialize() {}
              onAdd(i) {
                this.implementation.onAdd &&
                  this.implementation.onAdd(i, i.painter.context.gl);
              }
              onRemove(i) {
                this.implementation.onRemove &&
                  this.implementation.onRemove(i, i.painter.context.gl);
              }
            }
            var tg = {
              paint: new te({
                "sky-type": new B(Ae.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new B(Ae.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new B(
                  Ae.paint_sky["sky-atmosphere-sun-intensity"]
                ),
                "sky-gradient-center": new B(
                  Ae.paint_sky["sky-gradient-center"]
                ),
                "sky-gradient-radius": new B(
                  Ae.paint_sky["sky-gradient-radius"]
                ),
                "sky-gradient": new ee(Ae.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new B(
                  Ae.paint_sky["sky-atmosphere-halo-color"]
                ),
                "sky-atmosphere-color": new B(
                  Ae.paint_sky["sky-atmosphere-color"]
                ),
                "sky-opacity": new B(Ae.paint_sky["sky-opacity"]),
              }),
            };
            function Wd(r, i, o) {
              const l = [0, 0, 1],
                h = Qf([]);
              return (
                ad(h, h, o ? -Qt(r) + Math.PI : Qt(r)),
                Hu(h, h, -Qt(i)),
                $u(l, l, h),
                Mt(l, l)
              );
            }
            const ng = {
              circle: class extends Kr {
                constructor(r) {
                  super(r, Mv);
                }
                createBucket(r) {
                  return new Rp(r);
                }
                queryRadius(r) {
                  const i = r;
                  return (
                    Gl("circle-radius", this, i) +
                    Gl("circle-stroke-width", this, i) +
                    Fp(this.paint.get("circle-translate"))
                  );
                }
                queryIntersectsFeature(r, i, o, l, h, m, _, x) {
                  const E = r_(
                      this.paint.get("circle-translate"),
                      this.paint.get("circle-translate-anchor"),
                      m.angle,
                      r.pixelToTileUnitsFactor
                    ),
                    T =
                      this.paint.get("circle-radius").evaluate(i, o) +
                      this.paint.get("circle-stroke-width").evaluate(i, o);
                  return o_(
                    r,
                    l,
                    m,
                    _,
                    x,
                    "map" === this.paint.get("circle-pitch-alignment"),
                    "map" === this.paint.get("circle-pitch-scale"),
                    E,
                    T
                  );
                }
                getProgramIds() {
                  return ["circle"];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
              },
              heatmap: class extends Kr {
                createBucket(r) {
                  return new l_(r);
                }
                constructor(r) {
                  super(r, u_), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(r) {
                  "heatmap-color" === r && this._updateColorRamp();
                }
                _updateColorRamp() {
                  (this.colorRamp = gm({
                    expression:
                      this._transitionablePaint._values["heatmap-color"].value
                        .expression,
                    evaluationKey: "heatmapDensity",
                    image: this.colorRamp,
                  })),
                    (this.colorRampTexture = null);
                }
                resize() {
                  this.heatmapFbo &&
                    (this.heatmapFbo.destroy(), (this.heatmapFbo = null));
                }
                queryRadius(r) {
                  return Gl("heatmap-radius", this, r);
                }
                queryIntersectsFeature(r, i, o, l, h, m, _, x) {
                  const E = this.paint.get("heatmap-radius").evaluate(i, o);
                  return o_(r, l, m, _, x, !0, !0, new nt(0, 0), E);
                }
                hasOffscreenPass() {
                  return (
                    0 !== this.paint.get("heatmap-opacity") &&
                    "none" !== this.visibility
                  );
                }
                getProgramIds() {
                  return ["heatmap", "heatmapTexture"];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
              },
              hillshade: class extends Kr {
                constructor(r) {
                  super(r, bb);
                }
                hasOffscreenPass() {
                  return (
                    0 !== this.paint.get("hillshade-exaggeration") &&
                    "none" !== this.visibility
                  );
                }
                getProgramIds() {
                  return ["hillshade", "hillshadePrepare"];
                }
              },
              fill: class extends Kr {
                constructor(r) {
                  super(r, Rv);
                }
                getProgramIds() {
                  const r = this.paint.get("fill-pattern"),
                    i = r && r.constantOr(1),
                    o = [i ? "fillPattern" : "fill"];
                  return (
                    this.paint.get("fill-antialias") &&
                      o.push(
                        i && !this.getPaintProperty("fill-outline-color")
                          ? "fillOutlinePattern"
                          : "fillOutline"
                      ),
                    o
                  );
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
                recalculate(r, i) {
                  super.recalculate(r, i);
                  const o = this.paint._values["fill-outline-color"];
                  "constant" === o.value.kind &&
                    void 0 === o.value.value &&
                    (this.paint._values["fill-outline-color"] =
                      this.paint._values["fill-color"]);
                }
                createBucket(r) {
                  return new Wp(r);
                }
                queryRadius() {
                  return Fp(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(r, i, o, l, h, m) {
                  return (
                    !r.queryGeometry.isAboveHorizon &&
                    n_(
                      i_(
                        r.tilespaceGeometry,
                        this.paint.get("fill-translate"),
                        this.paint.get("fill-translate-anchor"),
                        m.angle,
                        r.pixelToTileUnitsFactor
                      ),
                      l
                    )
                  );
                }
                isTileClipped() {
                  return !0;
                }
              },
              "fill-extrusion": class extends Kr {
                constructor(r) {
                  super(r, Im);
                }
                createBucket(r) {
                  return new Yp(r);
                }
                queryRadius() {
                  return Fp(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                  return !0;
                }
                getProgramIds() {
                  return [
                    this.paint.get("fill-extrusion-pattern").constantOr(1)
                      ? "fillExtrusionPattern"
                      : "fillExtrusion",
                  ];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
                queryIntersectsFeature(r, i, o, l, h, m, _, x, E) {
                  const T = r_(
                      this.paint.get("fill-extrusion-translate"),
                      this.paint.get("fill-extrusion-translate-anchor"),
                      m.angle,
                      r.pixelToTileUnitsFactor
                    ),
                    I = this.paint.get("fill-extrusion-height").evaluate(i, o),
                    A = this.paint.get("fill-extrusion-base").evaluate(i, o),
                    L = [0, 0],
                    O = x && m.elevation,
                    F = m.elevation ? m.elevation.exaggeration() : 1,
                    V = r.tile.getBucket(this);
                  if (O && V instanceof Yp) {
                    const re = V.centroidVertexArray,
                      le = E + 1;
                    le < re.length &&
                      ((L[0] = re.geta_centroid_pos0(le)),
                      (L[1] = re.geta_centroid_pos1(le)));
                  }
                  if (0 === L[0] && 1 === L[1]) return !1;
                  "globe" === m.projection.name &&
                    (l = Sd(
                      [l],
                      [new nt(0, 0), new nt(wt, wt)],
                      r.tileID.canonical
                    )
                      .map((re) => re.polygon)
                      .flat());
                  const G = O ? x : null,
                    [K, oe] =
                      ((le = l),
                      (ae = A),
                      (De = I),
                      (xe = T),
                      (Pe = _),
                      ($e = G),
                      (Ie = L),
                      (Fe = F),
                      (Re = m.center.lat),
                      "globe" === (re = m).projection.name
                        ? (function (
                            qe,
                            Me,
                            tt,
                            pt,
                            rt,
                            Lt,
                            Ke,
                            bt,
                            Pt,
                            Yt,
                            At
                          ) {
                            const Et = [],
                              In = [],
                              Nt = qe.projection.upVectorScale(
                                At,
                                qe.center.lat,
                                qe.worldSize
                              ).metersToTile,
                              kt = [0, 0, 0, 1],
                              kn = [0, 0, 0, 1],
                              zn = (vn, Kn, ci, wi) => {
                                (vn[0] = Kn),
                                  (vn[1] = ci),
                                  (vn[2] = wi),
                                  (vn[3] = 1);
                              },
                              Bn = Sm();
                            tt > 0 && (tt += Bn), (pt += Bn);
                            for (const vn of Me) {
                              const Kn = [],
                                ci = [];
                              for (const wi of vn) {
                                const Vn = wi.x + rt.x,
                                  Ii = wi.y + rt.y,
                                  Ei = qe.projection.projectTilePoint(
                                    Vn,
                                    Ii,
                                    At
                                  ),
                                  ti = qe.projection.upVector(At, wi.x, wi.y);
                                let dn = tt,
                                  ui = pt;
                                if (Ke) {
                                  const jn = S_(Vn, Ii, tt, pt, Ke, bt, Pt, Yt);
                                  (dn += jn.base), (ui += jn.top);
                                }
                                0 !== tt
                                  ? zn(
                                      kt,
                                      Ei.x + ti[0] * Nt * dn,
                                      Ei.y + ti[1] * Nt * dn,
                                      Ei.z + ti[2] * Nt * dn
                                    )
                                  : zn(kt, Ei.x, Ei.y, Ei.z),
                                  zn(
                                    kn,
                                    Ei.x + ti[0] * Nt * ui,
                                    Ei.y + ti[1] * Nt * ui,
                                    Ei.z + ti[2] * Nt * ui
                                  ),
                                  Jn(kt, kt, Lt),
                                  Jn(kn, kn, Lt),
                                  Kn.push(new Vc(kt[0], kt[1], kt[2])),
                                  ci.push(new Vc(kn[0], kn[1], kn[2]));
                              }
                              Et.push(Kn), In.push(ci);
                            }
                            return [Et, In];
                          })(
                            re,
                            le,
                            ae,
                            De,
                            xe,
                            Pe,
                            $e,
                            Ie,
                            Fe,
                            Re,
                            r.tileID.canonical
                          )
                        : $e
                        ? (function (qe, Me, tt, pt, rt, Lt, Ke, bt, Pt) {
                            const Yt = [],
                              At = [],
                              Et = [0, 0, 0, 1];
                            for (const In of qe) {
                              const Nt = [],
                                kt = [];
                              for (const kn of In) {
                                const zn = kn.x + pt.x,
                                  Bn = kn.y + pt.y,
                                  vn = S_(zn, Bn, Me, tt, Lt, Ke, bt, Pt);
                                (Et[0] = zn),
                                  (Et[1] = Bn),
                                  (Et[2] = vn.base),
                                  (Et[3] = 1),
                                  aa(Et, Et, rt),
                                  (Et[3] = Math.max(Et[3], 1e-5));
                                const Kn = new Vc(
                                  Et[0] / Et[3],
                                  Et[1] / Et[3],
                                  Et[2] / Et[3]
                                );
                                (Et[0] = zn),
                                  (Et[1] = Bn),
                                  (Et[2] = vn.top),
                                  (Et[3] = 1),
                                  aa(Et, Et, rt),
                                  (Et[3] = Math.max(Et[3], 1e-5));
                                const ci = new Vc(
                                  Et[0] / Et[3],
                                  Et[1] / Et[3],
                                  Et[2] / Et[3]
                                );
                                Nt.push(Kn), kt.push(ci);
                              }
                              Yt.push(Nt), At.push(kt);
                            }
                            return [Yt, At];
                          })(le, ae, De, xe, Pe, $e, Ie, Fe, Re)
                        : (function (qe, Me, tt, pt, rt) {
                            const Lt = [],
                              Ke = [],
                              bt = rt[8] * Me,
                              Pt = rt[9] * Me,
                              Yt = rt[10] * Me,
                              At = rt[11] * Me,
                              Et = rt[8] * tt,
                              In = rt[9] * tt,
                              Nt = rt[10] * tt,
                              kt = rt[11] * tt;
                            for (const kn of qe) {
                              const zn = [],
                                Bn = [];
                              for (const vn of kn) {
                                const Kn = vn.x + pt.x,
                                  ci = vn.y + pt.y,
                                  wi = rt[0] * Kn + rt[4] * ci + rt[12],
                                  Vn = rt[1] * Kn + rt[5] * ci + rt[13],
                                  Ii = rt[2] * Kn + rt[6] * ci + rt[14],
                                  Ei = rt[3] * Kn + rt[7] * ci + rt[15],
                                  ti = wi + bt,
                                  dn = Vn + Pt,
                                  ui = Ii + Yt,
                                  jn = Math.max(Ei + At, 1e-5),
                                  hr = wi + Et,
                                  Ti = Vn + In,
                                  er = Ii + Nt,
                                  Wi = Math.max(Ei + kt, 1e-5);
                                zn.push(new Vc(ti / jn, dn / jn, ui / jn)),
                                  Bn.push(new Vc(hr / Wi, Ti / Wi, er / Wi));
                              }
                              Lt.push(zn), Ke.push(Bn);
                            }
                            return [Lt, Ke];
                          })(le, ae, De, xe, Pe)),
                    J = r.queryGeometry;
                  var re, le, ae, De, xe, Pe, $e, Ie, Fe, Re;
                  return (function (re, le, ae) {
                    let De = 1 / 0;
                    n_(ae, le) && (De = C_(ae, le[0]));
                    for (let xe = 0; xe < le.length; xe++) {
                      const Pe = le[xe],
                        $e = re[xe];
                      for (let Ie = 0; Ie < Pe.length - 1; Ie++) {
                        const Fe = Pe[Ie],
                          Re = [Fe, Pe[Ie + 1], $e[Ie + 1], $e[Ie], Fe];
                        t_(ae, Re) && (De = Math.min(De, C_(ae, Re)));
                      }
                    }
                    return De !== 1 / 0 && De;
                  })(
                    K,
                    oe,
                    J.isPointQuery() ? J.screenBounds : J.screenGeometry
                  );
                }
              },
              line: class extends Kr {
                constructor(r) {
                  super(r, Mm), (this.gradientVersion = 0);
                }
                _handleSpecialPaintPropertyUpdate(r) {
                  if ("line-gradient" === r) {
                    const i =
                      this._transitionablePaint._values["line-gradient"].value
                        .expression;
                    (this.stepInterpolant =
                      i._styleExpression &&
                      i._styleExpression.expression instanceof Fh),
                      (this.gradientVersion =
                        (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
                  }
                }
                gradientExpression() {
                  return this._transitionablePaint._values["line-gradient"]
                    .value.expression;
                }
                widthExpression() {
                  return this._transitionablePaint._values["line-width"].value
                    .expression;
                }
                recalculate(r, i) {
                  super.recalculate(r, i),
                    (this.paint._values["line-floorwidth"] =
                      A_.possiblyEvaluate(
                        this._transitioningPaint._values["line-width"].value,
                        r
                      ));
                }
                createBucket(r) {
                  return new Ad(r);
                }
                getProgramIds() {
                  return [
                    this.paint.get("line-pattern").constantOr(1)
                      ? "linePattern"
                      : "line",
                  ];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
                queryRadius(r) {
                  const i = r,
                    o = Am(
                      Gl("line-width", this, i),
                      Gl("line-gap-width", this, i)
                    ),
                    l = Gl("line-offset", this, i);
                  return (
                    o / 2 + Math.abs(l) + Fp(this.paint.get("line-translate"))
                  );
                }
                queryIntersectsFeature(r, i, o, l, h, m) {
                  if (r.queryGeometry.isAboveHorizon) return !1;
                  const _ = i_(
                      r.tilespaceGeometry,
                      this.paint.get("line-translate"),
                      this.paint.get("line-translate-anchor"),
                      m.angle,
                      r.pixelToTileUnitsFactor
                    ),
                    x =
                      (r.pixelToTileUnitsFactor / 2) *
                      Am(
                        this.paint.get("line-width").evaluate(i, o),
                        this.paint.get("line-gap-width").evaluate(i, o)
                      ),
                    E = this.paint.get("line-offset").evaluate(i, o);
                  return (
                    E &&
                      (l = (function (T, I) {
                        const A = [],
                          L = new nt(0, 0);
                        for (let O = 0; O < T.length; O++) {
                          const F = T[O],
                            V = [];
                          for (let G = 0; G < F.length; G++) {
                            const K = F[G],
                              oe = F[G + 1],
                              J =
                                0 === G
                                  ? L
                                  : K.sub(F[G - 1])
                                      ._unit()
                                      ._perp(),
                              re =
                                G === F.length - 1
                                  ? L
                                  : oe.sub(K)._unit()._perp(),
                              le = J._add(re)._unit();
                            le._mult(1 / (le.x * re.x + le.y * re.y)),
                              V.push(le._mult(I)._add(K));
                          }
                          A.push(V);
                        }
                        return A;
                      })(l, E * r.pixelToTileUnitsFactor)),
                    (function (T, I, A) {
                      for (let L = 0; L < I.length; L++) {
                        const O = I[L];
                        if (T.length >= 3)
                          for (let F = 0; F < O.length; F++)
                            if (nl(T, O[F])) return !0;
                        if (Dv(T, O, A)) return !0;
                      }
                      return !1;
                    })(_, l, x)
                  );
                }
                isTileClipped() {
                  return !0;
                }
              },
              symbol: qd,
              background: class extends Kr {
                constructor(r) {
                  super(r, Lb);
                }
                getProgramIds() {
                  return [
                    this.paint.get("background-pattern")
                      ? "backgroundPattern"
                      : "background",
                  ];
                }
              },
              raster: class extends Kr {
                constructor(r) {
                  super(r, sf);
                }
                getProgramIds() {
                  return ["raster"];
                }
              },
              sky: class extends Kr {
                constructor(r) {
                  super(r, tg), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(r) {
                  "sky-gradient" === r
                    ? this._updateColorRamp()
                    : ("sky-atmosphere-sun" !== r &&
                        "sky-atmosphere-halo-color" !== r &&
                        "sky-atmosphere-color" !== r &&
                        "sky-atmosphere-sun-intensity" !== r) ||
                      (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                  (this.colorRamp = gm({
                    expression:
                      this._transitionablePaint._values["sky-gradient"].value
                        .expression,
                    evaluationKey: "skyRadialProgress",
                  })),
                    this.colorRampTexture &&
                      (this.colorRampTexture.destroy(),
                      (this.colorRampTexture = null));
                }
                needsSkyboxCapture(r) {
                  if (
                    this._skyboxInvalidated ||
                    !this.skyboxTexture ||
                    !this.skyboxGeometry
                  )
                    return !0;
                  if (!this.paint.get("sky-atmosphere-sun")) {
                    const i = r.style.light.properties.get("position");
                    return (
                      this._lightPosition.azimuthal !== i.azimuthal ||
                      this._lightPosition.polar !== i.polar
                    );
                  }
                  return !1;
                }
                getCenter(r, i) {
                  if ("atmosphere" === this.paint.get("sky-type")) {
                    const l = this.paint.get("sky-atmosphere-sun"),
                      h = !l,
                      m = r.style.light,
                      _ = m.properties.get("position");
                    return (
                      h &&
                        "viewport" === m.properties.get("anchor") &&
                        Wn(
                          "The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."
                        ),
                      h
                        ? Wd(_.azimuthal, 90 - _.polar, i)
                        : Wd(l[0], 90 - l[1], i)
                    );
                  }
                  const o = this.paint.get("sky-gradient-center");
                  return Wd(o[0], 90 - o[1], i);
                }
                is3D() {
                  return !1;
                }
                isSky() {
                  return !0;
                }
                markSkyboxValid(r) {
                  (this._skyboxInvalidated = !1),
                    (this._lightPosition =
                      r.style.light.properties.get("position"));
                }
                hasOffscreenPass() {
                  return !0;
                }
                getProgramIds() {
                  const r = this.paint.get("sky-type");
                  return "atmosphere" === r
                    ? ["skyboxCapture", "skybox"]
                    : "gradient" === r
                    ? ["skyboxGradient"]
                    : null;
                }
              },
            };
            class lf {
              constructor(i, o, l, h) {
                (this.context = i),
                  (this.format = l),
                  (this.texture = i.gl.createTexture()),
                  this.update(o, h);
              }
              update(i, o, l) {
                const { width: h, height: m } = i,
                  { context: _ } = this,
                  { gl: x } = _,
                  {
                    HTMLImageElement: E,
                    HTMLCanvasElement: T,
                    HTMLVideoElement: I,
                    ImageData: A,
                    ImageBitmap: L,
                  } = Be;
                if (
                  (x.bindTexture(x.TEXTURE_2D, this.texture),
                  _.pixelStoreUnpackFlipY.set(!1),
                  _.pixelStoreUnpack.set(1),
                  _.pixelStoreUnpackPremultiplyAlpha.set(
                    this.format === x.RGBA && (!o || !1 !== o.premultiply)
                  ),
                  l || (this.size && this.size[0] === h && this.size[1] === m))
                ) {
                  const { x: O, y: F } = l || { x: 0, y: 0 };
                  i instanceof E ||
                  i instanceof T ||
                  i instanceof I ||
                  i instanceof A ||
                  (L && i instanceof L)
                    ? x.texSubImage2D(
                        x.TEXTURE_2D,
                        0,
                        O,
                        F,
                        x.RGBA,
                        x.UNSIGNED_BYTE,
                        i
                      )
                    : x.texSubImage2D(
                        x.TEXTURE_2D,
                        0,
                        O,
                        F,
                        h,
                        m,
                        x.RGBA,
                        x.UNSIGNED_BYTE,
                        i.data
                      );
                } else (this.size = [h, m]), i instanceof E || i instanceof T || i instanceof I || i instanceof A || (L && i instanceof L) ? x.texImage2D(x.TEXTURE_2D, 0, this.format, this.format, x.UNSIGNED_BYTE, i) : x.texImage2D(x.TEXTURE_2D, 0, this.format, h, m, 0, this.format, x.UNSIGNED_BYTE, i.data);
                (this.useMipmap = Boolean(
                  o && o.useMipmap && this.isSizePowerOfTwo()
                )),
                  this.useMipmap && x.generateMipmap(x.TEXTURE_2D);
              }
              bind(i, o) {
                const { context: l } = this,
                  { gl: h } = l;
                h.bindTexture(h.TEXTURE_2D, this.texture),
                  i !== this.filter &&
                    (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, i),
                    h.texParameteri(
                      h.TEXTURE_2D,
                      h.TEXTURE_MIN_FILTER,
                      this.useMipmap
                        ? i === h.NEAREST
                          ? h.NEAREST_MIPMAP_NEAREST
                          : h.LINEAR_MIPMAP_NEAREST
                        : i
                    ),
                    (this.filter = i)),
                  o !== this.wrap &&
                    (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, o),
                    h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, o),
                    (this.wrap = o));
              }
              isSizePowerOfTwo() {
                return (
                  this.size[0] === this.size[1] &&
                  (Math.log(this.size[0]) / Math.LN2) % 1 == 0
                );
              }
              destroy() {
                const { gl: i } = this.context;
                i.deleteTexture(this.texture), (this.texture = null);
              }
            }
            class p0 {
              constructor(i) {
                (this._callback = i),
                  (this._triggered = !1),
                  typeof MessageChannel < "u" &&
                    ((this._channel = new MessageChannel()),
                    (this._channel.port2.onmessage = () => {
                      (this._triggered = !1), this._callback();
                    }));
              }
              trigger() {
                this._triggered ||
                  ((this._triggered = !0),
                  this._channel
                    ? this._channel.port1.postMessage(!0)
                    : setTimeout(() => {
                        (this._triggered = !1), this._callback();
                      }, 0));
              }
              remove() {
                (this._channel = void 0), (this._callback = () => {});
              }
            }
            class f0 {
              constructor() {
                (this.tasks = {}),
                  (this.taskQueue = []),
                  No(["process"], this),
                  (this.invoker = new p0(this.process)),
                  (this.nextId = 0);
              }
              add(i, o) {
                const l = this.nextId++,
                  h = (function ({ type: m, isSymbolTile: _, zoom: x }) {
                    return (
                      (x = x || 0),
                      "message" === m
                        ? 0
                        : "maybePrepare" !== m || _
                        ? "parseTile" !== m || _
                          ? "parseTile" === m && _
                            ? 300 - x
                            : "maybePrepare" === m && _
                            ? 400 - x
                            : 500
                          : 200 - x
                        : 100 - x
                    );
                  })(o);
                if (0 === h) {
                  zs();
                  try {
                    i();
                  } finally {
                  }
                  return { cancel: () => {} };
                }
                return (
                  (this.tasks[l] = { fn: i, metadata: o, priority: h, id: l }),
                  this.taskQueue.push(l),
                  this.invoker.trigger(),
                  {
                    cancel: () => {
                      delete this.tasks[l];
                    },
                  }
                );
              }
              process() {
                zs();
                try {
                  if (
                    ((this.taskQueue = this.taskQueue.filter(
                      (l) => !!this.tasks[l]
                    )),
                    !this.taskQueue.length)
                  )
                    return;
                  const i = this.pick();
                  if (null === i) return;
                  const o = this.tasks[i];
                  if (
                    (delete this.tasks[i],
                    this.taskQueue.length && this.invoker.trigger(),
                    !o)
                  )
                    return;
                  o.fn();
                } finally {
                }
              }
              pick() {
                let i = null,
                  o = 1 / 0;
                for (let h = 0; h < this.taskQueue.length; h++) {
                  const m = this.tasks[this.taskQueue[h]];
                  m.priority < o && ((o = m.priority), (i = h));
                }
                if (null === i) return null;
                const l = this.taskQueue[i];
                return this.taskQueue.splice(i, 1), l;
              }
              remove() {
                this.invoker.remove();
              }
            }
            class oy {
              constructor(i) {
                (this._stringToNumber = {}), (this._numberToString = []);
                for (let o = 0; o < i.length; o++) {
                  const l = i[o];
                  (this._stringToNumber[l] = o), (this._numberToString[o] = l);
                }
              }
              encode(i) {
                return this._stringToNumber[i];
              }
              decode(i) {
                return this._numberToString[i];
              }
            }
            const m0 = ["tile", "layer", "source", "sourceLayer", "state"];
            class ig {
              constructor(i, o, l, h, m) {
                (this.type = "Feature"),
                  (this._vectorTileFeature = i),
                  (this._z = o),
                  (this._x = l),
                  (this._y = h),
                  (this.properties = i.properties),
                  (this.id = m);
              }
              get geometry() {
                return (
                  void 0 === this._geometry &&
                    (this._geometry = this._vectorTileFeature.toGeoJSON(
                      this._x,
                      this._y,
                      this._z
                    ).geometry),
                  this._geometry
                );
              }
              set geometry(i) {
                this._geometry = i;
              }
              toJSON() {
                const i = {
                  type: "Feature",
                  state: void 0,
                  geometry: this.geometry,
                  properties: this.properties,
                };
                void 0 !== this.id && (i.id = this.id);
                for (const o of m0) void 0 !== this[o] && (i[o] = this[o]);
                return i;
              }
            }
            const Zc = new Uint16Array(8184);
            for (let r = 0; r < 2046; r++) {
              let i = r + 2,
                o = 0,
                l = 0,
                h = 0,
                m = 0,
                _ = 0,
                x = 0;
              for (
                1 & i ? (h = m = _ = 32) : (o = l = x = 32);
                (i >>= 1) > 1;

              ) {
                const T = (o + h) >> 1,
                  I = (l + m) >> 1;
                1 & i
                  ? ((h = o), (m = l), (o = _), (l = x))
                  : ((o = h), (l = m), (h = _), (m = x)),
                  (_ = T),
                  (x = I);
              }
              const E = 4 * r;
              (Zc[E + 0] = o),
                (Zc[E + 1] = l),
                (Zc[E + 2] = h),
                (Zc[E + 3] = m);
            }
            const Es = new Uint16Array(2178),
              al = new Uint8Array(1089),
              cf = new Uint16Array(1089);
            function uf(r) {
              return 0 === r ? -0.03125 : 32 === r ? 0.03125 : 0;
            }
            var g0 = ge([
              { name: "a_pos", type: "Int16", components: 2 },
              { name: "a_texture_pos", type: "Int16", components: 2 },
            ]);
            const _0 = {
              type: 2,
              extent: wt,
              loadGeometry: () => [
                [
                  new nt(0, 0),
                  new nt(8193, 0),
                  new nt(8193, 8193),
                  new nt(0, 8193),
                  new nt(0, 0),
                ],
              ],
            };
            class sy {
              constructor(i, o, l, h, m) {
                (this.tileID = i),
                  (this.uid = rs()),
                  (this.uses = 0),
                  (this.tileSize = o),
                  (this.tileZoom = l),
                  (this.buckets = {}),
                  (this.expirationTime = null),
                  (this.queryPadding = 0),
                  (this.hasSymbolBuckets = !1),
                  (this.hasRTLText = !1),
                  (this.dependencies = {}),
                  (this.isRaster = m),
                  (this.expiredRequestCount = 0),
                  (this.state = "loading"),
                  h &&
                    h.transform &&
                    (this.projection = h.transform.projection);
              }
              registerFadeDuration(i) {
                const o = i + this.timeAdded;
                o < cs.now() ||
                  (this.fadeEndTime && o < this.fadeEndTime) ||
                  (this.fadeEndTime = o);
              }
              wasRequested() {
                return (
                  "errored" === this.state ||
                  "loaded" === this.state ||
                  "reloading" === this.state
                );
              }
              get tileTransform() {
                return (
                  this._tileTransform ||
                    (this._tileTransform = qc(
                      this.tileID.canonical,
                      this.projection
                    )),
                  this._tileTransform
                );
              }
              loadVectorData(i, o, l) {
                if ((this.unloadVectorData(), (this.state = "loaded"), i)) {
                  i.featureIndex &&
                    ((this.latestFeatureIndex = i.featureIndex),
                    i.rawTileData
                      ? ((this.latestRawTileData = i.rawTileData),
                        (this.latestFeatureIndex.rawTileData = i.rawTileData))
                      : this.latestRawTileData &&
                        (this.latestFeatureIndex.rawTileData =
                          this.latestRawTileData)),
                    (this.collisionBoxArray = i.collisionBoxArray),
                    (this.buckets = (function (h, m) {
                      const _ = {};
                      if (!m) return _;
                      for (const x of h) {
                        const E = x.layerIds
                          .map((T) => m.getLayer(T))
                          .filter(Boolean);
                        if (0 !== E.length) {
                          (x.layers = E),
                            x.stateDependentLayerIds &&
                              (x.stateDependentLayers =
                                x.stateDependentLayerIds.map(
                                  (T) => E.filter((I) => I.id === T)[0]
                                ));
                          for (const T of E) _[T.id] = x;
                        }
                      }
                      return _;
                    })(i.buckets, o.style)),
                    (this.hasSymbolBuckets = !1);
                  for (const h in this.buckets) {
                    const m = this.buckets[h];
                    if (m instanceof fa) {
                      if (((this.hasSymbolBuckets = !0), !l)) break;
                      m.justReloaded = !0;
                    }
                  }
                  if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                    for (const h in this.buckets) {
                      const m = this.buckets[h];
                      if (m instanceof fa && m.hasRTLText) {
                        (this.hasRTLText = !0),
                          S.isLoading() ||
                            S.isLoaded() ||
                            "deferred" !== b() ||
                            D();
                        break;
                      }
                    }
                  this.queryPadding = 0;
                  for (const h in this.buckets) {
                    const m = this.buckets[h];
                    this.queryPadding = Math.max(
                      this.queryPadding,
                      o.style.getLayer(h).queryRadius(m)
                    );
                  }
                  i.imageAtlas && (this.imageAtlas = i.imageAtlas),
                    i.glyphAtlasImage &&
                      (this.glyphAtlasImage = i.glyphAtlasImage),
                    i.lineAtlas && (this.lineAtlas = i.lineAtlas);
                } else this.collisionBoxArray = new Pn();
              }
              unloadVectorData() {
                if (this.hasData()) {
                  for (const i in this.buckets) this.buckets[i].destroy();
                  (this.buckets = {}),
                    this.imageAtlas && (this.imageAtlas = null),
                    this.lineAtlas && (this.lineAtlas = null),
                    this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                    this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                    this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                    this._tileBoundsBuffer &&
                      (this._tileBoundsBuffer.destroy(),
                      this._tileBoundsIndexBuffer.destroy(),
                      this._tileBoundsSegments.destroy(),
                      (this._tileBoundsBuffer = null)),
                    this._tileDebugBuffer &&
                      (this._tileDebugBuffer.destroy(),
                      this._tileDebugSegments.destroy(),
                      (this._tileDebugBuffer = null)),
                    this._tileDebugIndexBuffer &&
                      (this._tileDebugIndexBuffer.destroy(),
                      (this._tileDebugIndexBuffer = null)),
                    this._globeTileDebugBorderBuffer &&
                      (this._globeTileDebugBorderBuffer.destroy(),
                      (this._globeTileDebugBorderBuffer = null)),
                    this._tileDebugTextBuffer &&
                      (this._tileDebugTextBuffer.destroy(),
                      this._tileDebugTextSegments.destroy(),
                      this._tileDebugTextIndexBuffer.destroy(),
                      (this._tileDebugTextBuffer = null)),
                    this._globeTileDebugTextBuffer &&
                      (this._globeTileDebugTextBuffer.destroy(),
                      (this._globeTileDebugTextBuffer = null)),
                    (this.latestFeatureIndex = null),
                    (this.state = "unloaded");
                }
              }
              getBucket(i) {
                return this.buckets[i.id];
              }
              upload(i) {
                for (const l in this.buckets) {
                  const h = this.buckets[l];
                  h.uploadPending() && h.upload(i);
                }
                const o = i.gl;
                this.imageAtlas &&
                  !this.imageAtlas.uploaded &&
                  ((this.imageAtlasTexture = new lf(
                    i,
                    this.imageAtlas.image,
                    o.RGBA
                  )),
                  (this.imageAtlas.uploaded = !0)),
                  this.glyphAtlasImage &&
                    ((this.glyphAtlasTexture = new lf(
                      i,
                      this.glyphAtlasImage,
                      o.ALPHA
                    )),
                    (this.glyphAtlasImage = null)),
                  this.lineAtlas &&
                    !this.lineAtlas.uploaded &&
                    ((this.lineAtlasTexture = new lf(
                      i,
                      this.lineAtlas.image,
                      o.ALPHA
                    )),
                    (this.lineAtlas.uploaded = !0));
              }
              prepare(i) {
                this.imageAtlas &&
                  this.imageAtlas.patchUpdatedImages(i, this.imageAtlasTexture);
              }
              queryRenderedFeatures(i, o, l, h, m, _, x, E) {
                return this.latestFeatureIndex &&
                  this.latestFeatureIndex.rawTileData
                  ? this.latestFeatureIndex.query(
                      {
                        tileResult: h,
                        pixelPosMatrix: x,
                        transform: _,
                        params: m,
                        tileTransform: this.tileTransform,
                      },
                      i,
                      o,
                      l
                    )
                  : {};
              }
              querySourceFeatures(i, o) {
                const l = this.latestFeatureIndex;
                if (!l || !l.rawTileData) return;
                const h = l.loadVTLayers(),
                  m = o ? o.sourceLayer : "",
                  _ = h._geojsonTileLayer || h[m];
                if (!_) return;
                const x = Pu(o && o.filter),
                  { z: E, x: T, y: I } = this.tileID.canonical,
                  A = { z: E, x: T, y: I };
                for (let L = 0; L < _.length; L++) {
                  const O = _.feature(L);
                  if (x.needGeometry) {
                    const G = tl(O, !0);
                    if (
                      !x.filter(
                        new M(this.tileID.overscaledZ),
                        G,
                        this.tileID.canonical
                      )
                    )
                      continue;
                  } else if (!x.filter(new M(this.tileID.overscaledZ), O))
                    continue;
                  const F = l.getId(O, m),
                    V = new ig(O, E, T, I, F);
                  (V.tile = A), i.push(V);
                }
              }
              hasData() {
                return (
                  "loaded" === this.state ||
                  "reloading" === this.state ||
                  "expired" === this.state
                );
              }
              patternsLoaded() {
                return (
                  !!this.imageAtlas &&
                  !!Object.keys(this.imageAtlas.patternPositions).length
                );
              }
              setExpiryData(i) {
                const o = this.expirationTime;
                if (i.cacheControl) {
                  const l = io(i.cacheControl);
                  l["max-age"] &&
                    (this.expirationTime = Date.now() + 1e3 * l["max-age"]);
                } else i.expires && (this.expirationTime = new Date(i.expires).getTime());
                if (this.expirationTime) {
                  const l = Date.now();
                  let h = !1;
                  if (this.expirationTime > l) h = !1;
                  else if (o)
                    if (this.expirationTime < o) h = !0;
                    else {
                      const m = this.expirationTime - o;
                      m
                        ? (this.expirationTime = l + Math.max(m, 3e4))
                        : (h = !0);
                    }
                  else h = !0;
                  h
                    ? (this.expiredRequestCount++, (this.state = "expired"))
                    : (this.expiredRequestCount = 0);
                }
              }
              getExpiryTimeout() {
                if (this.expirationTime)
                  return this.expiredRequestCount
                    ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                    : Math.min(
                        this.expirationTime - new Date().getTime(),
                        Math.pow(2, 31) - 1
                      );
              }
              setFeatureState(i, o) {
                if (
                  !this.latestFeatureIndex ||
                  !this.latestFeatureIndex.rawTileData ||
                  0 === Object.keys(i).length ||
                  !o
                )
                  return;
                const l = this.latestFeatureIndex.loadVTLayers(),
                  h = o.style.listImages();
                for (const m in this.buckets) {
                  if (!o.style.hasLayer(m)) continue;
                  const _ = this.buckets[m],
                    x = _.layers[0].sourceLayer || "_geojsonTileLayer",
                    E = l[x],
                    T = i[x];
                  if (!E || !T || 0 === Object.keys(T).length) continue;
                  if (
                    (_.update(
                      T,
                      E,
                      h,
                      (this.imageAtlas && this.imageAtlas.patternPositions) ||
                        {}
                    ),
                    _ instanceof Ad || _ instanceof Wp)
                  ) {
                    const A = o.style._getSourceCache(_.layers[0].source);
                    o._terrain &&
                      o._terrain.enabled &&
                      A &&
                      _.programConfigurations.needsUpload &&
                      o._terrain._clearRenderCacheForTile(A.id, this.tileID);
                  }
                  const I = o && o.style && o.style.getLayer(m);
                  I &&
                    (this.queryPadding = Math.max(
                      this.queryPadding,
                      I.queryRadius(_)
                    ));
                }
              }
              holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
              }
              symbolFadeFinished() {
                return (
                  !this.symbolFadeHoldUntil ||
                  this.symbolFadeHoldUntil < cs.now()
                );
              }
              clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
              }
              setHoldDuration(i) {
                this.symbolFadeHoldUntil = cs.now() + i;
              }
              setTexture(i, o) {
                const l = o.context,
                  h = l.gl;
                (this.texture = this.texture || o.getTileTexture(i.width)),
                  this.texture
                    ? this.texture.update(i, { useMipmap: !0 })
                    : ((this.texture = new lf(l, i, h.RGBA, { useMipmap: !0 })),
                      this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
              }
              setDependencies(i, o) {
                const l = {};
                for (const h of o) l[h] = !0;
                this.dependencies[i] = l;
              }
              hasDependency(i, o) {
                for (const l of i) {
                  const h = this.dependencies[l];
                  if (h) for (const m of o) if (h[m]) return !0;
                }
                return !1;
              }
              clearQueryDebugViz() {}
              _makeDebugTileBoundsBuffers(i, o) {
                if (!o || "mercator" === o.name || this._tileDebugBuffer)
                  return;
                const l = el(_0, this.tileID.canonical, this.tileTransform)[0],
                  h = new Ge(),
                  m = new Er();
                for (let _ = 0; _ < l.length; _++) {
                  const { x, y: E } = l[_];
                  h.emplaceBack(x, E), m.emplaceBack(_);
                }
                m.emplaceBack(0),
                  (this._tileDebugIndexBuffer = i.createIndexBuffer(m)),
                  (this._tileDebugBuffer = i.createVertexBuffer(h, Ja.members)),
                  (this._tileDebugSegments = xi.simpleSegment(
                    0,
                    0,
                    h.length,
                    m.length
                  ));
              }
              _makeTileBoundsBuffers(i, o) {
                if (this._tileBoundsBuffer || !o || "mercator" === o.name)
                  return;
                const l = el(_0, this.tileID.canonical, this.tileTransform)[0];
                let h, m;
                if (this.isRaster) {
                  const _ = (function (x, E) {
                    const T = qc(x, E),
                      I = Math.pow(2, x.z);
                    for (let G = 0; G < 33; G++)
                      for (let K = 0; K < 33; K++) {
                        const oe = ao((x.x + (K + uf(K)) / 32) / I),
                          J = qi((x.y + (G + uf(G)) / 32) / I),
                          re = E.project(oe, J),
                          le = 33 * G + K;
                        (Es[2 * le + 0] = Math.round(
                          (re.x * T.scale - T.x) * wt
                        )),
                          (Es[2 * le + 1] = Math.round(
                            (re.y * T.scale - T.y) * wt
                          ));
                      }
                    al.fill(0), cf.fill(0);
                    for (let G = 2045; G >= 0; G--) {
                      const K = 4 * G,
                        oe = Zc[K + 0],
                        J = Zc[K + 1],
                        re = Zc[K + 2],
                        le = Zc[K + 3],
                        ae = (oe + re) >> 1,
                        De = (J + le) >> 1,
                        xe = ae + De - J,
                        Pe = De + oe - ae,
                        $e = 33 * J + oe,
                        Ie = 33 * le + re,
                        Fe = 33 * De + ae,
                        Re =
                          Math.hypot(
                            (Es[2 * $e + 0] + Es[2 * Ie + 0]) / 2 -
                              Es[2 * Fe + 0],
                            (Es[2 * $e + 1] + Es[2 * Ie + 1]) / 2 -
                              Es[2 * Fe + 1]
                          ) >= 16;
                      (al[Fe] = al[Fe] || (Re ? 1 : 0)),
                        G < 1022 &&
                          (al[Fe] =
                            al[Fe] ||
                            al[33 * ((J + Pe) >> 1) + ((oe + xe) >> 1)] ||
                            al[33 * ((le + Pe) >> 1) + ((re + xe) >> 1)]);
                    }
                    const A = new Le(),
                      L = new _t();
                    let O = 0;
                    function F(G, K) {
                      const oe = 33 * K + G;
                      return (
                        0 === cf[oe] &&
                          (A.emplaceBack(
                            Es[2 * oe + 0],
                            Es[2 * oe + 1],
                            (G * wt) / 32,
                            (K * wt) / 32
                          ),
                          (cf[oe] = ++O)),
                        cf[oe] - 1
                      );
                    }
                    function V(G, K, oe, J, re, le) {
                      const ae = (G + oe) >> 1,
                        De = (K + J) >> 1;
                      if (
                        Math.abs(G - re) + Math.abs(K - le) > 1 &&
                        al[33 * De + ae]
                      )
                        V(re, le, G, K, ae, De), V(oe, J, re, le, ae, De);
                      else {
                        const xe = F(G, K),
                          Pe = F(oe, J),
                          $e = F(re, le);
                        L.emplaceBack(xe, Pe, $e);
                      }
                    }
                    return (
                      V(0, 0, 32, 32, 32, 0),
                      V(32, 32, 0, 0, 0, 32),
                      { vertices: A, indices: L }
                    );
                  })(this.tileID.canonical, o);
                  (h = _.vertices), (m = _.indices);
                } else {
                  (h = new Le()), (m = new _t());
                  for (const { x, y: E } of l) h.emplaceBack(x, E, 0, 0);
                  const _ = $p(h.int16, void 0, 4);
                  for (let x = 0; x < _.length; x += 3)
                    m.emplaceBack(_[x], _[x + 1], _[x + 2]);
                }
                (this._tileBoundsBuffer = i.createVertexBuffer(h, g0.members)),
                  (this._tileBoundsIndexBuffer = i.createIndexBuffer(m)),
                  (this._tileBoundsSegments = xi.simpleSegment(
                    0,
                    0,
                    h.length,
                    m.length
                  ));
              }
              _makeGlobeTileDebugBuffers(i, o) {
                const l = o.projection;
                if (!l || "globe" !== l.name || o.freezeTileCoverage) return;
                const h = this.tileID.canonical,
                  m = Wu(Ev(h, o)),
                  _ = Ji(o.zoom);
                let x;
                _ > 0 && (x = Dp(new Float64Array(16), o.globeMatrix)),
                  this._makeGlobeTileDebugBorderBuffer(i, h, o, m, x, _),
                  this._makeGlobeTileDebugTextBuffer(i, h, o, m, x, _);
              }
              _globePoint(i, o, l, h, m, _, x) {
                let E = hd(i, o, l);
                if (_) {
                  const T = 1 << l.z,
                    I = ua(h.center.lng),
                    A = ai(h.center.lat),
                    L = (l.x + 0.5) / T - I;
                  let O = 0;
                  L > 0.5 ? (O = -1) : L < -0.5 && (O = 1);
                  let F = (i / wt + l.x) / T + O,
                    V = (o / wt + l.y) / T;
                  (F = (F - I) * h._pixelsPerMercatorPixel + I),
                    (V = (V - A) * h._pixelsPerMercatorPixel + A);
                  const G = [F * h.worldSize, V * h.worldSize, 0];
                  Jn(G, G, _), (E = qu(E, G, x));
                }
                return Jn(E, E, m);
              }
              _makeGlobeTileDebugBorderBuffer(i, o, l, h, m, _) {
                const x = new Ge(),
                  E = new Er(),
                  T = new be(),
                  I = (L, O, F, V, G) => {
                    const K = (F - L) / (G - 1),
                      oe = (V - O) / (G - 1),
                      J = x.length;
                    for (let re = 0; re < G; re++) {
                      const le = L + re * K,
                        ae = O + re * oe;
                      x.emplaceBack(le, ae);
                      const De = this._globePoint(le, ae, o, l, h, m, _);
                      T.emplaceBack(De[0], De[1], De[2]), E.emplaceBack(J + re);
                    }
                  },
                  A = wt;
                I(0, 0, A, 0, 16),
                  I(A, 0, A, A, 16),
                  I(A, A, 0, A, 16),
                  I(0, A, 0, 0, 16),
                  (this._tileDebugIndexBuffer = i.createIndexBuffer(E)),
                  (this._tileDebugBuffer = i.createVertexBuffer(x, Ja.members)),
                  (this._globeTileDebugBorderBuffer = i.createVertexBuffer(
                    T,
                    Nc.members
                  )),
                  (this._tileDebugSegments = xi.simpleSegment(
                    0,
                    0,
                    x.length,
                    E.length
                  ));
              }
              _makeGlobeTileDebugTextBuffer(i, o, l, h, m, _) {
                const E = new Ge(),
                  T = new _t(),
                  I = new be(),
                  A = 25;
                T.reserve(32), E.reserve(A), I.reserve(A);
                const L = (O, F) => A * O + F;
                for (let O = 0; O < A; O++) {
                  const F = 2048 * O;
                  for (let V = 0; V < A; V++) {
                    const G = 2048 * V;
                    E.emplaceBack(G, F);
                    const K = this._globePoint(G, F, o, l, h, m, _);
                    I.emplaceBack(K[0], K[1], K[2]);
                  }
                }
                for (let O = 0; O < 4; O++)
                  for (let F = 0; F < 4; F++) {
                    const V = L(O, F),
                      G = L(O, F + 1),
                      K = L(O + 1, F),
                      oe = L(O + 1, F + 1);
                    T.emplaceBack(V, G, K), T.emplaceBack(K, G, oe);
                  }
                (this._tileDebugTextIndexBuffer = i.createIndexBuffer(T)),
                  (this._tileDebugTextBuffer = i.createVertexBuffer(
                    E,
                    Ja.members
                  )),
                  (this._globeTileDebugTextBuffer = i.createVertexBuffer(
                    I,
                    Nc.members
                  )),
                  (this._tileDebugTextSegments = xi.simpleSegment(0, 0, A, 32));
              }
            }
            class kb {
              constructor() {
                (this.state = {}),
                  (this.stateChanges = {}),
                  (this.deletedStates = {});
              }
              updateState(i, o, l) {
                const h = String(o);
                if (
                  ((this.stateChanges[i] = this.stateChanges[i] || {}),
                  (this.stateChanges[i][h] = this.stateChanges[i][h] || {}),
                  pi(this.stateChanges[i][h], l),
                  null === this.deletedStates[i])
                ) {
                  this.deletedStates[i] = {};
                  for (const m in this.state[i])
                    m !== h && (this.deletedStates[i][m] = null);
                } else if (
                  this.deletedStates[i] &&
                  null === this.deletedStates[i][h]
                ) {
                  this.deletedStates[i][h] = {};
                  for (const m in this.state[i][h])
                    l[m] || (this.deletedStates[i][h][m] = null);
                } else
                  for (const m in l)
                    this.deletedStates[i] &&
                      this.deletedStates[i][h] &&
                      null === this.deletedStates[i][h][m] &&
                      delete this.deletedStates[i][h][m];
              }
              removeFeatureState(i, o, l) {
                if (null === this.deletedStates[i]) return;
                const h = String(o);
                if (
                  ((this.deletedStates[i] = this.deletedStates[i] || {}),
                  l && void 0 !== o)
                )
                  null !== this.deletedStates[i][h] &&
                    ((this.deletedStates[i][h] =
                      this.deletedStates[i][h] || {}),
                    (this.deletedStates[i][h][l] = null));
                else if (void 0 !== o)
                  if (this.stateChanges[i] && this.stateChanges[i][h])
                    for (l in ((this.deletedStates[i][h] = {}),
                    this.stateChanges[i][h]))
                      this.deletedStates[i][h][l] = null;
                  else this.deletedStates[i][h] = null;
                else this.deletedStates[i] = null;
              }
              getState(i, o) {
                const l = String(o),
                  h = pi(
                    {},
                    (this.state[i] || {})[l],
                    (this.stateChanges[i] || {})[l]
                  );
                if (null === this.deletedStates[i]) return {};
                if (this.deletedStates[i]) {
                  const m = this.deletedStates[i][o];
                  if (null === m) return {};
                  for (const _ in m) delete h[_];
                }
                return h;
              }
              initializeTileState(i, o) {
                i.setFeatureState(this.state, o);
              }
              coalesceChanges(i, o) {
                const l = {};
                for (const h in this.stateChanges) {
                  this.state[h] = this.state[h] || {};
                  const m = {};
                  for (const _ in this.stateChanges[h])
                    this.state[h][_] || (this.state[h][_] = {}),
                      pi(this.state[h][_], this.stateChanges[h][_]),
                      (m[_] = this.state[h][_]);
                  l[h] = m;
                }
                for (const h in this.deletedStates) {
                  this.state[h] = this.state[h] || {};
                  const m = {};
                  if (null === this.deletedStates[h])
                    for (const _ in this.state[h])
                      (m[_] = {}), (this.state[h][_] = {});
                  else
                    for (const _ in this.deletedStates[h]) {
                      if (null === this.deletedStates[h][_])
                        this.state[h][_] = {};
                      else if (this.state[h][_])
                        for (const x of Object.keys(this.deletedStates[h][_]))
                          delete this.state[h][_][x];
                      m[_] = this.state[h][_];
                    }
                  (l[h] = l[h] || {}), pi(l[h], m);
                }
                if (
                  ((this.stateChanges = {}),
                  (this.deletedStates = {}),
                  0 !== Object.keys(l).length)
                )
                  for (const h in i) i[h].setFeatureState(l, o);
              }
            }
            class y0 {
              constructor(i) {
                (this.size = i),
                  (this.minimums = []),
                  (this.maximums = []),
                  (this.leaves = []);
              }
              getElevation(i, o) {
                const l = this.toIdx(i, o);
                return { min: this.minimums[l], max: this.maximums[l] };
              }
              isLeaf(i, o) {
                return this.leaves[this.toIdx(i, o)];
              }
              toIdx(i, o) {
                return o * this.size + i;
              }
            }
            function v0(r, i, o, l) {
              let h = 0,
                m = Number.MAX_VALUE;
              for (let _ = 0; _ < 3; _++)
                if (Math.abs(l[_]) < 1e-15) {
                  if (o[_] < r[_] || o[_] > i[_]) return null;
                } else {
                  const x = 1 / l[_];
                  let E = (r[_] - o[_]) * x,
                    T = (i[_] - o[_]) * x;
                  if (E > T) {
                    const I = E;
                    (E = T), (T = I);
                  }
                  if ((E > h && (h = E), T < m && (m = T), h > m)) return null;
                }
              return h;
            }
            function x0(r, i, o, l, h, m, _, x, E, T, I) {
              const A = l - r,
                L = h - i,
                O = m - o,
                F = _ - r,
                V = x - i,
                G = E - o,
                K = I[1] * G - I[2] * V,
                oe = I[2] * F - I[0] * G,
                J = I[0] * V - I[1] * F,
                re = A * K + L * oe + O * J;
              if (Math.abs(re) < 1e-15) return null;
              const le = 1 / re,
                ae = T[0] - r,
                De = T[1] - i,
                xe = T[2] - o,
                Pe = (ae * K + De * oe + xe * J) * le;
              if (Pe < 0 || Pe > 1) return null;
              const $e = De * O - xe * L,
                Ie = xe * A - ae * O,
                Fe = ae * L - De * A,
                Re = (I[0] * $e + I[1] * Ie + I[2] * Fe) * le;
              return Re < 0 || Pe + Re > 1
                ? null
                : (F * $e + V * Ie + G * Fe) * le;
            }
            function b0(r, i, o) {
              return (r - i) / (o - i);
            }
            function w0(r, i, o, l, h, m, _, x, E) {
              const T = 1 << o,
                I = m - l,
                A = _ - h,
                L = ((r + 1) / T) * I + l,
                O = ((i + 0) / T) * A + h,
                F = ((i + 1) / T) * A + h;
              (x[0] = ((r + 0) / T) * I + l),
                (x[1] = O),
                (E[0] = L),
                (E[1] = F);
            }
            class E0 {
              constructor(i) {
                if (
                  ((this.maximums = []),
                  (this.minimums = []),
                  (this.leaves = []),
                  (this.childOffsets = []),
                  (this.nodeCount = 0),
                  (this.dem = i),
                  (this._siblingOffset = [
                    [0, 0],
                    [1, 0],
                    [0, 1],
                    [1, 1],
                  ]),
                  !this.dem)
                )
                  return;
                const o = (function (m) {
                    const _ = Math.ceil(Math.log2(m.dim / 8)),
                      x = [];
                    let E = Math.ceil(Math.pow(2, _));
                    const T = 1 / E,
                      I = (O, F, V, G, K) => {
                        const oe = G ? 1 : 0,
                          J = (O + 1) * V - oe,
                          re = F * V,
                          le = (F + 1) * V - oe;
                        (K[0] = O * V), (K[1] = re), (K[2] = J), (K[3] = le);
                      };
                    let A = new y0(E);
                    const L = [];
                    for (let O = 0; O < E * E; O++) {
                      I(O % E, Math.floor(O / E), T, !1, L);
                      const F = ga(L[0], L[1], m),
                        V = ga(L[2], L[1], m),
                        G = ga(L[2], L[3], m),
                        K = ga(L[0], L[3], m);
                      A.minimums.push(Math.min(F, V, G, K)),
                        A.maximums.push(Math.max(F, V, G, K)),
                        A.leaves.push(1);
                    }
                    for (x.push(A), E /= 2; E >= 1; E /= 2) {
                      const O = x[x.length - 1];
                      A = new y0(E);
                      for (let F = 0; F < E * E; F++) {
                        I(F % E, Math.floor(F / E), 2, !0, L);
                        const V = O.getElevation(L[0], L[1]),
                          G = O.getElevation(L[2], L[1]),
                          K = O.getElevation(L[2], L[3]),
                          oe = O.getElevation(L[0], L[3]),
                          J = O.isLeaf(L[0], L[1]),
                          re = O.isLeaf(L[2], L[1]),
                          le = O.isLeaf(L[2], L[3]),
                          ae = O.isLeaf(L[0], L[3]),
                          De = Math.min(V.min, G.min, K.min, oe.min),
                          xe = Math.max(V.max, G.max, K.max, oe.max),
                          Pe = J && re && le && ae;
                        A.maximums.push(xe),
                          A.minimums.push(De),
                          A.leaves.push(xe - De <= 5 && Pe ? 1 : 0);
                      }
                      x.push(A);
                    }
                    return x;
                  })(this.dem),
                  l = o.length - 1,
                  h = o[l];
                this._addNode(h.minimums[0], h.maximums[0], h.leaves[0]),
                  this._construct(o, 0, 0, l, 0);
              }
              raycastRoot(i, o, l, h, m, _, x = 1) {
                return v0([i, o, -100], [l, h, this.maximums[0] * x], m, _);
              }
              raycast(i, o, l, h, m, _, x = 1) {
                if (!this.nodeCount) return null;
                const E = this.raycastRoot(i, o, l, h, m, _, x);
                if (null == E) return null;
                const T = [],
                  I = [],
                  A = [],
                  L = [],
                  O = [{ idx: 0, t: E, nodex: 0, nodey: 0, depth: 0 }];
                for (; O.length > 0; ) {
                  const {
                    idx: F,
                    t: V,
                    nodex: G,
                    nodey: K,
                    depth: oe,
                  } = O.pop();
                  if (this.leaves[F]) {
                    w0(G, K, oe, i, o, l, h, A, L);
                    const re = 1 << oe,
                      le = (G + 0) / re,
                      ae = (G + 1) / re,
                      De = (K + 0) / re,
                      xe = (K + 1) / re,
                      Pe = ga(le, De, this.dem) * x,
                      $e = ga(ae, De, this.dem) * x,
                      Ie = ga(ae, xe, this.dem) * x,
                      Fe = ga(le, xe, this.dem) * x,
                      Re = x0(
                        A[0],
                        A[1],
                        Pe,
                        L[0],
                        A[1],
                        $e,
                        L[0],
                        L[1],
                        Ie,
                        m,
                        _
                      ),
                      Ve = x0(
                        L[0],
                        L[1],
                        Ie,
                        A[0],
                        L[1],
                        Fe,
                        A[0],
                        A[1],
                        Pe,
                        m,
                        _
                      ),
                      qe = Math.min(
                        null !== Re ? Re : Number.MAX_VALUE,
                        null !== Ve ? Ve : Number.MAX_VALUE
                      );
                    if (qe !== Number.MAX_VALUE) return qe;
                    {
                      const Me = rd([], m, _, V);
                      if (
                        ll(
                          Pe,
                          $e,
                          Fe,
                          Ie,
                          b0(Me[0], A[0], L[0]),
                          b0(Me[1], A[1], L[1])
                        ) >= Me[2]
                      )
                        return V;
                    }
                    continue;
                  }
                  let J = 0;
                  for (let re = 0; re < this._siblingOffset.length; re++) {
                    w0(
                      (G << 1) + this._siblingOffset[re][0],
                      (K << 1) + this._siblingOffset[re][1],
                      oe + 1,
                      i,
                      o,
                      l,
                      h,
                      A,
                      L
                    ),
                      (A[2] = -100),
                      (L[2] = this.maximums[this.childOffsets[F] + re] * x);
                    const le = v0(A, L, m, _);
                    if (null != le) {
                      const ae = le;
                      T[re] = ae;
                      let De = !1;
                      for (let xe = 0; xe < J && !De; xe++)
                        ae >= T[I[xe]] && (I.splice(xe, 0, re), (De = !0));
                      De || (I[J] = re), J++;
                    }
                  }
                  for (let re = 0; re < J; re++) {
                    const le = I[re];
                    O.push({
                      idx: this.childOffsets[F] + le,
                      t: T[le],
                      nodex: (G << 1) + this._siblingOffset[le][0],
                      nodey: (K << 1) + this._siblingOffset[le][1],
                      depth: oe + 1,
                    });
                  }
                }
                return null;
              }
              _addNode(i, o, l) {
                return (
                  this.minimums.push(i),
                  this.maximums.push(o),
                  this.leaves.push(l),
                  this.childOffsets.push(0),
                  this.nodeCount++
                );
              }
              _construct(i, o, l, h, m) {
                if (1 === i[h].isLeaf(o, l)) return;
                this.childOffsets[m] || (this.childOffsets[m] = this.nodeCount);
                const _ = h - 1,
                  x = i[_];
                let E = 0,
                  T = 0;
                for (let I = 0; I < this._siblingOffset.length; I++) {
                  const A = 2 * o + this._siblingOffset[I][0],
                    L = 2 * l + this._siblingOffset[I][1],
                    O = x.getElevation(A, L),
                    F = x.isLeaf(A, L),
                    V = this._addNode(O.min, O.max, F);
                  F && (E |= 1 << I), T || (T = V);
                }
                for (let I = 0; I < this._siblingOffset.length; I++)
                  E & (1 << I) ||
                    this._construct(
                      i,
                      2 * o + this._siblingOffset[I][0],
                      2 * l + this._siblingOffset[I][1],
                      _,
                      T + I
                    );
              }
            }
            function ll(r, i, o, l, h, m) {
              return ln(ln(r, o, m), ln(i, l, m), h);
            }
            function ga(r, i, o) {
              const l = o.dim,
                h = tn(r * l - 0.5, 0, l - 1),
                m = tn(i * l - 0.5, 0, l - 1),
                _ = Math.floor(h),
                x = Math.floor(m),
                E = Math.min(_ + 1, l - 1),
                T = Math.min(x + 1, l - 1);
              return ll(
                o.get(_, x),
                o.get(E, x),
                o.get(_, T),
                o.get(E, T),
                h - _,
                m - x
              );
            }
            const ay = {
              mapbox: [6553.6, 25.6, 0.1, 1e4],
              terrarium: [256, 1, 1 / 256, 32768],
            };
            function ly(r, i, o) {
              return (256 * r * 256 + 256 * i + o) / 10 - 1e4;
            }
            function rg(r, i, o) {
              return 256 * r + i + o / 256 - 32768;
            }
            class Zd {
              get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
              }
              constructor(i, o, l, h = !1, m = !1) {
                if (((this.uid = i), o.height !== o.width))
                  throw new RangeError("DEM tiles must be square");
                if (l && "mapbox" !== l && "terrarium" !== l)
                  return Wn(
                    `"${l}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`
                  );
                this.stride = o.height;
                const _ = (this.dim = o.height - 2),
                  x = new Uint32Array(o.data.buffer);
                if (
                  ((this.pixels = new Uint8Array(o.data.buffer)),
                  (this.encoding = l || "mapbox"),
                  (this.borderReady = h),
                  !h)
                ) {
                  for (let E = 0; E < _; E++)
                    (x[this._idx(-1, E)] = x[this._idx(0, E)]),
                      (x[this._idx(_, E)] = x[this._idx(_ - 1, E)]),
                      (x[this._idx(E, -1)] = x[this._idx(E, 0)]),
                      (x[this._idx(E, _)] = x[this._idx(E, _ - 1)]);
                  (x[this._idx(-1, -1)] = x[this._idx(0, 0)]),
                    (x[this._idx(_, -1)] = x[this._idx(_ - 1, 0)]),
                    (x[this._idx(-1, _)] = x[this._idx(0, _ - 1)]),
                    (x[this._idx(_, _)] = x[this._idx(_ - 1, _ - 1)]),
                    m && this._buildQuadTree();
                }
              }
              _buildQuadTree() {
                this._tree = new E0(this);
              }
              get(i, o, l = !1) {
                l && ((i = tn(i, -1, this.dim)), (o = tn(o, -1, this.dim)));
                const h = 4 * this._idx(i, o);
                return (
                  "terrarium" === this.encoding ? rg : ly
                )(this.pixels[h], this.pixels[h + 1], this.pixels[h + 2]);
              }
              static getUnpackVector(i) {
                return ay[i];
              }
              get unpackVector() {
                return ay[this.encoding];
              }
              _idx(i, o) {
                if (i < -1 || i >= this.dim + 1 || o < -1 || o >= this.dim + 1)
                  throw new RangeError(
                    "out of range source coordinates for DEM data"
                  );
                return (o + 1) * this.stride + (i + 1);
              }
              static pack(i, o) {
                const l = [0, 0, 0, 0],
                  h = Zd.getUnpackVector(o);
                let m = Math.floor((i + h[3]) / h[2]);
                return (
                  (l[2] = m % 256),
                  (m = Math.floor(m / 256)),
                  (l[1] = m % 256),
                  (m = Math.floor(m / 256)),
                  (l[0] = m),
                  l
                );
              }
              getPixels() {
                return new Qr(
                  { width: this.stride, height: this.stride },
                  this.pixels
                );
              }
              backfillBorder(i, o, l) {
                if (this.dim !== i.dim)
                  throw new Error("dem dimension mismatch");
                let h = o * this.dim,
                  m = o * this.dim + this.dim,
                  _ = l * this.dim,
                  x = l * this.dim + this.dim;
                switch (o) {
                  case -1:
                    h = m - 1;
                    break;
                  case 1:
                    m = h + 1;
                }
                switch (l) {
                  case -1:
                    _ = x - 1;
                    break;
                  case 1:
                    x = _ + 1;
                }
                const E = -o * this.dim,
                  T = -l * this.dim;
                for (let I = _; I < x; I++)
                  for (let A = h; A < m; A++) {
                    const L = 4 * this._idx(A, I),
                      O = 4 * this._idx(A + E, I + T);
                    (this.pixels[L + 0] = i.pixels[O + 0]),
                      (this.pixels[L + 1] = i.pixels[O + 1]),
                      (this.pixels[L + 2] = i.pixels[O + 2]),
                      (this.pixels[L + 3] = i.pixels[O + 3]);
                  }
              }
              onDeserialize() {
                this._tree && (this._tree.dem = this);
              }
            }
            lt(Zd, "DEMData"), lt(E0, "DemMinMaxQuadTree", { omit: ["dem"] });
            class og {
              constructor(i, o) {
                (this.max = i), (this.onRemove = o), this.reset();
              }
              reset() {
                for (const i in this.data)
                  for (const o of this.data[i])
                    o.timeout && clearTimeout(o.timeout),
                      this.onRemove(o.value);
                return (this.data = {}), (this.order = []), this;
              }
              add(i, o, l) {
                const h = i.wrapped().key;
                void 0 === this.data[h] && (this.data[h] = []);
                const m = { value: o, timeout: void 0 };
                if (
                  (void 0 !== l &&
                    (m.timeout = setTimeout(() => {
                      this.remove(i, m);
                    }, l)),
                  this.data[h].push(m),
                  this.order.push(h),
                  this.order.length > this.max)
                ) {
                  const _ = this._getAndRemoveByKey(this.order[0]);
                  _ && this.onRemove(_);
                }
                return this;
              }
              has(i) {
                return i.wrapped().key in this.data;
              }
              getAndRemove(i) {
                return this.has(i)
                  ? this._getAndRemoveByKey(i.wrapped().key)
                  : null;
              }
              _getAndRemoveByKey(i) {
                const o = this.data[i].shift();
                return (
                  o.timeout && clearTimeout(o.timeout),
                  0 === this.data[i].length && delete this.data[i],
                  this.order.splice(this.order.indexOf(i), 1),
                  o.value
                );
              }
              getByKey(i) {
                const o = this.data[i];
                return o ? o[0].value : null;
              }
              get(i) {
                return this.has(i) ? this.data[i.wrapped().key][0].value : null;
              }
              remove(i, o) {
                if (!this.has(i)) return this;
                const l = i.wrapped().key,
                  h = void 0 === o ? 0 : this.data[l].indexOf(o),
                  m = this.data[l][h];
                return (
                  this.data[l].splice(h, 1),
                  m.timeout && clearTimeout(m.timeout),
                  0 === this.data[l].length && delete this.data[l],
                  this.onRemove(m.value),
                  this.order.splice(this.order.indexOf(l), 1),
                  this
                );
              }
              setMaxSize(i) {
                for (this.max = i; this.order.length > this.max; ) {
                  const o = this._getAndRemoveByKey(this.order[0]);
                  o && this.onRemove(o);
                }
                return this;
              }
              filter(i) {
                const o = [];
                for (const l in this.data)
                  for (const h of this.data[l]) i(h.value) || o.push(h);
                for (const l of o) this.remove(l.value.tileID, l);
              }
            }
            class ph {
              constructor(i, o, l) {
                (this.func = i), (this.mask = o), (this.range = l);
              }
            }
            (ph.ReadOnly = !1),
              (ph.ReadWrite = !0),
              (ph.disabled = new ph(519, ph.ReadOnly, [0, 1]));
            class hf {
              constructor(i, o, l, h, m, _) {
                (this.test = i),
                  (this.ref = o),
                  (this.mask = l),
                  (this.fail = h),
                  (this.depthFail = m),
                  (this.pass = _);
              }
            }
            hf.disabled = new hf(
              { func: 519, mask: 0 },
              0,
              0,
              7680,
              7680,
              7680
            );
            class ya {
              constructor(i, o, l) {
                (this.blendFunction = i),
                  (this.blendColor = o),
                  (this.mask = l);
              }
            }
            (ya.Replace = [1, 0]),
              (ya.disabled = new ya(ya.Replace, gi.transparent, [
                !1,
                !1,
                !1,
                !1,
              ])),
              (ya.unblended = new ya(ya.Replace, gi.transparent, [
                !0,
                !0,
                !0,
                !0,
              ])),
              (ya.alphaBlended = new ya([1, 771], gi.transparent, [
                !0,
                !0,
                !0,
                !0,
              ]));
            class Ts {
              constructor(i, o, l) {
                (this.enable = i), (this.mode = o), (this.frontFace = l);
              }
            }
            (Ts.disabled = new Ts(!1, 1029, 2305)),
              (Ts.backCCW = new Ts(!0, 1029, 2305)),
              (Ts.backCW = new Ts(!0, 1029, 2304)),
              (Ts.frontCW = new Ts(!0, 1028, 2304)),
              (Ts.frontCCW = new Ts(!0, 1028, 2305));
            class Xc extends pc {
              constructor(i, o, l) {
                super(),
                  (this.id = i),
                  (this._onlySymbols = l),
                  o.on("data", (h) => {
                    "source" === h.dataType &&
                      "metadata" === h.sourceDataType &&
                      (this._sourceLoaded = !0),
                      this._sourceLoaded &&
                        !this._paused &&
                        "source" === h.dataType &&
                        "content" === h.sourceDataType &&
                        (this.reload(),
                        this.transform && this.update(this.transform));
                  }),
                  o.on("error", () => {
                    this._sourceErrored = !0;
                  }),
                  (this._source = o),
                  (this._tiles = {}),
                  (this._cache = new og(0, this._unloadTile.bind(this))),
                  (this._timers = {}),
                  (this._cacheTimers = {}),
                  (this._minTileCacheSize = o.minTileCacheSize),
                  (this._maxTileCacheSize = o.maxTileCacheSize),
                  (this._loadedParentTiles = {}),
                  (this._coveredTiles = {}),
                  (this._state = new kb()),
                  (this._isRaster =
                    "raster" === this._source.type ||
                    "raster-dem" === this._source.type ||
                    ("custom" === this._source.type &&
                      "raster" === this._source._dataType));
              }
              onAdd(i) {
                (this.map = i),
                  (this._minTileCacheSize =
                    void 0 === this._minTileCacheSize && i
                      ? i._minTileCacheSize
                      : this._minTileCacheSize),
                  (this._maxTileCacheSize =
                    void 0 === this._maxTileCacheSize && i
                      ? i._maxTileCacheSize
                      : this._maxTileCacheSize);
              }
              loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded || !this._source.loaded()) return !1;
                for (const i in this._tiles) {
                  const o = this._tiles[i];
                  if ("loaded" !== o.state && "errored" !== o.state) return !1;
                }
                return !0;
              }
              getSource() {
                return this._source;
              }
              pause() {
                this._paused = !0;
              }
              resume() {
                if (!this._paused) return;
                const i = this._shouldReloadOnResume;
                (this._paused = !1),
                  (this._shouldReloadOnResume = !1),
                  i && this.reload(),
                  this.transform && this.update(this.transform);
              }
              _loadTile(i, o) {
                return (
                  (i.isSymbolTile = this._onlySymbols),
                  this._source.loadTile(i, o)
                );
              }
              _unloadTile(i) {
                if (this._source.unloadTile)
                  return this._source.unloadTile(i, () => {});
              }
              _abortTile(i) {
                if (this._source.abortTile)
                  return this._source.abortTile(i, () => {});
              }
              serialize() {
                return this._source.serialize();
              }
              prepare(i) {
                this._source.prepare && this._source.prepare(),
                  this._state.coalesceChanges(
                    this._tiles,
                    this.map ? this.map.painter : null
                  );
                for (const o in this._tiles) {
                  const l = this._tiles[o];
                  l.upload(i), l.prepare(this.map.style.imageManager);
                }
              }
              getIds() {
                return Rs(this._tiles)
                  .map((i) => i.tileID)
                  .sort(Xd)
                  .map((i) => i.key);
              }
              getRenderableIds(i) {
                const o = [];
                for (const l in this._tiles)
                  this._isIdRenderable(+l, i) && o.push(this._tiles[l]);
                return i
                  ? o
                      .sort((l, h) => {
                        const m = l.tileID,
                          _ = h.tileID,
                          x = new nt(m.canonical.x, m.canonical.y)._rotate(
                            this.transform.angle
                          ),
                          E = new nt(_.canonical.x, _.canonical.y)._rotate(
                            this.transform.angle
                          );
                        return (
                          m.overscaledZ - _.overscaledZ ||
                          E.y - x.y ||
                          E.x - x.x
                        );
                      })
                      .map((l) => l.tileID.key)
                  : o
                      .map((l) => l.tileID)
                      .sort(Xd)
                      .map((l) => l.key);
              }
              hasRenderableParent(i) {
                const o = this.findLoadedParent(i, 0);
                return !!o && this._isIdRenderable(o.tileID.key);
              }
              _isIdRenderable(i, o) {
                return (
                  this._tiles[i] &&
                  this._tiles[i].hasData() &&
                  !this._coveredTiles[i] &&
                  (o || !this._tiles[i].holdingForFade())
                );
              }
              reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                  this._cache.reset();
                  for (const i in this._tiles)
                    "errored" !== this._tiles[i].state &&
                      this._reloadTile(+i, "reloading");
                }
              }
              _reloadTile(i, o) {
                const l = this._tiles[i];
                l &&
                  ("loading" !== l.state && (l.state = o),
                  this._loadTile(l, this._tileLoaded.bind(this, l, i, o)));
              }
              _tileLoaded(i, o, l, h) {
                if (h)
                  if (((i.state = "errored"), 404 !== h.status))
                    this._source.fire(new us(h, { tile: i }));
                  else if (
                    "raster-dem" === this._source.type &&
                    this.usedForTerrain &&
                    this.map.painter.terrain
                  ) {
                    const m = this.map.painter.terrain;
                    this.update(this.transform, m.getScaledDemTileSize(), !0),
                      m.resetTileLookupCache(this.id);
                  } else this.update(this.transform);
                else
                  (i.timeAdded = cs.now()),
                    "expired" === l && (i.refreshedUponExpiration = !0),
                    this._setTileReloadTimer(o, i),
                    "raster-dem" === this._source.type &&
                      i.dem &&
                      this._backfillDEM(i),
                    this._state.initializeTileState(
                      i,
                      this.map ? this.map.painter : null
                    ),
                    this._source.fire(
                      new Ra("data", {
                        dataType: "source",
                        tile: i,
                        coord: i.tileID,
                        sourceCacheId: this.id,
                      })
                    );
              }
              _backfillDEM(i) {
                const o = this.getRenderableIds();
                for (let h = 0; h < o.length; h++) {
                  const m = o[h];
                  if (i.neighboringTiles && i.neighboringTiles[m]) {
                    const _ = this.getTileByID(m);
                    l(i, _), l(_, i);
                  }
                }
                function l(h, m) {
                  if (!h.dem || h.dem.borderReady) return;
                  (h.needsHillshadePrepare = !0),
                    (h.needsDEMTextureUpload = !0);
                  let _ = m.tileID.canonical.x - h.tileID.canonical.x;
                  const x = m.tileID.canonical.y - h.tileID.canonical.y,
                    E = Math.pow(2, h.tileID.canonical.z),
                    T = m.tileID.key;
                  (0 === _ && 0 === x) ||
                    Math.abs(x) > 1 ||
                    (Math.abs(_) > 1 &&
                      (1 === Math.abs(_ + E)
                        ? (_ += E)
                        : 1 === Math.abs(_ - E) && (_ -= E)),
                    m.dem &&
                      h.dem &&
                      (h.dem.backfillBorder(m.dem, _, x),
                      h.neighboringTiles &&
                        h.neighboringTiles[T] &&
                        (h.neighboringTiles[T].backfilled = !0)));
                }
              }
              getTile(i) {
                return this.getTileByID(i.key);
              }
              getTileByID(i) {
                return this._tiles[i];
              }
              _retainLoadedChildren(i, o, l, h) {
                for (const m in this._tiles) {
                  let _ = this._tiles[m];
                  if (
                    h[m] ||
                    !_.hasData() ||
                    _.tileID.overscaledZ <= o ||
                    _.tileID.overscaledZ > l
                  )
                    continue;
                  let x = _.tileID;
                  for (; _ && _.tileID.overscaledZ > o + 1; ) {
                    const T = _.tileID.scaledTo(_.tileID.overscaledZ - 1);
                    (_ = this._tiles[T.key]), _ && _.hasData() && (x = T);
                  }
                  let E = x;
                  for (; E.overscaledZ > o; )
                    if (((E = E.scaledTo(E.overscaledZ - 1)), i[E.key])) {
                      h[x.key] = x;
                      break;
                    }
                }
              }
              findLoadedParent(i, o) {
                if (i.key in this._loadedParentTiles) {
                  const l = this._loadedParentTiles[i.key];
                  return l && l.tileID.overscaledZ >= o ? l : null;
                }
                for (let l = i.overscaledZ - 1; l >= o; l--) {
                  const h = i.scaledTo(l),
                    m = this._getLoadedTile(h);
                  if (m) return m;
                }
              }
              _getLoadedTile(i) {
                const o = this._tiles[i.key];
                return o && o.hasData()
                  ? o
                  : this._cache.getByKey(
                      this._source.reparseOverscaled
                        ? i.wrapped().key
                        : i.canonical.key
                    );
              }
              updateCacheSize(i, o) {
                o = o || this._source.tileSize;
                const l = Math.ceil(i.width / o) + 1,
                  h = Math.ceil(i.height / o) + 1,
                  m = Math.floor(l * h * 5),
                  _ =
                    "number" == typeof this._minTileCacheSize
                      ? Math.max(this._minTileCacheSize, m)
                      : m,
                  x =
                    "number" == typeof this._maxTileCacheSize
                      ? Math.min(this._maxTileCacheSize, _)
                      : _;
                this._cache.setMaxSize(x);
              }
              handleWrapJump(i) {
                const o = Math.round(
                  (i - (void 0 === this._prevLng ? i : this._prevLng)) / 360
                );
                if (((this._prevLng = i), o)) {
                  const l = {};
                  for (const h in this._tiles) {
                    const m = this._tiles[h];
                    (m.tileID = m.tileID.unwrapTo(m.tileID.wrap + o)),
                      (l[m.tileID.key] = m);
                  }
                  this._tiles = l;
                  for (const h in this._timers)
                    clearTimeout(this._timers[h]), delete this._timers[h];
                  for (const h in this._tiles)
                    this._setTileReloadTimer(+h, this._tiles[h]);
                }
              }
              update(i, o, l) {
                if (
                  ((this.transform = i),
                  !this._sourceLoaded ||
                    this._paused ||
                    this.transform.freezeTileCoverage ||
                    (this.usedForTerrain && !l))
                )
                  return;
                let h;
                this.updateCacheSize(i, o),
                  "globe" !== this.transform.projection.name &&
                    this.handleWrapJump(this.transform.center.lng),
                  (this._coveredTiles = {}),
                  this.used || this.usedForTerrain
                    ? this._source.tileID
                      ? (h = i
                          .getVisibleUnwrappedCoordinates(this._source.tileID)
                          .map(
                            (x) =>
                              new Br(
                                x.canonical.z,
                                x.wrap,
                                x.canonical.z,
                                x.canonical.x,
                                x.canonical.y
                              )
                          ))
                      : ((h = i.coveringTiles({
                          tileSize: o || this._source.tileSize,
                          minzoom: this._source.minzoom,
                          maxzoom: this._source.maxzoom,
                          roundZoom: this._source.roundZoom && !l,
                          reparseOverscaled: this._source.reparseOverscaled,
                          isTerrainDEM: this.usedForTerrain,
                        })),
                        this._source.hasTile &&
                          (h = h.filter((x) => this._source.hasTile(x))))
                    : (h = []);
                const m = this._updateRetainedTiles(h);
                if (Kc(this._source.type) && 0 !== h.length) {
                  const x = {},
                    E = {},
                    T = Object.keys(m);
                  for (const A of T) {
                    const L = m[A],
                      O = this._tiles[A];
                    if (!O || (O.fadeEndTime && O.fadeEndTime <= cs.now()))
                      continue;
                    const F = this.findLoadedParent(
                      L,
                      Math.max(
                        L.overscaledZ - Xc.maxOverzooming,
                        this._source.minzoom
                      )
                    );
                    F &&
                      (this._addTile(F.tileID), (x[F.tileID.key] = F.tileID)),
                      (E[A] = L);
                  }
                  const I = h[h.length - 1].overscaledZ;
                  for (const A in this._tiles) {
                    const L = this._tiles[A];
                    if (m[A] || !L.hasData()) continue;
                    let O = L.tileID;
                    for (; O.overscaledZ > I; ) {
                      O = O.scaledTo(O.overscaledZ - 1);
                      const F = this._tiles[O.key];
                      if (F && F.hasData() && E[O.key]) {
                        m[A] = L.tileID;
                        break;
                      }
                    }
                  }
                  for (const A in x)
                    m[A] || ((this._coveredTiles[A] = !0), (m[A] = x[A]));
                }
                for (const x in m) this._tiles[x].clearFadeHold();
                const _ = (function (x, E) {
                  const T = [];
                  for (const I in x) I in E || T.push(I);
                  return T;
                })(this._tiles, m);
                for (const x of _) {
                  const E = this._tiles[x];
                  E.hasSymbolBuckets && !E.holdingForFade()
                    ? E.setHoldDuration(this.map._fadeDuration)
                    : (E.hasSymbolBuckets && !E.symbolFadeFinished()) ||
                      this._removeTile(+x);
                }
                this._updateLoadedParentTileCache(),
                  this._onlySymbols &&
                    this._source.afterUpdate &&
                    this._source.afterUpdate();
              }
              releaseSymbolFadeTiles() {
                for (const i in this._tiles)
                  this._tiles[i].holdingForFade() && this._removeTile(+i);
              }
              _updateRetainedTiles(i) {
                const o = {};
                if (0 === i.length) return o;
                const l = {},
                  h = i.reduce((T, I) => Math.min(T, I.overscaledZ), 1 / 0),
                  m = i[0].overscaledZ,
                  _ = Math.max(m - Xc.maxOverzooming, this._source.minzoom),
                  x = Math.max(m + Xc.maxUnderzooming, this._source.minzoom),
                  E = {};
                for (const T of i) {
                  const I = this._addTile(T);
                  (o[T.key] = T),
                    I.hasData() || (h < this._source.maxzoom && (E[T.key] = T));
                }
                this._retainLoadedChildren(E, h, x, o);
                for (const T of i) {
                  let I = this._tiles[T.key];
                  if (I.hasData()) continue;
                  if (T.canonical.z >= this._source.maxzoom) {
                    const L = T.children(this._source.maxzoom)[0],
                      O = this.getTile(L);
                    if (O && O.hasData()) {
                      o[L.key] = L;
                      continue;
                    }
                  } else {
                    const L = T.children(this._source.maxzoom);
                    if (
                      o[L[0].key] &&
                      o[L[1].key] &&
                      o[L[2].key] &&
                      o[L[3].key]
                    )
                      continue;
                  }
                  let A = I.wasRequested();
                  for (let L = T.overscaledZ - 1; L >= _; --L) {
                    const O = T.scaledTo(L);
                    if (
                      l[O.key] ||
                      ((l[O.key] = !0),
                      (I = this.getTile(O)),
                      !I && A && (I = this._addTile(O)),
                      I &&
                        ((o[O.key] = O), (A = I.wasRequested()), I.hasData()))
                    )
                      break;
                  }
                }
                return o;
              }
              _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for (const i in this._tiles) {
                  const o = [];
                  let l,
                    h = this._tiles[i].tileID;
                  for (; h.overscaledZ > 0; ) {
                    if (h.key in this._loadedParentTiles) {
                      l = this._loadedParentTiles[h.key];
                      break;
                    }
                    o.push(h.key);
                    const m = h.scaledTo(h.overscaledZ - 1);
                    if (((l = this._getLoadedTile(m)), l)) break;
                    h = m;
                  }
                  for (const m of o) this._loadedParentTiles[m] = l;
                }
              }
              _addTile(i) {
                let o = this._tiles[i.key];
                if (o) return o;
                (o = this._cache.getAndRemove(i)),
                  o &&
                    (this._setTileReloadTimer(i.key, o),
                    (o.tileID = i),
                    this._state.initializeTileState(
                      o,
                      this.map ? this.map.painter : null
                    ),
                    this._cacheTimers[i.key] &&
                      (clearTimeout(this._cacheTimers[i.key]),
                      delete this._cacheTimers[i.key],
                      this._setTileReloadTimer(i.key, o)));
                const l = Boolean(o);
                if (!l) {
                  const h = this.map ? this.map.painter : null;
                  (o = new sy(
                    i,
                    this._source.tileSize * i.overscaleFactor(),
                    this.transform.tileZoom,
                    h,
                    this._isRaster
                  )),
                    this._loadTile(
                      o,
                      this._tileLoaded.bind(this, o, i.key, o.state)
                    );
                }
                return o
                  ? (o.uses++,
                    (this._tiles[i.key] = o),
                    l ||
                      this._source.fire(
                        new Ra("dataloading", {
                          tile: o,
                          coord: o.tileID,
                          dataType: "source",
                        })
                      ),
                    o)
                  : null;
              }
              _setTileReloadTimer(i, o) {
                i in this._timers &&
                  (clearTimeout(this._timers[i]), delete this._timers[i]);
                const l = o.getExpiryTimeout();
                l &&
                  (this._timers[i] = setTimeout(() => {
                    this._reloadTile(i, "expired"), delete this._timers[i];
                  }, l));
              }
              _removeTile(i) {
                const o = this._tiles[i];
                o &&
                  (o.uses--,
                  delete this._tiles[i],
                  this._timers[i] &&
                    (clearTimeout(this._timers[i]), delete this._timers[i]),
                  o.uses > 0 ||
                    (o.hasData() && "reloading" !== o.state
                      ? this._cache.add(o.tileID, o, o.getExpiryTimeout())
                      : ((o.aborted = !0),
                        this._abortTile(o),
                        this._unloadTile(o))));
              }
              clearTiles() {
                (this._shouldReloadOnResume = !1), (this._paused = !1);
                for (const i in this._tiles) this._removeTile(+i);
                this._source._clear && this._source._clear(),
                  this._cache.reset(),
                  this.map &&
                    this.usedForTerrain &&
                    this.map.painter.terrain &&
                    this.map.painter.terrain.resetTileLookupCache(this.id);
              }
              tilesIn(i, o, l) {
                const h = [],
                  m = this.transform;
                if (!m) return h;
                const _ = "globe" === m.projection.name,
                  x = ua(m.center.lng);
                for (const E in this._tiles) {
                  const T = this._tiles[E];
                  if ((l && T.clearQueryDebugViz(), T.holdingForFade()))
                    continue;
                  let I;
                  if (_) {
                    const A = T.tileID.canonical;
                    if (0 === A.z) {
                      const L = [
                        Math.abs(tn(x, ...Yc(A, -1)) - x),
                        Math.abs(tn(x, ...Yc(A, 1)) - x),
                      ];
                      I = [0, 2 * L.indexOf(Math.min(...L)) - 1];
                    } else {
                      const L = [
                        Math.abs(tn(x, ...Yc(A, -1)) - x),
                        Math.abs(tn(x, ...Yc(A, 0)) - x),
                        Math.abs(tn(x, ...Yc(A, 1)) - x),
                      ];
                      I = [L.indexOf(Math.min(...L)) - 1];
                    }
                  } else I = [0];
                  for (const A of I) {
                    const L = i.containsTile(T, m, o, A);
                    L && h.push(L);
                  }
                }
                return h;
              }
              getVisibleCoordinates(i) {
                const o = this.getRenderableIds(i).map(
                  (l) => this._tiles[l].tileID
                );
                for (const l of o)
                  l.projMatrix = this.transform.calculateProjMatrix(
                    l.toUnwrapped()
                  );
                return o;
              }
              hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (Kc(this._source.type))
                  for (const i in this._tiles) {
                    const o = this._tiles[i];
                    if (void 0 !== o.fadeEndTime && o.fadeEndTime >= cs.now())
                      return !0;
                  }
                return !1;
              }
              setFeatureState(i, o, l) {
                this._state.updateState((i = i || "_geojsonTileLayer"), o, l);
              }
              removeFeatureState(i, o, l) {
                this._state.removeFeatureState(
                  (i = i || "_geojsonTileLayer"),
                  o,
                  l
                );
              }
              getFeatureState(i, o) {
                return this._state.getState((i = i || "_geojsonTileLayer"), o);
              }
              setDependencies(i, o, l) {
                const h = this._tiles[i];
                h && h.setDependencies(o, l);
              }
              reloadTilesForDependencies(i, o) {
                for (const l in this._tiles)
                  this._tiles[l].hasDependency(i, o) &&
                    this._reloadTile(+l, "reloading");
                this._cache.filter((l) => !l.hasDependency(i, o));
              }
              _preloadTiles(i, o) {
                if (!this._sourceLoaded) {
                  const x = () => {
                    this._sourceLoaded &&
                      (this._source.off("data", x), this._preloadTiles(i, o));
                  };
                  return void this._source.on("data", x);
                }
                const l = new Map(),
                  h = Array.isArray(i) ? i : [i],
                  m = this.map.painter.terrain,
                  _ =
                    this.usedForTerrain && m
                      ? m.getScaledDemTileSize()
                      : this._source.tileSize;
                for (const x of h) {
                  const E = x.coveringTiles({
                    tileSize: _,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !this.usedForTerrain,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain,
                  });
                  for (const T of E) l.set(T.key, T);
                  this.usedForTerrain && x.updateElevation(!1);
                }
                Ai(
                  Array.from(l.values()),
                  (x, E) => {
                    const T = new sy(
                      x,
                      this._source.tileSize * x.overscaleFactor(),
                      this.transform.tileZoom,
                      this.map.painter,
                      this._isRaster
                    );
                    this._loadTile(T, (I) => {
                      "raster-dem" === this._source.type &&
                        T.dem &&
                        this._backfillDEM(T),
                        E(I, T);
                    });
                  },
                  o
                );
              }
            }
            function Xd(r, i) {
              const o = Math.abs(2 * r.wrap) - +(r.wrap < 0),
                l = Math.abs(2 * i.wrap) - +(i.wrap < 0);
              return (
                r.overscaledZ - i.overscaledZ ||
                l - o ||
                i.canonical.y - r.canonical.y ||
                i.canonical.x - r.canonical.x
              );
            }
            function Kc(r) {
              return (
                "raster" === r ||
                "image" === r ||
                "video" === r ||
                "custom" === r
              );
            }
            function Yc(r, i) {
              const o = 1 << r.z;
              return [r.x / o + i, (r.x + 1) / o + i];
            }
            (Xc.maxOverzooming = 10), (Xc.maxUnderzooming = 3);
            class cl {
              constructor(i, o, l) {
                (this._demTile = i),
                  (this._dem = this._demTile.dem),
                  (this._scale = o),
                  (this._offset = l);
              }
              static create(i, o, l) {
                const h = l || i.findDEMTileFor(o);
                if (!h || !h.dem) return;
                const m = h.dem,
                  _ = h.tileID,
                  x = 1 << (o.canonical.z - _.canonical.z);
                return new cl(h, h.tileSize / wt / x, [
                  (o.canonical.x / x - _.canonical.x) * m.dim,
                  (o.canonical.y / x - _.canonical.y) * m.dim,
                ]);
              }
              tileCoordToPixel(i, o) {
                const l = o * this._scale + this._offset[1],
                  h = Math.floor(i * this._scale + this._offset[0]),
                  m = Math.floor(l);
                return new nt(h, m);
              }
              getElevationAt(i, o, l, h) {
                const m = i * this._scale + this._offset[0],
                  _ = o * this._scale + this._offset[1],
                  x = Math.floor(m),
                  E = Math.floor(_),
                  T = this._dem;
                return (
                  (h = !!h),
                  l
                    ? ln(
                        ln(T.get(x, E, h), T.get(x, E + 1, h), _ - E),
                        ln(T.get(x + 1, E, h), T.get(x + 1, E + 1, h), _ - E),
                        m - x
                      )
                    : T.get(x, E, h)
                );
              }
              getElevationAtPixel(i, o, l) {
                return this._dem.get(i, o, !!l);
              }
              getMeterToDEM(i) {
                return (
                  (1 << this._demTile.tileID.canonical.z) *
                  Ao(1, i) *
                  this._dem.stride
                );
              }
            }
            class pf {
              constructor(i, o) {
                (this.tileID = i),
                  (this.x = i.canonical.x),
                  (this.y = i.canonical.y),
                  (this.z = i.canonical.z),
                  (this.grid = new Js(wt, 16, 0)),
                  (this.featureIndexArray = new Bl()),
                  (this.promoteId = o);
              }
              insert(i, o, l, h, m, _ = 0) {
                const x = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(l, h, m, _);
                const E = this.grid;
                for (let T = 0; T < o.length; T++) {
                  const I = o[T],
                    A = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (let L = 0; L < I.length; L++) {
                    const O = I[L];
                    (A[0] = Math.min(A[0], O.x)),
                      (A[1] = Math.min(A[1], O.y)),
                      (A[2] = Math.max(A[2], O.x)),
                      (A[3] = Math.max(A[3], O.y));
                  }
                  A[0] < wt &&
                    A[1] < wt &&
                    A[2] >= 0 &&
                    A[3] >= 0 &&
                    E.insert(x, A[0], A[1], A[2], A[3]);
                }
              }
              loadVTLayers() {
                if (!this.vtLayers) {
                  (this.vtLayers = new Zp(new kd(this.rawTileData)).layers),
                    (this.sourceLayerCoder = new oy(
                      this.vtLayers
                        ? Object.keys(this.vtLayers).sort()
                        : ["_geojsonTileLayer"]
                    )),
                    (this.vtFeatures = {});
                  for (const i in this.vtLayers) this.vtFeatures[i] = [];
                }
                return this.vtLayers;
              }
              query(i, o, l, h) {
                this.loadVTLayers();
                const m = i.params || {},
                  _ = Pu(m.filter),
                  x = i.tileResult,
                  E = i.transform,
                  T = x.bufferedTilespaceBounds,
                  I = this.grid.query(
                    T.min.x,
                    T.min.y,
                    T.max.x,
                    T.max.y,
                    (F, V, G, K) => pm(x.bufferedTilespaceGeometry, F, V, G, K)
                  );
                I.sort(cy);
                let A = null;
                E.elevation &&
                  I.length > 0 &&
                  (A = cl.create(E.elevation, this.tileID));
                const L = {};
                let O;
                for (let F = 0; F < I.length; F++) {
                  const V = I[F];
                  if (V === O) continue;
                  O = V;
                  const G = this.featureIndexArray.get(V);
                  let K = null;
                  this.loadMatchingFeature(
                    L,
                    G,
                    _,
                    m.layers,
                    m.availableImages,
                    o,
                    l,
                    h,
                    (oe, J, re, le = 0) => (
                      K || (K = el(oe, this.tileID.canonical, i.tileTransform)),
                      J.queryIntersectsFeature(
                        x,
                        oe,
                        re,
                        K,
                        this.z,
                        i.transform,
                        i.pixelPosMatrix,
                        A,
                        le
                      )
                    )
                  );
                }
                return L;
              }
              loadMatchingFeature(i, o, l, h, m, _, x, E, T) {
                const {
                    featureIndex: I,
                    bucketIndex: A,
                    sourceLayerIndex: L,
                    layoutVertexArrayOffset: O,
                  } = o,
                  F = this.bucketLayerIDs[A];
                if (
                  h &&
                  !(function (oe, J) {
                    for (let re = 0; re < oe.length; re++)
                      if (J.indexOf(oe[re]) >= 0) return !0;
                    return !1;
                  })(h, F)
                )
                  return;
                const V = this.sourceLayerCoder.decode(L),
                  G = this.vtLayers[V].feature(I);
                if (l.needGeometry) {
                  const oe = tl(G, !0);
                  if (
                    !l.filter(
                      new M(this.tileID.overscaledZ),
                      oe,
                      this.tileID.canonical
                    )
                  )
                    return;
                } else if (!l.filter(new M(this.tileID.overscaledZ), G)) return;
                const K = this.getId(G, V);
                for (let oe = 0; oe < F.length; oe++) {
                  const J = F[oe];
                  if (h && h.indexOf(J) < 0) continue;
                  const re = _[J];
                  if (!re) continue;
                  let le = {};
                  void 0 !== K &&
                    E &&
                    (le = E.getState(re.sourceLayer || "_geojsonTileLayer", K));
                  const ae = pi({}, x[J]);
                  (ae.paint = Kd(ae.paint, re.paint, G, le, m)),
                    (ae.layout = Kd(ae.layout, re.layout, G, le, m));
                  const De = !T || T(G, re, le, O);
                  if (!De) continue;
                  const xe = new ig(G, this.z, this.x, this.y, K);
                  xe.layer = ae;
                  let Pe = i[J];
                  void 0 === Pe && (Pe = i[J] = []),
                    Pe.push({
                      featureIndex: I,
                      feature: xe,
                      intersectionZ: De,
                    });
                }
              }
              lookupSymbolFeatures(i, o, l, h, m, _, x, E) {
                const T = {};
                this.loadVTLayers();
                const I = Pu(m);
                for (const A of i)
                  this.loadMatchingFeature(
                    T,
                    {
                      bucketIndex: l,
                      sourceLayerIndex: h,
                      featureIndex: A,
                      layoutVertexArrayOffset: 0,
                    },
                    I,
                    _,
                    x,
                    E,
                    o
                  );
                return T;
              }
              loadFeature(i) {
                const { featureIndex: o, sourceLayerIndex: l } = i;
                this.loadVTLayers();
                const h = this.sourceLayerCoder.decode(l),
                  m = this.vtFeatures[h];
                if (m[o]) return m[o];
                const _ = this.vtLayers[h].feature(o);
                return (m[o] = _), _;
              }
              hasLayer(i) {
                for (const o of this.bucketLayerIDs)
                  for (const l of o) if (i === l) return !0;
                return !1;
              }
              getId(i, o) {
                let l = i.id;
                if (this.promoteId) {
                  const h =
                    "string" == typeof this.promoteId
                      ? this.promoteId
                      : this.promoteId[o];
                  null != h && (l = i.properties[h]),
                    "boolean" == typeof l && (l = Number(l));
                }
                return l;
              }
            }
            function Kd(r, i, o, l, h) {
              return rn(r, (m, _) => {
                const x = i instanceof Y ? i.get(_) : null;
                return x && x.evaluate ? x.evaluate(o, l, h) : x;
              });
            }
            function cy(r, i) {
              return i - r;
            }
            lt(pf, "FeatureIndex", {
              omit: ["rawTileData", "sourceLayerCoder"],
            });
            class ag {
              constructor(i, o) {
                (this.width = i),
                  (this.height = o),
                  (this.nextRow = 0),
                  (this.image = new Yr({ width: i, height: o })),
                  (this.positions = {}),
                  (this.uploaded = !1);
              }
              getDash(i, o) {
                const l = this.getKey(i, o);
                return this.positions[l];
              }
              trim() {
                const i = this.width,
                  o = (this.height = ss(this.nextRow));
                this.image.resize({ width: i, height: o });
              }
              getKey(i, o) {
                return i.join(",") + o;
              }
              getDashRanges(i, o, l) {
                const h = [];
                let m = i.length % 2 == 1 ? -i[i.length - 1] * l : 0,
                  _ = i[0] * l,
                  x = !0;
                h.push({
                  left: m,
                  right: _,
                  isDash: x,
                  zeroLength: 0 === i[0],
                });
                let E = i[0];
                for (let T = 1; T < i.length; T++) {
                  x = !x;
                  const I = i[T];
                  (m = E * l),
                    (E += I),
                    (_ = E * l),
                    h.push({
                      left: m,
                      right: _,
                      isDash: x,
                      zeroLength: 0 === I,
                    });
                }
                return h;
              }
              addRoundDash(i, o, l) {
                const h = o / 2;
                for (let m = -l; m <= l; m++) {
                  const _ = this.width * (this.nextRow + l + m);
                  let x = 0,
                    E = i[x];
                  for (let T = 0; T < this.width; T++) {
                    T / E.right > 1 && (E = i[++x]);
                    const I = Math.abs(T - E.left),
                      A = Math.abs(T - E.right),
                      L = Math.min(I, A);
                    let O;
                    const F = (m / l) * (h + 1);
                    if (E.isDash) {
                      const V = h - Math.abs(F);
                      O = Math.sqrt(L * L + V * V);
                    } else O = h - Math.sqrt(L * L + F * F);
                    this.image.data[_ + T] = Math.max(
                      0,
                      Math.min(255, O + 128)
                    );
                  }
                }
              }
              addRegularDash(i, o) {
                for (let E = i.length - 1; E >= 0; --E) {
                  const T = i[E],
                    I = i[E + 1];
                  T.zeroLength
                    ? i.splice(E, 1)
                    : I &&
                      I.isDash === T.isDash &&
                      ((I.left = T.left), i.splice(E, 1));
                }
                const l = i[0],
                  h = i[i.length - 1];
                l.isDash === h.isDash &&
                  ((l.left = h.left - this.width),
                  (h.right = l.right + this.width));
                const m = this.width * this.nextRow;
                let _ = 0,
                  x = i[_];
                for (let E = 0; E < this.width; E++) {
                  E / x.right > 1 && (x = i[++_]);
                  const T = Math.abs(E - x.left),
                    I = Math.abs(E - x.right),
                    A = Math.min(T, I);
                  this.image.data[m + E] = Math.max(
                    0,
                    Math.min(255, (x.isDash ? A : -A) + o + 128)
                  );
                }
              }
              addDash(i, o) {
                const l = this.getKey(i, o);
                if (this.positions[l]) return this.positions[l];
                const h = "round" === o,
                  m = h ? 7 : 0,
                  _ = 2 * m + 1;
                if (this.nextRow + _ > this.height)
                  return Wn("LineAtlas out of space"), null;
                0 === i.length && i.push(1);
                let x = 0;
                for (let I = 0; I < i.length; I++)
                  i[I] < 0 &&
                    (Wn(
                      "Negative value is found in line dasharray, replacing values with 0"
                    ),
                    (i[I] = 0)),
                    (x += i[I]);
                if (0 !== x) {
                  const I = this.width / x,
                    A = this.getDashRanges(i, this.width, I);
                  h
                    ? this.addRoundDash(A, I, m)
                    : this.addRegularDash(A, "square" === o ? 0.5 * I : 0);
                }
                const E = this.nextRow + m;
                this.nextRow += _;
                const T = { tl: [E, m], br: [x, 0] };
                return (this.positions[l] = T), T;
              }
            }
            lt(ag, "LineAtlas");
            class mf {
              constructor(i) {
                const o = {},
                  l = [];
                for (const x in i) {
                  const E = i[x],
                    T = (o[x] = {});
                  for (const I in E.glyphs) {
                    const A = E.glyphs[+I];
                    if (!A || 0 === A.bitmap.width || 0 === A.bitmap.height)
                      continue;
                    const L = A.metrics.localGlyph ? 2 : 1,
                      O = {
                        x: 0,
                        y: 0,
                        w: A.bitmap.width + 2 * L,
                        h: A.bitmap.height + 2 * L,
                      };
                    l.push(O), (T[I] = O);
                  }
                }
                const { w: h, h: m } = Rd(l),
                  _ = new Yr({ width: h || 1, height: m || 1 });
                for (const x in i) {
                  const E = i[x];
                  for (const T in E.glyphs) {
                    const I = E.glyphs[+T];
                    if (!I || 0 === I.bitmap.width || 0 === I.bitmap.height)
                      continue;
                    const A = o[x][T],
                      L = I.metrics.localGlyph ? 2 : 1;
                    Yr.copy(
                      I.bitmap,
                      _,
                      { x: 0, y: 0 },
                      { x: A.x + L, y: A.y + L },
                      I.bitmap
                    );
                  }
                }
                (this.image = _), (this.positions = o);
              }
            }
            lt(mf, "GlyphAtlas");
            class uy {
              constructor(i) {
                (this.tileID = new Br(
                  i.tileID.overscaledZ,
                  i.tileID.wrap,
                  i.tileID.canonical.z,
                  i.tileID.canonical.x,
                  i.tileID.canonical.y
                )),
                  (this.tileZoom = i.tileZoom),
                  (this.uid = i.uid),
                  (this.zoom = i.zoom),
                  (this.canonical = i.tileID.canonical),
                  (this.pixelRatio = i.pixelRatio),
                  (this.tileSize = i.tileSize),
                  (this.source = i.source),
                  (this.overscaling = this.tileID.overscaleFactor()),
                  (this.showCollisionBoxes = i.showCollisionBoxes),
                  (this.collectResourceTiming = !!i.collectResourceTiming),
                  (this.returnDependencies = !!i.returnDependencies),
                  (this.promoteId = i.promoteId),
                  (this.enableTerrain = !!i.enableTerrain),
                  (this.isSymbolTile = i.isSymbolTile),
                  (this.tileTransform = qc(i.tileID.canonical, i.projection)),
                  (this.projection = i.projection);
              }
              parse(i, o, l, h, m) {
                (this.status = "parsing"),
                  (this.data = i),
                  (this.collisionBoxArray = new Pn());
                const _ = new oy(Object.keys(i.layers).sort()),
                  x = new pf(this.tileID, this.promoteId);
                x.bucketLayerIDs = [];
                const E = {},
                  T = new ag(256, 256),
                  I = {
                    featureIndex: x,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: T,
                    availableImages: l,
                  },
                  A = o.familiesBySource[this.source];
                for (const le in A) {
                  const ae = i.layers[le];
                  if (!ae) continue;
                  let De = !1,
                    xe = !1;
                  for (const Ie of A[le])
                    "symbol" === Ie[0].type ? (De = !0) : (xe = !0);
                  if (
                    (!0 === this.isSymbolTile && !De) ||
                    (!1 === this.isSymbolTile && !xe)
                  )
                    continue;
                  1 === ae.version &&
                    Wn(
                      `Vector tile source "${this.source}" layer "${le}" does not use vector tile spec v2 and therefore may have some rendering errors.`
                    );
                  const Pe = _.encode(le),
                    $e = [];
                  for (let Ie = 0; Ie < ae.length; Ie++) {
                    const Fe = ae.feature(Ie),
                      Re = x.getId(Fe, le);
                    $e.push({
                      feature: Fe,
                      id: Re,
                      index: Ie,
                      sourceLayerIndex: Pe,
                    });
                  }
                  for (const Ie of A[le]) {
                    const Fe = Ie[0];
                    (void 0 !== this.isSymbolTile &&
                      ("symbol" === Fe.type) !== this.isSymbolTile) ||
                      (Fe.minzoom && this.zoom < Math.floor(Fe.minzoom)) ||
                      (Fe.maxzoom && this.zoom >= Fe.maxzoom) ||
                      ("none" !== Fe.visibility &&
                        (Yd(Ie, this.zoom, l),
                        (E[Fe.id] = Fe.createBucket({
                          index: x.bucketLayerIDs.length,
                          layers: Ie,
                          zoom: this.zoom,
                          canonical: this.canonical,
                          pixelRatio: this.pixelRatio,
                          overscaling: this.overscaling,
                          collisionBoxArray: this.collisionBoxArray,
                          sourceLayerIndex: Pe,
                          sourceID: this.source,
                          enableTerrain: this.enableTerrain,
                          projection: this.projection.spec,
                          availableImages: l,
                        })).populate(
                          $e,
                          I,
                          this.tileID.canonical,
                          this.tileTransform
                        ),
                        x.bucketLayerIDs.push(Ie.map((Re) => Re.id))));
                  }
                }
                let L, O, F, V;
                T.trim();
                const G = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom,
                  },
                  K = () => {
                    if (L) return m(L);
                    if (O && F && V) {
                      const le = new mf(O),
                        ae = new Uc(F, V);
                      for (const De in E) {
                        const xe = E[De];
                        xe instanceof fa
                          ? (Yd(xe.layers, this.zoom, l),
                            Hc(
                              xe,
                              O,
                              le.positions,
                              F,
                              ae.iconPositions,
                              this.showCollisionBoxes,
                              l,
                              this.tileID.canonical,
                              this.tileZoom,
                              this.projection
                            ))
                          : xe.hasPattern &&
                            (xe instanceof Ad ||
                              xe instanceof Wp ||
                              xe instanceof Yp) &&
                            (Yd(xe.layers, this.zoom, l),
                            xe.addFeatures(
                              I,
                              this.tileID.canonical,
                              ae.patternPositions,
                              l,
                              this.tileTransform
                            ));
                      }
                      (this.status = "done"),
                        m(null, {
                          buckets: Rs(E).filter((De) => !De.isEmpty()),
                          featureIndex: x,
                          collisionBoxArray: this.collisionBoxArray,
                          glyphAtlasImage: le.image,
                          lineAtlas: T,
                          imageAtlas: ae,
                          glyphMap: this.returnDependencies ? O : null,
                          iconMap: this.returnDependencies ? F : null,
                          glyphPositions: this.returnDependencies
                            ? le.positions
                            : null,
                        });
                    }
                  },
                  oe = rn(I.glyphDependencies, (le) =>
                    Object.keys(le).map(Number)
                  );
                Object.keys(oe).length
                  ? h.send(
                      "getGlyphs",
                      { uid: this.uid, stacks: oe },
                      (le, ae) => {
                        L || ((L = le), (O = ae), K());
                      },
                      void 0,
                      !1,
                      G
                    )
                  : (O = {});
                const J = Object.keys(I.iconDependencies);
                J.length
                  ? h.send(
                      "getImages",
                      {
                        icons: J,
                        source: this.source,
                        tileID: this.tileID,
                        type: "icons",
                      },
                      (le, ae) => {
                        L || ((L = le), (F = ae), K());
                      },
                      void 0,
                      !1,
                      G
                    )
                  : (F = {});
                const re = Object.keys(I.patternDependencies);
                re.length
                  ? h.send(
                      "getImages",
                      {
                        icons: re,
                        source: this.source,
                        tileID: this.tileID,
                        type: "patterns",
                      },
                      (le, ae) => {
                        L || ((L = le), (V = ae), K());
                      },
                      void 0,
                      !1,
                      G
                    )
                  : (V = {}),
                  K();
              }
            }
            function Yd(r, i, o) {
              const l = new M(i);
              for (const h of r) h.recalculate(l, o);
            }
            class hy {
              constructor(i) {
                (this.entries = {}), (this.scheduler = i);
              }
              request(i, o, l, h) {
                const m = (this.entries[i] = this.entries[i] || {
                  callbacks: [],
                });
                if (m.result) {
                  const [_, x] = m.result;
                  return (
                    this.scheduler
                      ? this.scheduler.add(() => {
                          h(_, x);
                        }, o)
                      : h(_, x),
                    () => {}
                  );
                }
                return (
                  m.callbacks.push(h),
                  m.cancel ||
                    (m.cancel = l((_, x) => {
                      m.result = [_, x];
                      for (const E of m.callbacks)
                        this.scheduler
                          ? this.scheduler.add(() => {
                              E(_, x);
                            }, o)
                          : E(_, x);
                      setTimeout(() => delete this.entries[i], 3e3);
                    })),
                  () => {
                    m.result ||
                      ((m.callbacks = m.callbacks.filter((_) => _ !== h)),
                      m.callbacks.length ||
                        (m.cancel(), delete this.entries[i]));
                  }
                );
              }
            }
            function T0(r, i, o) {
              const l = JSON.stringify(r.request);
              return (
                r.data &&
                  (this.deduped.entries[l] = { result: [null, r.data] }),
                this.deduped.request(
                  l,
                  {
                    type: "parseTile",
                    isSymbolTile: r.isSymbolTile,
                    zoom: r.tileZoom,
                  },
                  (h) => {
                    const m = Tl(r.request, (_, x, E, T) => {
                      _
                        ? h(_)
                        : x &&
                          h(null, {
                            vectorTile: o ? void 0 : new Zp(new kd(x)),
                            rawData: x,
                            cacheControl: E,
                            expires: T,
                          });
                    });
                    return () => {
                      m.cancel(), h();
                    };
                  },
                  i
                )
              );
            }
            const dy = [
              Int8Array,
              Uint8Array,
              Uint8ClampedArray,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array,
            ];
            class gf {
              static from(i) {
                if (!(i instanceof ArrayBuffer))
                  throw new Error("Data must be an instance of ArrayBuffer.");
                const [o, l] = new Uint8Array(i, 0, 2);
                if (219 !== o)
                  throw new Error(
                    "Data does not appear to be in a KDBush format."
                  );
                const h = l >> 4;
                if (1 !== h)
                  throw new Error(`Got v${h} data when expected v1.`);
                const m = dy[15 & l];
                if (!m) throw new Error("Unrecognized array type.");
                const [_] = new Uint16Array(i, 2, 1),
                  [x] = new Uint32Array(i, 4, 1);
                return new gf(x, _, m, i);
              }
              constructor(i, o = 64, l = Float64Array, h) {
                if (isNaN(i) || i < 0)
                  throw new Error(`Unpexpected numItems value: ${i}.`);
                (this.numItems = +i),
                  (this.nodeSize = Math.min(Math.max(+o, 2), 65535)),
                  (this.ArrayType = l),
                  (this.IndexArrayType = i < 65536 ? Uint16Array : Uint32Array);
                const m = dy.indexOf(this.ArrayType),
                  _ = 2 * i * this.ArrayType.BYTES_PER_ELEMENT,
                  x = i * this.IndexArrayType.BYTES_PER_ELEMENT,
                  E = (8 - (x % 8)) % 8;
                if (m < 0)
                  throw new Error(`Unexpected typed array class: ${l}.`);
                h && h instanceof ArrayBuffer
                  ? ((this.data = h),
                    (this.ids = new this.IndexArrayType(this.data, 8, i)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + x + E,
                      2 * i
                    )),
                    (this._pos = 2 * i),
                    (this._finished = !0))
                  : ((this.data = new ArrayBuffer(8 + _ + x + E)),
                    (this.ids = new this.IndexArrayType(this.data, 8, i)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + x + E,
                      2 * i
                    )),
                    (this._pos = 0),
                    (this._finished = !1),
                    new Uint8Array(this.data, 0, 2).set([219, 16 + m]),
                    (new Uint16Array(this.data, 2, 1)[0] = o),
                    (new Uint32Array(this.data, 4, 1)[0] = i));
              }
              add(i, o) {
                const l = this._pos >> 1;
                return (
                  (this.ids[l] = l),
                  (this.coords[this._pos++] = i),
                  (this.coords[this._pos++] = o),
                  l
                );
              }
              finish() {
                const i = this._pos >> 1;
                if (i !== this.numItems)
                  throw new Error(
                    `Added ${i} items when expected ${this.numItems}.`
                  );
                return (
                  lg(
                    this.ids,
                    this.coords,
                    this.nodeSize,
                    0,
                    this.numItems - 1,
                    0
                  ),
                  (this._finished = !0),
                  this
                );
              }
              range(i, o, l, h) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish()."
                  );
                const { ids: m, coords: _, nodeSize: x } = this,
                  E = [0, m.length - 1, 0],
                  T = [];
                for (; E.length; ) {
                  const I = E.pop() || 0,
                    A = E.pop() || 0,
                    L = E.pop() || 0;
                  if (A - L <= x) {
                    for (let G = L; G <= A; G++) {
                      const K = _[2 * G],
                        oe = _[2 * G + 1];
                      K >= i && K <= l && oe >= o && oe <= h && T.push(m[G]);
                    }
                    continue;
                  }
                  const O = (L + A) >> 1,
                    F = _[2 * O],
                    V = _[2 * O + 1];
                  F >= i && F <= l && V >= o && V <= h && T.push(m[O]),
                    (0 === I ? i <= F : o <= V) &&
                      (E.push(L), E.push(O - 1), E.push(1 - I)),
                    (0 === I ? l >= F : h >= V) &&
                      (E.push(O + 1), E.push(A), E.push(1 - I));
                }
                return T;
              }
              within(i, o, l) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish()."
                  );
                const { ids: h, coords: m, nodeSize: _ } = this,
                  x = [0, h.length - 1, 0],
                  E = [],
                  T = l * l;
                for (; x.length; ) {
                  const I = x.pop() || 0,
                    A = x.pop() || 0,
                    L = x.pop() || 0;
                  if (A - L <= _) {
                    for (let G = L; G <= A; G++)
                      co(m[2 * G], m[2 * G + 1], i, o) <= T && E.push(h[G]);
                    continue;
                  }
                  const O = (L + A) >> 1,
                    F = m[2 * O],
                    V = m[2 * O + 1];
                  co(F, V, i, o) <= T && E.push(h[O]),
                    (0 === I ? i - l <= F : o - l <= V) &&
                      (x.push(L), x.push(O - 1), x.push(1 - I)),
                    (0 === I ? i + l >= F : o + l >= V) &&
                      (x.push(O + 1), x.push(A), x.push(1 - I));
                }
                return E;
              }
            }
            function lg(r, i, o, l, h, m) {
              if (h - l <= o) return;
              const _ = (l + h) >> 1;
              cg(r, i, _, l, h, m),
                lg(r, i, o, l, _ - 1, 1 - m),
                lg(r, i, o, _ + 1, h, 1 - m);
            }
            function cg(r, i, o, l, h, m) {
              for (; h > l; ) {
                if (h - l > 600) {
                  const T = h - l + 1,
                    I = o - l + 1,
                    A = Math.log(T),
                    L = 0.5 * Math.exp((2 * A) / 3),
                    O =
                      0.5 *
                      Math.sqrt((A * L * (T - L)) / T) *
                      (I - T / 2 < 0 ? -1 : 1);
                  cg(
                    r,
                    i,
                    o,
                    Math.max(l, Math.floor(o - (I * L) / T + O)),
                    Math.min(h, Math.floor(o + ((T - I) * L) / T + O)),
                    m
                  );
                }
                const _ = i[2 * o + m];
                let x = l,
                  E = h;
                for (
                  fh(r, i, l, o), i[2 * h + m] > _ && fh(r, i, l, h);
                  x < E;

                ) {
                  for (fh(r, i, x, E), x++, E--; i[2 * x + m] < _; ) x++;
                  for (; i[2 * E + m] > _; ) E--;
                }
                i[2 * l + m] === _ ? fh(r, i, l, E) : (E++, fh(r, i, E, h)),
                  E <= o && (l = E + 1),
                  o <= E && (h = E - 1);
              }
            }
            function fh(r, i, o, l) {
              ug(r, o, l), ug(i, 2 * o, 2 * l), ug(i, 2 * o + 1, 2 * l + 1);
            }
            function ug(r, i, o) {
              const l = r[i];
              (r[i] = r[o]), (r[o] = l);
            }
            function co(r, i, o, l) {
              const h = r - o,
                m = i - l;
              return h * h + m * m;
            }
            (d.ARRAY_TYPE = Qn),
              (d.AUTH_ERR_MSG = ce),
              (d.Aabb = zr),
              (d.Actor = class {
                constructor(r, i, o) {
                  (this.target = r),
                    (this.parent = i),
                    (this.mapId = o),
                    (this.callbacks = {}),
                    (this.cancelCallbacks = {}),
                    No(["receive"], this),
                    this.target.addEventListener("message", this.receive, !1),
                    (this.globalScope = zs() ? r : Be),
                    (this.scheduler = new f0());
                }
                send(r, i, o, l, h = !1, m) {
                  const _ = Math.round(1e18 * Math.random())
                    .toString(36)
                    .substring(0, 10);
                  o && ((o.metadata = m), (this.callbacks[_] = o));
                  const x = lc(this.globalScope) ? void 0 : [];
                  return (
                    this.target.postMessage(
                      {
                        id: _,
                        type: r,
                        hasCallback: !!o,
                        targetMapId: l,
                        mustQueue: h,
                        sourceMapId: this.mapId,
                        data: Fr(i, x),
                      },
                      x
                    ),
                    {
                      cancel: () => {
                        o && delete this.callbacks[_],
                          this.target.postMessage({
                            id: _,
                            type: "<cancel>",
                            targetMapId: l,
                            sourceMapId: this.mapId,
                          });
                      },
                    }
                  );
                }
                receive(r) {
                  const i = r.data,
                    o = i.id;
                  if (o && (!i.targetMapId || this.mapId === i.targetMapId))
                    if ("<cancel>" === i.type) {
                      const l = this.cancelCallbacks[o];
                      delete this.cancelCallbacks[o], l && l.cancel();
                    } else if (i.mustQueue || zs()) {
                      const l = this.callbacks[o];
                      this.cancelCallbacks[o] = this.scheduler.add(
                        () => this.processTask(o, i),
                        (l && l.metadata) || { type: "message" }
                      );
                    } else this.processTask(o, i);
                }
                processTask(r, i) {
                  if ("<response>" === i.type) {
                    const o = this.callbacks[r];
                    delete this.callbacks[r],
                      o && (i.error ? o(Ga(i.error)) : o(null, Ga(i.data)));
                  } else {
                    const o = lc(this.globalScope) ? void 0 : [],
                      l = i.hasCallback
                        ? (m, _) => {
                            delete this.cancelCallbacks[r],
                              this.target.postMessage(
                                {
                                  id: r,
                                  type: "<response>",
                                  sourceMapId: this.mapId,
                                  error: m ? Fr(m) : null,
                                  data: Fr(_, o),
                                },
                                o
                              );
                          }
                        : (m) => {},
                      h = Ga(i.data);
                    if (this.parent[i.type])
                      this.parent[i.type](i.sourceMapId, h, l);
                    else if (this.parent.getWorkerSource) {
                      const m = i.type.split(".");
                      this.parent
                        .getWorkerSource(i.sourceMapId, m[0], h.source)
                        [m[1]](h, l);
                    } else l(new Error(`Could not find function ${i.type}`));
                  }
                }
                remove() {
                  this.scheduler.remove(),
                    this.target.removeEventListener(
                      "message",
                      this.receive,
                      !1
                    );
                }
              }),
              (d.CanonicalTileID = bi),
              (d.Color = gi),
              (d.ColorMode = ya),
              (d.CullFaceMode = Ts),
              (d.DEMData = Zd),
              (d.DataConstantProperty = B),
              (d.DedupedRequest = hy),
              (d.DepthMode = ph),
              (d.EXTENT = wt),
              (d.Elevation = class {
                isDataAvailableAtPoint(r) {
                  const i = this._source();
                  if (this.isUsingMockSource() || !i || r.y < 0 || r.y > 1)
                    return !1;
                  const o = i.getSource().maxzoom,
                    l = 1 << o,
                    h = Math.floor(r.x),
                    m = Math.floor((r.x - h) * l),
                    _ = Math.floor(r.y * l),
                    x = this.findDEMTileFor(new Br(o, h, o, m, _));
                  return !(!x || !x.dem);
                }
                getAtPointOrZero(r, i = 0) {
                  return this.getAtPoint(r, i) || 0;
                }
                getAtPoint(r, i, o = !0) {
                  if (this.isUsingMockSource()) return null;
                  null == i && (i = null);
                  const l = this._source();
                  if (!l || r.y < 0 || r.y > 1) return i;
                  const h = l.getSource().maxzoom,
                    m = 1 << h,
                    _ = Math.floor(r.x),
                    x = r.x - _,
                    E = new Br(h, _, h, Math.floor(x * m), Math.floor(r.y * m)),
                    T = this.findDEMTileFor(E);
                  if (!T || !T.dem) return i;
                  const I = T.dem,
                    A = 1 << T.tileID.canonical.z,
                    L = (x * A - T.tileID.canonical.x) * I.dim,
                    O = (r.y * A - T.tileID.canonical.y) * I.dim,
                    F = Math.floor(L),
                    V = Math.floor(O);
                  return (
                    (o ? this.exaggeration() : 1) *
                    ln(
                      ln(I.get(F, V), I.get(F, V + 1), O - V),
                      ln(I.get(F + 1, V), I.get(F + 1, V + 1), O - V),
                      L - F
                    )
                  );
                }
                getAtTileOffset(r, i, o) {
                  const l = 1 << r.canonical.z;
                  return this.getAtPointOrZero(
                    new Zu(
                      r.wrap + (r.canonical.x + i / wt) / l,
                      (r.canonical.y + o / wt) / l
                    )
                  );
                }
                getAtTileOffsetFunc(r, i, o, l) {
                  return (h) => {
                    const m = this.getAtTileOffset(r, h.x, h.y),
                      _ = l.upVector(r.canonical, h.x, h.y);
                    return (
                      ur(
                        _,
                        _,
                        m * l.upVectorScale(r.canonical, i, o).metersToTile
                      ),
                      _
                    );
                  };
                }
                getForTilePoints(r, i, o, l) {
                  if (this.isUsingMockSource()) return !1;
                  const h = cl.create(this, r, l);
                  return (
                    !!h &&
                    (i.forEach((m) => {
                      m[2] =
                        this.exaggeration() * h.getElevationAt(m[0], m[1], o);
                    }),
                    !0)
                  );
                }
                getMinMaxForTile(r) {
                  if (this.isUsingMockSource()) return null;
                  const i = this.findDEMTileFor(r);
                  if (!i || !i.dem) return null;
                  const o = i.dem.tree,
                    l = i.tileID,
                    h = 1 << (r.canonical.z - l.canonical.z);
                  let m = r.canonical.x / h - l.canonical.x,
                    _ = r.canonical.y / h - l.canonical.y,
                    x = 0;
                  for (
                    let E = 0;
                    E < r.canonical.z - l.canonical.z && !o.leaves[x];
                    E++
                  ) {
                    (m *= 2), (_ *= 2);
                    const T = 2 * Math.floor(_) + Math.floor(m);
                    (x = o.childOffsets[x] + T), (m %= 1), (_ %= 1);
                  }
                  return {
                    min: this.exaggeration() * o.minimums[x],
                    max: this.exaggeration() * o.maximums[x],
                  };
                }
                getMinElevationBelowMSL() {
                  throw new Error("Pure virtual method called.");
                }
                raycast(r, i, o) {
                  throw new Error("Pure virtual method called.");
                }
                pointCoordinate(r) {
                  throw new Error("Pure virtual method called.");
                }
                _source() {
                  throw new Error("Pure virtual method called.");
                }
                isUsingMockSource() {
                  throw new Error("Pure virtual method called.");
                }
                exaggeration() {
                  throw new Error("Pure virtual method called.");
                }
                findDEMTileFor(r) {
                  throw new Error("Pure virtual method called.");
                }
                get visibleDemTiles() {
                  throw new Error("Getter must be implemented in subclass.");
                }
              }),
              (d.ErrorEvent = us),
              (d.EvaluationParameters = M),
              (d.Event = Ra),
              (d.Evented = pc),
              (d.FillExtrusionBucket = Yp),
              (d.Frustum = Mp),
              (d.FrustumCorners = qg),
              (d.GLOBE_RADIUS = la),
              (d.GLOBE_SCALE_MATCH_LATITUDE = 45),
              (d.GLOBE_ZOOM_THRESHOLD_MAX = 6),
              (d.GLOBE_ZOOM_THRESHOLD_MIN = 5),
              (d.GlobeSharedBuffers = class {
                constructor(r) {
                  this._createGrid(r), this._createPoles(r);
                }
                destroy() {
                  this._poleIndexBuffer.destroy(),
                    this._gridBuffer.destroy(),
                    this._gridIndexBuffer.destroy(),
                    this._poleNorthVertexBuffer.destroy(),
                    this._poleSouthVertexBuffer.destroy();
                  for (const r of this._poleSegments) r.destroy();
                  for (const r of this._gridSegments)
                    r.withSkirts.destroy(), r.withoutSkirts.destroy();
                  if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();
                    for (const r of this._wireframeSegments) r.destroy();
                  }
                }
                _fillGridMeshWithLods(r, i) {
                  const o = new Ge(),
                    l = new _t(),
                    h = [],
                    m = r + 1 + 2,
                    _ = i[0] + 1,
                    x = i[0] + 1 + (1 + i.length),
                    E = (T, I, A) => {
                      let L = T === m - 1 ? T - 2 : 0 === T ? T : T - 1;
                      return (L += A ? 24575 : 0), [L, I];
                    };
                  for (let T = 0; T < m; ++T) o.emplaceBack(...E(T, 0, !0));
                  for (let T = 0; T < _; ++T)
                    for (let I = 0; I < m; ++I)
                      o.emplaceBack(...E(I, T, (0 === I || I === m - 1) && !0));
                  for (let T = 0; T < i.length; ++T) {
                    const I = i[T];
                    for (let A = 0; A < m; ++A) o.emplaceBack(...E(A, I, !0));
                  }
                  for (let T = 0; T < i.length; ++T) {
                    const I = l.length,
                      A = i[T] + 1 + 2,
                      L = new _t();
                    for (let V = 0; V < A - 1; V++) {
                      const G = V === A - 2,
                        K = G ? m * (x - i.length + T - V) : m;
                      for (let oe = 0; oe < m - 1; oe++) {
                        const J = V * m + oe;
                        0 === V || G || 0 === oe || oe === m - 2
                          ? (L.emplaceBack(J + 1, J, J + K),
                            L.emplaceBack(J + K, J + K + 1, J + 1))
                          : (l.emplaceBack(J + 1, J, J + K),
                            l.emplaceBack(J + K, J + K + 1, J + 1));
                      }
                    }
                    const O = xi.simpleSegment(0, I, o.length, l.length - I);
                    for (let V = 0; V < L.uint16.length; V += 3)
                      l.emplaceBack(
                        L.uint16[V],
                        L.uint16[V + 1],
                        L.uint16[V + 2]
                      );
                    const F = xi.simpleSegment(0, I, o.length, l.length - I);
                    h.push({ withoutSkirts: O, withSkirts: F });
                  }
                  return { vertices: o, indices: l, segments: h };
                }
                _createGrid(r) {
                  const i = this._fillGridMeshWithLods(64, Gu);
                  (this._gridSegments = i.segments),
                    (this._gridBuffer = r.createVertexBuffer(
                      i.vertices,
                      Ja.members
                    )),
                    (this._gridIndexBuffer = r.createIndexBuffer(
                      i.indices,
                      !0
                    ));
                }
                _createPoles(r) {
                  const i = new _t();
                  for (let h = 0; h <= 64; h++) i.emplaceBack(0, h + 1, h + 2);
                  this._poleIndexBuffer = r.createIndexBuffer(i, !0);
                  const o = new Sn(),
                    l = new Sn();
                  this._poleSegments = [];
                  for (let h = 0, m = 0; h < 5; h++) {
                    const _ = 360 / (1 << h);
                    o.emplaceBack(0, -la, 0, 0.5, 0),
                      l.emplaceBack(0, -la, 0, 0.5, 1);
                    for (let x = 0; x <= 64; x++) {
                      const E = x / 64,
                        T = ln(0, _, E),
                        [I, A, L] = cd(Qg, rm, T, la);
                      o.emplaceBack(I, A, L, E, 0),
                        l.emplaceBack(I, A, L, E, 1);
                    }
                    this._poleSegments.push(xi.simpleSegment(m, 0, 66, 64)),
                      (m += 66);
                  }
                  (this._poleNorthVertexBuffer = r.createVertexBuffer(
                    o,
                    Gg,
                    !1
                  )),
                    (this._poleSouthVertexBuffer = r.createVertexBuffer(
                      l,
                      Gg,
                      !1
                    ));
                }
                getGridBuffers(r, i) {
                  return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    i
                      ? this._gridSegments[r].withSkirts
                      : this._gridSegments[r].withoutSkirts,
                  ];
                }
                getPoleBuffers(r) {
                  return [
                    this._poleNorthVertexBuffer,
                    this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[r],
                  ];
                }
                getWirefameBuffers(r, i) {
                  if (!this._wireframeSegments) {
                    const o = new vi(),
                      l = 64,
                      h = l + 1 + 2,
                      m = 1;
                    this._wireframeSegments = [];
                    for (let _ = 0, x = 0; _ < Gu.length; _++) {
                      const E = Gu[_];
                      for (let I = m; I < E + m; I++)
                        for (let A = m; A < l + m; A++) {
                          const L = I * h + A;
                          o.emplaceBack(L, L + 1),
                            o.emplaceBack(L, L + h),
                            o.emplaceBack(L, L + h + 1);
                        }
                      const T = E * l * 3;
                      this._wireframeSegments.push(
                        xi.simpleSegment(0, x, (E + 1) * h, T)
                      ),
                        (x += T);
                    }
                    this._wireframeIndexBuffer = r.createIndexBuffer(o);
                  }
                  return [
                    this._gridBuffer,
                    this._wireframeIndexBuffer,
                    this._wireframeSegments[i],
                  ];
                }
              }),
              (d.GlyphManager = sh),
              (d.ImagePosition = Od),
              (d.KDBush = gf),
              (d.LivePerformanceUtils = Lf),
              (d.LngLat = Ln),
              (d.LngLatBounds = Lc),
              (d.LocalGlyphMode = rf),
              (d.MAX_MERCATOR_LATITUDE = Si),
              (d.MercatorCoordinate = Zu),
              (d.ONE_EM = 24),
              (d.OverscaledTileID = Br),
              (d.PerformanceMarkers = ka),
              (d.Point = nt),
              (d.Properties = te),
              (d.RGBAImage = Qr),
              (d.Ray = Jf),
              (d.RequestManager = class {
                constructor(r, i, o) {
                  (this._transformRequestFn = r),
                    (this._customAccessToken = i),
                    (this._silenceAuthErrors = !!o),
                    this._createSkuToken();
                }
                _createSkuToken() {
                  const r = (function () {
                    let i = "";
                    for (let o = 0; o < 10; o++)
                      i +=
                        "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[
                          Math.floor(62 * Math.random())
                        ];
                    return {
                      token: ["1", vl, i].join(""),
                      tokenExpiresAt: Date.now() + 432e5,
                    };
                  })();
                  (this._skuToken = r.token),
                    (this._skuTokenExpiresAt = r.tokenExpiresAt);
                }
                _isSkuTokenExpired() {
                  return Date.now() > this._skuTokenExpiresAt;
                }
                transformRequest(r, i) {
                  return (
                    (this._transformRequestFn &&
                      this._transformRequestFn(r, i)) || { url: r }
                  );
                }
                normalizeStyleURL(r, i) {
                  if (!me(r)) return r;
                  const o = et(r);
                  return (
                    (o.path = `/styles/v1${o.path}`),
                    this._makeAPIURL(o, this._customAccessToken || i)
                  );
                }
                normalizeGlyphsURL(r, i) {
                  if (!me(r)) return r;
                  const o = et(r);
                  return (
                    (o.path = `/fonts/v1${o.path}`),
                    this._makeAPIURL(o, this._customAccessToken || i)
                  );
                }
                normalizeSourceURL(r, i, o, l) {
                  if (!me(r)) return r;
                  const h = et(r);
                  return (
                    (h.path = `/v4/${h.authority}.json`),
                    h.params.push("secure"),
                    o && h.params.push(`language=${o}`),
                    l && h.params.push(`worldview=${l}`),
                    this._makeAPIURL(h, this._customAccessToken || i)
                  );
                }
                normalizeSpriteURL(r, i, o, l) {
                  const h = et(r);
                  return me(r)
                    ? ((h.path = `/styles/v1${h.path}/sprite${i}${o}`),
                      this._makeAPIURL(h, this._customAccessToken || l))
                    : ((h.path += `${i}${o}`), We(h));
                }
                normalizeTileURL(r, i, o) {
                  if (
                    (this._isSkuTokenExpired() && this._createSkuToken(),
                    r && !me(r))
                  )
                    return r;
                  const l = et(r);
                  (l.path = l.path.replace(
                    /(\.(png|jpg)\d*)(?=$)/,
                    `${
                      i || (o && "raster" !== l.authority && 512 === o)
                        ? "@2x"
                        : ""
                    }${zt.supported ? ".webp" : "$1"}`
                  )),
                    "raster" === l.authority
                      ? (l.path = `/${jt.RASTER_URL_PREFIX}${l.path}`)
                      : ((l.path = l.path.replace(/^.+\/v4\//, "/")),
                        (l.path = `/${jt.TILE_URL_VERSION}${l.path}`));
                  const h =
                    this._customAccessToken ||
                    (function (m) {
                      for (const _ of m) {
                        const x = _.match(/^access_token=(.*)$/);
                        if (x) return x[1];
                      }
                      return null;
                    })(l.params) ||
                    jt.ACCESS_TOKEN;
                  return (
                    jt.REQUIRE_ACCESS_TOKEN &&
                      h &&
                      this._skuToken &&
                      l.params.push(`sku=${this._skuToken}`),
                    this._makeAPIURL(l, h)
                  );
                }
                canonicalizeTileURL(r, i) {
                  const o = et(r);
                  if (
                    !o.path.match(/^(\/v4\/|\/raster\/v1\/)/) ||
                    !o.path.match(/\.[\w]+$/)
                  )
                    return r;
                  let l = "mapbox://";
                  o.path.match(/^\/raster\/v1\//)
                    ? (l += `raster/${o.path.replace(
                        `/${jt.RASTER_URL_PREFIX}/`,
                        ""
                      )}`)
                    : (l += `tiles/${o.path.replace(
                        `/${jt.TILE_URL_VERSION}/`,
                        ""
                      )}`);
                  let h = o.params;
                  return (
                    i && (h = h.filter((m) => !m.match(/^access_token=/))),
                    h.length && (l += `?${h.join("&")}`),
                    l
                  );
                }
                canonicalizeTileset(r, i) {
                  const o = !!i && me(i),
                    l = [];
                  for (const h of r.tiles || [])
                    ve(h) ? l.push(this.canonicalizeTileURL(h, o)) : l.push(h);
                  return l;
                }
                _makeAPIURL(r, i) {
                  const o =
                      "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",
                    l = et(jt.API_URL);
                  if (
                    ((r.protocol = l.protocol),
                    (r.authority = l.authority),
                    "http" === r.protocol)
                  ) {
                    const h = r.params.indexOf("secure");
                    h >= 0 && r.params.splice(h, 1);
                  }
                  if (
                    ("/" !== l.path && (r.path = `${l.path}${r.path}`),
                    !jt.REQUIRE_ACCESS_TOKEN)
                  )
                    return We(r);
                  if (((i = i || jt.ACCESS_TOKEN), !this._silenceAuthErrors)) {
                    if (!i)
                      throw new Error(
                        `An API access token is required to use Mapbox GL. ${o}`
                      );
                    if ("s" === i[0])
                      throw new Error(
                        `Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o}`
                      );
                  }
                  return (
                    (r.params = r.params.filter(
                      (h) => -1 === h.indexOf("access_token")
                    )),
                    r.params.push(`access_token=${i || ""}`),
                    We(r)
                  );
                }
              }),
              (d.ResourceType = Bs),
              (d.SegmentVector = xi),
              (d.SourceCache = Xc),
              (d.StencilMode = hf),
              (d.StructArrayLayout1ui2 = Er),
              (d.StructArrayLayout2f1f2i16 = Dt),
              (d.StructArrayLayout2i4 = Ge),
              (d.StructArrayLayout2ui4 = vi),
              (d.StructArrayLayout3f12 = Ht),
              (d.StructArrayLayout3ui6 = _t),
              (d.StructArrayLayout4i8 = Le),
              (d.StructArrayLayout5f20 = Sn),
              (d.Texture = lf),
              (d.Tile = sy),
              (d.Transitionable = z),
              (d.Uniform1f = sn),
              (d.Uniform1i = class extends Za {
                constructor(r) {
                  super(r), (this.current = 0);
                }
                set(r, i, o) {
                  this.fetchUniformLocation(r, i) &&
                    this.current !== o &&
                    ((this.current = o), this.gl.uniform1i(this.location, o));
                }
              }),
              (d.Uniform2f = class extends Za {
                constructor(r) {
                  super(r), (this.current = [0, 0]);
                }
                set(r, i, o) {
                  this.fetchUniformLocation(r, i) &&
                    ((o[0] === this.current[0] && o[1] === this.current[1]) ||
                      ((this.current = o),
                      this.gl.uniform2f(this.location, o[0], o[1])));
                }
              }),
              (d.Uniform3f = class extends Za {
                constructor(r) {
                  super(r), (this.current = [0, 0, 0]);
                }
                set(r, i, o) {
                  this.fetchUniformLocation(r, i) &&
                    ((o[0] === this.current[0] &&
                      o[1] === this.current[1] &&
                      o[2] === this.current[2]) ||
                      ((this.current = o),
                      this.gl.uniform3f(this.location, o[0], o[1], o[2])));
                }
              }),
              (d.Uniform4f = fv),
              (d.UniformColor = mv),
              (d.UniformMatrix2f = class extends Za {
                constructor(r) {
                  super(r), (this.current = _b);
                }
                set(r, i, o) {
                  if (this.fetchUniformLocation(r, i))
                    for (let l = 0; l < 4; l++)
                      if (o[l] !== this.current[l]) {
                        (this.current = o),
                          this.gl.uniformMatrix2fv(this.location, !1, o);
                        break;
                      }
                }
              }),
              (d.UniformMatrix3f = class extends Za {
                constructor(r) {
                  super(r), (this.current = gb);
                }
                set(r, i, o) {
                  if (this.fetchUniformLocation(r, i))
                    for (let l = 0; l < 9; l++)
                      if (o[l] !== this.current[l]) {
                        (this.current = o),
                          this.gl.uniformMatrix3fv(this.location, !1, o);
                        break;
                      }
                }
              }),
              (d.UniformMatrix4f = class extends Za {
                constructor(r) {
                  super(r), (this.current = mb);
                }
                set(r, i, o) {
                  if (this.fetchUniformLocation(r, i)) {
                    if (o[12] !== this.current[12] || o[0] !== this.current[0])
                      return (
                        (this.current = o),
                        void this.gl.uniformMatrix4fv(this.location, !1, o)
                      );
                    for (let l = 1; l < 16; l++)
                      if (o[l] !== this.current[l]) {
                        (this.current = o),
                          this.gl.uniformMatrix4fv(this.location, !1, o);
                        break;
                      }
                  }
                }
              }),
              (d.UnwrappedTileID = D_),
              (d.ValidationError = ct),
              (d.VectorTileFeature = Dd),
              (d.VectorTileWorkerSource = class extends pc {
                constructor(r, i, o, l, h) {
                  super(),
                    (this.actor = r),
                    (this.layerIndex = i),
                    (this.availableImages = o),
                    (this.loadVectorData = h || T0),
                    (this.loading = {}),
                    (this.loaded = {}),
                    (this.deduped = new hy(r.scheduler)),
                    (this.isSpriteLoaded = l),
                    (this.scheduler = r.scheduler);
                }
                loadTile(r, i) {
                  const o = r.uid,
                    l = r && r.request,
                    h = l && l.collectResourceTiming,
                    m = (this.loading[o] = new uy(r));
                  m.abort = this.loadVectorData(r, (_, x) => {
                    const E = !this.loading[o];
                    if ((delete this.loading[o], E || _ || !x))
                      return (
                        (m.status = "done"), E || (this.loaded[o] = m), i(_)
                      );
                    const T = x.rawData,
                      I = {};
                    x.expires && (I.expires = x.expires),
                      x.cacheControl && (I.cacheControl = x.cacheControl),
                      (m.vectorTile = x.vectorTile || new Zp(new kd(T)));
                    const A = () => {
                      m.parse(
                        m.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.actor,
                        (L, O) => {
                          if (L || !O) return i(L);
                          const F = {};
                          if (h) {
                            const V = Sh(l);
                            V.length > 0 &&
                              (F.resourceTiming = JSON.parse(
                                JSON.stringify(V)
                              ));
                          }
                          i(null, pi({ rawTileData: T.slice(0) }, O, I, F));
                        }
                      );
                    };
                    this.isSpriteLoaded
                      ? A()
                      : this.once("isSpriteLoaded", () => {
                          this.scheduler
                            ? this.scheduler.add(A, {
                                type: "parseTile",
                                isSymbolTile: r.isSymbolTile,
                                zoom: r.tileZoom,
                              })
                            : A();
                        }),
                      (this.loaded = this.loaded || {}),
                      (this.loaded[o] = m);
                  });
                }
                reloadTile(r, i) {
                  const o = this.loaded,
                    l = r.uid,
                    h = this;
                  if (o && o[l]) {
                    const m = o[l];
                    (m.showCollisionBoxes = r.showCollisionBoxes),
                      (m.enableTerrain = !!r.enableTerrain),
                      (m.projection = r.projection),
                      (m.tileTransform = qc(r.tileID.canonical, r.projection));
                    const _ = (x, E) => {
                      const T = m.reloadCallback;
                      T &&
                        (delete m.reloadCallback,
                        m.parse(
                          m.vectorTile,
                          h.layerIndex,
                          this.availableImages,
                          h.actor,
                          T
                        )),
                        i(x, E);
                    };
                    "parsing" === m.status
                      ? (m.reloadCallback = _)
                      : "done" === m.status &&
                        (m.vectorTile
                          ? m.parse(
                              m.vectorTile,
                              this.layerIndex,
                              this.availableImages,
                              this.actor,
                              _
                            )
                          : _());
                  }
                }
                abortTile(r, i) {
                  const o = r.uid,
                    l = this.loading[o];
                  l && (l.abort && l.abort(), delete this.loading[o]), i();
                }
                removeTile(r, i) {
                  const o = this.loaded,
                    l = r.uid;
                  o && o[l] && delete o[l], i();
                }
              }),
              (d.WritingMode = Po),
              (d.ZoomDependentExpression = Ec),
              (d.add = Ya),
              (d.addDynamicAttributes = $d),
              (d.adjoint = function (r, i) {
                var o = i[0],
                  l = i[1],
                  h = i[2],
                  m = i[3],
                  _ = i[4],
                  x = i[5],
                  E = i[6],
                  T = i[7],
                  I = i[8];
                return (
                  (r[0] = _ * I - x * T),
                  (r[1] = h * T - l * I),
                  (r[2] = l * x - h * _),
                  (r[3] = x * E - m * I),
                  (r[4] = o * I - h * E),
                  (r[5] = h * m - o * x),
                  (r[6] = m * T - _ * E),
                  (r[7] = l * E - o * T),
                  (r[8] = o * _ - l * m),
                  r
                );
              }),
              (d.asyncAll = Ai),
              (d.bezier = Ia),
              (d.bindAll = No),
              (d.boundsAttributes = g0),
              (d.bufferConvexPolygon = function (r, i) {
                const o = [];
                for (let l = 0; l < r.length; l++) {
                  const h = Tn(l - 1, -1, r.length - 1),
                    m = Tn(l + 1, -1, r.length - 1),
                    _ = r[l],
                    x = r[m],
                    E = r[h].sub(_).unit(),
                    T = x.sub(_).unit(),
                    I = T.angleWithSep(E.x, E.y),
                    A = E.add(T)
                      .unit()
                      .mult((-1 * i) / Math.sin(I / 2));
                  o.push(_.add(A));
                }
                return o;
              }),
              (d.cacheEntryPossiblyAdded = function (r) {
                ro++,
                  ro > du &&
                    (r.getActor().send("enforceCacheSizeLimit", wl), (ro = 0));
              }),
              (d.calculateGlobeLabelMatrix = function (r, i) {
                const { x: o, y: l } = r.point,
                  h = nm(o, l, r.worldSize / r._pixelsPerMercatorPixel, 0, 0);
                return Rc(h, h, Lp(Qo(i)));
              }),
              (d.calculateGlobeMatrix = function (r) {
                const { x: i, y: o } = r.point,
                  { lng: l, lat: h } = r._center;
                return nm(i, o, r.worldSize, l, h);
              }),
              (d.calculateGlobeMercatorMatrix = function (r) {
                const i = r.pixelsPerMeter,
                  o = i / Ao(1, r.center.lat),
                  l = sa(new Float64Array(16));
                return (
                  id(l, l, [r.point.x, r.point.y, 0]),
                  Oc(l, l, [o, o, i]),
                  Float32Array.from(l)
                );
              }),
              (d.circumferenceAtLatitude = om),
              (d.clamp = tn),
              (d.clearTileCache = function (r) {
                if (!uc()) return;
                const i = Be.caches.delete(bl);
                r && i.catch(r).then(() => r());
              }),
              (d.clipLine = Gm),
              (d.clone = function (r) {
                var i = new Qn(16);
                return (
                  (i[0] = r[0]),
                  (i[1] = r[1]),
                  (i[2] = r[2]),
                  (i[3] = r[3]),
                  (i[4] = r[4]),
                  (i[5] = r[5]),
                  (i[6] = r[6]),
                  (i[7] = r[7]),
                  (i[8] = r[8]),
                  (i[9] = r[9]),
                  (i[10] = r[10]),
                  (i[11] = r[11]),
                  (i[12] = r[12]),
                  (i[13] = r[13]),
                  (i[14] = r[14]),
                  (i[15] = r[15]),
                  i
                );
              }),
              (d.clone$1 = $r),
              (d.collisionCircleLayout = L_),
              (d.config = jt),
              (d.conjugate = function (r, i) {
                return (
                  (r[0] = -i[0]),
                  (r[1] = -i[1]),
                  (r[2] = -i[2]),
                  (r[3] = i[3]),
                  r
                );
              }),
              (d.create = function () {
                var r = new Qn(16);
                return (
                  Qn != Float32Array &&
                    ((r[1] = 0),
                    (r[2] = 0),
                    (r[3] = 0),
                    (r[4] = 0),
                    (r[6] = 0),
                    (r[7] = 0),
                    (r[8] = 0),
                    (r[9] = 0),
                    (r[11] = 0),
                    (r[12] = 0),
                    (r[13] = 0),
                    (r[14] = 0)),
                  (r[0] = 1),
                  (r[5] = 1),
                  (r[10] = 1),
                  (r[15] = 1),
                  r
                );
              }),
              (d.create$1 = Tp),
              (d.createExpression = Ba),
              (d.createLayout = ge),
              (d.createStyleLayer = function (r) {
                return "custom" === r.type ? new af(r) : new ng[r.type](r);
              }),
              (d.cross = Xf),
              (d.degToRad = Qt),
              (d.distance = function (r, i) {
                return Math.hypot(i[0] - r[0], i[1] - r[1], i[2] - r[2]);
              }),
              (d.div = function (r, i, o) {
                return (
                  (r[0] = i[0] / o[0]),
                  (r[1] = i[1] / o[1]),
                  (r[2] = i[2] / o[2]),
                  r
                );
              }),
              (d.dot = Io),
              (d.earthRadius = pd),
              (d.ease = ac),
              (d.easeCubicInOut = cu),
              (d.ecefToLatLng = function ([r, i, o]) {
                const l = Math.hypot(r, i, o),
                  h = Math.atan2(r, o),
                  m = 0.5 * Math.PI - Math.acos(-i / l);
                return new Ln(zi(h), zi(m));
              }),
              (d.emitValidationErrors = Lu),
              (d.endsWith = xl),
              (d.enforceCacheSizeLimit = function (r) {
                Pa(),
                  Ar &&
                    Ar.then((i) => {
                      i.keys().then((o) => {
                        for (let l = 0; l < o.length - r; l++) i.delete(o[l]);
                      });
                    });
              }),
              (d.evaluateSizeForFeature = jc),
              (d.evaluateSizeForZoom = nh),
              (d.evaluateVariableOffset = qm),
              (d.evented = v),
              (d.exactEquals = function (r, i) {
                return (
                  r[0] === i[0] &&
                  r[1] === i[1] &&
                  r[2] === i[2] &&
                  r[3] === i[3]
                );
              }),
              (d.exactEquals$1 = function (r, i) {
                return r[0] === i[0] && r[1] === i[1] && r[2] === i[2];
              }),
              (d.exported = cs),
              (d.exported$1 = zt),
              (d.extend = pi),
              (d.extend$1 = Vo),
              (d.fillExtrusionHeightLift = Sm),
              (d.filterObject = Ns),
              (d.fromMat4 = function (r, i) {
                return (
                  (r[0] = i[0]),
                  (r[1] = i[1]),
                  (r[2] = i[2]),
                  (r[3] = i[4]),
                  (r[4] = i[5]),
                  (r[5] = i[6]),
                  (r[6] = i[8]),
                  (r[7] = i[9]),
                  (r[8] = i[10]),
                  r
                );
              }),
              (d.fromQuat = function (r, i) {
                var o = i[0],
                  l = i[1],
                  h = i[2],
                  m = i[3],
                  _ = o + o,
                  x = l + l,
                  E = h + h,
                  T = o * _,
                  I = l * _,
                  A = l * x,
                  L = h * _,
                  O = h * x,
                  F = h * E,
                  V = m * _,
                  G = m * x,
                  K = m * E;
                return (
                  (r[0] = 1 - A - F),
                  (r[1] = I + K),
                  (r[2] = L - G),
                  (r[3] = 0),
                  (r[4] = I - K),
                  (r[5] = 1 - T - F),
                  (r[6] = O + V),
                  (r[7] = 0),
                  (r[8] = L + G),
                  (r[9] = O - V),
                  (r[10] = 1 - T - A),
                  (r[11] = 0),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[14] = 0),
                  (r[15] = 1),
                  r
                );
              }),
              (d.fromRotation = function (r, i) {
                var o = Math.sin(i),
                  l = Math.cos(i);
                return (
                  (r[0] = l),
                  (r[1] = o),
                  (r[2] = 0),
                  (r[3] = -o),
                  (r[4] = l),
                  (r[5] = 0),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 1),
                  r
                );
              }),
              (d.fromScaling = Vg),
              (d.furthestTileCorner = function (r) {
                const i = Math.round(((r + 45 + 360) % 360) / 90) % 4;
                return sc[i];
              }),
              (d.getAABBPointSquareDist = function (r, i, o) {
                let l = 0;
                for (let h = 0; h < 2; ++h) {
                  const m = o ? o[h] : 0;
                  r[h] > m && (l += (r[h] - m) * (r[h] - m)),
                    i[h] < m && (l += (m - i[h]) * (m - i[h]));
                }
                return l;
              }),
              (d.getAnchorAlignment = $_),
              (d.getAnchorJustification = Wm),
              (d.getBounds = function (r) {
                let i = 1 / 0,
                  o = 1 / 0,
                  l = -1 / 0,
                  h = -1 / 0;
                for (const m of r)
                  (i = Math.min(i, m.x)),
                    (o = Math.min(o, m.y)),
                    (l = Math.max(l, m.x)),
                    (h = Math.max(h, m.y));
                return { min: new nt(i, o), max: new nt(l, h) };
              }),
              (d.getColumn = as),
              (d.getDefaultExportFromCjs = Ur),
              (d.getGridMatrix = function (r, i, o, l) {
                const h = i.getNorth(),
                  m = i.getSouth(),
                  _ = i.getWest(),
                  x = i.getEast(),
                  E = 1 << r.z,
                  T = x - _,
                  I = h - m,
                  A = T / 64,
                  L = -I / Gu[o],
                  O = [0, A, 0, L, 0, 0, h, _, 0];
                if (r.z > 0) {
                  const F = 180 / l;
                  kc(O, O, [
                    F / T + 1,
                    0,
                    0,
                    0,
                    F / I + 1,
                    0,
                    (-0.5 * F) / A,
                    (0.5 * F) / L,
                    1,
                  ]);
                }
                return (O[2] = E), (O[5] = r.x), (O[8] = r.y), O;
              }),
              (d.getImage = ne),
              (d.getJSON = function (r, i) {
                return La(pi(r, { type: "json" }), i);
              }),
              (d.getLatitudinalLod = function (r) {
                const i = Si - 5;
                r = (tn(r, -i, i) / i) * 90;
                const o = Math.pow(Math.abs(Math.sin(Qt(r))), 3);
                return Math.round(o * (Gu.length - 1));
              }),
              (d.getMapSessionAPI = Xn),
              (d.getPerformanceMeasurement = Sh),
              (d.getProjection = Ot),
              (d.getRTLTextPluginStatus = b),
              (d.getReferrer = js),
              (d.getTilePoint = function (r, { x: i, y: o }, l = 0) {
                return new nt(
                  ((i - l) * r.scale - r.x) * wt,
                  (o * r.scale - r.y) * wt
                );
              }),
              (d.getTileVec3 = function (r, i, o = 0) {
                return Ka(
                  ((i.x - o) * r.scale - r.x) * wt,
                  (i.y * r.scale - r.y) * wt,
                  Dr(i.z, i.y)
                );
              }),
              (d.getVideo = function (r, i) {
                const o = Be.document.createElement("video");
                (o.muted = !0),
                  (o.onloadstart = function () {
                    i(null, o);
                  });
                for (let l = 0; l < r.length; l++) {
                  const h = Be.document.createElement("source");
                  pu(r[l]) || (o.crossOrigin = "Anonymous"),
                    (h.src = r[l]),
                    o.appendChild(h);
                }
                return { cancel: () => {} };
              }),
              (d.globeCenterToScreenPoint = function (r) {
                const i = [0, 0, 0],
                  o = sa(new Float64Array(16));
                return (
                  Rc(o, r.pixelMatrix, r.globeMatrix),
                  Jn(i, i, o),
                  new nt(i[0], i[1])
                );
              }),
              (d.globeDenormalizeECEF = Lp),
              (d.globeECEFOrigin = function (r, i) {
                const o = [0, 0, 0];
                return Jn(o, o, Wu(Qo(i.canonical))), Jn(o, o, r), o;
              }),
              (d.globeMetersToEcef = ld),
              (d.globeNormalizeECEF = Wu),
              (d.globePixelsToTileUnits = function (r, i) {
                return (wt / (512 * Math.pow(2, r))) * dd(Qo(i));
              }),
              (d.globePoleMatrixForTile = function (r, i, o) {
                const l = sa(new Float64Array(16)),
                  h = (i / (1 << r) - 0.5) * Math.PI * 2;
                return Cp(l, o.globeMatrix, h), Float32Array.from(l);
              }),
              (d.globeTileBounds = Qo),
              (d.globeTiltAtLngLat = Kg),
              (d.globeToMercatorTransition = Ji),
              (d.globeUseCustomAntiAliasing = function (r, i, o) {
                const l = Ji(o.zoom),
                  h = r.style.map._antialias,
                  m = !!i.extStandardDerivatives,
                  _ =
                    i.extStandardDerivativesForceOff ||
                    (r.terrain && r.terrain.exaggeration() > 0);
                return 0 === l && !h && !_ && m;
              }),
              (d.identity = sa),
              (d.identity$1 = Qf),
              (d.invert = Dp),
              (d.isFullscreen = function () {
                return (
                  !!Be.document.fullscreenElement ||
                  !!Be.document.webkitFullscreenElement
                );
              }),
              (d.isLngLatBehindGlobe = im),
              (d.isMapAuthenticated = function (r) {
                return gr.has(r);
              }),
              (d.isMapboxURL = me),
              (d.isSafariWithAntialiasingBug = function (r) {
                const i = r.navigator ? r.navigator.userAgent : null;
                return (
                  !!lc(r) &&
                  i &&
                  (i.match("Version/15.4") ||
                    i.match("Version/15.5") ||
                    i.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
                );
              }),
              (d.latFromMercatorY = qi),
              (d.latLngToECEF = ud),
              (d.len = Kf),
              (d.length = Fc),
              (d.length$1 = function (r) {
                return Math.hypot(r[0], r[1], r[2], r[3]);
              }),
              (d.lngFromMercatorX = ao),
              (d.loadVectorTile = T0),
              (d.makeRequest = La),
              (d.mapValue = function (r, i, o, l, h) {
                return tn(((r - i) / (o - i)) * (h - l) + l, l, h);
              }),
              (d.mercatorScale = sm),
              (d.mercatorXfromLng = ua),
              (d.mercatorYfromLat = ai),
              (d.mercatorZfromAltitude = Ao),
              (d.mul = Ip),
              (d.mul$1 = yv),
              (d.multiply = Rc),
              (d.multiply$1 = kc),
              (d.multiply$2 = Ug),
              (d.nextPowerOfTwo = ss),
              (d.normalize = Mt),
              (d.normalize$1 = Hg),
              (d.normalize$2 = Yf),
              (d.number = ln),
              (d.ortho = function (r, i, o, l, h, m, _) {
                var x = 1 / (i - o),
                  E = 1 / (l - h),
                  T = 1 / (m - _);
                return (
                  (r[0] = -2 * x),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = -2 * E),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[10] = 2 * T),
                  (r[11] = 0),
                  (r[12] = (i + o) * x),
                  (r[13] = (h + l) * E),
                  (r[14] = (_ + m) * T),
                  (r[15] = 1),
                  r
                );
              }),
              (d.pbf = R_),
              (d.perspective = function (r, i, o, l, h) {
                var m,
                  _ = 1 / Math.tan(i / 2);
                return (
                  (r[0] = _ / o),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = _),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[11] = -1),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[15] = 0),
                  null != h && h !== 1 / 0
                    ? ((r[10] = (h + l) * (m = 1 / (l - h))),
                      (r[14] = 2 * h * l * m))
                    : ((r[10] = -1), (r[14] = -2 * l)),
                  r
                );
              }),
              (d.pick = function (r, i) {
                const o = {};
                for (let l = 0; l < i.length; l++) {
                  const h = i[l];
                  h in r && (o[h] = r[h]);
                }
                return o;
              }),
              (d.plugin = S),
              (d.pointGeometry = is),
              (d.polesInViewport = function (r) {
                const i = sa(new Float64Array(16));
                Rc(i, r.pixelMatrix, r.globeMatrix);
                const o = [0, Yo, 0],
                  l = [0, Mo, 0];
                return (
                  Jn(o, o, i),
                  Jn(l, l, i),
                  [
                    o[0] > 0 &&
                      o[0] <= r.width &&
                      o[1] > 0 &&
                      o[1] <= r.height &&
                      !im(r, new Ln(r.center.lat, 90)),
                    l[0] > 0 &&
                      l[0] <= r.width &&
                      l[1] > 0 &&
                      l[1] <= r.height &&
                      !im(r, new Ln(r.center.lat, -90)),
                  ]
                );
              }),
              (d.polygonContainsPoint = nl),
              (d.polygonIntersectsBox = pm),
              (d.polygonIntersectsPolygon = t_),
              (d.polygonizeBounds = function (r, i, o = 0, l = !0) {
                const h = new nt(o, o),
                  m = r.sub(h),
                  _ = i.add(h),
                  x = [m, new nt(_.x, m.y), _, new nt(m.x, _.y)];
                return l && x.push(m.clone()), x;
              }),
              (d.posAttributes = Ja),
              (d.postMapLoadEvent = fi),
              (d.postPerformanceEvent = Di),
              (d.postTurnstileEvent = on),
              (d.potpack = Rd),
              (d.prevPowerOfTwo = function (r) {
                return r <= 1
                  ? 1
                  : Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
              }),
              (d.radToDeg = zi),
              (d.refProperties = [
                "type",
                "source",
                "source-layer",
                "minzoom",
                "maxzoom",
                "filter",
                "layout",
              ]),
              (d.registerForPluginStateChange = function (r) {
                return (
                  r({ pluginStatus: f, pluginURL: a }),
                  v.on("pluginStateChange", r),
                  r
                );
              }),
              (d.removeAuthState = function (r) {
                gr.delete(r);
              }),
              (d.renderColorRamp = gm),
              (d.resample = lm),
              (d.rotateX = Wf),
              (d.rotateX$1 = Hu),
              (d.rotateY = Cp),
              (d.rotateY$1 = ad),
              (d.rotateZ = function (r, i, o) {
                var l = Math.sin(o),
                  h = Math.cos(o),
                  m = i[0],
                  _ = i[1],
                  x = i[2],
                  E = i[3],
                  T = i[4],
                  I = i[5],
                  A = i[6],
                  L = i[7];
                return (
                  i !== r &&
                    ((r[8] = i[8]),
                    (r[9] = i[9]),
                    (r[10] = i[10]),
                    (r[11] = i[11]),
                    (r[12] = i[12]),
                    (r[13] = i[13]),
                    (r[14] = i[14]),
                    (r[15] = i[15])),
                  (r[0] = m * h + T * l),
                  (r[1] = _ * h + I * l),
                  (r[2] = x * h + A * l),
                  (r[3] = E * h + L * l),
                  (r[4] = T * h - m * l),
                  (r[5] = I * h - _ * l),
                  (r[6] = A * h - x * l),
                  (r[7] = L * h - E * l),
                  r
                );
              }),
              (d.rotateZ$1 = function (r, i, o) {
                o *= 0.5;
                var l = i[0],
                  h = i[1],
                  m = i[2],
                  _ = i[3],
                  x = Math.sin(o),
                  E = Math.cos(o);
                return (
                  (r[0] = l * E + h * x),
                  (r[1] = h * E - l * x),
                  (r[2] = m * E + _ * x),
                  (r[3] = _ * E - m * x),
                  r
                );
              }),
              (d.scale = Oc),
              (d.scale$1 = sd),
              (d.scale$2 = ur),
              (d.scaleAndAdd = rd),
              (d.set = function (r, i, o, l) {
                return (r[0] = i), (r[1] = o), (r[2] = l), r;
              }),
              (d.setCacheLimits = function (r, i) {
                (wl = r), (du = i);
              }),
              (d.setColumn = function (r, i, o) {
                (r[4 * i + 0] = o[0]),
                  (r[4 * i + 1] = o[1]),
                  (r[4 * i + 2] = o[2]),
                  (r[4 * i + 3] = o[3]);
              }),
              (d.setRTLTextPlugin = function (r, i, o = !1) {
                if (f === Mc || f === Fu || f === Nu)
                  throw new Error(
                    "setRTLTextPlugin cannot be called multiple times."
                  );
                (a = cs.resolveURL(r)), (f = Mc), (qa = i), g(), o || D();
              }),
              (d.smoothstep = Ma),
              (d.spec = Ae),
              (d.squaredLength = function (r) {
                var i = r[0],
                  o = r[1],
                  l = r[2];
                return i * i + o * o + l * l;
              }),
              (d.storeAuthState = function (r, i) {
                i ? gr.add(r) : gr.delete(r);
              }),
              (d.sub = _s),
              (d.subtract = Zf),
              (d.symbolSize = Rm),
              (d.tileAABB = function (r, i, o, l, h, m, _, x, E) {
                if ("globe" === E.name)
                  return (function xb(r, i, o) {
                    const l = i / r.worldSize,
                      h = r.globeMatrix;
                    if (o.z <= 1) {
                      const xe = Qo(o).getCorners();
                      return Ap(xe, h, l), zr.fromPoints(xe);
                    }
                    const m = tm(o),
                      _ = Xg(m);
                    Ap(_, h, l);
                    const x = Number.MAX_VALUE,
                      E = [-x, -x, -x],
                      T = [x, x, x];
                    if (m.contains(r.center)) {
                      for (const $e of _) Uu(T, T, $e), Qa(E, E, $e);
                      E[2] = 0;
                      const xe = r.point,
                        Pe = [xe.x * l, xe.y * l, 0];
                      return Uu(T, T, Pe), Qa(E, E, Pe), new zr(T, E);
                    }
                    const I = [h[12] * l, h[13] * l, h[14] * l],
                      A = m.getCenter(),
                      L = tn(r.center.lat, -Si, Si),
                      O = tn(A.lat, -Si, Si),
                      F = ua(r.center.lng),
                      V = ai(L);
                    let G = F - ua(A.lng);
                    const K = V - ai(O);
                    G > 0.5 ? (G -= 1) : G < -0.5 && (G += 1);
                    let oe = 0;
                    Math.abs(G) > Math.abs(K)
                      ? (oe = G >= 0 ? 1 : 3)
                      : ((oe = K >= 0 ? 0 : 2),
                        rd(
                          I,
                          I,
                          [h[4] * l, h[5] * l, h[6] * l],
                          -Math.sin(Qt(K >= 0 ? m.getSouth() : m.getNorth())) *
                            la
                        ));
                    const J = _[oe],
                      re = _[(oe + 1) % 4],
                      le = new wv(J, re, I),
                      ae = [
                        em(le, 0) || J[0],
                        em(le, 1) || J[1],
                        em(le, 2) || J[2],
                      ],
                      De = Ji(r.zoom);
                    if (De > 0) {
                      const xe = (function (
                        { x: $e, y: Ie, z: Fe },
                        Re,
                        Ve,
                        qe,
                        Me
                      ) {
                        const tt = 1 / (1 << Fe);
                        let pt = $e * tt,
                          rt = pt + tt,
                          Lt = Ie * tt,
                          Ke = Lt + tt,
                          bt = 0;
                        const Pt = (pt + rt) / 2 - qe;
                        return (
                          Pt > 0.5 ? (bt = -1) : Pt < -0.5 && (bt = 1),
                          (pt = ((pt + bt) * Re - (qe *= Re)) * Ve + qe),
                          (rt = ((rt + bt) * Re - qe) * Ve + qe),
                          (Lt = (Lt * Re - (Me *= Re)) * Ve + Me),
                          (Ke = (Ke * Re - Me) * Ve + Me),
                          [
                            [pt, Ke, 0],
                            [rt, Ke, 0],
                            [rt, Lt, 0],
                            [pt, Lt, 0],
                          ]
                        );
                      })(o, i, r._pixelsPerMercatorPixel, F, V);
                      for (let $e = 0; $e < _.length; $e++)
                        qu(_[$e], xe[$e], De);
                      const Pe = Ya([], xe[oe], xe[(oe + 1) % 4]);
                      ur(Pe, Pe, 0.5), qu(ae, Pe, De);
                    }
                    for (const xe of _) Uu(T, T, xe), Qa(E, E, xe);
                    return (
                      (T[2] = Math.min(J[2], re[2])),
                      Uu(T, T, ae),
                      Qa(E, E, ae),
                      new zr(T, E)
                    );
                  })(r, i, new bi(o, l, h));
                const T = qc({ z: o, x: l, y: h }, E);
                return new zr(
                  [(m + T.x / T.scale) * i, i * (T.y / T.scale), _],
                  [(m + T.x2 / T.scale) * i, i * (T.y2 / T.scale), x]
                );
              }),
              (d.tileCornersToBounds = tm),
              (d.tileTransform = qc),
              (d.transformMat3 = function (r, i, o) {
                var l = i[0],
                  h = i[1],
                  m = i[2];
                return (
                  (r[0] = l * o[0] + h * o[3] + m * o[6]),
                  (r[1] = l * o[1] + h * o[4] + m * o[7]),
                  (r[2] = l * o[2] + h * o[5] + m * o[8]),
                  r
                );
              }),
              (d.transformMat4 = Jn),
              (d.transformMat4$1 = aa),
              (d.transformQuat = $u),
              (d.transitionTileAABBinECEF = Ev),
              (d.translate = id),
              (d.transpose = function (r, i) {
                if (r === i) {
                  var o = i[1],
                    l = i[2],
                    h = i[5];
                  (r[1] = i[3]),
                    (r[2] = i[6]),
                    (r[3] = o),
                    (r[5] = i[7]),
                    (r[6] = l),
                    (r[7] = h);
                } else
                  (r[0] = i[0]),
                    (r[1] = i[3]),
                    (r[2] = i[6]),
                    (r[3] = i[1]),
                    (r[4] = i[4]),
                    (r[5] = i[7]),
                    (r[6] = i[2]),
                    (r[7] = i[5]),
                    (r[8] = i[8]);
                return r;
              }),
              (d.triggerPluginCompletionEvent = u),
              (d.uniqueId = rs),
              (d.updateGlobeVertexNormal = function (r, i, o, l, h) {
                const m = 5 * i + 2;
                (r.float32[m + 0] = o),
                  (r.float32[m + 1] = l),
                  (r.float32[m + 2] = h);
              }),
              (d.validateCustomStyleLayer = function (r) {
                const i = [],
                  o = r.id;
                return (
                  void 0 === o &&
                    i.push({
                      message: `layers.${o}: missing required property "id"`,
                    }),
                  void 0 === r.render &&
                    i.push({
                      message: `layers.${o}: missing required method "render"`,
                    }),
                  r.renderingMode &&
                    "2d" !== r.renderingMode &&
                    "3d" !== r.renderingMode &&
                    i.push({
                      message: `layers.${o}: property "renderingMode" must be either "2d" or "3d"`,
                    }),
                  i
                );
              }),
              (d.validateFilter = (r) => Or(zl(r))),
              (d.validateFog = (r) => Or(mn(r))),
              (d.validateLayer = (r) => Or(_p(r))),
              (d.validateLight = (r) => Or(vp(r))),
              (d.validateSource = (r) => Or(Kh(r))),
              (d.validateStyle = Yh),
              (d.validateTerrain = (r) => Or(Ze(r))),
              (d.values = Rs),
              (d.vectorTile = Dm),
              (d.version = Oo),
              (d.warnOnce = Wn),
              (d.window = Be),
              (d.wrap = Tn);
          }),
          op(0, function (d) {
            function Be(se) {
              if (
                "number" == typeof se ||
                "boolean" == typeof se ||
                "string" == typeof se ||
                null == se
              )
                return JSON.stringify(se);
              if (Array.isArray(se)) {
                let $ = "[";
                for (const ne of se) $ += `${Be(ne)},`;
                return `${$}]`;
              }
              let U = "{";
              for (const $ of Object.keys(se).sort()) U += `${$}:${Be(se[$])},`;
              return `${U}}`;
            }
            function Oo(se) {
              let U = "";
              for (const $ of d.refProperties) U += `/${Be(se[$])}`;
              return U;
            }
            class eo {
              constructor(U) {
                (this.keyCache = {}), U && this.replace(U);
              }
              replace(U) {
                (this._layerConfigs = {}),
                  (this._layers = {}),
                  this.update(U, []);
              }
              update(U, $) {
                for (const ce of U)
                  (this._layerConfigs[ce.id] = ce),
                    (this._layers[ce.id] =
                      d.createStyleLayer(ce)).compileFilter(),
                    this.keyCache[ce.id] && delete this.keyCache[ce.id];
                for (const ce of $)
                  delete this.keyCache[ce],
                    delete this._layerConfigs[ce],
                    delete this._layers[ce];
                this.familiesBySource = {};
                const ne = (function (ce, me) {
                  const ve = {};
                  for (let fe = 0; fe < ce.length; fe++) {
                    const Ce = (me && me[ce[fe].id]) || Oo(ce[fe]);
                    me && (me[ce[fe].id] = Ce);
                    let Qe = ve[Ce];
                    Qe || (Qe = ve[Ce] = []), Qe.push(ce[fe]);
                  }
                  const ye = [];
                  for (const fe in ve) ye.push(ve[fe]);
                  return ye;
                })(d.values(this._layerConfigs), this.keyCache);
                for (const ce of ne) {
                  const me = ce.map((et) => this._layers[et.id]),
                    ve = me[0];
                  if ("none" === ve.visibility) continue;
                  const ye = ve.source || "";
                  let fe = this.familiesBySource[ye];
                  fe || (fe = this.familiesBySource[ye] = {});
                  const Ce = ve.sourceLayer || "_geojsonTileLayer";
                  let Qe = fe[Ce];
                  Qe || (Qe = fe[Ce] = []), Qe.push(me);
                }
              }
            }
            class jt {
              loadTile(U, $) {
                const {
                    uid: ne,
                    encoding: ce,
                    rawImageData: me,
                    padding: ve,
                    buildQuadTree: ye,
                  } = U,
                  fe =
                    d.window.ImageBitmap && me instanceof d.window.ImageBitmap
                      ? this.getImageData(me, ve)
                      : me;
                $(null, new d.DEMData(ne, fe, ce, ve < 1, ye));
              }
              getImageData(U, $) {
                (this.offscreenCanvas && this.offscreenCanvasContext) ||
                  ((this.offscreenCanvas = new OffscreenCanvas(
                    U.width,
                    U.height
                  )),
                  (this.offscreenCanvasContext =
                    this.offscreenCanvas.getContext("2d", {
                      willReadFrequently: !0,
                    }))),
                  (this.offscreenCanvas.width = U.width),
                  (this.offscreenCanvas.height = U.height),
                  this.offscreenCanvasContext.drawImage(
                    U,
                    0,
                    0,
                    U.width,
                    U.height
                  );
                const ne = this.offscreenCanvasContext.getImageData(
                  -$,
                  -$,
                  U.width + 2 * $,
                  U.height + 2 * $
                );
                return (
                  this.offscreenCanvasContext.clearRect(
                    0,
                    0,
                    this.offscreenCanvas.width,
                    this.offscreenCanvas.height
                  ),
                  ne
                );
              }
            }
            function zt(se, U) {
              if (0 !== se.length) {
                Mi(se[0], U);
                for (var $ = 1; $ < se.length; $++) Mi(se[$], !U);
              }
            }
            function Mi(se, U) {
              for (
                var $ = 0, ne = 0, ce = 0, me = se.length, ve = me - 1;
                ce < me;
                ve = ce++
              ) {
                var ye = (se[ce][0] - se[ve][0]) * (se[ve][1] + se[ce][1]),
                  fe = $ + ye;
                (ne += Math.abs($) >= Math.abs(ye) ? $ - fe + ye : ye - fe + $),
                  ($ = fe);
              }
              $ + ne >= 0 != !!U && se.reverse();
            }
            var mr = d.getDefaultExportFromCjs(function se(U, $) {
              var ne,
                ce = U && U.type;
              if ("FeatureCollection" === ce)
                for (ne = 0; ne < U.features.length; ne++)
                  se(U.features[ne], $);
              else if ("GeometryCollection" === ce)
                for (ne = 0; ne < U.geometries.length; ne++)
                  se(U.geometries[ne], $);
              else if ("Feature" === ce) se(U.geometry, $);
              else if ("Polygon" === ce) zt(U.coordinates, $);
              else if ("MultiPolygon" === ce)
                for (ne = 0; ne < U.coordinates.length; ne++)
                  zt(U.coordinates[ne], $);
              return U;
            });
            const Fo = d.VectorTileFeature.prototype.toGeoJSON;
            var ns = { exports: {} },
              oc = d.pointGeometry,
              vl = d.vectorTile.VectorTileFeature,
              Ur = to;
            function to(se, U) {
              (this.options = U || {}),
                (this.features = se),
                (this.length = se.length);
            }
            function Mr(se, U) {
              (this.id = "number" == typeof se.id ? se.id : void 0),
                (this.type = se.type),
                (this.rawGeometry =
                  1 === se.type ? [se.geometry] : se.geometry),
                (this.properties = se.tags),
                (this.extent = U || 4096);
            }
            (to.prototype.feature = function (se) {
              return new Mr(this.features[se], this.options.extent);
            }),
              (Mr.prototype.loadGeometry = function () {
                var se = this.rawGeometry;
                this.geometry = [];
                for (var U = 0; U < se.length; U++) {
                  for (var $ = se[U], ne = [], ce = 0; ce < $.length; ce++)
                    ne.push(new oc($[ce][0], $[ce][1]));
                  this.geometry.push(ne);
                }
                return this.geometry;
              }),
              (Mr.prototype.bbox = function () {
                this.geometry || this.loadGeometry();
                for (
                  var se = this.geometry,
                    U = 1 / 0,
                    $ = -1 / 0,
                    ne = 1 / 0,
                    ce = -1 / 0,
                    me = 0;
                  me < se.length;
                  me++
                )
                  for (var ve = se[me], ye = 0; ye < ve.length; ye++) {
                    var fe = ve[ye];
                    (U = Math.min(U, fe.x)),
                      ($ = Math.max($, fe.x)),
                      (ne = Math.min(ne, fe.y)),
                      (ce = Math.max(ce, fe.y));
                  }
                return [U, ne, $, ce];
              }),
              (Mr.prototype.toGeoJSON = vl.prototype.toGeoJSON);
            var Ca = d.pbf,
              is = Ur;
            function go(se) {
              var U = new Ca();
              return (
                (function ($, ne) {
                  for (var ce in $.layers) ne.writeMessage(3, nt, $.layers[ce]);
                })(se, U),
                U.finish()
              );
            }
            function nt(se, U) {
              var $;
              U.writeVarintField(15, se.version || 1),
                U.writeStringField(1, se.name || ""),
                U.writeVarintField(5, se.extent || 4096);
              var ne = { keys: [], values: [], keycache: {}, valuecache: {} };
              for ($ = 0; $ < se.length; $++)
                (ne.feature = se.feature($)), U.writeMessage(2, Dh, ne);
              var ce = ne.keys;
              for ($ = 0; $ < ce.length; $++) U.writeStringField(3, ce[$]);
              var me = ne.values;
              for ($ = 0; $ < me.length; $++) U.writeMessage(4, cu, me[$]);
            }
            function Dh(se, U) {
              var $ = se.feature;
              void 0 !== $.id && U.writeVarintField(1, $.id),
                U.writeMessage(2, Sa, se),
                U.writeVarintField(3, $.type),
                U.writeMessage(4, sc, $);
            }
            function Sa(se, U) {
              var $ = se.feature,
                ne = se.keys,
                ce = se.values,
                me = se.keycache,
                ve = se.valuecache;
              for (var ye in $.properties) {
                var fe = $.properties[ye],
                  Ce = me[ye];
                if (null !== fe) {
                  void 0 === Ce && (ne.push(ye), (me[ye] = Ce = ne.length - 1)),
                    U.writeVarint(Ce);
                  var Qe = typeof fe;
                  "string" !== Qe &&
                    "boolean" !== Qe &&
                    "number" !== Qe &&
                    (fe = JSON.stringify(fe));
                  var et = Qe + ":" + fe,
                    We = ve[et];
                  void 0 === We && (ce.push(fe), (ve[et] = We = ce.length - 1)),
                    U.writeVarint(We);
                }
              }
            }
            function Qt(se, U) {
              return (U << 3) + (7 & se);
            }
            function zi(se) {
              return (se << 1) ^ (se >> 31);
            }
            function sc(se, U) {
              for (
                var $ = se.loadGeometry(),
                  ne = se.type,
                  ce = 0,
                  me = 0,
                  ve = $.length,
                  ye = 0;
                ye < ve;
                ye++
              ) {
                var fe = $[ye],
                  Ce = 1;
                1 === ne && (Ce = fe.length), U.writeVarint(Qt(1, Ce));
                for (
                  var Qe = 3 === ne ? fe.length - 1 : fe.length, et = 0;
                  et < Qe;
                  et++
                ) {
                  1 === et && 1 !== ne && U.writeVarint(Qt(2, Qe - 1));
                  var We = fe[et].x - ce,
                    Rt = fe[et].y - me;
                  U.writeVarint(zi(We)),
                    U.writeVarint(zi(Rt)),
                    (ce += We),
                    (me += Rt);
                }
                3 === ne && U.writeVarint(Qt(7, 1));
              }
            }
            function cu(se, U) {
              var $ = typeof se;
              "string" === $
                ? U.writeStringField(1, se)
                : "boolean" === $
                ? U.writeBooleanField(7, se)
                : "number" === $ &&
                  (se % 1 != 0
                    ? U.writeDoubleField(3, se)
                    : se < 0
                    ? U.writeSVarintField(6, se)
                    : U.writeVarintField(5, se));
            }
            (ns.exports = go),
              (ns.exports.fromVectorTileJs = go),
              (ns.exports.fromGeojsonVt = function (se, U) {
                U = U || {};
                var $ = {};
                for (var ne in se)
                  ($[ne] = new is(se[ne].features, U)),
                    ($[ne].name = ne),
                    ($[ne].version = U.version),
                    ($[ne].extent = U.extent);
                return go({ layers: $ });
              }),
              (ns.exports.GeoJSONWrapper = is);
            var Ia = d.getDefaultExportFromCjs(ns.exports);
            const ac = {
                minZoom: 0,
                maxZoom: 16,
                minPoints: 2,
                radius: 40,
                extent: 512,
                nodeSize: 64,
                log: !1,
                generateId: !1,
                reduce: null,
                map: (se) => se,
              },
              tn =
                Math.fround ||
                ((Ma = new Float32Array(1)), (se) => ((Ma[0] = +se), Ma[0]));
            var Ma;
            class pi {
              constructor(U) {
                (this.options = Object.assign(Object.create(ac), U)),
                  (this.trees = new Array(this.options.maxZoom + 1)),
                  (this.stride = this.options.reduce ? 7 : 6),
                  (this.clusterProps = []);
              }
              load(U) {
                const { log: $, minZoom: ne, maxZoom: ce } = this.options;
                $ && console.time("total time");
                const me = `prepare ${U.length} points`;
                $ && console.time(me), (this.points = U);
                const ve = [];
                for (let fe = 0; fe < U.length; fe++) {
                  const Ce = U[fe];
                  if (!Ce.geometry) continue;
                  const [Qe, et] = Ce.geometry.coordinates,
                    We = tn(os(Qe)),
                    Rt = tn(ss(et));
                  ve.push(We, Rt, 1 / 0, fe, -1, 1),
                    this.options.reduce && ve.push(0);
                }
                let ye = (this.trees[ce + 1] = this._createTree(ve));
                $ && console.timeEnd(me);
                for (let fe = ce; fe >= ne; fe--) {
                  const Ce = +Date.now();
                  (ye = this.trees[fe] =
                    this._createTree(this._cluster(ye, fe))),
                    $ &&
                      console.log(
                        "z%d: %d clusters in %dms",
                        fe,
                        ye.numItems,
                        +Date.now() - Ce
                      );
                }
                return $ && console.timeEnd("total time"), this;
              }
              getClusters(U, $) {
                let ne = ((((U[0] + 180) % 360) + 360) % 360) - 180;
                const ce = Math.max(-90, Math.min(90, U[1]));
                let me =
                  180 === U[2]
                    ? 180
                    : ((((U[2] + 180) % 360) + 360) % 360) - 180;
                const ve = Math.max(-90, Math.min(90, U[3]));
                if (U[2] - U[0] >= 360) (ne = -180), (me = 180);
                else if (ne > me) {
                  const et = this.getClusters([ne, ce, 180, ve], $),
                    We = this.getClusters([-180, ce, me, ve], $);
                  return et.concat(We);
                }
                const ye = this.trees[this._limitZoom($)],
                  fe = ye.range(os(ne), ss(ve), os(me), ss(ce)),
                  Ce = ye.data,
                  Qe = [];
                for (const et of fe) {
                  const We = this.stride * et;
                  Qe.push(
                    Ce[We + 5] > 1
                      ? Os(Ce, We, this.clusterProps)
                      : this.points[Ce[We + 3]]
                  );
                }
                return Qe;
              }
              getChildren(U) {
                const $ = this._getOriginId(U),
                  ne = this._getOriginZoom(U),
                  ce = "No cluster with the specified id.",
                  me = this.trees[ne];
                if (!me) throw new Error(ce);
                const ve = me.data;
                if ($ * this.stride >= ve.length) throw new Error(ce);
                const ye =
                    this.options.radius /
                    (this.options.extent * Math.pow(2, ne - 1)),
                  fe = me.within(
                    ve[$ * this.stride],
                    ve[$ * this.stride + 1],
                    ye
                  ),
                  Ce = [];
                for (const Qe of fe) {
                  const et = Qe * this.stride;
                  ve[et + 4] === U &&
                    Ce.push(
                      ve[et + 5] > 1
                        ? Os(ve, et, this.clusterProps)
                        : this.points[ve[et + 3]]
                    );
                }
                if (0 === Ce.length) throw new Error(ce);
                return Ce;
              }
              getLeaves(U, $, ne) {
                const ce = [];
                return (
                  this._appendLeaves(ce, U, ($ = $ || 10), (ne = ne || 0), 0),
                  ce
                );
              }
              getTile(U, $, ne) {
                const ce = this.trees[this._limitZoom(U)],
                  me = Math.pow(2, U),
                  { extent: ve, radius: ye } = this.options,
                  fe = ye / ve,
                  Ce = (ne - fe) / me,
                  Qe = (ne + 1 + fe) / me,
                  et = { features: [] };
                return (
                  this._addTileFeatures(
                    ce.range(($ - fe) / me, Ce, ($ + 1 + fe) / me, Qe),
                    ce.data,
                    $,
                    ne,
                    me,
                    et
                  ),
                  0 === $ &&
                    this._addTileFeatures(
                      ce.range(1 - fe / me, Ce, 1, Qe),
                      ce.data,
                      me,
                      ne,
                      me,
                      et
                    ),
                  $ === me - 1 &&
                    this._addTileFeatures(
                      ce.range(0, Ce, fe / me, Qe),
                      ce.data,
                      -1,
                      ne,
                      me,
                      et
                    ),
                  et.features.length ? et : null
                );
              }
              getClusterExpansionZoom(U) {
                let $ = this._getOriginZoom(U) - 1;
                for (; $ <= this.options.maxZoom; ) {
                  const ne = this.getChildren(U);
                  if (($++, 1 !== ne.length)) break;
                  U = ne[0].properties.cluster_id;
                }
                return $;
              }
              _appendLeaves(U, $, ne, ce, me) {
                const ve = this.getChildren($);
                for (const ye of ve) {
                  const fe = ye.properties;
                  if (
                    (fe && fe.cluster
                      ? me + fe.point_count <= ce
                        ? (me += fe.point_count)
                        : (me = this._appendLeaves(
                            U,
                            fe.cluster_id,
                            ne,
                            ce,
                            me
                          ))
                      : me < ce
                      ? me++
                      : U.push(ye),
                    U.length === ne)
                  )
                    break;
                }
                return me;
              }
              _createTree(U) {
                const $ = new d.KDBush(
                  (U.length / this.stride) | 0,
                  this.options.nodeSize,
                  Float32Array
                );
                for (let ne = 0; ne < U.length; ne += this.stride)
                  $.add(U[ne], U[ne + 1]);
                return $.finish(), ($.data = U), $;
              }
              _addTileFeatures(U, $, ne, ce, me, ve) {
                for (const ye of U) {
                  const fe = ye * this.stride,
                    Ce = $[fe + 5] > 1;
                  let Qe, et, We;
                  if (Ce)
                    (Qe = rs($, fe, this.clusterProps)),
                      (et = $[fe]),
                      (We = $[fe + 1]);
                  else {
                    const Ct = this.points[$[fe + 3]];
                    Qe = Ct.properties;
                    const [Zt, on] = Ct.geometry.coordinates;
                    (et = os(Zt)), (We = ss(on));
                  }
                  const Rt = {
                    type: 1,
                    geometry: [
                      [
                        Math.round(this.options.extent * (et * me - ne)),
                        Math.round(this.options.extent * (We * me - ce)),
                      ],
                    ],
                    tags: Qe,
                  };
                  let Ut;
                  (Ut =
                    Ce || this.options.generateId
                      ? $[fe + 3]
                      : this.points[$[fe + 3]].id),
                    void 0 !== Ut && (Rt.id = Ut),
                    ve.features.push(Rt);
                }
              }
              _limitZoom(U) {
                return Math.max(
                  this.options.minZoom,
                  Math.min(Math.floor(+U), this.options.maxZoom + 1)
                );
              }
              _cluster(U, $) {
                const {
                    radius: ne,
                    extent: ce,
                    reduce: me,
                    minPoints: ve,
                  } = this.options,
                  ye = ne / (ce * Math.pow(2, $)),
                  fe = U.data,
                  Ce = [],
                  Qe = this.stride;
                for (let et = 0; et < fe.length; et += Qe) {
                  if (fe[et + 2] <= $) continue;
                  fe[et + 2] = $;
                  const We = fe[et],
                    Rt = fe[et + 1],
                    Ut = U.within(fe[et], fe[et + 1], ye),
                    Ct = fe[et + 5];
                  let Zt = Ct;
                  for (const on of Ut) {
                    const Zn = on * Qe;
                    fe[Zn + 2] > $ && (Zt += fe[Zn + 5]);
                  }
                  if (Zt > Ct && Zt >= ve) {
                    let on,
                      Zn = We * Ct,
                      fi = Rt * Ct,
                      Ki = -1;
                    const Di =
                      (((et / Qe) | 0) << 5) + ($ + 1) + this.points.length;
                    for (const zo of Ut) {
                      const Xn = zo * Qe;
                      if (fe[Xn + 2] <= $) continue;
                      fe[Xn + 2] = $;
                      const gr = fe[Xn + 5];
                      (Zn += fe[Xn] * gr),
                        (fi += fe[Xn + 1] * gr),
                        (fe[Xn + 4] = Di),
                        me &&
                          (on ||
                            ((on = this._map(fe, et, !0)),
                            (Ki = this.clusterProps.length),
                            this.clusterProps.push(on)),
                          me(on, this._map(fe, Xn)));
                    }
                    (fe[et + 4] = Di),
                      Ce.push(Zn / Zt, fi / Zt, 1 / 0, Di, -1, Zt),
                      me && Ce.push(Ki);
                  } else {
                    for (let on = 0; on < Qe; on++) Ce.push(fe[et + on]);
                    if (Zt > 1)
                      for (const on of Ut) {
                        const Zn = on * Qe;
                        if (!(fe[Zn + 2] <= $)) {
                          fe[Zn + 2] = $;
                          for (let fi = 0; fi < Qe; fi++) Ce.push(fe[Zn + fi]);
                        }
                      }
                  }
                }
                return Ce;
              }
              _getOriginId(U) {
                return (U - this.points.length) >> 5;
              }
              _getOriginZoom(U) {
                return (U - this.points.length) % 32;
              }
              _map(U, $, ne) {
                if (U[$ + 5] > 1) {
                  const ve = this.clusterProps[U[$ + 6]];
                  return ne ? Object.assign({}, ve) : ve;
                }
                const ce = this.points[U[$ + 3]].properties,
                  me = this.options.map(ce);
                return ne && me === ce ? Object.assign({}, me) : me;
              }
            }
            function Os(se, U, $) {
              return {
                type: "Feature",
                id: se[U + 3],
                properties: rs(se, U, $),
                geometry: {
                  type: "Point",
                  coordinates: [
                    ((ne = se[U]), 360 * (ne - 0.5)),
                    Fs(se[U + 1]),
                  ],
                },
              };
              var ne;
            }
            function rs(se, U, $) {
              const ne = se[U + 5],
                ce =
                  ne >= 1e4
                    ? `${Math.round(ne / 1e3)}k`
                    : ne >= 1e3
                    ? Math.round(ne / 100) / 10 + "k"
                    : ne,
                me = se[U + 6],
                ve = -1 === me ? {} : Object.assign({}, $[me]);
              return Object.assign(ve, {
                cluster: !0,
                cluster_id: se[U + 3],
                point_count: ne,
                point_count_abbreviated: ce,
              });
            }
            function os(se) {
              return se / 360 + 0.5;
            }
            function ss(se) {
              const U = Math.sin((se * Math.PI) / 180),
                $ = 0.5 - (0.25 * Math.log((1 + U) / (1 - U))) / Math.PI;
              return $ < 0 ? 0 : $ > 1 ? 1 : $;
            }
            function Fs(se) {
              const U = ((180 - 360 * se) * Math.PI) / 180;
              return (360 * Math.atan(Math.exp(U))) / Math.PI - 90;
            }
            function No(se, U, $, ne) {
              for (
                var ce,
                  me = ne,
                  ve = ($ - U) >> 1,
                  ye = $ - U,
                  fe = se[U],
                  Ce = se[U + 1],
                  Qe = se[$],
                  et = se[$ + 1],
                  We = U + 3;
                We < $;
                We += 3
              ) {
                var Rt = xl(se[We], se[We + 1], fe, Ce, Qe, et);
                if (Rt > me) (ce = We), (me = Rt);
                else if (Rt === me) {
                  var Ut = Math.abs(We - ve);
                  Ut < ye && ((ce = We), (ye = Ut));
                }
              }
              me > ne &&
                (ce - U > 3 && No(se, U, ce, ne),
                (se[ce + 2] = me),
                $ - ce > 3 && No(se, ce, $, ne));
            }
            function xl(se, U, $, ne, ce, me) {
              var ve = ce - $,
                ye = me - ne;
              if (0 !== ve || 0 !== ye) {
                var fe = ((se - $) * ve + (U - ne) * ye) / (ve * ve + ye * ye);
                fe > 1
                  ? (($ = ce), (ne = me))
                  : fe > 0 && (($ += ve * fe), (ne += ye * fe));
              }
              return (ve = se - $) * ve + (ye = U - ne) * ye;
            }
            function rn(se, U, $, ne) {
              var ce = {
                id: void 0 === se ? null : se,
                type: U,
                geometry: $,
                tags: ne,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0,
              };
              return (
                (function (me) {
                  var ve = me.geometry,
                    ye = me.type;
                  if (
                    "Point" === ye ||
                    "MultiPoint" === ye ||
                    "LineString" === ye
                  )
                    Ns(me, ve);
                  else if ("Polygon" === ye || "MultiLineString" === ye)
                    for (var fe = 0; fe < ve.length; fe++) Ns(me, ve[fe]);
                  else if ("MultiPolygon" === ye)
                    for (fe = 0; fe < ve.length; fe++)
                      for (var Ce = 0; Ce < ve[fe].length; Ce++)
                        Ns(me, ve[fe][Ce]);
                })(ce),
                ce
              );
            }
            function Ns(se, U) {
              for (var $ = 0; $ < U.length; $ += 3)
                (se.minX = Math.min(se.minX, U[$])),
                  (se.minY = Math.min(se.minY, U[$ + 1])),
                  (se.maxX = Math.max(se.maxX, U[$])),
                  (se.maxY = Math.max(se.maxY, U[$ + 1]));
            }
            function $r(se, U, $, ne) {
              if (U.geometry) {
                var ce = U.geometry.coordinates,
                  me = U.geometry.type,
                  ve = Math.pow($.tolerance / ((1 << $.maxZoom) * $.extent), 2),
                  ye = [],
                  fe = U.id;
                if (
                  ($.promoteId
                    ? (fe = U.properties[$.promoteId])
                    : $.generateId && (fe = ne || 0),
                  "Point" === me)
                )
                  Aa(ce, ye);
                else if ("MultiPoint" === me)
                  for (var Ce = 0; Ce < ce.length; Ce++) Aa(ce[Ce], ye);
                else if ("LineString" === me) Wn(ce, ye, ve, !1);
                else if ("MultiLineString" === me) {
                  if ($.lineMetrics) {
                    for (Ce = 0; Ce < ce.length; Ce++)
                      Wn(ce[Ce], (ye = []), ve, !1),
                        se.push(rn(fe, "LineString", ye, U.properties));
                    return;
                  }
                  no(ce, ye, ve, !1);
                } else if ("Polygon" === me) no(ce, ye, ve, !0);
                else {
                  if ("MultiPolygon" !== me) {
                    if ("GeometryCollection" === me) {
                      for (Ce = 0; Ce < U.geometry.geometries.length; Ce++)
                        $r(
                          se,
                          {
                            id: fe,
                            geometry: U.geometry.geometries[Ce],
                            properties: U.properties,
                          },
                          $,
                          ne
                        );
                      return;
                    }
                    throw new Error(
                      "Input data is not a valid GeoJSON object."
                    );
                  }
                  for (Ce = 0; Ce < ce.length; Ce++) {
                    var Qe = [];
                    no(ce[Ce], Qe, ve, !0), ye.push(Qe);
                  }
                }
                se.push(rn(fe, me, ye, U.properties));
              }
            }
            function Aa(se, U) {
              U.push(uu(se[0])), U.push(zs(se[1])), U.push(0);
            }
            function Wn(se, U, $, ne) {
              for (var ce, me, ve = 0, ye = 0; ye < se.length; ye++) {
                var fe = uu(se[ye][0]),
                  Ce = zs(se[ye][1]);
                U.push(fe),
                  U.push(Ce),
                  U.push(0),
                  ye > 0 &&
                    (ve += ne
                      ? (ce * Ce - fe * me) / 2
                      : Math.sqrt(Math.pow(fe - ce, 2) + Math.pow(Ce - me, 2))),
                  (ce = fe),
                  (me = Ce);
              }
              var Qe = U.length - 3;
              (U[2] = 1),
                No(U, 0, Qe, $),
                (U[Qe + 2] = 1),
                (U.size = Math.abs(ve)),
                (U.start = 0),
                (U.end = U.size);
            }
            function no(se, U, $, ne) {
              for (var ce = 0; ce < se.length; ce++) {
                var me = [];
                Wn(se[ce], me, $, ne), U.push(me);
              }
            }
            function uu(se) {
              return se / 360 + 0.5;
            }
            function zs(se) {
              var U = Math.sin((se * Math.PI) / 180),
                $ = 0.5 - (0.25 * Math.log((1 + U) / (1 - U))) / Math.PI;
              return $ < 0 ? 0 : $ > 1 ? 1 : $;
            }
            function io(se, U, $, ne, ce, me, ve, ye) {
              if (((ne /= U), me >= ($ /= U) && ve < ne)) return se;
              if (ve < $ || me >= ne) return null;
              for (var fe = [], Ce = 0; Ce < se.length; Ce++) {
                var Qe = se[Ce],
                  et = Qe.geometry,
                  We = Qe.type,
                  Rt = 0 === ce ? Qe.minX : Qe.minY,
                  Ut = 0 === ce ? Qe.maxX : Qe.maxY;
                if (Rt >= $ && Ut < ne) fe.push(Qe);
                else if (!(Ut < $ || Rt >= ne)) {
                  var Ct = [];
                  if ("Point" === We || "MultiPoint" === We)
                    hu(et, Ct, $, ne, ce);
                  else if ("LineString" === We)
                    lc(et, Ct, $, ne, ce, !1, ye.lineMetrics);
                  else if ("MultiLineString" === We) as(et, Ct, $, ne, ce, !1);
                  else if ("Polygon" === We) as(et, Ct, $, ne, ce, !0);
                  else if ("MultiPolygon" === We)
                    for (var Zt = 0; Zt < et.length; Zt++) {
                      var on = [];
                      as(et[Zt], on, $, ne, ce, !0), on.length && Ct.push(on);
                    }
                  if (Ct.length) {
                    if (ye.lineMetrics && "LineString" === We) {
                      for (Zt = 0; Zt < Ct.length; Zt++)
                        fe.push(rn(Qe.id, We, Ct[Zt], Qe.tags));
                      continue;
                    }
                    ("LineString" !== We && "MultiLineString" !== We) ||
                      (1 === Ct.length
                        ? ((We = "LineString"), (Ct = Ct[0]))
                        : (We = "MultiLineString")),
                      ("Point" !== We && "MultiPoint" !== We) ||
                        (We = 3 === Ct.length ? "Point" : "MultiPoint"),
                      fe.push(rn(Qe.id, We, Ct, Qe.tags));
                  }
                }
              }
              return fe.length ? fe : null;
            }
            function hu(se, U, $, ne, ce) {
              for (var me = 0; me < se.length; me += 3) {
                var ve = se[me + ce];
                ve >= $ &&
                  ve <= ne &&
                  (U.push(se[me]), U.push(se[me + 1]), U.push(se[me + 2]));
              }
            }
            function lc(se, U, $, ne, ce, me, ve) {
              for (
                var ye,
                  fe,
                  Ce = cc(se),
                  Qe = 0 === ce ? wl : du,
                  et = se.start,
                  We = 0;
                We < se.length - 3;
                We += 3
              ) {
                var Rt = se[We],
                  Ut = se[We + 1],
                  Ct = se[We + 2],
                  Zt = se[We + 3],
                  on = se[We + 4],
                  Zn = 0 === ce ? Rt : Ut,
                  fi = 0 === ce ? Zt : on,
                  Ki = !1;
                ve &&
                  (ye = Math.sqrt(Math.pow(Rt - Zt, 2) + Math.pow(Ut - on, 2))),
                  Zn < $
                    ? fi > $ &&
                      ((fe = Qe(Ce, Rt, Ut, Zt, on, $)),
                      ve && (Ce.start = et + ye * fe))
                    : Zn > ne
                    ? fi < ne &&
                      ((fe = Qe(Ce, Rt, Ut, Zt, on, ne)),
                      ve && (Ce.start = et + ye * fe))
                    : bl(Ce, Rt, Ut, Ct),
                  fi < $ &&
                    Zn >= $ &&
                    ((fe = Qe(Ce, Rt, Ut, Zt, on, $)), (Ki = !0)),
                  fi > ne &&
                    Zn <= ne &&
                    ((fe = Qe(Ce, Rt, Ut, Zt, on, ne)), (Ki = !0)),
                  !me &&
                    Ki &&
                    (ve && (Ce.end = et + ye * fe), U.push(Ce), (Ce = cc(se))),
                  ve && (et += ye);
              }
              var Di = se.length - 3;
              (Rt = se[Di]),
                (Ut = se[Di + 1]),
                (Ct = se[Di + 2]),
                (Zn = 0 === ce ? Rt : Ut) >= $ &&
                  Zn <= ne &&
                  bl(Ce, Rt, Ut, Ct),
                (Di = Ce.length - 3),
                me &&
                  Di >= 3 &&
                  (Ce[Di] !== Ce[0] || Ce[Di + 1] !== Ce[1]) &&
                  bl(Ce, Ce[0], Ce[1], Ce[2]),
                Ce.length && U.push(Ce);
            }
            function cc(se) {
              var U = [];
              return (
                (U.size = se.size), (U.start = se.start), (U.end = se.end), U
              );
            }
            function as(se, U, $, ne, ce, me) {
              for (var ve = 0; ve < se.length; ve++)
                lc(se[ve], U, $, ne, ce, me, !1);
            }
            function bl(se, U, $, ne) {
              se.push(U), se.push($), se.push(ne);
            }
            function wl(se, U, $, ne, ce, me) {
              var ve = (me - U) / (ne - U);
              return se.push(me), se.push($ + (ce - $) * ve), se.push(1), ve;
            }
            function du(se, U, $, ne, ce, me) {
              var ve = (me - $) / (ce - $);
              return se.push(U + (ne - U) * ve), se.push(me), se.push(1), ve;
            }
            function Ar(se, U) {
              for (var $ = [], ne = 0; ne < se.length; ne++) {
                var ce,
                  me = se[ne],
                  ve = me.type;
                if (
                  "Point" === ve ||
                  "MultiPoint" === ve ||
                  "LineString" === ve
                )
                  ce = ls(me.geometry, U);
                else if ("MultiLineString" === ve || "Polygon" === ve) {
                  ce = [];
                  for (var ye = 0; ye < me.geometry.length; ye++)
                    ce.push(ls(me.geometry[ye], U));
                } else if ("MultiPolygon" === ve)
                  for (ce = [], ye = 0; ye < me.geometry.length; ye++) {
                    for (var fe = [], Ce = 0; Ce < me.geometry[ye].length; Ce++)
                      fe.push(ls(me.geometry[ye][Ce], U));
                    ce.push(fe);
                  }
                $.push(rn(me.id, ve, ce, me.tags));
              }
              return $;
            }
            function ls(se, U) {
              var $ = [];
              ($.size = se.size),
                void 0 !== se.start && (($.start = se.start), ($.end = se.end));
              for (var ne = 0; ne < se.length; ne += 3)
                $.push(se[ne] + U, se[ne + 1], se[ne + 2]);
              return $;
            }
            function uc(se, U) {
              if (se.transformed) return se;
              var $,
                ne,
                ce,
                me = 1 << se.z,
                ve = se.x,
                ye = se.y;
              for ($ = 0; $ < se.features.length; $++) {
                var fe = se.features[$],
                  Ce = fe.geometry,
                  Qe = fe.type;
                if (((fe.geometry = []), 1 === Qe))
                  for (ne = 0; ne < Ce.length; ne += 2)
                    fe.geometry.push(Pa(Ce[ne], Ce[ne + 1], U, me, ve, ye));
                else
                  for (ne = 0; ne < Ce.length; ne++) {
                    var et = [];
                    for (ce = 0; ce < Ce[ne].length; ce += 2)
                      et.push(Pa(Ce[ne][ce], Ce[ne][ce + 1], U, me, ve, ye));
                    fe.geometry.push(et);
                  }
              }
              return (se.transformed = !0), se;
            }
            function Pa(se, U, $, ne, ce, me) {
              return [
                Math.round($ * (se * ne - ce)),
                Math.round($ * (U * ne - me)),
              ];
            }
            function El(se, U, $, ne, ce) {
              for (
                var me =
                    U === ce.maxZoom
                      ? 0
                      : ce.tolerance / ((1 << U) * ce.extent),
                  ve = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: 0,
                    source: null,
                    x: $,
                    y: ne,
                    z: U,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0,
                  },
                  ye = 0;
                ye < se.length;
                ye++
              ) {
                ve.numFeatures++, ro(ve, se[ye], me, ce);
                var fe = se[ye].minX,
                  Ce = se[ye].minY,
                  Qe = se[ye].maxX,
                  et = se[ye].maxY;
                fe < ve.minX && (ve.minX = fe),
                  Ce < ve.minY && (ve.minY = Ce),
                  Qe > ve.maxX && (ve.maxX = Qe),
                  et > ve.maxY && (ve.maxY = et);
              }
              return ve;
            }
            function ro(se, U, $, ne) {
              var ce = U.geometry,
                me = U.type,
                ve = [];
              if ("Point" === me || "MultiPoint" === me)
                for (var ye = 0; ye < ce.length; ye += 3)
                  ve.push(ce[ye]),
                    ve.push(ce[ye + 1]),
                    se.numPoints++,
                    se.numSimplified++;
              else if ("LineString" === me) Bs(ve, ce, se, $, !1, !1);
              else if ("MultiLineString" === me || "Polygon" === me)
                for (ye = 0; ye < ce.length; ye++)
                  Bs(ve, ce[ye], se, $, "Polygon" === me, 0 === ye);
              else if ("MultiPolygon" === me)
                for (var fe = 0; fe < ce.length; fe++) {
                  var Ce = ce[fe];
                  for (ye = 0; ye < Ce.length; ye++)
                    Bs(ve, Ce[ye], se, $, !0, 0 === ye);
                }
              if (ve.length) {
                var Qe = U.tags || null;
                if ("LineString" === me && ne.lineMetrics) {
                  for (var et in ((Qe = {}), U.tags)) Qe[et] = U.tags[et];
                  (Qe.mapbox_clip_start = ce.start / ce.size),
                    (Qe.mapbox_clip_end = ce.end / ce.size);
                }
                var We = {
                  geometry: ve,
                  type:
                    "Polygon" === me || "MultiPolygon" === me
                      ? 3
                      : "LineString" === me || "MultiLineString" === me
                      ? 2
                      : 1,
                  tags: Qe,
                };
                null !== U.id && (We.id = U.id), se.features.push(We);
              }
            }
            function Bs(se, U, $, ne, ce, me) {
              var ve = ne * ne;
              if (ne > 0 && U.size < (ce ? ve : ne))
                $.numPoints += U.length / 3;
              else {
                for (var ye = [], fe = 0; fe < U.length; fe += 3)
                  (0 === ne || U[fe + 2] > ve) &&
                    ($.numSimplified++, ye.push(U[fe]), ye.push(U[fe + 1])),
                    $.numPoints++;
                ce &&
                  (function (Ce, Qe) {
                    for (
                      var et = 0, We = 0, Rt = Ce.length, Ut = Rt - 2;
                      We < Rt;
                      Ut = We, We += 2
                    )
                      et += (Ce[We] - Ce[Ut]) * (Ce[We + 1] + Ce[Ut + 1]);
                    if (et > 0 === Qe)
                      for (We = 0, Rt = Ce.length; We < Rt / 2; We += 2) {
                        var Ct = Ce[We],
                          Zt = Ce[We + 1];
                        (Ce[We] = Ce[Rt - 2 - We]),
                          (Ce[We + 1] = Ce[Rt - 1 - We]),
                          (Ce[Rt - 2 - We] = Ct),
                          (Ce[Rt - 1 - We] = Zt);
                      }
                  })(ye, me),
                  se.push(ye);
              }
            }
            function Vs(se, U) {
              var $ = (U = this.options =
                (function (ce, me) {
                  for (var ve in me) ce[ve] = me[ve];
                  return ce;
                })(Object.create(this.options), U)).debug;
              if (
                ($ && console.time("preprocess data"),
                U.maxZoom < 0 || U.maxZoom > 24)
              )
                throw new Error("maxZoom should be in the 0-24 range");
              if (U.promoteId && U.generateId)
                throw new Error(
                  "promoteId and generateId cannot be used together."
                );
              var ce,
                me,
                ve,
                ye,
                fe,
                Ce,
                ne = (function (ce, me) {
                  var ve = [];
                  if ("FeatureCollection" === ce.type)
                    for (var ye = 0; ye < ce.features.length; ye++)
                      $r(ve, ce.features[ye], me, ye);
                  else
                    $r(ve, "Feature" === ce.type ? ce : { geometry: ce }, me);
                  return ve;
                })(se, U);
              (this.tiles = {}),
                (this.tileCoords = []),
                $ &&
                  (console.timeEnd("preprocess data"),
                  console.log(
                    "index: maxZoom: %d, maxPoints: %d",
                    U.indexMaxZoom,
                    U.indexMaxPoints
                  ),
                  console.time("generate tiles"),
                  (this.stats = {}),
                  (this.total = 0)),
                (ye = ce = ne),
                (fe = io(
                  ce,
                  1,
                  -1 - (ve = (me = U).buffer / me.extent),
                  ve,
                  0,
                  -1,
                  2,
                  me
                )),
                (Ce = io(ce, 1, 1 - ve, 2 + ve, 0, -1, 2, me)),
                (fe || Ce) &&
                  ((ye = io(ce, 1, -ve, 1 + ve, 0, -1, 2, me) || []),
                  fe && (ye = Ar(fe, 1).concat(ye)),
                  Ce && (ye = ye.concat(Ar(Ce, -1)))),
                (ne = ye).length && this.splitTile(ne, 0, 0, 0),
                $ &&
                  (ne.length &&
                    console.log(
                      "features: %d, points: %d",
                      this.tiles[0].numFeatures,
                      this.tiles[0].numPoints
                    ),
                  console.timeEnd("generate tiles"),
                  console.log(
                    "tiles generated:",
                    this.total,
                    JSON.stringify(this.stats)
                  ));
            }
            function js(se, U, $) {
              return 32 * ((1 << se) * $ + U) + se;
            }
            function La(se, U) {
              const $ = se.tileID.canonical;
              if (!this._geoJSONIndex) return U(null, null);
              const ne = this._geoJSONIndex.getTile($.z, $.x, $.y);
              if (!ne) return U(null, null);
              const ce = new (class {
                constructor(ve) {
                  (this.layers = { _geojsonTileLayer: this }),
                    (this.name = "_geojsonTileLayer"),
                    (this.extent = d.EXTENT),
                    (this.length = ve.length),
                    (this._features = ve);
                }
                feature(ve) {
                  return new (class {
                    constructor(ye) {
                      (this._feature = ye),
                        (this.extent = d.EXTENT),
                        (this.type = ye.type),
                        (this.properties = ye.tags),
                        "id" in ye &&
                          !isNaN(ye.id) &&
                          (this.id = parseInt(ye.id, 10));
                    }
                    loadGeometry() {
                      if (1 === this._feature.type) {
                        const ye = [];
                        for (const fe of this._feature.geometry)
                          ye.push([new d.Point(fe[0], fe[1])]);
                        return ye;
                      }
                      {
                        const ye = [];
                        for (const fe of this._feature.geometry) {
                          const Ce = [];
                          for (const Qe of fe)
                            Ce.push(new d.Point(Qe[0], Qe[1]));
                          ye.push(Ce);
                        }
                        return ye;
                      }
                    }
                    toGeoJSON(ye, fe, Ce) {
                      return Fo.call(this, ye, fe, Ce);
                    }
                  })(this._features[ve]);
                }
              })(ne.features);
              let me = Ia(ce);
              (0 === me.byteOffset && me.byteLength === me.buffer.byteLength) ||
                (me = new Uint8Array(me)),
                U(null, { vectorTile: ce, rawData: me.buffer });
            }
            (Vs.prototype.options = {
              maxZoom: 14,
              indexMaxZoom: 5,
              indexMaxPoints: 1e5,
              tolerance: 3,
              extent: 4096,
              buffer: 64,
              lineMetrics: !1,
              promoteId: null,
              generateId: !1,
              debug: 0,
            }),
              (Vs.prototype.splitTile = function (se, U, $, ne, ce, me, ve) {
                for (
                  var ye = [se, U, $, ne], fe = this.options, Ce = fe.debug;
                  ye.length;

                ) {
                  (ne = ye.pop()),
                    ($ = ye.pop()),
                    (U = ye.pop()),
                    (se = ye.pop());
                  var Qe = 1 << U,
                    et = js(U, $, ne),
                    We = this.tiles[et];
                  if (
                    !We &&
                    (Ce > 1 && console.time("creation"),
                    (We = this.tiles[et] = El(se, U, $, ne, fe)),
                    this.tileCoords.push({ z: U, x: $, y: ne }),
                    Ce)
                  ) {
                    Ce > 1 &&
                      (console.log(
                        "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
                        U,
                        $,
                        ne,
                        We.numFeatures,
                        We.numPoints,
                        We.numSimplified
                      ),
                      console.timeEnd("creation"));
                    var Rt = "z" + U;
                    (this.stats[Rt] = (this.stats[Rt] || 0) + 1), this.total++;
                  }
                  if (((We.source = se), ce)) {
                    if (U === fe.maxZoom || U === ce) continue;
                    var Ut = 1 << (ce - U);
                    if ($ !== Math.floor(me / Ut) || ne !== Math.floor(ve / Ut))
                      continue;
                  } else if (
                    U === fe.indexMaxZoom ||
                    We.numPoints <= fe.indexMaxPoints
                  )
                    continue;
                  if (((We.source = null), 0 !== se.length)) {
                    Ce > 1 && console.time("clipping");
                    var Ct,
                      Zt,
                      on,
                      Zn,
                      fi,
                      Ki,
                      Di = (0.5 * fe.buffer) / fe.extent,
                      zo = 0.5 - Di,
                      Xn = 0.5 + Di,
                      gr = 1 + Di;
                    (Ct = Zt = on = Zn = null),
                      (fi = io(
                        se,
                        Qe,
                        $ - Di,
                        $ + Xn,
                        0,
                        We.minX,
                        We.maxX,
                        fe
                      )),
                      (Ki = io(
                        se,
                        Qe,
                        $ + zo,
                        $ + gr,
                        0,
                        We.minX,
                        We.maxX,
                        fe
                      )),
                      (se = null),
                      fi &&
                        ((Ct = io(
                          fi,
                          Qe,
                          ne - Di,
                          ne + Xn,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (Zt = io(
                          fi,
                          Qe,
                          ne + zo,
                          ne + gr,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (fi = null)),
                      Ki &&
                        ((on = io(
                          Ki,
                          Qe,
                          ne - Di,
                          ne + Xn,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (Zn = io(
                          Ki,
                          Qe,
                          ne + zo,
                          ne + gr,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (Ki = null)),
                      Ce > 1 && console.timeEnd("clipping"),
                      ye.push(Ct || [], U + 1, 2 * $, 2 * ne),
                      ye.push(Zt || [], U + 1, 2 * $, 2 * ne + 1),
                      ye.push(on || [], U + 1, 2 * $ + 1, 2 * ne),
                      ye.push(Zn || [], U + 1, 2 * $ + 1, 2 * ne + 1);
                  }
                }
              }),
              (Vs.prototype.getTile = function (se, U, $) {
                var ne = this.options,
                  ce = ne.extent,
                  me = ne.debug;
                if (se < 0 || se > 24) return null;
                var ve = 1 << se,
                  ye = js(se, (U = ((U % ve) + ve) % ve), $);
                if (this.tiles[ye]) return uc(this.tiles[ye], ce);
                me > 1 && console.log("drilling down to z%d-%d-%d", se, U, $);
                for (var fe, Ce = se, Qe = U, et = $; !fe && Ce > 0; )
                  Ce--,
                    (Qe = Math.floor(Qe / 2)),
                    (et = Math.floor(et / 2)),
                    (fe = this.tiles[js(Ce, Qe, et)]);
                return fe && fe.source
                  ? (me > 1 &&
                      console.log("found parent tile z%d-%d-%d", Ce, Qe, et),
                    me > 1 && console.time("drilling down"),
                    this.splitTile(fe.source, Ce, Qe, et, se, U, $),
                    me > 1 && console.timeEnd("drilling down"),
                    this.tiles[ye] ? uc(this.tiles[ye], ce) : null)
                  : null;
              });
            class Tl extends d.VectorTileWorkerSource {
              constructor(U, $, ne, ce, me) {
                super(U, $, ne, ce, La), me && (this.loadGeoJSON = me);
              }
              loadData(U, $) {
                const ne = U && U.request,
                  ce = ne && ne.collectResourceTiming;
                this.loadGeoJSON(U, (me, ve) => {
                  if (me || !ve) return $(me);
                  if ("object" != typeof ve)
                    return $(
                      new Error(
                        `Input data given to '${U.source}' is not a valid GeoJSON object.`
                      )
                    );
                  {
                    mr(ve, !0);
                    try {
                      if (U.filter) {
                        const fe = d.createExpression(U.filter, {
                          type: "boolean",
                          "property-type": "data-driven",
                          overridable: !1,
                          transition: !1,
                        });
                        if ("error" === fe.result)
                          throw new Error(
                            fe.value
                              .map((Qe) => `${Qe.key}: ${Qe.message}`)
                              .join(", ")
                          );
                        const Ce = ve.features.filter((Qe) =>
                          fe.value.evaluate({ zoom: 0 }, Qe)
                        );
                        ve = { type: "FeatureCollection", features: Ce };
                      }
                      this._geoJSONIndex = U.cluster
                        ? new pi(
                            (function ({
                              superclusterOptions: fe,
                              clusterProperties: Ce,
                            }) {
                              if (!Ce || !fe) return fe;
                              const Qe = {},
                                et = {},
                                We = { accumulated: null, zoom: 0 },
                                Rt = { properties: null },
                                Ut = Object.keys(Ce);
                              for (const Ct of Ut) {
                                const [Zt, on] = Ce[Ct],
                                  Zn = d.createExpression(on),
                                  fi = d.createExpression(
                                    "string" == typeof Zt
                                      ? [Zt, ["accumulated"], ["get", Ct]]
                                      : Zt
                                  );
                                (Qe[Ct] = Zn.value), (et[Ct] = fi.value);
                              }
                              return (
                                (fe.map = (Ct) => {
                                  Rt.properties = Ct;
                                  const Zt = {};
                                  for (const on of Ut)
                                    Zt[on] = Qe[on].evaluate(We, Rt);
                                  return Zt;
                                }),
                                (fe.reduce = (Ct, Zt) => {
                                  Rt.properties = Zt;
                                  for (const on of Ut)
                                    (We.accumulated = Ct[on]),
                                      (Ct[on] = et[on].evaluate(We, Rt));
                                }),
                                fe
                              );
                            })(U)
                          ).load(ve.features)
                        : new Vs((fe = ve), U.geojsonVtOptions);
                    } catch (fe) {
                      return $(fe);
                    }
                    this.loaded = {};
                    const ye = {};
                    if (ce) {
                      const fe = d.getPerformanceMeasurement(ne);
                      fe &&
                        ((ye.resourceTiming = {}),
                        (ye.resourceTiming[U.source] = JSON.parse(
                          JSON.stringify(fe)
                        )));
                    }
                    $(null, ye);
                  }
                  var fe;
                });
              }
              reloadTile(U, $) {
                const ne = this.loaded;
                return ne && ne[U.uid]
                  ? super.reloadTile(U, $)
                  : this.loadTile(U, $);
              }
              loadGeoJSON(U, $) {
                if (U.request) d.getJSON(U.request, $);
                else {
                  if ("string" != typeof U.data)
                    return $(
                      new Error(
                        `Input data given to '${U.source}' is not a valid GeoJSON object.`
                      )
                    );
                  try {
                    return $(null, JSON.parse(U.data));
                  } catch {
                    return $(
                      new Error(
                        `Input data given to '${U.source}' is not a valid GeoJSON object.`
                      )
                    );
                  }
                }
              }
              getClusterExpansionZoom(U, $) {
                try {
                  $(
                    null,
                    this._geoJSONIndex.getClusterExpansionZoom(U.clusterId)
                  );
                } catch (ne) {
                  $(ne);
                }
              }
              getClusterChildren(U, $) {
                try {
                  $(null, this._geoJSONIndex.getChildren(U.clusterId));
                } catch (ne) {
                  $(ne);
                }
              }
              getClusterLeaves(U, $) {
                try {
                  $(
                    null,
                    this._geoJSONIndex.getLeaves(U.clusterId, U.limit, U.offset)
                  );
                } catch (ne) {
                  $(ne);
                }
              }
            }
            class pu {
              constructor(U) {
                (this.self = U),
                  (this.actor = new d.Actor(U, this)),
                  (this.layerIndexes = {}),
                  (this.availableImages = {}),
                  (this.isSpriteLoaded = {}),
                  (this.projections = {}),
                  (this.defaultProjection = d.getProjection({
                    name: "mercator",
                  })),
                  (this.workerSourceTypes = {
                    vector: d.VectorTileWorkerSource,
                    geojson: Tl,
                  }),
                  (this.workerSources = {}),
                  (this.demWorkerSources = {}),
                  (this.self.registerWorkerSource = ($, ne) => {
                    if (this.workerSourceTypes[$])
                      throw new Error(
                        `Worker source with name "${$}" already registered.`
                      );
                    this.workerSourceTypes[$] = ne;
                  }),
                  (this.self.registerRTLTextPlugin = ($) => {
                    if (d.plugin.isParsed())
                      throw new Error("RTL text plugin already registered.");
                    (d.plugin.applyArabicShaping = $.applyArabicShaping),
                      (d.plugin.processBidirectionalText =
                        $.processBidirectionalText),
                      (d.plugin.processStyledBidirectionalText =
                        $.processStyledBidirectionalText);
                  });
              }
              clearCaches(U, $, ne) {
                delete this.layerIndexes[U],
                  delete this.availableImages[U],
                  delete this.workerSources[U],
                  delete this.demWorkerSources[U],
                  ne();
              }
              checkIfReady(U, $, ne) {
                ne();
              }
              setReferrer(U, $) {
                this.referrer = $;
              }
              spriteLoaded(U, $) {
                this.isSpriteLoaded[U] = $;
                for (const ne in this.workerSources[U]) {
                  const ce = this.workerSources[U][ne];
                  for (const me in ce)
                    ce[me] instanceof d.VectorTileWorkerSource &&
                      ((ce[me].isSpriteLoaded = $),
                      ce[me].fire(new d.Event("isSpriteLoaded")));
                }
              }
              setImages(U, $, ne) {
                this.availableImages[U] = $;
                for (const ce in this.workerSources[U]) {
                  const me = this.workerSources[U][ce];
                  for (const ve in me) me[ve].availableImages = $;
                }
                ne();
              }
              enableTerrain(U, $, ne) {
                (this.terrain = $), ne();
              }
              setProjection(U, $) {
                this.projections[U] = d.getProjection($);
              }
              setLayers(U, $, ne) {
                this.getLayerIndex(U).replace($), ne();
              }
              updateLayers(U, $, ne) {
                this.getLayerIndex(U).update($.layers, $.removedIds), ne();
              }
              loadTile(U, $, ne) {
                const ce = this.enableTerrain
                  ? d.extend({ enableTerrain: this.terrain }, $)
                  : $;
                (ce.projection = this.projections[U] || this.defaultProjection),
                  this.getWorkerSource(U, $.type, $.source).loadTile(ce, ne);
              }
              loadDEMTile(U, $, ne) {
                const ce = this.enableTerrain
                  ? d.extend({ buildQuadTree: this.terrain }, $)
                  : $;
                this.getDEMWorkerSource(U, $.source).loadTile(ce, ne);
              }
              reloadTile(U, $, ne) {
                const ce = this.enableTerrain
                  ? d.extend({ enableTerrain: this.terrain }, $)
                  : $;
                (ce.projection = this.projections[U] || this.defaultProjection),
                  this.getWorkerSource(U, $.type, $.source).reloadTile(ce, ne);
              }
              abortTile(U, $, ne) {
                this.getWorkerSource(U, $.type, $.source).abortTile($, ne);
              }
              removeTile(U, $, ne) {
                this.getWorkerSource(U, $.type, $.source).removeTile($, ne);
              }
              removeSource(U, $, ne) {
                if (
                  !this.workerSources[U] ||
                  !this.workerSources[U][$.type] ||
                  !this.workerSources[U][$.type][$.source]
                )
                  return;
                const ce = this.workerSources[U][$.type][$.source];
                delete this.workerSources[U][$.type][$.source],
                  void 0 !== ce.removeSource ? ce.removeSource($, ne) : ne();
              }
              loadWorkerSource(U, $, ne) {
                try {
                  this.self.importScripts($.url), ne();
                } catch (ce) {
                  ne(ce.toString());
                }
              }
              syncRTLPluginState(U, $, ne) {
                try {
                  d.plugin.setState($);
                  const ce = d.plugin.getPluginURL();
                  if (
                    d.plugin.isLoaded() &&
                    !d.plugin.isParsed() &&
                    null != ce
                  ) {
                    this.self.importScripts(ce);
                    const me = d.plugin.isParsed();
                    ne(
                      me
                        ? void 0
                        : new Error(
                            `RTL Text Plugin failed to import scripts from ${ce}`
                          ),
                      me
                    );
                  }
                } catch (ce) {
                  ne(ce.toString());
                }
              }
              getAvailableImages(U) {
                let $ = this.availableImages[U];
                return $ || ($ = []), $;
              }
              getLayerIndex(U) {
                let $ = this.layerIndexes[U];
                return $ || ($ = this.layerIndexes[U] = new eo()), $;
              }
              getWorkerSource(U, $, ne) {
                return (
                  this.workerSources[U] || (this.workerSources[U] = {}),
                  this.workerSources[U][$] || (this.workerSources[U][$] = {}),
                  this.workerSources[U][$][ne] ||
                    (this.workerSources[U][$][ne] = new this.workerSourceTypes[
                      $
                    ](
                      {
                        send: (me, ve, ye, fe, Ce, Qe) => {
                          this.actor.send(me, ve, ye, U, Ce, Qe);
                        },
                        scheduler: this.actor.scheduler,
                      },
                      this.getLayerIndex(U),
                      this.getAvailableImages(U),
                      this.isSpriteLoaded[U]
                    )),
                  this.workerSources[U][$][ne]
                );
              }
              getDEMWorkerSource(U, $) {
                return (
                  this.demWorkerSources[U] || (this.demWorkerSources[U] = {}),
                  this.demWorkerSources[U][$] ||
                    (this.demWorkerSources[U][$] = new jt()),
                  this.demWorkerSources[U][$]
                );
              }
              enforceCacheSizeLimit(U, $) {
                d.enforceCacheSizeLimit($);
              }
              getWorkerPerformanceMetrics(U, $, ne) {
                ne(void 0, void 0);
              }
            }
            return (
              typeof WorkerGlobalScope < "u" &&
                typeof self < "u" &&
                self instanceof WorkerGlobalScope &&
                (self.worker = new pu(self)),
              pu
            );
          }),
          op(0, function (d) {
            function Be(f, a) {
              if (Array.isArray(f)) {
                if (!Array.isArray(a) || f.length !== a.length) return !1;
                for (let u = 0; u < f.length; u++)
                  if (!Be(f[u], a[u])) return !1;
                return !0;
              }
              if ("object" == typeof f && null !== f && null !== a) {
                if (
                  "object" != typeof a ||
                  Object.keys(f).length !== Object.keys(a).length
                )
                  return !1;
                for (const u in f) if (!Be(f[u], a[u])) return !1;
                return !0;
              }
              return f === a;
            }
            var Oo = eo;
            function eo(f) {
              return (
                (a = f),
                !(
                  typeof window > "u" ||
                  typeof document > "u" ||
                  !(
                    Array.prototype &&
                    Array.prototype.every &&
                    Array.prototype.filter &&
                    Array.prototype.forEach &&
                    Array.prototype.indexOf &&
                    Array.prototype.lastIndexOf &&
                    Array.prototype.map &&
                    Array.prototype.some &&
                    Array.prototype.reduce &&
                    Array.prototype.reduceRight &&
                    Array.isArray
                  ) ||
                  !Function.prototype ||
                  !Function.prototype.bind ||
                  !(
                    Object.keys &&
                    Object.create &&
                    Object.getPrototypeOf &&
                    Object.getOwnPropertyNames &&
                    Object.isSealed &&
                    Object.isFrozen &&
                    Object.isExtensible &&
                    Object.getOwnPropertyDescriptor &&
                    Object.defineProperty &&
                    Object.defineProperties &&
                    Object.seal &&
                    Object.freeze &&
                    Object.preventExtensions
                  ) ||
                  !(
                    "JSON" in window &&
                    "parse" in JSON &&
                    "stringify" in JSON
                  ) ||
                  !(function () {
                    if (
                      !(
                        "Worker" in window &&
                        "Blob" in window &&
                        "URL" in window
                      )
                    )
                      return !1;
                    var g,
                      v,
                      b = new Blob([""], { type: "text/javascript" }),
                      D = URL.createObjectURL(b);
                    try {
                      (v = new Worker(D)), (g = !0);
                    } catch {
                      g = !1;
                    }
                    return v && v.terminate(), URL.revokeObjectURL(D), g;
                  })() ||
                  !("Uint8ClampedArray" in window) ||
                  !ArrayBuffer.isView ||
                  !(function () {
                    var g = document.createElement("canvas");
                    g.width = g.height = 1;
                    var v = g.getContext("2d");
                    if (!v) return !1;
                    var b = v.getImageData(0, 0, 1, 1);
                    return b && b.width === g.width;
                  })() ||
                  (void 0 === jt[(u = a && a.failIfMajorPerformanceCaveat)] &&
                    (jt[u] = (function (g) {
                      var v,
                        D,
                        S,
                        M,
                        b =
                          ((D = g),
                          (S = document.createElement("canvas")),
                          ((M = Object.create(
                            eo.webGLContextAttributes
                          )).failIfMajorPerformanceCaveat = D),
                          S.getContext("webgl", M) ||
                            S.getContext("experimental-webgl", M));
                      if (!b) return !1;
                      try {
                        v = b.createShader(b.VERTEX_SHADER);
                      } catch {
                        return !1;
                      }
                      return (
                        !(!v || b.isContextLost()) &&
                        (b.shaderSource(v, "void main() {}"),
                        b.compileShader(v),
                        !0 === b.getShaderParameter(v, b.COMPILE_STATUS))
                      );
                    })(u)),
                  !jt[u] || document.documentMode)
                )
              );
              var a, u;
            }
            var jt = {};
            function zt(f, a, u) {
              const g = d.window.document.createElement(f);
              return (
                void 0 !== a && (g.className = a), u && u.appendChild(g), g
              );
            }
            function Mi(f, a, u) {
              const g = d.window.document.createElementNS(
                "http://www.w3.org/2000/svg",
                f
              );
              for (const v of Object.keys(a)) g.setAttributeNS(null, v, a[v]);
              return u && u.appendChild(g), g;
            }
            eo.webGLContextAttributes = {
              antialias: !1,
              alpha: !0,
              stencil: !0,
              depth: !0,
            };
            const mr =
                d.window.document && d.window.document.documentElement.style,
              Fo =
                mr && void 0 !== mr.userSelect
                  ? "userSelect"
                  : "WebkitUserSelect";
            let ns;
            function oc() {
              mr && Fo && ((ns = mr[Fo]), (mr[Fo] = "none"));
            }
            function vl() {
              mr && Fo && (mr[Fo] = ns);
            }
            function Ur(f) {
              f.preventDefault(),
                f.stopPropagation(),
                d.window.removeEventListener("click", Ur, !0);
            }
            function to() {
              d.window.addEventListener("click", Ur, !0),
                d.window.setTimeout(() => {
                  d.window.removeEventListener("click", Ur, !0);
                }, 0);
            }
            function Mr(f, a) {
              const u = f.getBoundingClientRect();
              return go(f, u, a);
            }
            function Ca(f, a) {
              const u = f.getBoundingClientRect(),
                g = [];
              for (let v = 0; v < a.length; v++) g.push(go(f, u, a[v]));
              return g;
            }
            function is(f) {
              return void 0 !== d.window.InstallTrigger &&
                2 === f.button &&
                f.ctrlKey &&
                d.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0
                ? 0
                : f.button;
            }
            function go(f, a, u) {
              const g = f.offsetWidth === a.width ? 1 : f.offsetWidth / a.width;
              return new d.Point(
                (u.clientX - a.left) * g,
                (u.clientY - a.top) * g
              );
            }
            function nt(f, a) {
              var u = a[0],
                g = a[1],
                v = a[2],
                b = a[3],
                D = u * b - v * g;
              return D
                ? ((f[0] = b * (D = 1 / D)),
                  (f[1] = -g * D),
                  (f[2] = -v * D),
                  (f[3] = u * D),
                  f)
                : null;
            }
            function Dh(f) {
              const { userImage: a } = f;
              return (
                !!(a && a.render && a.render()) &&
                (f.data.replace(new Uint8Array(a.data.buffer)), !0)
              );
            }
            class Sa extends d.Evented {
              constructor() {
                super(),
                  (this.images = {}),
                  (this.updatedImages = {}),
                  (this.callbackDispatchedThisFrame = {}),
                  (this.loaded = !1),
                  (this.requestors = []),
                  (this.patterns = {}),
                  (this.atlasImage = new d.RGBAImage({ width: 1, height: 1 })),
                  (this.dirty = !0);
              }
              isLoaded() {
                return this.loaded;
              }
              setLoaded(a) {
                if (this.loaded !== a && ((this.loaded = a), a)) {
                  for (const { ids: u, callback: g } of this.requestors)
                    this._notify(u, g);
                  this.requestors = [];
                }
              }
              hasImage(a) {
                return !!this.getImage(a);
              }
              getImage(a) {
                return this.images[a];
              }
              addImage(a, u) {
                this._validate(a, u) && (this.images[a] = u);
              }
              _validate(a, u) {
                let g = !0;
                return (
                  this._validateStretch(u.stretchX, u.data && u.data.width) ||
                    (this.fire(
                      new d.ErrorEvent(
                        new Error(`Image "${a}" has invalid "stretchX" value`)
                      )
                    ),
                    (g = !1)),
                  this._validateStretch(u.stretchY, u.data && u.data.height) ||
                    (this.fire(
                      new d.ErrorEvent(
                        new Error(`Image "${a}" has invalid "stretchY" value`)
                      )
                    ),
                    (g = !1)),
                  this._validateContent(u.content, u) ||
                    (this.fire(
                      new d.ErrorEvent(
                        new Error(`Image "${a}" has invalid "content" value`)
                      )
                    ),
                    (g = !1)),
                  g
                );
              }
              _validateStretch(a, u) {
                if (!a) return !0;
                let g = 0;
                for (const v of a) {
                  if (v[0] < g || v[1] < v[0] || u < v[1]) return !1;
                  g = v[1];
                }
                return !0;
              }
              _validateContent(a, u) {
                return !(
                  a &&
                  (4 !== a.length ||
                    a[0] < 0 ||
                    u.data.width < a[0] ||
                    a[1] < 0 ||
                    u.data.height < a[1] ||
                    a[2] < 0 ||
                    u.data.width < a[2] ||
                    a[3] < 0 ||
                    u.data.height < a[3] ||
                    a[2] < a[0] ||
                    a[3] < a[1])
                );
              }
              updateImage(a, u) {
                (u.version = this.images[a].version + 1),
                  (this.images[a] = u),
                  (this.updatedImages[a] = !0);
              }
              removeImage(a) {
                const u = this.images[a];
                delete this.images[a],
                  delete this.patterns[a],
                  u.userImage && u.userImage.onRemove && u.userImage.onRemove();
              }
              listImages() {
                return Object.keys(this.images);
              }
              getImages(a, u) {
                let g = !0;
                if (!this.isLoaded())
                  for (const v of a) this.images[v] || (g = !1);
                this.isLoaded() || g
                  ? this._notify(a, u)
                  : this.requestors.push({ ids: a, callback: u });
              }
              _notify(a, u) {
                const g = {};
                for (const v of a) {
                  this.images[v] ||
                    this.fire(new d.Event("styleimagemissing", { id: v }));
                  const b = this.images[v];
                  b
                    ? (g[v] = {
                        data: b.data.clone(),
                        pixelRatio: b.pixelRatio,
                        sdf: b.sdf,
                        version: b.version,
                        stretchX: b.stretchX,
                        stretchY: b.stretchY,
                        content: b.content,
                        hasRenderCallback: Boolean(
                          b.userImage && b.userImage.render
                        ),
                      })
                    : d.warnOnce(
                        `Image "${v}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`
                      );
                }
                u(null, g);
              }
              getPixelSize() {
                const { width: a, height: u } = this.atlasImage;
                return { width: a, height: u };
              }
              getPattern(a) {
                const u = this.patterns[a],
                  g = this.getImage(a);
                if (!g) return null;
                if (u && u.position.version === g.version) return u.position;
                if (u) u.position.version = g.version;
                else {
                  const v = {
                      w: g.data.width + 2,
                      h: g.data.height + 2,
                      x: 0,
                      y: 0,
                    },
                    b = new d.ImagePosition(v, g);
                  this.patterns[a] = { bin: v, position: b };
                }
                return this._updatePatternAtlas(), this.patterns[a].position;
              }
              bind(a) {
                const u = a.gl;
                this.atlasTexture
                  ? this.dirty &&
                    (this.atlasTexture.update(this.atlasImage),
                    (this.dirty = !1))
                  : (this.atlasTexture = new d.Texture(
                      a,
                      this.atlasImage,
                      u.RGBA
                    )),
                  this.atlasTexture &&
                    this.atlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE);
              }
              _updatePatternAtlas() {
                const a = [];
                for (const b in this.patterns) a.push(this.patterns[b].bin);
                const { w: u, h: g } = d.potpack(a),
                  v = this.atlasImage;
                v.resize({ width: u || 1, height: g || 1 });
                for (const b in this.patterns) {
                  const { bin: D } = this.patterns[b],
                    S = D.x + 1,
                    M = D.y + 1,
                    R = this.images[b].data,
                    k = R.width,
                    z = R.height;
                  d.RGBAImage.copy(
                    R,
                    v,
                    { x: 0, y: 0 },
                    { x: S, y: M },
                    { width: k, height: z }
                  ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: 0, y: z - 1 },
                      { x: S, y: M - 1 },
                      { width: k, height: 1 }
                    ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: 0, y: 0 },
                      { x: S, y: M + z },
                      { width: k, height: 1 }
                    ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: k - 1, y: 0 },
                      { x: S - 1, y: M },
                      { width: 1, height: z }
                    ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: 0, y: 0 },
                      { x: S + k, y: M },
                      { width: 1, height: z }
                    );
                }
                this.dirty = !0;
              }
              beginFrame() {
                this.callbackDispatchedThisFrame = {};
              }
              dispatchRenderCallbacks(a) {
                for (const u of a) {
                  if (this.callbackDispatchedThisFrame[u]) continue;
                  this.callbackDispatchedThisFrame[u] = !0;
                  const g = this.images[u];
                  Dh(g) && this.updateImage(u, g);
                }
              }
            }
            const Qt = new d.Properties({
              anchor: new d.DataConstantProperty(d.spec.light.anchor),
              position: new (class {
                constructor() {
                  this.specification = d.spec.light.position;
                }
                possiblyEvaluate(f, a) {
                  return (function ([u, g, v]) {
                    const b = d.degToRad(g + 90),
                      D = d.degToRad(v);
                    return {
                      x: u * Math.cos(b) * Math.sin(D),
                      y: u * Math.sin(b) * Math.sin(D),
                      z: u * Math.cos(D),
                      azimuthal: g,
                      polar: v,
                    };
                  })(f.expression.evaluate(a));
                }
                interpolate(f, a, u) {
                  return {
                    x: d.number(f.x, a.x, u),
                    y: d.number(f.y, a.y, u),
                    z: d.number(f.z, a.z, u),
                    azimuthal: d.number(f.azimuthal, a.azimuthal, u),
                    polar: d.number(f.polar, a.polar, u),
                  };
                }
              })(),
              color: new d.DataConstantProperty(d.spec.light.color),
              intensity: new d.DataConstantProperty(d.spec.light.intensity),
            });
            class zi extends d.Evented {
              constructor(a) {
                super(),
                  (this._transitionable = new d.Transitionable(Qt)),
                  this.setLight(a),
                  (this._transitioning = this._transitionable.untransitioned());
              }
              getLight() {
                return this._transitionable.serialize();
              }
              setLight(a, u = {}) {
                if (!this._validate(d.validateLight, a, u))
                  for (const g in a) {
                    const v = a[g];
                    d.endsWith(g, "-transition")
                      ? this._transitionable.setTransition(g.slice(0, -11), v)
                      : this._transitionable.setValue(g, v);
                  }
              }
              updateTransitions(a) {
                this._transitioning = this._transitionable.transitioned(
                  a,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(a) {
                this.properties = this._transitioning.possiblyEvaluate(a);
              }
              _validate(a, u, g) {
                return (
                  (!g || !1 !== g.validate) &&
                  d.emitValidationErrors(
                    this,
                    a.call(
                      d.validateStyle,
                      d.extend({
                        value: u,
                        style: { glyphs: !0, sprite: !0 },
                        styleSpec: d.spec,
                      })
                    )
                  )
                );
              }
            }
            const sc = new d.Properties({
              source: new d.DataConstantProperty(d.spec.terrain.source),
              exaggeration: new d.DataConstantProperty(
                d.spec.terrain.exaggeration
              ),
            });
            let cu = class extends d.Evented {
              constructor(f, a) {
                super(),
                  (this._transitionable = new d.Transitionable(sc)),
                  this.set(f),
                  (this._transitioning = this._transitionable.untransitioned()),
                  (this.drapeRenderMode = a);
              }
              get() {
                return this._transitionable.serialize();
              }
              set(f) {
                for (const a in f) {
                  const u = f[a];
                  d.endsWith(a, "-transition")
                    ? this._transitionable.setTransition(a.slice(0, -11), u)
                    : this._transitionable.setValue(a, u);
                }
              }
              updateTransitions(f) {
                this._transitioning = this._transitionable.transitioned(
                  f,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(f) {
                this.properties = this._transitioning.possiblyEvaluate(f);
              }
            };
            function Ia(f, a, u, g) {
              const v = d.smoothstep(45, 65, u),
                [b, D] = ac(f, g),
                S = d.length(a);
              let M = 1 - Math.min(1, Math.exp(((S - b) / (D - b)) * -6));
              return (
                (M *= M * M), (M = Math.min(1, 1.00747 * M)), M * v * f.alpha
              );
            }
            function ac(f, a) {
              const u = 0.5 / Math.tan(0.5 * a);
              return [f.range[0] + u, f.range[1] + u];
            }
            const tn = new d.Properties({
              range: new d.DataConstantProperty(d.spec.fog.range),
              color: new d.DataConstantProperty(d.spec.fog.color),
              "high-color": new d.DataConstantProperty(
                d.spec.fog["high-color"]
              ),
              "space-color": new d.DataConstantProperty(
                d.spec.fog["space-color"]
              ),
              "horizon-blend": new d.DataConstantProperty(
                d.spec.fog["horizon-blend"]
              ),
              "star-intensity": new d.DataConstantProperty(
                d.spec.fog["star-intensity"]
              ),
            });
            class Ma extends d.Evented {
              constructor(a, u) {
                super(),
                  (this._transitionable = new d.Transitionable(tn)),
                  this.set(a),
                  (this._transitioning = this._transitionable.untransitioned()),
                  (this._transform = u);
              }
              get state() {
                const a = this._transform,
                  u = "globe" === a.projection.name,
                  g = d.globeToMercatorTransition(a.zoom),
                  v = this.properties.get("range"),
                  b = [0.5, 3];
                return {
                  range: u
                    ? [d.number(b[0], v[0], g), d.number(b[1], v[1], g)]
                    : v,
                  horizonBlend: this.properties.get("horizon-blend"),
                  alpha: this.properties.get("color").a,
                };
              }
              get() {
                return this._transitionable.serialize();
              }
              set(a, u = {}) {
                if (!this._validate(d.validateFog, a, u)) {
                  for (const g of Object.keys(d.spec.fog))
                    a && void 0 === a[g] && (a[g] = d.spec.fog[g].default);
                  for (const g in a) {
                    const v = a[g];
                    d.endsWith(g, "-transition")
                      ? this._transitionable.setTransition(g.slice(0, -11), v)
                      : this._transitionable.setValue(g, v);
                  }
                }
              }
              getOpacity(a) {
                if (!this._transform.projection.supportsFog) return 0;
                const u =
                  (this.properties && this.properties.get("color")) || 1;
                return (
                  ("globe" === this._transform.projection.name
                    ? 1
                    : d.smoothstep(45, 65, a)) * u.a
                );
              }
              getOpacityAtLatLng(a, u) {
                return this._transform.projection.supportsFog
                  ? (function (g, v, b) {
                      const D = d.MercatorCoordinate.fromLngLat(v),
                        S = b.elevation ? b.elevation.getAtPointOrZero(D) : 0,
                        M = [D.x, D.y, S];
                      return (
                        d.transformMat4(M, M, b.mercatorFogMatrix),
                        Ia(g, M, b.pitch, b._fov)
                      );
                    })(this.state, a, u)
                  : 0;
              }
              getFovAdjustedRange(a) {
                return this._transform.projection.supportsFog
                  ? ac(this.state, a)
                  : [0, 1];
              }
              updateTransitions(a) {
                this._transitioning = this._transitionable.transitioned(
                  a,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(a) {
                this.properties = this._transitioning.possiblyEvaluate(a);
              }
              _validate(a, u, g) {
                return (
                  (!g || !1 !== g.validate) &&
                  d.emitValidationErrors(
                    this,
                    a.call(
                      d.validateStyle,
                      d.extend({
                        value: u,
                        style: { glyphs: !0, sprite: !0 },
                        styleSpec: d.spec,
                      })
                    )
                  )
                );
              }
            }
            class Tn {
              constructor(a, u) {
                (this.workerPool = a),
                  (this.actors = []),
                  (this.currentActor = 0),
                  (this.id = d.uniqueId());
                const g = this.workerPool.acquire(this.id);
                for (let v = 0; v < g.length; v++) {
                  const b = new Tn.Actor(g[v], u, this.id);
                  (b.name = `Worker ${v}`), this.actors.push(b);
                }
                (this.ready = !1),
                  this.broadcast("checkIfReady", null, () => {
                    this.ready = !0;
                  });
              }
              broadcast(a, u, g) {
                d.asyncAll(
                  this.actors,
                  (v, b) => {
                    v.send(a, u, b);
                  },
                  (g = g || function () {})
                );
              }
              getActor() {
                return (
                  (this.currentActor =
                    (this.currentActor + 1) % this.actors.length),
                  this.actors[this.currentActor]
                );
              }
              remove() {
                this.actors.forEach((a) => {
                  a.remove();
                }),
                  (this.actors = []),
                  this.workerPool.release(this.id);
              }
            }
            function Ai(f, a, u) {
              return (
                a *
                (d.EXTENT /
                  (f.tileSize * Math.pow(2, u - f.tileID.overscaledZ)))
              );
            }
            Tn.Actor = d.Actor;
            class Rs {
              constructor(a, u, g, v) {
                (this.screenBounds = a),
                  (this.cameraPoint = u),
                  (this._screenRaycastCache = {}),
                  (this._cameraRaycastCache = {}),
                  (this.isAboveHorizon = g),
                  (this.screenGeometry = this.bufferedScreenGeometry(0)),
                  (this.screenGeometryMercator = this._bufferedScreenMercator(
                    0,
                    v
                  ));
              }
              static createFromScreenPoints(a, u) {
                let g, v;
                if (a instanceof d.Point || "number" == typeof a[0]) {
                  const b = d.Point.convert(a);
                  (g = [b]), (v = u.isPointAboveHorizon(b));
                } else {
                  const b = d.Point.convert(a[0]),
                    D = d.Point.convert(a[1]);
                  (g = [b, D]),
                    (v = d
                      .polygonizeBounds(b, D)
                      .every((S) => u.isPointAboveHorizon(S)));
                }
                return new Rs(g, u.getCameraPoint(), v, u);
              }
              isPointQuery() {
                return 1 === this.screenBounds.length;
              }
              bufferedScreenGeometry(a) {
                return d.polygonizeBounds(
                  this.screenBounds[0],
                  1 === this.screenBounds.length
                    ? this.screenBounds[0]
                    : this.screenBounds[1],
                  a
                );
              }
              bufferedCameraGeometry(a) {
                const u = this.screenBounds[0],
                  g =
                    1 === this.screenBounds.length
                      ? this.screenBounds[0].add(new d.Point(1, 1))
                      : this.screenBounds[1],
                  v = d.polygonizeBounds(u, g, 0, !1);
                return (
                  this.cameraPoint.y > g.y &&
                    (this.cameraPoint.x > u.x && this.cameraPoint.x < g.x
                      ? v.splice(3, 0, this.cameraPoint)
                      : this.cameraPoint.x >= g.x
                      ? (v[2] = this.cameraPoint)
                      : this.cameraPoint.x <= u.x && (v[3] = this.cameraPoint)),
                  d.bufferConvexPolygon(v, a)
                );
              }
              bufferedCameraGeometryGlobe(a) {
                const u = this.screenBounds[0],
                  g =
                    1 === this.screenBounds.length
                      ? this.screenBounds[0].add(new d.Point(1, 1))
                      : this.screenBounds[1],
                  v = d.polygonizeBounds(u, g, a),
                  b = this.cameraPoint.clone();
                switch (
                  3 * ((b.y > u.y) + (b.y > g.y)) +
                  ((b.x > u.x) + (b.x > g.x))
                ) {
                  case 0:
                    (v[0] = b), (v[4] = b.clone());
                    break;
                  case 1:
                    v.splice(1, 0, b);
                    break;
                  case 2:
                    v[1] = b;
                    break;
                  case 3:
                    v.splice(4, 0, b);
                    break;
                  case 5:
                    v.splice(2, 0, b);
                    break;
                  case 6:
                    v[3] = b;
                    break;
                  case 7:
                    v.splice(3, 0, b);
                    break;
                  case 8:
                    v[2] = b;
                }
                return v;
              }
              containsTile(a, u, g, v = 0) {
                const b = a.queryPadding / u._pixelsPerMercatorPixel + 1,
                  D = g
                    ? this._bufferedCameraMercator(b, u)
                    : this._bufferedScreenMercator(b, u);
                let S = a.tileID.wrap + (D.unwrapped ? v : 0);
                const M = D.polygon.map((Y) =>
                  d.getTilePoint(a.tileTransform, Y, S)
                );
                if (!d.polygonIntersectsBox(M, 0, 0, d.EXTENT, d.EXTENT))
                  return;
                S =
                  a.tileID.wrap +
                  (this.screenGeometryMercator.unwrapped ? v : 0);
                const R = this.screenGeometryMercator.polygon.map((Y) =>
                    d.getTileVec3(a.tileTransform, Y, S)
                  ),
                  k = R.map((Y) => new d.Point(Y[0], Y[1])),
                  z =
                    u.getFreeCameraOptions().position ||
                    new d.MercatorCoordinate(0, 0, 0),
                  H = d.getTileVec3(a.tileTransform, z, S),
                  q = R.map((Y) => {
                    const B = d.sub(Y, Y, H);
                    return d.normalize(B, B), new d.Ray(H, B);
                  }),
                  X = Ai(a, 1, u.zoom) * u._pixelsPerMercatorPixel;
                return {
                  queryGeometry: this,
                  tilespaceGeometry: k,
                  tilespaceRays: q,
                  bufferedTilespaceGeometry: M,
                  bufferedTilespaceBounds:
                    ((Z = d.getBounds(M)),
                    (Z.min.x = d.clamp(Z.min.x, 0, d.EXTENT)),
                    (Z.min.y = d.clamp(Z.min.y, 0, d.EXTENT)),
                    (Z.max.x = d.clamp(Z.max.x, 0, d.EXTENT)),
                    (Z.max.y = d.clamp(Z.max.y, 0, d.EXTENT)),
                    Z),
                  tile: a,
                  tileID: a.tileID,
                  pixelToTileUnitsFactor: X,
                };
                var Z;
              }
              _bufferedScreenMercator(a, u) {
                const g = rs(a);
                if (this._screenRaycastCache[g])
                  return this._screenRaycastCache[g];
                {
                  let v;
                  return (
                    (v =
                      "globe" === u.projection.name
                        ? this._projectAndResample(
                            this.bufferedScreenGeometry(a),
                            u
                          )
                        : {
                            polygon: this.bufferedScreenGeometry(a).map((b) =>
                              u.pointCoordinate3D(b)
                            ),
                            unwrapped: !0,
                          }),
                    (this._screenRaycastCache[g] = v),
                    v
                  );
                }
              }
              _bufferedCameraMercator(a, u) {
                const g = rs(a);
                if (this._cameraRaycastCache[g])
                  return this._cameraRaycastCache[g];
                {
                  let v;
                  return (
                    (v =
                      "globe" === u.projection.name
                        ? this._projectAndResample(
                            this.bufferedCameraGeometryGlobe(a),
                            u
                          )
                        : {
                            polygon: this.bufferedCameraGeometry(a).map((b) =>
                              u.pointCoordinate3D(b)
                            ),
                            unwrapped: !0,
                          }),
                    (this._cameraRaycastCache[g] = v),
                    v
                  );
                }
              }
              _projectAndResample(a, u) {
                const g = (function (b, D) {
                  const S = d.multiply([], D.pixelMatrix, D.globeMatrix),
                    M = [0, -d.GLOBE_RADIUS, 0, 1],
                    R = [0, d.GLOBE_RADIUS, 0, 1],
                    k = [0, 0, 0, 1];
                  d.transformMat4$1(M, M, S),
                    d.transformMat4$1(R, R, S),
                    d.transformMat4$1(k, k, S);
                  const z = new d.Point(M[0] / M[3], M[1] / M[3]),
                    H = new d.Point(R[0] / R[3], R[1] / R[3]),
                    q = d.polygonContainsPoint(b, z) && M[3] < k[3],
                    X = d.polygonContainsPoint(b, H) && R[3] < k[3];
                  if (!q && !X) return null;
                  const Z = (function (ue, _e, ge) {
                    for (let Te = 1; Te < ue.length; Te++) {
                      const Ge = Os(_e.pointCoordinate3D(ue[Te - 1]).x),
                        be = Os(_e.pointCoordinate3D(ue[Te]).x);
                      if (ge < 0) {
                        if (Ge < be) return { idx: Te, t: -Ge / (be - 1 - Ge) };
                      } else if (be < Ge)
                        return { idx: Te, t: (1 - Ge) / (be + 1 - Ge) };
                    }
                    return null;
                  })(b, D, q ? -1 : 1);
                  if (!Z) return null;
                  const { idx: Y, t: B } = Z;
                  let W = Y > 1 ? pi(b.slice(0, Y), D) : [],
                    ee = Y < b.length ? pi(b.slice(Y), D) : [];
                  (W = W.map((ue) => new d.Point(Os(ue.x), ue.y))),
                    (ee = ee.map((ue) => new d.Point(Os(ue.x), ue.y)));
                  const te = [...W];
                  0 === te.length && te.push(ee[ee.length - 1]);
                  const he = d.number(
                    te[te.length - 1].y,
                    (0 === ee.length ? W[0] : ee[0]).y,
                    B
                  );
                  let de;
                  return (
                    (de = q
                      ? [
                          new d.Point(0, he),
                          new d.Point(0, 0),
                          new d.Point(1, 0),
                          new d.Point(1, he),
                        ]
                      : [
                          new d.Point(1, he),
                          new d.Point(1, 1),
                          new d.Point(0, 1),
                          new d.Point(0, he),
                        ]),
                    te.push(...de),
                    0 === ee.length ? te.push(W[0]) : te.push(...ee),
                    {
                      polygon: te.map(
                        (ue) => new d.MercatorCoordinate(ue.x, ue.y)
                      ),
                      unwrapped: !1,
                    }
                  );
                })(a, u);
                if (g) return g;
                const v = (function (b, D) {
                  let S = !1,
                    M = -1 / 0,
                    R = 0;
                  for (let z = 0; z < b.length - 1; z++)
                    b[z].x > M && ((M = b[z].x), (R = z));
                  for (let z = 0; z < b.length - 1; z++) {
                    const H = (R + z) % (b.length - 1),
                      q = b[H],
                      X = b[H + 1];
                    Math.abs(q.x - X.x) > 0.5 &&
                      (q.x < X.x
                        ? ((q.x += 1), 0 === H && (b[b.length - 1].x += 1))
                        : ((X.x += 1), H + 1 === b.length - 1 && (b[0].x += 1)),
                      (S = !0));
                  }
                  const k = d.mercatorXfromLng(D.center.lng);
                  return (
                    S &&
                      k < Math.abs(k - 1) &&
                      b.forEach((z) => {
                        z.x -= 1;
                      }),
                    { polygon: b, unwrapped: S }
                  );
                })(
                  pi(a, u).map((b) => new d.Point(Os(b.x), b.y)),
                  u
                );
                return {
                  polygon: v.polygon.map(
                    (b) => new d.MercatorCoordinate(b.x, b.y)
                  ),
                  unwrapped: v.unwrapped,
                };
              }
            }
            function pi(f, a) {
              return d.resample(
                f,
                (u) => {
                  const g = a.pointCoordinate3D(u);
                  (u.x = g.x), (u.y = g.y);
                },
                1 / 256
              );
            }
            function Os(f) {
              return f < 0 ? 1 + (f % 1) : f % 1;
            }
            function rs(f) {
              return (100 * f) | 0;
            }
            function os(f, a, u, g, v) {
              const b = function (D, S) {
                if (D) return v(D);
                if (S) {
                  f.url && S.tiles && f.tiles && delete f.tiles;
                  const M = d.pick(d.extend(S, f), [
                    "tiles",
                    "minzoom",
                    "maxzoom",
                    "attribution",
                    "mapbox_logo",
                    "bounds",
                    "scheme",
                    "tileSize",
                    "encoding",
                  ]);
                  S.vector_layers &&
                    ((M.vectorLayers = S.vector_layers),
                    (M.vectorLayerIds = M.vectorLayers.map((R) => R.id))),
                    (M.tiles = a.canonicalizeTileset(M, f.url)),
                    v(null, M);
                }
              };
              return f.url
                ? d.getJSON(
                    a.transformRequest(
                      a.normalizeSourceURL(f.url, null, u, g),
                      d.ResourceType.Source
                    ),
                    b
                  )
                : d.exported.frame(() => b(null, f));
            }
            class ss {
              constructor(a, u, g) {
                (this.bounds = d.LngLatBounds.convert(this.validateBounds(a))),
                  (this.minzoom = u || 0),
                  (this.maxzoom = g || 24);
              }
              validateBounds(a) {
                return Array.isArray(a) && 4 === a.length
                  ? [
                      Math.max(-180, a[0]),
                      Math.max(-90, a[1]),
                      Math.min(180, a[2]),
                      Math.min(90, a[3]),
                    ]
                  : [-180, -90, 180, 90];
              }
              contains(a) {
                const u = Math.pow(2, a.z),
                  g = Math.floor(d.mercatorXfromLng(this.bounds.getWest()) * u),
                  v = Math.floor(
                    d.mercatorYfromLat(this.bounds.getNorth()) * u
                  ),
                  b = Math.ceil(d.mercatorXfromLng(this.bounds.getEast()) * u),
                  D = Math.ceil(d.mercatorYfromLat(this.bounds.getSouth()) * u);
                return a.x >= g && a.x < b && a.y >= v && a.y < D;
              }
            }
            class Fs {
              constructor(a, u, g) {
                this.context = a;
                const v = a.gl;
                (this.buffer = v.createBuffer()),
                  (this.dynamicDraw = Boolean(g)),
                  this.context.unbindVAO(),
                  a.bindElementBuffer.set(this.buffer),
                  v.bufferData(
                    v.ELEMENT_ARRAY_BUFFER,
                    u.arrayBuffer,
                    this.dynamicDraw ? v.DYNAMIC_DRAW : v.STATIC_DRAW
                  ),
                  this.dynamicDraw || u.destroy();
              }
              bind() {
                this.context.bindElementBuffer.set(this.buffer);
              }
              updateData(a) {
                const u = this.context.gl;
                this.context.unbindVAO(),
                  this.bind(),
                  u.bufferSubData(u.ELEMENT_ARRAY_BUFFER, 0, a.arrayBuffer);
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            const No = {
              Int8: "BYTE",
              Uint8: "UNSIGNED_BYTE",
              Int16: "SHORT",
              Uint16: "UNSIGNED_SHORT",
              Int32: "INT",
              Uint32: "UNSIGNED_INT",
              Float32: "FLOAT",
            };
            class xl {
              constructor(a, u, g, v) {
                (this.length = u.length),
                  (this.attributes = g),
                  (this.itemSize = u.bytesPerElement),
                  (this.dynamicDraw = v),
                  (this.context = a);
                const b = a.gl;
                (this.buffer = b.createBuffer()),
                  a.bindVertexBuffer.set(this.buffer),
                  b.bufferData(
                    b.ARRAY_BUFFER,
                    u.arrayBuffer,
                    this.dynamicDraw ? b.DYNAMIC_DRAW : b.STATIC_DRAW
                  ),
                  this.dynamicDraw || u.destroy();
              }
              bind() {
                this.context.bindVertexBuffer.set(this.buffer);
              }
              updateData(a) {
                const u = this.context.gl;
                this.bind(), u.bufferSubData(u.ARRAY_BUFFER, 0, a.arrayBuffer);
              }
              enableAttributes(a, u) {
                for (let g = 0; g < this.attributes.length; g++) {
                  const v = u.attributes[this.attributes[g].name];
                  void 0 !== v && a.enableVertexAttribArray(v);
                }
              }
              setVertexAttribPointers(a, u, g) {
                for (let v = 0; v < this.attributes.length; v++) {
                  const b = this.attributes[v],
                    D = u.attributes[b.name];
                  void 0 !== D &&
                    a.vertexAttribPointer(
                      D,
                      b.components,
                      a[No[b.type]],
                      !1,
                      this.itemSize,
                      b.offset + this.itemSize * (g || 0)
                    );
                }
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            class rn {
              constructor(a) {
                (this.gl = a.gl),
                  (this.default = this.getDefault()),
                  (this.current = this.default),
                  (this.dirty = !1);
              }
              get() {
                return this.current;
              }
              set(a) {}
              getDefault() {
                return this.default;
              }
              setDefault() {
                this.set(this.default);
              }
            }
            class Ns extends rn {
              getDefault() {
                return d.Color.transparent;
              }
              set(a) {
                const u = this.current;
                (a.r !== u.r ||
                  a.g !== u.g ||
                  a.b !== u.b ||
                  a.a !== u.a ||
                  this.dirty) &&
                  (this.gl.clearColor(a.r, a.g, a.b, a.a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class $r extends rn {
              getDefault() {
                return 1;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.clearDepth(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Aa extends rn {
              getDefault() {
                return 0;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.clearStencil(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Wn extends rn {
              getDefault() {
                return [!0, !0, !0, !0];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] ||
                  a[1] !== u[1] ||
                  a[2] !== u[2] ||
                  a[3] !== u[3] ||
                  this.dirty) &&
                  (this.gl.colorMask(a[0], a[1], a[2], a[3]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class no extends rn {
              getDefault() {
                return !0;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.depthMask(a), (this.current = a), (this.dirty = !1));
              }
            }
            class uu extends rn {
              getDefault() {
                return 255;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.stencilMask(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class zs extends rn {
              getDefault() {
                return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
              }
              set(a) {
                const u = this.current;
                (a.func !== u.func ||
                  a.ref !== u.ref ||
                  a.mask !== u.mask ||
                  this.dirty) &&
                  (this.gl.stencilFunc(a.func, a.ref, a.mask),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class io extends rn {
              getDefault() {
                const a = this.gl;
                return [a.KEEP, a.KEEP, a.KEEP];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] ||
                  a[1] !== u[1] ||
                  a[2] !== u[2] ||
                  this.dirty) &&
                  (this.gl.stencilOp(a[0], a[1], a[2]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class hu extends rn {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.STENCIL_TEST) : u.disable(u.STENCIL_TEST),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class lc extends rn {
              getDefault() {
                return [0, 1];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] || a[1] !== u[1] || this.dirty) &&
                  (this.gl.depthRange(a[0], a[1]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class cc extends rn {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.DEPTH_TEST) : u.disable(u.DEPTH_TEST),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class as extends rn {
              getDefault() {
                return this.gl.LESS;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.depthFunc(a), (this.current = a), (this.dirty = !1));
              }
            }
            class bl extends rn {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.BLEND) : u.disable(u.BLEND),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class wl extends rn {
              getDefault() {
                const a = this.gl;
                return [a.ONE, a.ZERO];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] || a[1] !== u[1] || this.dirty) &&
                  (this.gl.blendFunc(a[0], a[1]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class du extends rn {
              getDefault() {
                return d.Color.transparent;
              }
              set(a) {
                const u = this.current;
                (a.r !== u.r ||
                  a.g !== u.g ||
                  a.b !== u.b ||
                  a.a !== u.a ||
                  this.dirty) &&
                  (this.gl.blendColor(a.r, a.g, a.b, a.a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Ar extends rn {
              getDefault() {
                return this.gl.FUNC_ADD;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.blendEquation(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class ls extends rn {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.CULL_FACE) : u.disable(u.CULL_FACE),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class uc extends rn {
              getDefault() {
                return this.gl.BACK;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.cullFace(a), (this.current = a), (this.dirty = !1));
              }
            }
            class Pa extends rn {
              getDefault() {
                return this.gl.CCW;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.frontFace(a), (this.current = a), (this.dirty = !1));
              }
            }
            let El,
              ro = class extends rn {
                getDefault() {
                  return null;
                }
                set(f) {
                  (f !== this.current || this.dirty) &&
                    (this.gl.useProgram(f),
                    (this.current = f),
                    (this.dirty = !1));
                }
              };
            class Bs extends rn {
              getDefault() {
                return this.gl.TEXTURE0;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.activeTexture(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Vs extends rn {
              getDefault() {
                const a = this.gl;
                return [0, 0, a.drawingBufferWidth, a.drawingBufferHeight];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] ||
                  a[1] !== u[1] ||
                  a[2] !== u[2] ||
                  a[3] !== u[3] ||
                  this.dirty) &&
                  (this.gl.viewport(a[0], a[1], a[2], a[3]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class js extends rn {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindFramebuffer(u.FRAMEBUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class La extends rn {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindRenderbuffer(u.RENDERBUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class Tl extends rn {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindTexture(u.TEXTURE_2D, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class pu extends rn {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindBuffer(u.ARRAY_BUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class se extends rn {
              getDefault() {
                return null;
              }
              set(a) {
                const u = this.gl;
                u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class U extends rn {
              constructor(a) {
                super(a), (this.vao = a.extVertexArrayObject);
              }
              getDefault() {
                return null;
              }
              set(a) {
                this.vao &&
                  (a !== this.current || this.dirty) &&
                  (this.vao.bindVertexArrayOES(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class $ extends rn {
              getDefault() {
                return 4;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.pixelStorei(u.UNPACK_ALIGNMENT, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class ne extends rn {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class ce extends rn {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class me extends rn {
              constructor(a, u) {
                super(a), (this.context = a), (this.parent = u);
              }
              getDefault() {
                return null;
              }
            }
            class ve extends me {
              setDirty() {
                this.dirty = !0;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const u = this.gl;
                u.framebufferTexture2D(
                  u.FRAMEBUFFER,
                  u.COLOR_ATTACHMENT0,
                  u.TEXTURE_2D,
                  a,
                  0
                ),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class ye extends me {
              attachment() {
                return this.gl.DEPTH_ATTACHMENT;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const u = this.gl;
                u.framebufferRenderbuffer(
                  u.FRAMEBUFFER,
                  this.attachment(),
                  u.RENDERBUFFER,
                  a
                ),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class fe extends ye {
              attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
              }
            }
            class Ce {
              constructor(a, u, g, v) {
                (this.context = a), (this.width = u), (this.height = g);
                const b = (this.framebuffer = a.gl.createFramebuffer());
                (this.colorAttachment = new ve(a, b)),
                  v && (this.depthAttachment = new ye(a, b));
              }
              destroy() {
                const a = this.context.gl,
                  u = this.colorAttachment.get();
                if ((u && a.deleteTexture(u), this.depthAttachment)) {
                  const g = this.depthAttachment.get();
                  g && a.deleteRenderbuffer(g);
                }
                a.deleteFramebuffer(this.framebuffer);
              }
            }
            class Qe {
              constructor(a, u = !1) {
                if (
                  ((this.gl = a),
                  (this.isWebGL2 = u),
                  (this.extVertexArrayObject = this.gl.getExtension(
                    "OES_vertex_array_object"
                  )),
                  u)
                ) {
                  const g = a;
                  this.extVertexArrayObject = {
                    createVertexArrayOES: g.createVertexArray.bind(a),
                    deleteVertexArrayOES: g.deleteVertexArray.bind(a),
                    bindVertexArrayOES: g.bindVertexArray.bind(a),
                  };
                }
                (this.clearColor = new Ns(this)),
                  (this.clearDepth = new $r(this)),
                  (this.clearStencil = new Aa(this)),
                  (this.colorMask = new Wn(this)),
                  (this.depthMask = new no(this)),
                  (this.stencilMask = new uu(this)),
                  (this.stencilFunc = new zs(this)),
                  (this.stencilOp = new io(this)),
                  (this.stencilTest = new hu(this)),
                  (this.depthRange = new lc(this)),
                  (this.depthTest = new cc(this)),
                  (this.depthFunc = new as(this)),
                  (this.blend = new bl(this)),
                  (this.blendFunc = new wl(this)),
                  (this.blendColor = new du(this)),
                  (this.blendEquation = new Ar(this)),
                  (this.cullFace = new ls(this)),
                  (this.cullFaceSide = new uc(this)),
                  (this.frontFace = new Pa(this)),
                  (this.program = new ro(this)),
                  (this.activeTexture = new Bs(this)),
                  (this.viewport = new Vs(this)),
                  (this.bindFramebuffer = new js(this)),
                  (this.bindRenderbuffer = new La(this)),
                  (this.bindTexture = new Tl(this)),
                  (this.bindVertexBuffer = new pu(this)),
                  (this.bindElementBuffer = new se(this)),
                  (this.bindVertexArrayOES =
                    this.extVertexArrayObject && new U(this)),
                  (this.pixelStoreUnpack = new $(this)),
                  (this.pixelStoreUnpackPremultiplyAlpha = new ne(this)),
                  (this.pixelStoreUnpackFlipY = new ce(this)),
                  (this.extTextureFilterAnisotropic =
                    a.getExtension("EXT_texture_filter_anisotropic") ||
                    a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                    a.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
                  this.extTextureFilterAnisotropic &&
                    (this.extTextureFilterAnisotropicMax = a.getParameter(
                      this.extTextureFilterAnisotropic
                        .MAX_TEXTURE_MAX_ANISOTROPY_EXT
                    )),
                  (this.extTextureFilterAnisotropicForceOff = !1),
                  (this.extStandardDerivativesForceOff = !1),
                  (this.extDebugRendererInfo = a.getExtension(
                    "WEBGL_debug_renderer_info"
                  )),
                  this.extDebugRendererInfo &&
                    ((this.renderer = a.getParameter(
                      this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL
                    )),
                    (this.vendor = a.getParameter(
                      this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL
                    ))),
                  u ||
                    (this.extTextureHalfFloat = a.getExtension(
                      "OES_texture_half_float"
                    )),
                  (u ||
                    (this.extTextureHalfFloat &&
                      a.getExtension("OES_texture_half_float_linear"))) &&
                    (this.extRenderToTextureHalfFloat = a.getExtension(
                      "EXT_color_buffer_half_float"
                    )),
                  (this.extStandardDerivatives =
                    u || a.getExtension("OES_standard_derivatives")),
                  (this.extTimerQuery = a.getExtension(
                    "EXT_disjoint_timer_query"
                  )),
                  (this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE));
              }
              setDefault() {
                this.unbindVAO(),
                  this.clearColor.setDefault(),
                  this.clearDepth.setDefault(),
                  this.clearStencil.setDefault(),
                  this.colorMask.setDefault(),
                  this.depthMask.setDefault(),
                  this.stencilMask.setDefault(),
                  this.stencilFunc.setDefault(),
                  this.stencilOp.setDefault(),
                  this.stencilTest.setDefault(),
                  this.depthRange.setDefault(),
                  this.depthTest.setDefault(),
                  this.depthFunc.setDefault(),
                  this.blend.setDefault(),
                  this.blendFunc.setDefault(),
                  this.blendColor.setDefault(),
                  this.blendEquation.setDefault(),
                  this.cullFace.setDefault(),
                  this.cullFaceSide.setDefault(),
                  this.frontFace.setDefault(),
                  this.program.setDefault(),
                  this.activeTexture.setDefault(),
                  this.bindFramebuffer.setDefault(),
                  this.pixelStoreUnpack.setDefault(),
                  this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.pixelStoreUnpackFlipY.setDefault();
              }
              setDirty() {
                (this.clearColor.dirty = !0),
                  (this.clearDepth.dirty = !0),
                  (this.clearStencil.dirty = !0),
                  (this.colorMask.dirty = !0),
                  (this.depthMask.dirty = !0),
                  (this.stencilMask.dirty = !0),
                  (this.stencilFunc.dirty = !0),
                  (this.stencilOp.dirty = !0),
                  (this.stencilTest.dirty = !0),
                  (this.depthRange.dirty = !0),
                  (this.depthTest.dirty = !0),
                  (this.depthFunc.dirty = !0),
                  (this.blend.dirty = !0),
                  (this.blendFunc.dirty = !0),
                  (this.blendColor.dirty = !0),
                  (this.blendEquation.dirty = !0),
                  (this.cullFace.dirty = !0),
                  (this.cullFaceSide.dirty = !0),
                  (this.frontFace.dirty = !0),
                  (this.program.dirty = !0),
                  (this.activeTexture.dirty = !0),
                  (this.viewport.dirty = !0),
                  (this.bindFramebuffer.dirty = !0),
                  (this.bindRenderbuffer.dirty = !0),
                  (this.bindTexture.dirty = !0),
                  (this.bindVertexBuffer.dirty = !0),
                  (this.bindElementBuffer.dirty = !0),
                  this.extVertexArrayObject &&
                    (this.bindVertexArrayOES.dirty = !0),
                  (this.pixelStoreUnpack.dirty = !0),
                  (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
                  (this.pixelStoreUnpackFlipY.dirty = !0);
              }
              createIndexBuffer(a, u) {
                return new Fs(this, a, u);
              }
              createVertexBuffer(a, u, g) {
                return new xl(this, a, u, g);
              }
              createRenderbuffer(a, u, g) {
                const v = this.gl,
                  b = v.createRenderbuffer();
                return (
                  this.bindRenderbuffer.set(b),
                  v.renderbufferStorage(v.RENDERBUFFER, a, u, g),
                  this.bindRenderbuffer.set(null),
                  b
                );
              }
              createFramebuffer(a, u, g) {
                return new Ce(this, a, u, g);
              }
              clear({ color: a, depth: u, stencil: g }) {
                const v = this.gl;
                let b = 0;
                a &&
                  ((b |= v.COLOR_BUFFER_BIT),
                  this.clearColor.set(a),
                  this.colorMask.set([!0, !0, !0, !0])),
                  void 0 !== u &&
                    ((b |= v.DEPTH_BUFFER_BIT),
                    this.depthRange.set([0, 1]),
                    this.clearDepth.set(u),
                    this.depthMask.set(!0)),
                  void 0 !== g &&
                    ((b |= v.STENCIL_BUFFER_BIT),
                    this.clearStencil.set(g),
                    this.stencilMask.set(255)),
                  v.clear(b);
              }
              setCullFace(a) {
                !1 === a.enable
                  ? this.cullFace.set(!1)
                  : (this.cullFace.set(!0),
                    this.cullFaceSide.set(a.mode),
                    this.frontFace.set(a.frontFace));
              }
              setDepthMode(a) {
                a.func !== this.gl.ALWAYS || a.mask
                  ? (this.depthTest.set(!0),
                    this.depthFunc.set(a.func),
                    this.depthMask.set(a.mask),
                    this.depthRange.set(a.range))
                  : this.depthTest.set(!1);
              }
              setStencilMode(a) {
                a.test.func !== this.gl.ALWAYS || a.mask
                  ? (this.stencilTest.set(!0),
                    this.stencilMask.set(a.mask),
                    this.stencilOp.set([a.fail, a.depthFail, a.pass]),
                    this.stencilFunc.set({
                      func: a.test.func,
                      ref: a.ref,
                      mask: a.test.mask,
                    }))
                  : this.stencilTest.set(!1);
              }
              setColorMode(a) {
                Be(a.blendFunction, d.ColorMode.Replace)
                  ? this.blend.set(!1)
                  : (this.blend.set(!0),
                    this.blendFunc.set(a.blendFunction),
                    this.blendColor.set(a.blendColor)),
                  this.colorMask.set(a.mask);
              }
              unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
              }
            }
            class et extends d.Evented {
              constructor(a, u, g, v) {
                if (
                  (super(),
                  (this.id = a),
                  (this.dispatcher = g),
                  (this.type = "vector"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.scheme = "xyz"),
                  (this.tileSize = 512),
                  (this.reparseOverscaled = !0),
                  (this.isTileClipped = !0),
                  (this._loaded = !1),
                  d.extend(
                    this,
                    d.pick(u, ["url", "scheme", "tileSize", "promoteId"])
                  ),
                  (this._options = d.extend({ type: "vector" }, u)),
                  (this._collectResourceTiming = u.collectResourceTiming),
                  512 !== this.tileSize)
                )
                  throw new Error(
                    "vector tile sources must have a tileSize of 512"
                  );
                this.setEventedParent(v),
                  (this._tileWorkers = {}),
                  (this._deduped = new d.DedupedRequest());
              }
              load(a) {
                (this._loaded = !1),
                  this.fire(new d.Event("dataloading", { dataType: "source" }));
                const u = Array.isArray(this.map._language)
                    ? this.map._language.join()
                    : this.map._language,
                  g = this.map._worldview;
                this._tileJSONRequest = os(
                  this._options,
                  this.map._requestManager,
                  u,
                  g,
                  (v, b) => {
                    (this._tileJSONRequest = null),
                      (this._loaded = !0),
                      v
                        ? (u &&
                            console.warn(
                              `Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${u}`
                            ),
                          g &&
                            2 !== g.length &&
                            console.warn(
                              `Requested worldview strings must be a valid ISO alpha-2 code. Found: ${g}`
                            ),
                          this.fire(new d.ErrorEvent(v)))
                        : b &&
                          (d.extend(this, b),
                          b.bounds &&
                            (this.tileBounds = new ss(
                              b.bounds,
                              this.minzoom,
                              this.maxzoom
                            )),
                          d.postTurnstileEvent(
                            b.tiles,
                            this.map._requestManager._customAccessToken
                          ),
                          this.fire(
                            new d.Event("data", {
                              dataType: "source",
                              sourceDataType: "metadata",
                            })
                          ),
                          this.fire(
                            new d.Event("data", {
                              dataType: "source",
                              sourceDataType: "content",
                            })
                          )),
                      a && a(v);
                  }
                );
              }
              loaded() {
                return this._loaded;
              }
              hasTile(a) {
                return (
                  !this.tileBounds || this.tileBounds.contains(a.canonical)
                );
              }
              onAdd(a) {
                (this.map = a), this.load();
              }
              reload() {
                this.cancelTileJSONRequest(),
                  this.load(() => this.map.style._clearSource(this.id));
              }
              setTiles(a) {
                return (this._options.tiles = a), this.reload(), this;
              }
              setUrl(a) {
                return (
                  (this.url = a), (this._options.url = a), this.reload(), this
                );
              }
              onRemove() {
                this.cancelTileJSONRequest();
              }
              serialize() {
                return d.extend({}, this._options);
              }
              loadTile(a, u) {
                const g = this.map._requestManager.normalizeTileURL(
                    a.tileID.canonical.url(this.tiles, this.scheme)
                  ),
                  v = {
                    request: this.map._requestManager.transformRequest(
                      g,
                      d.ResourceType.Tile
                    ),
                    data: void 0,
                    uid: a.uid,
                    tileID: a.tileID,
                    tileZoom: a.tileZoom,
                    zoom: a.tileID.overscaledZ,
                    tileSize: this.tileSize * a.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    pixelRatio: d.exported.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: a.isSymbolTile,
                  };
                if (
                  ((v.request.collectResourceTiming =
                    this._collectResourceTiming),
                  a.actor && "expired" !== a.state)
                )
                  "loading" === a.state
                    ? (a.reloadCallback = u)
                    : (a.request = a.actor.send("reloadTile", v, b.bind(this)));
                else if (
                  ((a.actor = this._tileWorkers[g] =
                    this._tileWorkers[g] || this.dispatcher.getActor()),
                  this.dispatcher.ready)
                )
                  a.request = a.actor.send(
                    "loadTile",
                    v,
                    b.bind(this),
                    void 0,
                    !0
                  );
                else {
                  const D = d.loadVectorTile.call(
                    { deduped: this._deduped },
                    v,
                    (S, M) => {
                      S || !M
                        ? b.call(this, S)
                        : ((v.data = {
                            cacheControl: M.cacheControl,
                            expires: M.expires,
                            rawData: M.rawData.slice(0),
                          }),
                          a.actor &&
                            a.actor.send(
                              "loadTile",
                              v,
                              b.bind(this),
                              void 0,
                              !0
                            ));
                    },
                    !0
                  );
                  a.request = { cancel: D };
                }
                function b(D, S) {
                  return (
                    delete a.request,
                    a.aborted
                      ? u(null)
                      : D && 404 !== D.status
                      ? u(D)
                      : (S &&
                          S.resourceTiming &&
                          (a.resourceTiming = S.resourceTiming),
                        this.map._refreshExpiredTiles &&
                          S &&
                          a.setExpiryData(S),
                        a.loadVectorData(S, this.map.painter),
                        d.cacheEntryPossiblyAdded(this.dispatcher),
                        u(null),
                        void (
                          a.reloadCallback &&
                          (this.loadTile(a, a.reloadCallback),
                          (a.reloadCallback = null))
                        ))
                  );
                }
              }
              abortTile(a) {
                a.request && (a.request.cancel(), delete a.request),
                  a.actor &&
                    a.actor.send("abortTile", {
                      uid: a.uid,
                      type: this.type,
                      source: this.id,
                    });
              }
              unloadTile(a) {
                a.unloadVectorData(),
                  a.actor &&
                    a.actor.send("removeTile", {
                      uid: a.uid,
                      type: this.type,
                      source: this.id,
                    });
              }
              hasTransition() {
                return !1;
              }
              afterUpdate() {
                this._tileWorkers = {};
              }
              cancelTileJSONRequest() {
                this._tileJSONRequest &&
                  (this._tileJSONRequest.cancel(),
                  (this._tileJSONRequest = null));
              }
            }
            class We extends d.Evented {
              constructor(a, u, g, v) {
                super(),
                  (this.id = a),
                  (this.dispatcher = g),
                  this.setEventedParent(v),
                  (this.type = "raster"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.roundZoom = !0),
                  (this.scheme = "xyz"),
                  (this.tileSize = 512),
                  (this._loaded = !1),
                  (this._options = d.extend({ type: "raster" }, u)),
                  d.extend(this, d.pick(u, ["url", "scheme", "tileSize"]));
              }
              load(a) {
                (this._loaded = !1),
                  this.fire(new d.Event("dataloading", { dataType: "source" })),
                  (this._tileJSONRequest = os(
                    this._options,
                    this.map._requestManager,
                    null,
                    null,
                    (u, g) => {
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        u
                          ? this.fire(new d.ErrorEvent(u))
                          : g &&
                            (d.extend(this, g),
                            g.bounds &&
                              (this.tileBounds = new ss(
                                g.bounds,
                                this.minzoom,
                                this.maxzoom
                              )),
                            d.postTurnstileEvent(g.tiles),
                            this.fire(
                              new d.Event("data", {
                                dataType: "source",
                                sourceDataType: "metadata",
                              })
                            ),
                            this.fire(
                              new d.Event("data", {
                                dataType: "source",
                                sourceDataType: "content",
                              })
                            )),
                        a && a(u);
                    }
                  ));
              }
              loaded() {
                return this._loaded;
              }
              onAdd(a) {
                (this.map = a), this.load();
              }
              reload() {
                this.cancelTileJSONRequest(),
                  this.load(() => this.map.style._clearSource(this.id));
              }
              setTiles(a) {
                return (this._options.tiles = a), this.reload(), this;
              }
              setUrl(a) {
                return (
                  (this.url = a), (this._options.url = a), this.reload(), this
                );
              }
              onRemove() {
                this.cancelTileJSONRequest();
              }
              serialize() {
                return d.extend({}, this._options);
              }
              hasTile(a) {
                return (
                  !this.tileBounds || this.tileBounds.contains(a.canonical)
                );
              }
              loadTile(a, u) {
                const g = d.exported.devicePixelRatio >= 2,
                  v = this.map._requestManager.normalizeTileURL(
                    a.tileID.canonical.url(this.tiles, this.scheme),
                    g,
                    this.tileSize
                  );
                a.request = d.getImage(
                  this.map._requestManager.transformRequest(
                    v,
                    d.ResourceType.Tile
                  ),
                  (b, D, S, M) => (
                    delete a.request,
                    a.aborted
                      ? ((a.state = "unloaded"), u(null))
                      : b
                      ? ((a.state = "errored"), u(b))
                      : D
                      ? (this.map._refreshExpiredTiles &&
                          a.setExpiryData({ cacheControl: S, expires: M }),
                        a.setTexture(D, this.map.painter),
                        (a.state = "loaded"),
                        d.cacheEntryPossiblyAdded(this.dispatcher),
                        void u(null))
                      : u(null)
                  )
                );
              }
              static loadTileData(a, u, g) {
                a.setTexture(u, g);
              }
              static unloadTileData(a, u) {
                a.texture && u.saveTileTexture(a.texture);
              }
              abortTile(a, u) {
                a.request && (a.request.cancel(), delete a.request), u();
              }
              unloadTile(a, u) {
                a.texture && this.map.painter.saveTileTexture(a.texture), u();
              }
              hasTransition() {
                return !1;
              }
              cancelTileJSONRequest() {
                this._tileJSONRequest &&
                  (this._tileJSONRequest.cancel(),
                  (this._tileJSONRequest = null));
              }
            }
            function Rt(f, a, u, g, v, b, D, S) {
              const M = [f, u, v, a, g, b, 1, 1, 1],
                R = [D, S, 1],
                k = d.adjoint([], M),
                [z, H, q] = d.transformMat3(R, R, d.transpose(k, k));
              return d.multiply$1(M, [z, 0, 0, 0, H, 0, 0, 0, q], M);
            }
            class Ut extends d.Evented {
              constructor(a, u, g, v) {
                super(),
                  (this.id = a),
                  (this.dispatcher = g),
                  (this.coordinates = u.coordinates),
                  (this.type = "image"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.tileSize = 512),
                  (this.tiles = {}),
                  (this._loaded = !1),
                  this.setEventedParent(v),
                  (this.options = u),
                  (this._dirty = !1);
              }
              load(a, u) {
                (this._loaded = u || !1),
                  this.fire(new d.Event("dataloading", { dataType: "source" })),
                  (this.url = this.options.url),
                  (this._imageRequest = d.getImage(
                    this.map._requestManager.transformRequest(
                      this.url,
                      d.ResourceType.Image
                    ),
                    (g, v) => {
                      if (((this._imageRequest = null), (this._loaded = !0), g))
                        this.fire(new d.ErrorEvent(g));
                      else if (v) {
                        const { HTMLImageElement: b } = d.window;
                        (this.image =
                          v instanceof b ? d.exported.getImageData(v) : v),
                          (this._dirty = !0),
                          (this.width = this.image.width),
                          (this.height = this.image.height),
                          a && (this.coordinates = a),
                          this._finishLoading();
                      }
                    }
                  ));
              }
              loaded() {
                return this._loaded;
              }
              updateImage(a) {
                return this.image && a.url
                  ? (this._imageRequest &&
                      a.url !== this.options.url &&
                      (this._imageRequest.cancel(),
                      (this._imageRequest = null)),
                    (this.options.url = a.url),
                    this.load(a.coordinates, this._loaded),
                    this)
                  : this;
              }
              _finishLoading() {
                this.map &&
                  (this.setCoordinates(this.coordinates),
                  this.fire(
                    new d.Event("data", {
                      dataType: "source",
                      sourceDataType: "metadata",
                    })
                  ));
              }
              onAdd(a) {
                (this.map = a), this.load();
              }
              onRemove() {
                this._imageRequest &&
                  (this._imageRequest.cancel(), (this._imageRequest = null)),
                  this.texture && this.texture.destroy();
              }
              setCoordinates(a) {
                (this.coordinates = a), (this._boundsArray = void 0);
                const u = a.map(d.MercatorCoordinate.fromLngLat);
                return (
                  (this.tileID = (function (g) {
                    let v = 1 / 0,
                      b = 1 / 0,
                      D = -1 / 0,
                      S = -1 / 0;
                    for (const z of g)
                      (v = Math.min(v, z.x)),
                        (b = Math.min(b, z.y)),
                        (D = Math.max(D, z.x)),
                        (S = Math.max(S, z.y));
                    const M = Math.max(D - v, S - b),
                      R = Math.max(0, Math.floor(-Math.log(M) / Math.LN2)),
                      k = Math.pow(2, R);
                    return new d.CanonicalTileID(
                      R,
                      Math.floor(((v + D) / 2) * k),
                      Math.floor(((b + S) / 2) * k)
                    );
                  })(u)),
                  (this.minzoom = this.maxzoom = this.tileID.z),
                  this.fire(
                    new d.Event("data", {
                      dataType: "source",
                      sourceDataType: "content",
                    })
                  ),
                  this
                );
              }
              _clear() {
                this._boundsArray = void 0;
              }
              _prepareData(a) {
                for (const M in this.tiles) {
                  const R = this.tiles[M];
                  "loaded" !== R.state &&
                    ((R.state = "loaded"), (R.texture = this.texture));
                }
                if (this._boundsArray) return;
                const u = d.tileTransform(
                    this.tileID,
                    this.map.transform.projection
                  ),
                  [g, v, b, D] = this.coordinates.map((M) => {
                    const R = u.projection.project(M[0], M[1]);
                    return d.getTilePoint(u, R)._round();
                  });
                this.perspectiveTransform = (function (
                  M,
                  R,
                  k,
                  z,
                  H,
                  q,
                  X,
                  Z,
                  Y,
                  B
                ) {
                  const W = Rt(0, 0, M, 0, 0, R, M, R),
                    ee = Rt(k, z, H, q, X, Z, Y, B);
                  return (
                    d.multiply$1(ee, d.adjoint(W, W), ee),
                    [
                      ((ee[6] / ee[8]) * M) / d.EXTENT,
                      ((ee[7] / ee[8]) * R) / d.EXTENT,
                    ]
                  );
                })(
                  this.width,
                  this.height,
                  g.x,
                  g.y,
                  v.x,
                  v.y,
                  D.x,
                  D.y,
                  b.x,
                  b.y
                );
                const S = (this._boundsArray = new d.StructArrayLayout4i8());
                S.emplaceBack(g.x, g.y, 0, 0),
                  S.emplaceBack(v.x, v.y, d.EXTENT, 0),
                  S.emplaceBack(D.x, D.y, 0, d.EXTENT),
                  S.emplaceBack(b.x, b.y, d.EXTENT, d.EXTENT),
                  this.boundsBuffer && this.boundsBuffer.destroy(),
                  (this.boundsBuffer = a.createVertexBuffer(
                    S,
                    d.boundsAttributes.members
                  )),
                  (this.boundsSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
              }
              prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;
                const a = this.map.painter.context,
                  u = a.gl;
                this._dirty &&
                  (this.texture
                    ? this.texture.update(this.image)
                    : ((this.texture = new d.Texture(a, this.image, u.RGBA)),
                      this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE)),
                  (this._dirty = !1)),
                  this._prepareData(a);
              }
              loadTile(a, u) {
                this.tileID && this.tileID.equals(a.tileID.canonical)
                  ? ((this.tiles[String(a.tileID.wrap)] = a),
                    (a.buckets = {}),
                    u(null))
                  : ((a.state = "errored"), u(null));
              }
              serialize() {
                return {
                  type: "image",
                  url: this.options.url,
                  coordinates: this.coordinates,
                };
              }
              hasTransition() {
                return !1;
              }
            }
            const Ct = {
                vector: et,
                raster: We,
                "raster-dem": class extends We {
                  constructor(f, a, u, g) {
                    super(f, a, u, g),
                      (this.type = "raster-dem"),
                      (this.maxzoom = 22),
                      (this._options = d.extend({ type: "raster-dem" }, a)),
                      (this.encoding = a.encoding || "mapbox");
                  }
                  loadTile(f, a) {
                    const u = this.map._requestManager.normalizeTileURL(
                      f.tileID.canonical.url(this.tiles, this.scheme),
                      !1,
                      this.tileSize
                    );
                    function g(v, b) {
                      v && ((f.state = "errored"), a(v)),
                        b &&
                          ((f.dem = b),
                          f.dem.onDeserialize(),
                          (f.needsHillshadePrepare = !0),
                          (f.needsDEMTextureUpload = !0),
                          (f.state = "loaded"),
                          a(null));
                    }
                    f.request = d.getImage(
                      this.map._requestManager.transformRequest(
                        u,
                        d.ResourceType.Tile
                      ),
                      function (v, b, D, S) {
                        if ((delete f.request, f.aborted))
                          (f.state = "unloaded"), a(null);
                        else if (v) (f.state = "errored"), a(v);
                        else if (b) {
                          this.map._refreshExpiredTiles &&
                            f.setExpiryData({ cacheControl: D, expires: S });
                          const M =
                              d.window.ImageBitmap &&
                              b instanceof d.window.ImageBitmap &&
                              (null == El &&
                                (El =
                                  d.window.OffscreenCanvas &&
                                  new d.window.OffscreenCanvas(1, 1).getContext(
                                    "2d"
                                  ) &&
                                  "function" ==
                                    typeof d.window.createImageBitmap),
                              El),
                            R = 1 - (b.width - d.prevPowerOfTwo(b.width)) / 2;
                          R < 1 ||
                            f.neighboringTiles ||
                            (f.neighboringTiles = this._getNeighboringTiles(
                              f.tileID
                            ));
                          const k = M ? b : d.exported.getImageData(b, R),
                            z = {
                              uid: f.uid,
                              coord: f.tileID,
                              source: this.id,
                              rawImageData: k,
                              encoding: this.encoding,
                              padding: R,
                            };
                          (f.actor && "expired" !== f.state) ||
                            ((f.actor = this.dispatcher.getActor()),
                            f.actor.send(
                              "loadDEMTile",
                              z,
                              g.bind(this),
                              void 0,
                              !0
                            ));
                        }
                      }.bind(this)
                    );
                  }
                  _getNeighboringTiles(f) {
                    const a = f.canonical,
                      u = Math.pow(2, a.z),
                      g = (a.x - 1 + u) % u,
                      v = 0 === a.x ? f.wrap - 1 : f.wrap,
                      b = (a.x + 1 + u) % u,
                      D = a.x + 1 === u ? f.wrap + 1 : f.wrap,
                      S = {};
                    return (
                      (S[
                        new d.OverscaledTileID(
                          f.overscaledZ,
                          v,
                          a.z,
                          g,
                          a.y
                        ).key
                      ] = { backfilled: !1 }),
                      (S[
                        new d.OverscaledTileID(
                          f.overscaledZ,
                          D,
                          a.z,
                          b,
                          a.y
                        ).key
                      ] = { backfilled: !1 }),
                      a.y > 0 &&
                        ((S[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            v,
                            a.z,
                            g,
                            a.y - 1
                          ).key
                        ] = { backfilled: !1 }),
                        (S[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            f.wrap,
                            a.z,
                            a.x,
                            a.y - 1
                          ).key
                        ] = { backfilled: !1 }),
                        (S[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            D,
                            a.z,
                            b,
                            a.y - 1
                          ).key
                        ] = { backfilled: !1 })),
                      a.y + 1 < u &&
                        ((S[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            v,
                            a.z,
                            g,
                            a.y + 1
                          ).key
                        ] = { backfilled: !1 }),
                        (S[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            f.wrap,
                            a.z,
                            a.x,
                            a.y + 1
                          ).key
                        ] = { backfilled: !1 }),
                        (S[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            D,
                            a.z,
                            b,
                            a.y + 1
                          ).key
                        ] = { backfilled: !1 })),
                      S
                    );
                  }
                  unloadTile(f) {
                    f.demTexture &&
                      this.map.painter.saveTileTexture(f.demTexture),
                      f.fbo && (f.fbo.destroy(), delete f.fbo),
                      f.dem && delete f.dem,
                      delete f.neighboringTiles,
                      (f.state = "unloaded");
                  }
                },
                geojson: class extends d.Evented {
                  constructor(f, a, u, g) {
                    super(),
                      (this.id = f),
                      (this.type = "geojson"),
                      (this.minzoom = 0),
                      (this.maxzoom = 18),
                      (this.tileSize = 512),
                      (this.isTileClipped = !0),
                      (this.reparseOverscaled = !0),
                      (this._loaded = !1),
                      (this.actor = u.getActor()),
                      this.setEventedParent(g),
                      (this._data = a.data),
                      (this._options = d.extend({}, a)),
                      (this._collectResourceTiming = a.collectResourceTiming),
                      void 0 !== a.maxzoom && (this.maxzoom = a.maxzoom),
                      a.type && (this.type = a.type),
                      a.attribution && (this.attribution = a.attribution),
                      (this.promoteId = a.promoteId);
                    const v = d.EXTENT / this.tileSize;
                    this.workerOptions = d.extend(
                      {
                        source: this.id,
                        cluster: a.cluster || !1,
                        geojsonVtOptions: {
                          buffer: (void 0 !== a.buffer ? a.buffer : 128) * v,
                          tolerance:
                            (void 0 !== a.tolerance ? a.tolerance : 0.375) * v,
                          extent: d.EXTENT,
                          maxZoom: this.maxzoom,
                          lineMetrics: a.lineMetrics || !1,
                          generateId: a.generateId || !1,
                        },
                        superclusterOptions: {
                          maxZoom:
                            void 0 !== a.clusterMaxZoom
                              ? a.clusterMaxZoom
                              : this.maxzoom - 1,
                          minPoints: Math.max(2, a.clusterMinPoints || 2),
                          extent: d.EXTENT,
                          radius:
                            (void 0 !== a.clusterRadius
                              ? a.clusterRadius
                              : 50) * v,
                          log: !1,
                          generateId: a.generateId || !1,
                        },
                        clusterProperties: a.clusterProperties,
                        filter: a.filter,
                      },
                      a.workerOptions
                    );
                  }
                  onAdd(f) {
                    (this.map = f), this.setData(this._data);
                  }
                  setData(f) {
                    return (this._data = f), this._updateWorkerData(), this;
                  }
                  getClusterExpansionZoom(f, a) {
                    return (
                      this.actor.send(
                        "geojson.getClusterExpansionZoom",
                        { clusterId: f, source: this.id },
                        a
                      ),
                      this
                    );
                  }
                  getClusterChildren(f, a) {
                    return (
                      this.actor.send(
                        "geojson.getClusterChildren",
                        { clusterId: f, source: this.id },
                        a
                      ),
                      this
                    );
                  }
                  getClusterLeaves(f, a, u, g) {
                    return (
                      this.actor.send(
                        "geojson.getClusterLeaves",
                        { source: this.id, clusterId: f, limit: a, offset: u },
                        g
                      ),
                      this
                    );
                  }
                  _updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(
                      new d.Event("dataloading", { dataType: "source" })
                    ),
                      (this._loaded = !1);
                    const f = d.extend({}, this.workerOptions),
                      a = this._data;
                    "string" == typeof a
                      ? ((f.request = this.map._requestManager.transformRequest(
                          d.exported.resolveURL(a),
                          d.ResourceType.Source
                        )),
                        (f.request.collectResourceTiming =
                          this._collectResourceTiming))
                      : (f.data = JSON.stringify(a)),
                      (this._pendingLoad = this.actor.send(
                        `${this.type}.loadData`,
                        f,
                        (u, g) => {
                          if (
                            ((this._loaded = !0), (this._pendingLoad = null), u)
                          )
                            this.fire(new d.ErrorEvent(u));
                          else {
                            const v = {
                              dataType: "source",
                              sourceDataType: this._metadataFired
                                ? "content"
                                : "metadata",
                            };
                            this._collectResourceTiming &&
                              g &&
                              g.resourceTiming &&
                              g.resourceTiming[this.id] &&
                              (v.resourceTiming = g.resourceTiming[this.id]),
                              this.fire(new d.Event("data", v)),
                              (this._metadataFired = !0);
                          }
                          this._coalesce &&
                            (this._updateWorkerData(), (this._coalesce = !1));
                        }
                      ));
                  }
                  loaded() {
                    return this._loaded;
                  }
                  loadTile(f, a) {
                    const u = f.actor ? "reloadTile" : "loadTile";
                    (f.actor = this.actor),
                      (f.request = this.actor.send(
                        u,
                        {
                          type: this.type,
                          uid: f.uid,
                          tileID: f.tileID,
                          tileZoom: f.tileZoom,
                          zoom: f.tileID.overscaledZ,
                          maxZoom: this.maxzoom,
                          tileSize: this.tileSize,
                          source: this.id,
                          pixelRatio: d.exported.devicePixelRatio,
                          showCollisionBoxes: this.map.showCollisionBoxes,
                          promoteId: this.promoteId,
                        },
                        (g, v) => (
                          delete f.request,
                          f.unloadVectorData(),
                          f.aborted
                            ? a(null)
                            : g
                            ? a(g)
                            : (f.loadVectorData(
                                v,
                                this.map.painter,
                                "reloadTile" === u
                              ),
                              a(null))
                        ),
                        void 0,
                        "loadTile" === u
                      ));
                  }
                  abortTile(f) {
                    f.request && (f.request.cancel(), delete f.request),
                      (f.aborted = !0);
                  }
                  unloadTile(f) {
                    f.unloadVectorData(),
                      this.actor.send("removeTile", {
                        uid: f.uid,
                        type: this.type,
                        source: this.id,
                      });
                  }
                  onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                  }
                  serialize() {
                    return d.extend({}, this._options, {
                      type: this.type,
                      data: this._data,
                    });
                  }
                  hasTransition() {
                    return !1;
                  }
                },
                video: class extends Ut {
                  constructor(f, a, u, g) {
                    super(f, a, u, g),
                      (this.roundZoom = !0),
                      (this.type = "video"),
                      (this.options = a);
                  }
                  load() {
                    this._loaded = !1;
                    const f = this.options;
                    this.urls = [];
                    for (const a of f.urls)
                      this.urls.push(
                        this.map._requestManager.transformRequest(
                          a,
                          d.ResourceType.Source
                        ).url
                      );
                    d.getVideo(this.urls, (a, u) => {
                      (this._loaded = !0),
                        a
                          ? this.fire(new d.ErrorEvent(a))
                          : u &&
                            ((this.video = u),
                            (this.video.loop = !0),
                            this.video.setAttribute("playsinline", ""),
                            this.video.addEventListener("playing", () => {
                              this.map.triggerRepaint();
                            }),
                            this.map && this.video.play(),
                            this._finishLoading());
                    });
                  }
                  pause() {
                    this.video && this.video.pause();
                  }
                  play() {
                    this.video && this.video.play();
                  }
                  seek(f) {
                    if (this.video) {
                      const a = this.video.seekable;
                      f < a.start(0) || f > a.end(0)
                        ? this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${this.id}`,
                                null,
                                `Playback for this video can be set only between the ${a.start(
                                  0
                                )} and ${a.end(0)}-second mark.`
                              )
                            )
                          )
                        : (this.video.currentTime = f);
                    }
                  }
                  getVideo() {
                    return this.video;
                  }
                  onAdd(f) {
                    this.map ||
                      ((this.map = f),
                      this.load(),
                      this.video &&
                        (this.video.play(),
                        this.setCoordinates(this.coordinates)));
                  }
                  prepare() {
                    if (
                      0 === Object.keys(this.tiles).length ||
                      this.video.readyState < 2
                    )
                      return;
                    const f = this.map.painter.context,
                      a = f.gl;
                    this.texture
                      ? this.video.paused ||
                        (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE),
                        a.texSubImage2D(
                          a.TEXTURE_2D,
                          0,
                          0,
                          0,
                          a.RGBA,
                          a.UNSIGNED_BYTE,
                          this.video
                        ))
                      : ((this.texture = new d.Texture(f, this.video, a.RGBA)),
                        this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE),
                        (this.width = this.video.videoWidth),
                        (this.height = this.video.videoHeight)),
                      this._prepareData(f);
                  }
                  serialize() {
                    return {
                      type: "video",
                      urls: this.urls,
                      coordinates: this.coordinates,
                    };
                  }
                  hasTransition() {
                    return this.video && !this.video.paused;
                  }
                },
                image: Ut,
                canvas: class extends Ut {
                  constructor(f, a, u, g) {
                    super(f, a, u, g),
                      a.coordinates
                        ? (Array.isArray(a.coordinates) &&
                            4 === a.coordinates.length &&
                            !a.coordinates.some(
                              (v) =>
                                !Array.isArray(v) ||
                                2 !== v.length ||
                                v.some((b) => "number" != typeof b)
                            )) ||
                          this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                '"coordinates" property must be an array of 4 longitude/latitude array pairs'
                              )
                            )
                          )
                        : this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                'missing required property "coordinates"'
                              )
                            )
                          ),
                      a.animate &&
                        "boolean" != typeof a.animate &&
                        this.fire(
                          new d.ErrorEvent(
                            new d.ValidationError(
                              `sources.${f}`,
                              null,
                              'optional "animate" property must be a boolean value'
                            )
                          )
                        ),
                      a.canvas
                        ? "string" == typeof a.canvas ||
                          a.canvas instanceof d.window.HTMLCanvasElement ||
                          this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'
                              )
                            )
                          )
                        : this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                'missing required property "canvas"'
                              )
                            )
                          ),
                      (this.options = a),
                      (this.animate = void 0 === a.animate || a.animate);
                  }
                  load() {
                    (this._loaded = !0),
                      this.canvas ||
                        (this.canvas =
                          this.options.canvas instanceof
                          d.window.HTMLCanvasElement
                            ? this.options.canvas
                            : d.window.document.getElementById(
                                this.options.canvas
                              )),
                      (this.width = this.canvas.width),
                      (this.height = this.canvas.height),
                      this._hasInvalidDimensions()
                        ? this.fire(
                            new d.ErrorEvent(
                              new Error(
                                "Canvas dimensions cannot be less than or equal to zero."
                              )
                            )
                          )
                        : ((this.play = function () {
                            (this._playing = !0), this.map.triggerRepaint();
                          }),
                          (this.pause = function () {
                            this._playing &&
                              (this.prepare(), (this._playing = !1));
                          }),
                          this._finishLoading());
                  }
                  getCanvas() {
                    return this.canvas;
                  }
                  onAdd(f) {
                    (this.map = f),
                      this.load(),
                      this.canvas && this.animate && this.play();
                  }
                  onRemove() {
                    this.pause();
                  }
                  prepare() {
                    let f = !1;
                    if (
                      (this.canvas.width !== this.width &&
                        ((this.width = this.canvas.width), (f = !0)),
                      this.canvas.height !== this.height &&
                        ((this.height = this.canvas.height), (f = !0)),
                      this._hasInvalidDimensions() ||
                        0 === Object.keys(this.tiles).length)
                    )
                      return;
                    const a = this.map.painter.context;
                    this.texture
                      ? (f || this._playing) &&
                        this.texture.update(this.canvas, { premultiply: !0 })
                      : (this.texture = new d.Texture(
                          a,
                          this.canvas,
                          a.gl.RGBA,
                          { premultiply: !0 }
                        )),
                      this._prepareData(a);
                  }
                  serialize() {
                    return { type: "canvas", coordinates: this.coordinates };
                  }
                  hasTransition() {
                    return this._playing;
                  }
                  _hasInvalidDimensions() {
                    for (const f of [this.canvas.width, this.canvas.height])
                      if (isNaN(f) || f <= 0) return !0;
                    return !1;
                  }
                },
                custom: class extends d.Evented {
                  constructor(f, a, u, g) {
                    super(),
                      (this.id = f),
                      (this.type = "custom"),
                      (this._dataType = "raster"),
                      (this._dispatcher = u),
                      (this._implementation = a),
                      this.setEventedParent(g),
                      (this.scheme = "xyz"),
                      (this.minzoom = 0),
                      (this.maxzoom = 22),
                      (this.tileSize = 512),
                      (this._loaded = !1),
                      (this.roundZoom = !0),
                      this._implementation ||
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              `Missing implementation for ${this.id} custom source`
                            )
                          )
                        ),
                      this._implementation.loadTile ||
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              `Missing loadTile implementation for ${this.id} custom source`
                            )
                          )
                        ),
                      this._implementation.bounds &&
                        (this.tileBounds = new ss(
                          this._implementation.bounds,
                          this.minzoom,
                          this.maxzoom
                        )),
                      (a.update = this._update.bind(this)),
                      (a.clearTiles = this._clearTiles.bind(this)),
                      (a.coveringTiles = this._coveringTiles.bind(this)),
                      d.extend(
                        this,
                        d.pick(a, [
                          "dataType",
                          "scheme",
                          "minzoom",
                          "maxzoom",
                          "tileSize",
                          "attribution",
                          "minTileCacheSize",
                          "maxTileCacheSize",
                        ])
                      );
                  }
                  serialize() {
                    return d.pick(this, [
                      "type",
                      "scheme",
                      "minzoom",
                      "maxzoom",
                      "tileSize",
                      "attribution",
                    ]);
                  }
                  load() {
                    (this._loaded = !0),
                      this.fire(
                        new d.Event("data", {
                          dataType: "source",
                          sourceDataType: "metadata",
                        })
                      ),
                      this.fire(
                        new d.Event("data", {
                          dataType: "source",
                          sourceDataType: "content",
                        })
                      );
                  }
                  loaded() {
                    return this._loaded;
                  }
                  onAdd(f) {
                    (this._map = f),
                      (this._loaded = !1),
                      this.fire(
                        new d.Event("dataloading", { dataType: "source" })
                      ),
                      this._implementation.onAdd &&
                        this._implementation.onAdd(f),
                      this.load();
                  }
                  onRemove(f) {
                    this._implementation.onRemove &&
                      this._implementation.onRemove(f);
                  }
                  hasTile(f) {
                    if (this._implementation.hasTile) {
                      const { x: a, y: u, z: g } = f.canonical;
                      return this._implementation.hasTile({ x: a, y: u, z: g });
                    }
                    return (
                      !this.tileBounds || this.tileBounds.contains(f.canonical)
                    );
                  }
                  loadTile(f, a) {
                    const { x: u, y: g, z: v } = f.tileID.canonical,
                      b = new d.window.AbortController();
                    (f.request = Promise.resolve(
                      this._implementation.loadTile(
                        { x: u, y: g, z: v },
                        { signal: b.signal }
                      )
                    )
                      .then(
                        function (D) {
                          return (
                            delete f.request,
                            f.aborted
                              ? ((f.state = "unloaded"), a(null))
                              : void 0 === D
                              ? ((f.state = "errored"), a(null))
                              : null === D
                              ? (this.loadTileData(f, {
                                  width: this.tileSize,
                                  height: this.tileSize,
                                  data: null,
                                }),
                                (f.state = "loaded"),
                                a(null))
                              : (S = D) instanceof d.window.ImageData ||
                                S instanceof d.window.HTMLCanvasElement ||
                                S instanceof d.window.ImageBitmap ||
                                S instanceof d.window.HTMLImageElement
                              ? (this.loadTileData(f, D),
                                (f.state = "loaded"),
                                void a(null))
                              : ((f.state = "errored"),
                                a(
                                  new Error(
                                    `Can't infer data type for ${this.id}, only raster data supported at the moment`
                                  )
                                ))
                          );
                          var S;
                        }.bind(this)
                      )
                      .catch((D) => {
                        20 !== D.code && ((f.state = "errored"), a(D));
                      })),
                      (f.request.cancel = () => b.abort());
                  }
                  loadTileData(f, a) {
                    We.loadTileData(f, a, this._map.painter);
                  }
                  unloadTileData(f) {
                    We.unloadTileData(f, this._map.painter);
                  }
                  unloadTile(f, a) {
                    if (
                      (this.unloadTileData(f), this._implementation.unloadTile)
                    ) {
                      const { x: u, y: g, z: v } = f.tileID.canonical;
                      this._implementation.unloadTile({ x: u, y: g, z: v });
                    }
                    a();
                  }
                  abortTile(f, a) {
                    f.request &&
                      f.request.cancel &&
                      (f.request.cancel(), delete f.request),
                      a();
                  }
                  hasTransition() {
                    return !1;
                  }
                  _coveringTiles() {
                    return this._map.transform
                      .coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom,
                      })
                      .map((f) => ({
                        x: f.canonical.x,
                        y: f.canonical.y,
                        z: f.canonical.z,
                      }));
                  }
                  _clearTiles() {
                    this._map.style._clearSource(this.id);
                  }
                  _update() {
                    this.fire(
                      new d.Event("data", {
                        dataType: "source",
                        sourceDataType: "content",
                      })
                    );
                  }
                },
              },
              Zt = function (f, a, u, g) {
                const v = new Ct[a.type](f, a, u, g);
                if (v.id !== f)
                  throw new Error(
                    `Expected Source id to be ${f} instead of ${v.id}`
                  );
                return (
                  d.bindAll(
                    ["load", "abort", "unload", "serialize", "prepare"],
                    v
                  ),
                  v
                );
              };
            function on(f, a) {
              const u = d.identity([]);
              return (
                d.scale(u, u, [0.5 * f.width, 0.5 * -f.height, 1]),
                d.translate(u, u, [1, -1, 0]),
                d.multiply(u, u, f.calculateProjMatrix(a.toUnwrapped())),
                Float32Array.from(u)
              );
            }
            function Zn(f, a, u, g, v, b, D, S = !1) {
              const M = f.tilesIn(g, D, S);
              M.sort(Ki);
              const R = [];
              for (const z of M)
                R.push({
                  wrappedTileID: z.tile.tileID.wrapped().key,
                  queryResults: z.tile.queryRenderedFeatures(
                    a,
                    u,
                    f._state,
                    z,
                    v,
                    b,
                    on(f.transform, z.tile.tileID),
                    S
                  ),
                });
              const k = (function (z) {
                const H = {},
                  q = {};
                for (const X of z) {
                  const Z = X.queryResults,
                    Y = X.wrappedTileID,
                    B = (q[Y] = q[Y] || {});
                  for (const W in Z) {
                    const ee = Z[W],
                      te = (B[W] = B[W] || {}),
                      he = (H[W] = H[W] || []);
                    for (const de of ee)
                      te[de.featureIndex] ||
                        ((te[de.featureIndex] = !0), he.push(de));
                  }
                }
                return H;
              })(R);
              for (const z in k)
                k[z].forEach((H) => {
                  const q = H.feature,
                    X = q.layer;
                  X &&
                    "background" !== X.type &&
                    "sky" !== X.type &&
                    ((q.source = X.source),
                    X["source-layer"] && (q.sourceLayer = X["source-layer"]),
                    (q.state =
                      void 0 !== q.id
                        ? f.getFeatureState(X["source-layer"], q.id)
                        : {}));
                });
              return k;
            }
            function fi(f, a) {
              const u = f.getRenderableIds().map((b) => f.getTileByID(b)),
                g = [],
                v = {};
              for (let b = 0; b < u.length; b++) {
                const D = u[b],
                  S = D.tileID.canonical.key;
                v[S] || ((v[S] = !0), D.querySourceFeatures(g, a));
              }
              return g;
            }
            function Ki(f, a) {
              const u = f.tileID,
                g = a.tileID;
              return (
                u.overscaledZ - g.overscaledZ ||
                u.canonical.y - g.canonical.y ||
                u.wrap - g.wrap ||
                u.canonical.x - g.canonical.x
              );
            }
            function Di() {
              return null != qa.workerClass
                ? new qa.workerClass()
                : new d.window.Worker(qa.workerUrl);
            }
            const zo = "mapboxgl_preloaded_worker_pool";
            class Xn {
              constructor() {
                this.active = {};
              }
              acquire(a) {
                if (!this.workers)
                  for (
                    this.workers = [];
                    this.workers.length < Xn.workerCount;

                  )
                    this.workers.push(new Di());
                return (this.active[a] = !0), this.workers.slice();
              }
              release(a) {
                delete this.active[a],
                  0 === this.numActive() &&
                    (this.workers.forEach((u) => {
                      u.terminate();
                    }),
                    (this.workers = null));
              }
              isPreloaded() {
                return !!this.active[zo];
              }
              numActive() {
                return Object.keys(this.active).length;
              }
            }
            let gr;
            function ka() {
              return gr || (gr = new Xn()), gr;
            }
            function Lf(f, a) {
              const u = {};
              for (const g in f) "ref" !== g && (u[g] = f[g]);
              return (
                d.refProperties.forEach((g) => {
                  g in a && (u[g] = a[g]);
                }),
                u
              );
            }
            function Ch(f) {
              f = f.slice();
              const a = Object.create(null);
              for (let u = 0; u < f.length; u++) a[f[u].id] = f[u];
              for (let u = 0; u < f.length; u++)
                "ref" in f[u] && (f[u] = Lf(f[u], a[f[u].ref]));
              return f;
            }
            Xn.workerCount = 2;
            const xn = {
              setStyle: "setStyle",
              addLayer: "addLayer",
              removeLayer: "removeLayer",
              setPaintProperty: "setPaintProperty",
              setLayoutProperty: "setLayoutProperty",
              setFilter: "setFilter",
              addSource: "addSource",
              removeSource: "removeSource",
              setGeoJSONSourceData: "setGeoJSONSourceData",
              setLayerZoomRange: "setLayerZoomRange",
              setLayerProperty: "setLayerProperty",
              setCenter: "setCenter",
              setZoom: "setZoom",
              setBearing: "setBearing",
              setPitch: "setPitch",
              setSprite: "setSprite",
              setGlyphs: "setGlyphs",
              setTransition: "setTransition",
              setLight: "setLight",
              setTerrain: "setTerrain",
              setFog: "setFog",
              setProjection: "setProjection",
            };
            function Sh(f, a, u) {
              u.push({ command: xn.addSource, args: [f, a[f]] });
            }
            function hc(f, a, u) {
              a.push({ command: xn.removeSource, args: [f] }), (u[f] = !0);
            }
            function dc(f, a, u, g) {
              hc(f, u, g), Sh(f, a, u);
            }
            function Ih(f, a, u) {
              let g;
              for (g in f[u])
                if (
                  f[u].hasOwnProperty(g) &&
                  "data" !== g &&
                  !Be(f[u][g], a[u][g])
                )
                  return !1;
              for (g in a[u])
                if (
                  a[u].hasOwnProperty(g) &&
                  "data" !== g &&
                  !Be(f[u][g], a[u][g])
                )
                  return !1;
              return !0;
            }
            function Bo(f, a, u, g, v, b) {
              let D;
              for (D in ((a = a || {}), (f = f || {})))
                f.hasOwnProperty(D) &&
                  (Be(f[D], a[D]) ||
                    u.push({ command: b, args: [g, D, a[D], v] }));
              for (D in a)
                a.hasOwnProperty(D) &&
                  !f.hasOwnProperty(D) &&
                  (Be(f[D], a[D]) ||
                    u.push({ command: b, args: [g, D, a[D], v] }));
            }
            function cs(f) {
              return f.id;
            }
            function fu(f, a) {
              return (f[a.id] = a), f;
            }
            class mu {
              constructor(a, u) {
                this.reset(a, u);
              }
              reset(a, u) {
                (this.points = a || []), (this._distances = [0]);
                for (let g = 1; g < this.points.length; g++)
                  this._distances[g] =
                    this._distances[g - 1] +
                    this.points[g].dist(this.points[g - 1]);
                (this.length = this._distances[this._distances.length - 1]),
                  (this.padding = Math.min(u || 0, 0.5 * this.length)),
                  (this.paddedLength = this.length - 2 * this.padding);
              }
              lerp(a) {
                if (1 === this.points.length) return this.points[0];
                a = d.clamp(a, 0, 1);
                let u = 1,
                  g = this._distances[u];
                const v = a * this.paddedLength + this.padding;
                for (; g < v && u < this._distances.length; )
                  g = this._distances[++u];
                const b = u - 1,
                  D = this._distances[b],
                  S = g - D,
                  M = S > 0 ? (v - D) / S : 0;
                return this.points[b].mult(1 - M).add(this.points[u].mult(M));
              }
            }
            class Ra {
              constructor(a, u, g) {
                const v = (this.boxCells = []),
                  b = (this.circleCells = []);
                (this.xCellCount = Math.ceil(a / g)),
                  (this.yCellCount = Math.ceil(u / g));
                for (let D = 0; D < this.xCellCount * this.yCellCount; D++)
                  v.push([]), b.push([]);
                (this.circleKeys = []),
                  (this.boxKeys = []),
                  (this.bboxes = []),
                  (this.circles = []),
                  (this.width = a),
                  (this.height = u),
                  (this.xScale = this.xCellCount / a),
                  (this.yScale = this.yCellCount / u),
                  (this.boxUid = 0),
                  (this.circleUid = 0);
              }
              keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
              }
              insert(a, u, g, v, b) {
                this._forEachCell(
                  u,
                  g,
                  v,
                  b,
                  this._insertBoxCell,
                  this.boxUid++
                ),
                  this.boxKeys.push(a),
                  this.bboxes.push(u),
                  this.bboxes.push(g),
                  this.bboxes.push(v),
                  this.bboxes.push(b);
              }
              insertCircle(a, u, g, v) {
                this._forEachCell(
                  u - v,
                  g - v,
                  u + v,
                  g + v,
                  this._insertCircleCell,
                  this.circleUid++
                ),
                  this.circleKeys.push(a),
                  this.circles.push(u),
                  this.circles.push(g),
                  this.circles.push(v);
              }
              _insertBoxCell(a, u, g, v, b, D) {
                this.boxCells[b].push(D);
              }
              _insertCircleCell(a, u, g, v, b, D) {
                this.circleCells[b].push(D);
              }
              _query(a, u, g, v, b, D) {
                if (g < 0 || a > this.width || v < 0 || u > this.height)
                  return !b && [];
                const S = [];
                if (a <= 0 && u <= 0 && this.width <= g && this.height <= v) {
                  if (b) return !0;
                  for (let M = 0; M < this.boxKeys.length; M++)
                    S.push({
                      key: this.boxKeys[M],
                      x1: this.bboxes[4 * M],
                      y1: this.bboxes[4 * M + 1],
                      x2: this.bboxes[4 * M + 2],
                      y2: this.bboxes[4 * M + 3],
                    });
                  for (let M = 0; M < this.circleKeys.length; M++) {
                    const R = this.circles[3 * M],
                      k = this.circles[3 * M + 1],
                      z = this.circles[3 * M + 2];
                    S.push({
                      key: this.circleKeys[M],
                      x1: R - z,
                      y1: k - z,
                      x2: R + z,
                      y2: k + z,
                    });
                  }
                  return D ? S.filter(D) : S;
                }
                return (
                  this._forEachCell(
                    a,
                    u,
                    g,
                    v,
                    this._queryCell,
                    S,
                    { hitTest: b, seenUids: { box: {}, circle: {} } },
                    D
                  ),
                  b ? S.length > 0 : S
                );
              }
              _queryCircle(a, u, g, v, b) {
                const D = a - g,
                  S = a + g,
                  M = u - g,
                  R = u + g;
                if (S < 0 || D > this.width || R < 0 || M > this.height)
                  return !v && [];
                const k = [];
                return (
                  this._forEachCell(
                    D,
                    M,
                    S,
                    R,
                    this._queryCellCircle,
                    k,
                    {
                      hitTest: v,
                      circle: { x: a, y: u, radius: g },
                      seenUids: { box: {}, circle: {} },
                    },
                    b
                  ),
                  v ? k.length > 0 : k
                );
              }
              query(a, u, g, v, b) {
                return this._query(a, u, g, v, !1, b);
              }
              hitTest(a, u, g, v, b) {
                return this._query(a, u, g, v, !0, b);
              }
              hitTestCircle(a, u, g, v) {
                return this._queryCircle(a, u, g, !0, v);
              }
              _queryCell(a, u, g, v, b, D, S, M) {
                const R = S.seenUids,
                  k = this.boxCells[b];
                if (null !== k) {
                  const H = this.bboxes;
                  for (const q of k)
                    if (!R.box[q]) {
                      R.box[q] = !0;
                      const X = 4 * q;
                      if (
                        a <= H[X + 2] &&
                        u <= H[X + 3] &&
                        g >= H[X + 0] &&
                        v >= H[X + 1] &&
                        (!M || M(this.boxKeys[q]))
                      ) {
                        if (S.hitTest) return D.push(!0), !0;
                        D.push({
                          key: this.boxKeys[q],
                          x1: H[X],
                          y1: H[X + 1],
                          x2: H[X + 2],
                          y2: H[X + 3],
                        });
                      }
                    }
                }
                const z = this.circleCells[b];
                if (null !== z) {
                  const H = this.circles;
                  for (const q of z)
                    if (!R.circle[q]) {
                      R.circle[q] = !0;
                      const X = 3 * q;
                      if (
                        this._circleAndRectCollide(
                          H[X],
                          H[X + 1],
                          H[X + 2],
                          a,
                          u,
                          g,
                          v
                        ) &&
                        (!M || M(this.circleKeys[q]))
                      ) {
                        if (S.hitTest) return D.push(!0), !0;
                        {
                          const Z = H[X],
                            Y = H[X + 1],
                            B = H[X + 2];
                          D.push({
                            key: this.circleKeys[q],
                            x1: Z - B,
                            y1: Y - B,
                            x2: Z + B,
                            y2: Y + B,
                          });
                        }
                      }
                    }
                }
              }
              _queryCellCircle(a, u, g, v, b, D, S, M) {
                const R = S.circle,
                  k = S.seenUids,
                  z = this.boxCells[b];
                if (null !== z) {
                  const q = this.bboxes;
                  for (const X of z)
                    if (!k.box[X]) {
                      k.box[X] = !0;
                      const Z = 4 * X;
                      if (
                        this._circleAndRectCollide(
                          R.x,
                          R.y,
                          R.radius,
                          q[Z + 0],
                          q[Z + 1],
                          q[Z + 2],
                          q[Z + 3]
                        ) &&
                        (!M || M(this.boxKeys[X]))
                      )
                        return D.push(!0), !0;
                    }
                }
                const H = this.circleCells[b];
                if (null !== H) {
                  const q = this.circles;
                  for (const X of H)
                    if (!k.circle[X]) {
                      k.circle[X] = !0;
                      const Z = 3 * X;
                      if (
                        this._circlesCollide(
                          q[Z],
                          q[Z + 1],
                          q[Z + 2],
                          R.x,
                          R.y,
                          R.radius
                        ) &&
                        (!M || M(this.circleKeys[X]))
                      )
                        return D.push(!0), !0;
                    }
                }
              }
              _forEachCell(a, u, g, v, b, D, S, M) {
                const R = this._convertToXCellCoord(a),
                  k = this._convertToYCellCoord(u),
                  z = this._convertToXCellCoord(g),
                  H = this._convertToYCellCoord(v);
                for (let q = R; q <= z; q++)
                  for (let X = k; X <= H; X++)
                    if (
                      b.call(this, a, u, g, v, this.xCellCount * X + q, D, S, M)
                    )
                      return;
              }
              _convertToXCellCoord(a) {
                return Math.max(
                  0,
                  Math.min(this.xCellCount - 1, Math.floor(a * this.xScale))
                );
              }
              _convertToYCellCoord(a) {
                return Math.max(
                  0,
                  Math.min(this.yCellCount - 1, Math.floor(a * this.yScale))
                );
              }
              _circlesCollide(a, u, g, v, b, D) {
                const S = v - a,
                  M = b - u,
                  R = g + D;
                return R * R > S * S + M * M;
              }
              _circleAndRectCollide(a, u, g, v, b, D, S) {
                const M = (D - v) / 2,
                  R = Math.abs(a - (v + M));
                if (R > M + g) return !1;
                const k = (S - b) / 2,
                  z = Math.abs(u - (b + k));
                if (z > k + g) return !1;
                if (R <= M || z <= k) return !0;
                const H = R - M,
                  q = z - k;
                return H * H + q * q <= g * g;
              }
            }
            const us_unknown = 0,
              us_flipRequired = 1,
              us_flipNotRequired = 2,
              pc = Math.tan((85 * Math.PI) / 180);
            function Ae(f, a, u, g, v, b, D) {
              const S = d.create();
              if (u)
                if ("globe" === b.name) {
                  const M = d.calculateGlobeLabelMatrix(v, a);
                  d.multiply(S, S, M);
                } else {
                  const M = nt([], D);
                  (S[0] = M[0]),
                    (S[1] = M[1]),
                    (S[4] = M[2]),
                    (S[5] = M[3]),
                    g || d.rotateZ(S, S, v.angle);
                }
              else d.multiply(S, v.labelPlaneMatrix, f);
              return S;
            }
            function Vo(f, a, u, g, v, b, D) {
              const S = Ae(f, a, u, g, v, b, D);
              return (
                ("globe" === b.name && u) || (S[2] = S[6] = S[10] = S[14] = 0),
                S
              );
            }
            function mi(f, a, u, g, v, b, D) {
              if (u) {
                if ("globe" === b.name) {
                  const S = Ae(f, a, u, g, v, b, D);
                  return d.invert(S, S), d.multiply(S, f, S), S;
                }
                {
                  const S = d.clone(f),
                    M = d.identity([]);
                  return (
                    (M[0] = D[0]),
                    (M[1] = D[1]),
                    (M[4] = D[2]),
                    (M[5] = D[3]),
                    d.multiply(S, S, M),
                    g || d.rotateZ(S, S, -v.angle),
                    S
                  );
                }
              }
              return v.glCoordMatrix;
            }
            function Bi(f, a, u, g) {
              const v = [f, a, u, 1];
              u ? d.transformMat4$1(v, v, g) : it(v, v, g);
              const b = v[3];
              return (v[0] /= b), (v[1] /= b), (v[2] /= b), v;
            }
            function sp(f, a) {
              return Math.min(0.5 + (f / a) * 0.5, 1.5);
            }
            function jo(f, a) {
              const u = f[0] / f[3],
                g = f[1] / f[3];
              return u >= -a[0] && u <= a[0] && g >= -a[1] && g <= a[1];
            }
            function Mh(f, a, u, g, v, b, D, S, M, R) {
              const k = u.transform,
                z = g ? f.textSizeData : f.iconSizeData,
                H = d.evaluateSizeForZoom(z, u.transform.zoom),
                q = "globe" === k.projection.name,
                X = [(256 / u.width) * 2 + 1, (256 / u.height) * 2 + 1],
                Z = g
                  ? f.text.dynamicLayoutVertexArray
                  : f.icon.dynamicLayoutVertexArray;
              Z.clear();
              let Y = null;
              q &&
                (Y = g
                  ? f.text.globeExtVertexArray
                  : f.icon.globeExtVertexArray);
              const B = f.lineVertexArray,
                W = g ? f.text.placedSymbolArray : f.icon.placedSymbolArray,
                ee = u.transform.width / u.transform.height;
              let te,
                he = !1;
              for (let de = 0; de < W.length; de++) {
                const ue = W.get(de),
                  { numGlyphs: _e, writingMode: ge } = ue;
                if (
                  (ge !== d.WritingMode.vertical ||
                    he ||
                    te === d.WritingMode.horizontal ||
                    (he = !0),
                  (te = ge),
                  (ue.hidden || ge === d.WritingMode.vertical) && !he)
                ) {
                  Pr(_e, Z);
                  continue;
                }
                he = !1;
                const Te = new d.Point(ue.tileAnchorX, ue.tileAnchorY);
                let {
                  x: Ge,
                  y: be,
                  z: Le,
                } = k.projection.projectTilePoint(Te.x, Te.y, R.canonical);
                if (M) {
                  const [It, dt, Dt] = M(Te);
                  (Ge += It), (be += dt), (Le += Dt);
                }
                const Se = [Ge, be, Le, 1];
                if ((d.transformMat4$1(Se, Se, a), !jo(Se, X))) {
                  Pr(_e, Z);
                  continue;
                }
                const je = sp(u.transform.cameraToCenterDistance, Se[3]),
                  we = d.evaluateSizeForFeature(z, H, ue),
                  ke = D ? we / je : we * je,
                  He = Bi(Ge, be, Le, v);
                if (He[3] <= 0) {
                  Pr(_e, Z);
                  continue;
                }
                let Ne = {};
                const Xe = D ? null : M,
                  mt = ot(
                    ue,
                    ke,
                    !1,
                    S,
                    a,
                    v,
                    b,
                    f.glyphOffsetArray,
                    B,
                    Z,
                    Y,
                    He,
                    Te,
                    Ne,
                    ee,
                    Xe,
                    k.projection,
                    R,
                    D
                  );
                (he = mt.useVertical),
                  Xe && mt.needsFlipping && (Ne = {}),
                  (mt.notEnoughRoom ||
                    he ||
                    (mt.needsFlipping &&
                      ot(
                        ue,
                        ke,
                        !0,
                        S,
                        a,
                        v,
                        b,
                        f.glyphOffsetArray,
                        B,
                        Z,
                        Y,
                        He,
                        Te,
                        Ne,
                        ee,
                        Xe,
                        k.projection,
                        R,
                        D
                      ).notEnoughRoom)) &&
                    Pr(_e, Z);
              }
              g
                ? (f.text.dynamicLayoutVertexBuffer.updateData(Z),
                  Y && f.text.globeExtVertexBuffer.updateData(Y))
                : (f.icon.dynamicLayoutVertexBuffer.updateData(Z),
                  Y && f.icon.globeExtVertexBuffer.updateData(Y));
            }
            function gu(f, a, u, g, v, b, D, S, M, R, k, z, H, q, X, Z) {
              const { lineStartIndex: Y, glyphStartIndex: B, segment: W } = S,
                ee = B + S.numGlyphs,
                te = Y + S.lineLength,
                he = a.getoffsetX(B),
                de = a.getoffsetX(ee - 1),
                ue = Hr(
                  f * he,
                  u,
                  g,
                  v,
                  b,
                  D,
                  W,
                  Y,
                  te,
                  M,
                  R,
                  k,
                  z,
                  H,
                  !0,
                  q,
                  X,
                  Z
                );
              if (!ue) return null;
              const _e = Hr(
                f * de,
                u,
                g,
                v,
                b,
                D,
                W,
                Y,
                te,
                M,
                R,
                k,
                z,
                H,
                !0,
                q,
                X,
                Z
              );
              return _e ? { first: ue, last: _e } : null;
            }
            function Dn(f, a, u, g) {
              return f === d.WritingMode.horizontal && Math.abs(g) > Math.abs(u)
                ? { useVertical: !0 }
                : f === d.WritingMode.vertical
                ? g > 0
                  ? { needsFlipping: !0 }
                  : null
                : a !== us_unknown && (0 === (v = u) || Math.abs(g / v) > pc)
                ? a === us_flipRequired
                  ? { needsFlipping: !0 }
                  : null
                : u < 0
                ? { needsFlipping: !0 }
                : null;
              var v;
            }
            function ot(
              f,
              a,
              u,
              g,
              v,
              b,
              D,
              S,
              M,
              R,
              k,
              z,
              H,
              q,
              X,
              Z,
              Y,
              B,
              W
            ) {
              const ee = a / 24,
                te = f.lineOffsetX * ee,
                he = f.lineOffsetY * ee,
                {
                  lineStartIndex: de,
                  glyphStartIndex: ue,
                  numGlyphs: _e,
                  segment: ge,
                  writingMode: Te,
                  flipState: Ge,
                } = f,
                be = de + f.lineLength,
                Le = (Se) => {
                  if (k) {
                    const [He, Ne, Xe] = Se.up,
                      mt = R.length;
                    d.updateGlobeVertexNormal(k, mt + 0, He, Ne, Xe),
                      d.updateGlobeVertexNormal(k, mt + 1, He, Ne, Xe),
                      d.updateGlobeVertexNormal(k, mt + 2, He, Ne, Xe),
                      d.updateGlobeVertexNormal(k, mt + 3, He, Ne, Xe);
                  }
                  const [je, we, ke] = Se.point;
                  d.addDynamicAttributes(R, je, we, ke, Se.angle);
                };
              if (_e > 1) {
                const Se = gu(
                  ee,
                  S,
                  te,
                  he,
                  u,
                  z,
                  H,
                  f,
                  M,
                  b,
                  q,
                  Z,
                  !1,
                  Y,
                  B,
                  W
                );
                if (!Se) return { notEnoughRoom: !0 };
                if (g && !u) {
                  let [je, we, ke] = Se.first.point,
                    [He, Ne, Xe] = Se.last.point;
                  ([je, we] = Bi(je, we, ke, D)),
                    ([He, Ne] = Bi(He, Ne, Xe, D));
                  const mt = Dn(Te, Ge, (He - je) * X, Ne - we);
                  if (
                    ((f.flipState =
                      mt && mt.needsFlipping
                        ? us_flipRequired
                        : us_flipNotRequired),
                    mt)
                  )
                    return mt;
                }
                Le(Se.first);
                for (let je = ue + 1; je < ue + _e - 1; je++) {
                  const we = Hr(
                    ee * S.getoffsetX(je),
                    te,
                    he,
                    u,
                    z,
                    H,
                    ge,
                    de,
                    be,
                    M,
                    b,
                    q,
                    Z,
                    !1,
                    !1,
                    Y,
                    B,
                    W
                  );
                  if (!we)
                    return (R.length -= 4 * (je - ue)), { notEnoughRoom: !0 };
                  Le(we);
                }
                Le(Se.last);
              } else {
                if (g && !u) {
                  const je = Bi(H.x, H.y, 0, v),
                    we = de + ge + 1,
                    ke = new d.Point(M.getx(we), M.gety(we)),
                    He = Bi(ke.x, ke.y, 0, v),
                    Ne =
                      He[3] > 0
                        ? He
                        : $t(H, ke, je, 1, v, void 0, Y, B.canonical),
                    Xe = Dn(Te, Ge, (Ne[0] - je[0]) * X, Ne[1] - je[1]);
                  if (
                    ((f.flipState =
                      Xe && Xe.needsFlipping
                        ? us_flipRequired
                        : us_flipNotRequired),
                    Xe)
                  )
                    return Xe;
                }
                const Se = Hr(
                  ee * S.getoffsetX(ue),
                  te,
                  he,
                  u,
                  z,
                  H,
                  ge,
                  de,
                  be,
                  M,
                  b,
                  q,
                  Z,
                  !1,
                  !1,
                  Y,
                  B,
                  W
                );
                if (!Se) return { notEnoughRoom: !0 };
                Le(Se);
              }
              return {};
            }
            function xt(f, a, u, g, v) {
              const { x: b, y: D, z: S } = g.projectTilePoint(f.x, f.y, a);
              if (!v) return Bi(b, D, S, u);
              const [M, R, k] = v(f);
              return Bi(b + M, D + R, S + k, u);
            }
            function $t(f, a, u, g, v, b, D, S) {
              const M = xt(f.sub(a)._unit()._add(f), S, v, D, b);
              return (
                d.sub(M, u, M), d.normalize(M, M), d.scaleAndAdd(M, u, M, g)
              );
            }
            function Hr(f, a, u, g, v, b, D, S, M, R, k, z, H, q, X, Z, Y, B) {
              const W = g ? f - a : f + a;
              let ee = W > 0 ? 1 : -1,
                te = 0;
              g && ((ee *= -1), (te = Math.PI)), ee < 0 && (te += Math.PI);
              let he = (S + D + (ee > 0 ? 0 : 1)) | 0,
                de = v,
                ue = v,
                _e = 0,
                ge = 0;
              const Te = Math.abs(W),
                Ge = [],
                be = [];
              let Le = b,
                Se = Le;
              const je = () =>
                $t(Se, Le, ue, Te - _e + 1, k, H, Z, Y.canonical);
              for (; _e + ge <= Te; ) {
                if (((he += ee), he < S || he >= M)) return null;
                if (
                  ((ue = de),
                  (Se = Le),
                  Ge.push(ue),
                  q && be.push(Se),
                  (Le = new d.Point(R.getx(he), R.gety(he))),
                  (de = z[he]),
                  !de)
                ) {
                  const Dt = xt(Le, Y.canonical, k, Z, H);
                  de = Dt[3] > 0 ? (z[he] = Dt) : je();
                }
                (_e += ge), (ge = d.distance(ue, de));
              }
              X &&
                H &&
                (z[he] && ((de = je()), (ge = d.distance(ue, de))),
                (z[he] = de));
              const we = (Te - _e) / ge,
                ke = Le.sub(Se)._mult(we)._add(Se),
                He = d.sub([], de, ue),
                Ne = d.scaleAndAdd([], ue, He, we);
              let Xe = [0, 0, 1],
                mt = He[0],
                It = He[1];
              if (
                B &&
                ((Xe = Z.upVector(Y.canonical, ke.x, ke.y)),
                0 !== Xe[0] || 0 !== Xe[1] || 1 !== Xe[2])
              ) {
                const Dt = [Xe[2], 0, -Xe[0]],
                  Kt = d.cross([], Xe, Dt);
                d.normalize(Dt, Dt),
                  d.normalize(Kt, Kt),
                  (mt = d.dot(He, Dt)),
                  (It = d.dot(He, Kt));
              }
              if (u) {
                const Dt = d.cross([], Xe, He);
                d.normalize(Dt, Dt), d.scaleAndAdd(Ne, Ne, Dt, u * ee);
              }
              const dt = te + Math.atan2(It, mt);
              return (
                Ge.push(Ne),
                q && be.push(ke),
                { point: Ne, angle: dt, path: Ge, tilePath: be, up: Xe }
              );
            }
            function Pr(f, a) {
              const u = a.length,
                g = u + 4 * f;
              a.resize(g), a.float32.fill(-1 / 0, 4 * u, 4 * g);
            }
            function it(f, a, u) {
              const g = a[0],
                v = a[1];
              return (
                (f[0] = u[0] * g + u[4] * v + u[12]),
                (f[1] = u[1] * g + u[5] * v + u[13]),
                (f[3] = u[3] * g + u[7] * v + u[15]),
                f
              );
            }
            const _r = 100;
            class _u {
              constructor(
                a,
                u,
                g = new Ra(a.width + 200, a.height + 200, 25),
                v = new Ra(a.width + 200, a.height + 200, 25)
              ) {
                (this.transform = a),
                  (this.grid = g),
                  (this.ignoredGrid = v),
                  (this.pitchfactor =
                    Math.cos(a._pitch) * a.cameraToCenterDistance),
                  (this.screenRightBoundary = a.width + _r),
                  (this.screenBottomBoundary = a.height + _r),
                  (this.gridRightBoundary = a.width + 200),
                  (this.gridBottomBoundary = a.height + 200),
                  (this.fogState = u);
              }
              placeCollisionBox(a, u, g, v, b, D, S, M) {
                let R = g.projectedAnchorX,
                  k = g.projectedAnchorY,
                  z = g.projectedAnchorZ;
                const H = g.elevation,
                  q = g.tileID,
                  X = a.getProjection();
                if (H && q) {
                  const [de, ue, _e] = X.upVector(
                      q.canonical,
                      g.tileAnchorX,
                      g.tileAnchorY
                    ),
                    ge = X.upVectorScale(
                      q.canonical,
                      this.transform.center.lat,
                      this.transform.worldSize
                    ).metersToTile;
                  (R += de * H * ge), (k += ue * H * ge), (z += _e * H * ge);
                }
                const Z = this.projectAndGetPerspectiveRatio(
                    S,
                    R,
                    k,
                    z,
                    g.tileID,
                    "globe" === X.name || !!H || this.transform.pitch > 0,
                    X
                  ),
                  Y = D * Z.perspectiveRatio,
                  B = (g.x1 * u + v.x - g.padding) * Y + Z.point.x,
                  W = (g.y1 * u + v.y - g.padding) * Y + Z.point.y,
                  ee = (g.x2 * u + v.x + g.padding) * Y + Z.point.x,
                  te = (g.y2 * u + v.y + g.padding) * Y + Z.point.y,
                  he = Z.perspectiveRatio <= 0.55 || Z.occluded;
                return !this.isInsideGrid(B, W, ee, te) ||
                  (!b && this.grid.hitTest(B, W, ee, te, M)) ||
                  he
                  ? { box: [], offscreen: !1, occluded: Z.occluded }
                  : {
                      box: [B, W, ee, te],
                      offscreen: this.isOffscreen(B, W, ee, te),
                      occluded: !1,
                    };
              }
              placeCollisionCircles(
                a,
                u,
                g,
                v,
                b,
                D,
                S,
                M,
                R,
                k,
                z,
                H,
                q,
                X,
                Z
              ) {
                const Y = [],
                  B = this.transform.elevation,
                  W = a.getProjection(),
                  ee = B
                    ? B.getAtTileOffsetFunc(
                        Z,
                        this.transform.center.lat,
                        this.transform.worldSize,
                        W
                      )
                    : null,
                  te = new d.Point(g.tileAnchorX, g.tileAnchorY);
                let {
                  x: he,
                  y: de,
                  z: ue,
                } = W.projectTilePoint(te.x, te.y, Z.canonical);
                if (ee) {
                  const [ke, He, Ne] = ee(te);
                  (he += ke), (de += He), (ue += Ne);
                }
                const _e = "globe" === W.name,
                  ge = this.projectAndGetPerspectiveRatio(
                    S,
                    he,
                    de,
                    ue,
                    Z,
                    _e || !!B || this.transform.pitch > 0,
                    W
                  ),
                  { perspectiveRatio: Te } = ge,
                  Ge = (z ? D / Te : D * Te) / d.ONE_EM,
                  be = Bi(he, de, ue, M),
                  Le =
                    ge.signedDistanceFromCamera > 0
                      ? gu(
                          Ge,
                          b,
                          g.lineOffsetX * Ge,
                          g.lineOffsetY * Ge,
                          !1,
                          be,
                          te,
                          g,
                          v,
                          M,
                          {},
                          B && !z ? ee : null,
                          z && !!B,
                          W,
                          Z,
                          z
                        )
                      : null;
                let Se = !1,
                  je = !1,
                  we = !0;
                if (Le && !ge.occluded) {
                  const ke = 0.5 * q * Te + X,
                    He = new d.Point(-100, -100),
                    Ne = new d.Point(
                      this.screenRightBoundary,
                      this.screenBottomBoundary
                    ),
                    Xe = new mu(),
                    { first: mt, last: It } = Le,
                    dt = mt.path.length;
                  let Dt = [];
                  for (let _t = dt - 1; _t >= 1; _t--) Dt.push(mt.path[_t]);
                  for (let _t = 1; _t < It.path.length; _t++)
                    Dt.push(It.path[_t]);
                  const Kt = 2.5 * ke;
                  R &&
                    ((Dt = Dt.map(
                      ([_t, en, On], _n) => (
                        ee &&
                          !_e &&
                          (On = ee(
                            _n < dt - 1
                              ? mt.tilePath[dt - 1 - _n]
                              : It.tilePath[_n - dt + 2]
                          )[2]),
                        Bi(_t, en, On, R)
                      )
                    )),
                    Dt.some((_t) => _t[3] <= 0) && (Dt = []));
                  let Ht = [];
                  if (Dt.length > 0) {
                    let _t = 1 / 0,
                      en = -1 / 0,
                      On = 1 / 0,
                      _n = -1 / 0;
                    for (const Sn of Dt)
                      (_t = Math.min(_t, Sn[0])),
                        (On = Math.min(On, Sn[1])),
                        (en = Math.max(en, Sn[0])),
                        (_n = Math.max(_n, Sn[1]));
                    en >= He.x &&
                      _t <= Ne.x &&
                      _n >= He.y &&
                      On <= Ne.y &&
                      ((Ht = [Dt.map((Sn) => new d.Point(Sn[0], Sn[1]))]),
                      (_t < He.x || en > Ne.x || On < He.y || _n > Ne.y) &&
                        (Ht = d.clipLine(Ht, He.x, He.y, Ne.x, Ne.y)));
                  }
                  for (const _t of Ht) {
                    Xe.reset(_t, 0.25 * ke);
                    let en = 0;
                    en =
                      Xe.length <= 0.5 * ke
                        ? 1
                        : Math.ceil(Xe.paddedLength / Kt) + 1;
                    for (let On = 0; On < en; On++) {
                      const _n = On / Math.max(en - 1, 1),
                        Sn = Xe.lerp(_n),
                        Hi = Sn.x + _r,
                        vi = Sn.y + _r;
                      Y.push(Hi, vi, ke, 0);
                      const Er = Hi - ke,
                        Ko = vi - ke,
                        Hn = Hi + ke,
                        Pn = vi + ke;
                      if (
                        ((we = we && this.isOffscreen(Er, Ko, Hn, Pn)),
                        (je = je || this.isInsideGrid(Er, Ko, Hn, Pn)),
                        !u &&
                          this.grid.hitTestCircle(Hi, vi, ke, H) &&
                          ((Se = !0), !k))
                      )
                        return {
                          circles: [],
                          offscreen: !1,
                          collisionDetected: Se,
                          occluded: !1,
                        };
                    }
                  }
                }
                return {
                  circles: (!k && Se) || !je ? [] : Y,
                  offscreen: we,
                  collisionDetected: Se,
                  occluded: ge.occluded,
                };
              }
              queryRenderedSymbols(a) {
                if (
                  0 === a.length ||
                  (0 === this.grid.keysLength() &&
                    0 === this.ignoredGrid.keysLength())
                )
                  return {};
                const u = [];
                let g = 1 / 0,
                  v = 1 / 0,
                  b = -1 / 0,
                  D = -1 / 0;
                for (const k of a) {
                  const z = new d.Point(k.x + _r, k.y + _r);
                  (g = Math.min(g, z.x)),
                    (v = Math.min(v, z.y)),
                    (b = Math.max(b, z.x)),
                    (D = Math.max(D, z.y)),
                    u.push(z);
                }
                const S = this.grid
                    .query(g, v, b, D)
                    .concat(this.ignoredGrid.query(g, v, b, D)),
                  M = {},
                  R = {};
                for (const k of S) {
                  const z = k.key;
                  if (
                    (void 0 === M[z.bucketInstanceId] &&
                      (M[z.bucketInstanceId] = {}),
                    M[z.bucketInstanceId][z.featureIndex])
                  )
                    continue;
                  const H = [
                    new d.Point(k.x1, k.y1),
                    new d.Point(k.x2, k.y1),
                    new d.Point(k.x2, k.y2),
                    new d.Point(k.x1, k.y2),
                  ];
                  d.polygonIntersectsPolygon(u, H) &&
                    ((M[z.bucketInstanceId][z.featureIndex] = !0),
                    void 0 === R[z.bucketInstanceId] &&
                      (R[z.bucketInstanceId] = []),
                    R[z.bucketInstanceId].push(z.featureIndex));
                }
                return R;
              }
              insertCollisionBox(a, u, g, v, b) {
                (u ? this.ignoredGrid : this.grid).insert(
                  { bucketInstanceId: g, featureIndex: v, collisionGroupID: b },
                  a[0],
                  a[1],
                  a[2],
                  a[3]
                );
              }
              insertCollisionCircles(a, u, g, v, b) {
                const D = u ? this.ignoredGrid : this.grid,
                  S = {
                    bucketInstanceId: g,
                    featureIndex: v,
                    collisionGroupID: b,
                  };
                for (let M = 0; M < a.length; M += 4)
                  D.insertCircle(S, a[M], a[M + 1], a[M + 2]);
              }
              projectAndGetPerspectiveRatio(a, u, g, v, b, D, S) {
                const M = [u, g, v, 1];
                let R = !1;
                v || this.transform.pitch > 0
                  ? (d.transformMat4$1(M, M, a),
                    this.fogState &&
                      b &&
                      "globe" !== S.name &&
                      (R =
                        (function (H, q, X, Z, Y, B) {
                          const W = B.calculateFogTileMatrix(Y),
                            ee = [q, X, Z];
                          return (
                            d.transformMat4(ee, ee, W),
                            Ia(H, ee, B.pitch, B._fov)
                          );
                        })(
                          this.fogState,
                          u,
                          g,
                          v,
                          b.toUnwrapped(),
                          this.transform
                        ) > 0.9))
                  : it(M, M, a);
                const k = M[3];
                return {
                  point: new d.Point(
                    ((M[0] / k + 1) / 2) * this.transform.width + _r,
                    ((-M[1] / k + 1) / 2) * this.transform.height + _r
                  ),
                  perspectiveRatio: Math.min(
                    0.5 +
                      (this.transform.getCameraToCenterDistance(S) / k) * 0.5,
                    1.5
                  ),
                  signedDistanceFromCamera: k,
                  occluded: (D && M[2] > k) || R,
                };
              }
              isOffscreen(a, u, g, v) {
                return (
                  g < _r ||
                  a >= this.screenRightBoundary ||
                  v < _r ||
                  u > this.screenBottomBoundary
                );
              }
              isInsideGrid(a, u, g, v) {
                return (
                  g >= 0 &&
                  a < this.gridRightBoundary &&
                  v >= 0 &&
                  u < this.gridBottomBoundary
                );
              }
              getViewportMatrix() {
                const a = d.identity([]);
                return d.translate(a, a, [-100, -100, 0]), a;
              }
            }
            function st(f, a, u) {
              const g = a.createTileMatrix(f, f.worldSize, u.toUnwrapped());
              return d.multiply(new Float32Array(16), f.projMatrix, g);
            }
            function yr(f, a, u) {
              if (a.projection.name === u.projection.name) return f.projMatrix;
              const g = u.clone();
              return g.setProjection(a.projection), st(g, a.getProjection(), f);
            }
            function gt(f, a, u) {
              return a.name === u.projection.name ? f.projMatrix : st(u, a, f);
            }
            class Cn {
              constructor(a, u, g, v) {
                (this.opacity = a
                  ? Math.max(0, Math.min(1, a.opacity + (a.placed ? u : -u)))
                  : v && g
                  ? 1
                  : 0),
                  (this.placed = g);
              }
              isHidden() {
                return 0 === this.opacity && !this.placed;
              }
            }
            class hs {
              constructor(a, u, g, v, b, D = !1) {
                (this.text = new Cn(a ? a.text : null, u, g, b)),
                  (this.icon = new Cn(a ? a.icon : null, u, v, b)),
                  (this.clipped = D);
              }
              isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
              }
            }
            class yu {
              constructor(a, u, g, v = !1) {
                (this.text = a),
                  (this.icon = u),
                  (this.skipFade = g),
                  (this.clipped = v);
              }
            }
            class fc {
              constructor() {
                (this.invProjMatrix = d.create()),
                  (this.viewportMatrix = d.create()),
                  (this.circles = []);
              }
            }
            class Dl {
              constructor(a, u, g, v, b) {
                (this.bucketInstanceId = a),
                  (this.featureIndex = u),
                  (this.sourceLayerIndex = g),
                  (this.bucketIndex = v),
                  (this.tileID = b);
              }
            }
            class Lr {
              constructor(a) {
                (this.crossSourceCollisions = a),
                  (this.maxGroupID = 0),
                  (this.collisionGroups = {});
              }
              get(a) {
                if (this.crossSourceCollisions)
                  return { ID: 0, predicate: null };
                if (!this.collisionGroups[a]) {
                  const u = ++this.maxGroupID;
                  this.collisionGroups[a] = {
                    ID: u,
                    predicate: (g) => g.collisionGroupID === u,
                  };
                }
                return this.collisionGroups[a];
              }
            }
            function vu(f, a, u, g, v) {
              const { horizontalAlign: b, verticalAlign: D } =
                  d.getAnchorAlignment(f),
                S = -(b - 0.5) * a,
                M = -(D - 0.5) * u,
                R = d.evaluateVariableOffset(f, g);
              return new d.Point(S + R[0] * v, M + R[1] * v);
            }
            function mc(f, a, u, g, v) {
              const b = new d.Point(f, a);
              return u && b._rotate(g ? v : -v), b;
            }
            class Ah {
              constructor(a, u, g, v, b) {
                (this.transform = a.clone()),
                  (this.projection = a.projection.name),
                  (this.collisionIndex = new _u(this.transform, b)),
                  (this.placements = {}),
                  (this.opacities = {}),
                  (this.variableOffsets = {}),
                  (this.stale = !1),
                  (this.commitTime = 0),
                  (this.fadeDuration = u),
                  (this.retainedQueryData = {}),
                  (this.collisionGroups = new Lr(g)),
                  (this.collisionCircleArrays = {}),
                  (this.prevPlacement = v),
                  v && (v.prevPlacement = void 0),
                  (this.placedOrientations = {});
              }
              getBucketParts(a, u, g, v) {
                const b = g.getBucket(u),
                  D = g.latestFeatureIndex;
                if (!b || !D || u.id !== b.layerIds[0]) return;
                const S = b.layers[0].layout,
                  M = g.collisionBoxArray,
                  R = Math.pow(2, this.transform.zoom - g.tileID.overscaledZ),
                  k = g.tileSize / d.EXTENT,
                  z = g.tileID.toUnwrapped();
                this.transform.setProjection(b.projection);
                const H =
                  ((q = g.tileID),
                  (X = b.getProjection()),
                  (Z = this.transform),
                  X.name === this.projection
                    ? Z.calculateProjMatrix(q.toUnwrapped())
                    : st(Z, X, q));
                var q, X, Z;
                const Y = "map" === S.get("text-pitch-alignment"),
                  B = "map" === S.get("text-rotation-alignment");
                u.compileFilter();
                const W = u.dynamicFilter(),
                  ee = u.dynamicFilterNeedsFeature(),
                  te = this.transform.calculatePixelsToTileUnitsMatrix(g),
                  he = Vo(
                    H,
                    g.tileID.canonical,
                    Y,
                    B,
                    this.transform,
                    b.getProjection(),
                    te
                  );
                let de = null;
                if (Y) {
                  const ge = mi(
                    H,
                    g.tileID.canonical,
                    Y,
                    B,
                    this.transform,
                    b.getProjection(),
                    te
                  );
                  de = d.multiply([], this.transform.labelPlaneMatrix, ge);
                }
                let ue = null;
                W &&
                  g.latestFeatureIndex &&
                  (ue = {
                    unwrappedTileID: z,
                    dynamicFilter: W,
                    dynamicFilterNeedsFeature: ee,
                    featureIndex: g.latestFeatureIndex,
                  }),
                  (this.retainedQueryData[b.bucketInstanceId] = new Dl(
                    b.bucketInstanceId,
                    D,
                    b.sourceLayerIndex,
                    b.index,
                    g.tileID
                  ));
                const _e = {
                  bucket: b,
                  layout: S,
                  posMatrix: H,
                  textLabelPlaneMatrix: he,
                  labelToScreenMatrix: de,
                  clippingData: ue,
                  scale: R,
                  textPixelRatio: k,
                  holdingForFade: g.holdingForFade(),
                  collisionBoxArray: M,
                  partiallyEvaluatedTextSize: d.evaluateSizeForZoom(
                    b.textSizeData,
                    this.transform.zoom
                  ),
                  partiallyEvaluatedIconSize: d.evaluateSizeForZoom(
                    b.iconSizeData,
                    this.transform.zoom
                  ),
                  collisionGroup: this.collisionGroups.get(b.sourceID),
                };
                if (v)
                  for (const ge of b.sortKeyRanges) {
                    const {
                      sortKey: Te,
                      symbolInstanceStart: Ge,
                      symbolInstanceEnd: be,
                    } = ge;
                    a.push({
                      sortKey: Te,
                      symbolInstanceStart: Ge,
                      symbolInstanceEnd: be,
                      parameters: _e,
                    });
                  }
                else
                  a.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: b.symbolInstances.length,
                    parameters: _e,
                  });
              }
              attemptAnchorPlacement(
                a,
                u,
                g,
                v,
                b,
                D,
                S,
                M,
                R,
                k,
                z,
                H,
                q,
                X,
                Z,
                Y,
                B,
                W
              ) {
                const { textOffset0: ee, textOffset1: te, crossTileID: he } = H,
                  de = [ee, te],
                  ue = vu(a, g, v, de, b),
                  _e = this.collisionIndex.placeCollisionBox(
                    X,
                    b,
                    u,
                    mc(ue.x, ue.y, D, S, this.transform.angle),
                    z,
                    M,
                    R,
                    k.predicate
                  );
                if (Y) {
                  const ge = X.getSymbolInstanceIconSize(
                    W,
                    this.transform.zoom,
                    H.placedIconSymbolIndex
                  );
                  if (
                    0 ===
                    this.collisionIndex.placeCollisionBox(
                      X,
                      ge,
                      Y,
                      mc(ue.x, ue.y, D, S, this.transform.angle),
                      z,
                      M,
                      R,
                      k.predicate
                    ).box.length
                  )
                    return;
                }
                if (_e.box.length > 0) {
                  let ge;
                  return (
                    this.prevPlacement &&
                      this.prevPlacement.variableOffsets[he] &&
                      this.prevPlacement.placements[he] &&
                      this.prevPlacement.placements[he].text &&
                      (ge = this.prevPlacement.variableOffsets[he].anchor),
                    (this.variableOffsets[he] = {
                      textOffset: de,
                      width: g,
                      height: v,
                      anchor: a,
                      textScale: b,
                      prevAnchor: ge,
                    }),
                    this.markUsedJustification(X, a, H, Z),
                    X.allowVerticalPlacement &&
                      (this.markUsedOrientation(X, Z, H),
                      (this.placedOrientations[he] = Z)),
                    { shift: ue, placedGlyphBoxes: _e }
                  );
                }
              }
              placeLayerBucketPart(a, u, g, v) {
                const {
                    bucket: b,
                    layout: D,
                    posMatrix: S,
                    textLabelPlaneMatrix: M,
                    labelToScreenMatrix: R,
                    clippingData: k,
                    textPixelRatio: z,
                    holdingForFade: H,
                    collisionBoxArray: q,
                    partiallyEvaluatedTextSize: X,
                    partiallyEvaluatedIconSize: Z,
                    collisionGroup: Y,
                  } = a.parameters,
                  B = D.get("text-optional"),
                  W = D.get("icon-optional"),
                  ee = D.get("text-allow-overlap"),
                  te = D.get("icon-allow-overlap"),
                  he = "map" === D.get("text-rotation-alignment"),
                  de = "map" === D.get("text-pitch-alignment"),
                  ue = "none" !== D.get("icon-text-fit"),
                  _e = "viewport-y" === D.get("symbol-z-order");
                this.transform.setProjection(b.projection);
                let ge = ee && (te || !b.hasIconData() || W),
                  Te = te && (ee || !b.hasTextData() || B);
                !b.collisionArrays && q && b.deserializeCollisionBoxes(q),
                  g &&
                    v &&
                    b.updateCollisionDebugBuffers(this.transform.zoom, q);
                const Ge = (be, Le, Se) => {
                  const { crossTileID: je, numVerticalGlyphVertices: we } = be;
                  if (k) {
                    const Hn = {
                      zoom: this.transform.zoom,
                      pitch: this.transform.pitch,
                    };
                    let Pn = null;
                    if (k.dynamicFilterNeedsFeature) {
                      const hn = this.retainedQueryData[b.bucketInstanceId];
                      Pn = k.featureIndex.loadFeature({
                        featureIndex: be.featureIndex,
                        bucketIndex: hn.bucketIndex,
                        sourceLayerIndex: hn.sourceLayerIndex,
                        layoutVertexArrayOffset: 0,
                      });
                    }
                    if (
                      !(0, k.dynamicFilter)(
                        Hn,
                        Pn,
                        this.retainedQueryData[b.bucketInstanceId].tileID
                          .canonical,
                        new d.Point(be.tileAnchorX, be.tileAnchorY),
                        this.transform.calculateDistanceTileData(
                          k.unwrappedTileID
                        )
                      )
                    )
                      return (
                        (this.placements[je] = new yu(!1, !1, !1, !0)),
                        void u.add(je)
                      );
                  }
                  if (u.has(je)) return;
                  if (H) return void (this.placements[je] = new yu(!1, !1, !1));
                  let ke = !1,
                    He = !1,
                    Ne = !0,
                    Xe = !1,
                    mt = !1,
                    It = null,
                    dt = { box: null, offscreen: null, occluded: null },
                    Dt = { box: null, offscreen: null, occluded: null },
                    Kt = null,
                    Ht = null,
                    _t = null,
                    en = 0,
                    On = 0,
                    _n = 0;
                  Se.textFeatureIndex
                    ? (en = Se.textFeatureIndex)
                    : be.useRuntimeCollisionCircles && (en = be.featureIndex),
                    Se.verticalTextFeatureIndex &&
                      (On = Se.verticalTextFeatureIndex);
                  const Sn = (Hn) => {
                      Hn.tileID =
                        this.retainedQueryData[b.bucketInstanceId].tileID;
                      const Pn = this.transform.elevation;
                      (Pn || Hn.elevation) &&
                        (Hn.elevation = Pn
                          ? Pn.getAtTileOffset(
                              Hn.tileID,
                              Hn.tileAnchorX,
                              Hn.tileAnchorY
                            )
                          : 0);
                    },
                    Hi = Se.textBox;
                  if (Hi) {
                    Sn(Hi);
                    const Hn = (hn) => {
                        let si = d.WritingMode.horizontal;
                        if (
                          b.allowVerticalPlacement &&
                          !hn &&
                          this.prevPlacement
                        ) {
                          const Tr = this.prevPlacement.placedOrientations[je];
                          Tr &&
                            ((this.placedOrientations[je] = Tr),
                            (si = Tr),
                            this.markUsedOrientation(b, si, be));
                        }
                        return si;
                      },
                      Pn = (hn, si) => {
                        if (
                          b.allowVerticalPlacement &&
                          we > 0 &&
                          Se.verticalTextBox
                        ) {
                          for (const Tr of b.writingModes)
                            if (
                              (Tr === d.WritingMode.vertical
                                ? ((dt = si()), (Dt = dt))
                                : (dt = hn()),
                              dt && dt.box && dt.box.length)
                            )
                              break;
                        } else dt = hn();
                      };
                    if (D.get("text-variable-anchor")) {
                      let hn = D.get("text-variable-anchor");
                      if (
                        this.prevPlacement &&
                        this.prevPlacement.variableOffsets[je]
                      ) {
                        const Fn = this.prevPlacement.variableOffsets[je];
                        hn.indexOf(Fn.anchor) > 0 &&
                          ((hn = hn.filter((Gi) => Gi !== Fn.anchor)),
                          hn.unshift(Fn.anchor));
                      }
                      const si = (Fn, Gi, zu) => {
                        const ta = b.getSymbolInstanceTextSize(
                            X,
                            be,
                            this.transform.zoom,
                            Le
                          ),
                          Bl = (Fn.x2 - Fn.x1) * ta + 2 * Fn.padding,
                          Nr = (Fn.y2 - Fn.y1) * ta + 2 * Fn.padding,
                          na = ue && !te ? Gi : null;
                        na && Sn(na);
                        let Wa = { box: [], offscreen: !1, occluded: !1 };
                        const Vl = ee ? 2 * hn.length : hn.length;
                        for (let Ac = 0; Ac < Vl; ++Ac) {
                          const Bu = this.attemptAnchorPlacement(
                            hn[Ac % hn.length],
                            Fn,
                            Bl,
                            Nr,
                            ta,
                            he,
                            de,
                            z,
                            S,
                            Y,
                            Ac >= hn.length,
                            be,
                            Le,
                            b,
                            zu,
                            na,
                            X,
                            Z
                          );
                          if (
                            Bu &&
                            ((Wa = Bu.placedGlyphBoxes),
                            Wa && Wa.box && Wa.box.length)
                          ) {
                            (ke = !0), (It = Bu.shift);
                            break;
                          }
                        }
                        return Wa;
                      };
                      Pn(
                        () => si(Hi, Se.iconBox, d.WritingMode.horizontal),
                        () => {
                          const Fn = Se.verticalTextBox;
                          return (
                            Fn && Sn(Fn),
                            b.allowVerticalPlacement &&
                            !(dt && dt.box && dt.box.length) &&
                            we > 0 &&
                            Fn
                              ? si(
                                  Fn,
                                  Se.verticalIconBox,
                                  d.WritingMode.vertical
                                )
                              : { box: null, offscreen: null, occluded: null }
                          );
                        }
                      ),
                        dt &&
                          ((ke = dt.box),
                          (Ne = dt.offscreen),
                          (Xe = dt.occluded));
                      const Tr = Hn(!(!dt || !dt.box));
                      if (!ke && this.prevPlacement) {
                        const Fn = this.prevPlacement.variableOffsets[je];
                        Fn &&
                          ((this.variableOffsets[je] = Fn),
                          this.markUsedJustification(b, Fn.anchor, be, Tr));
                      }
                    } else {
                      const hn = (si, Tr) => {
                        const Fn = b.getSymbolInstanceTextSize(
                            X,
                            be,
                            this.transform.zoom,
                            Le
                          ),
                          Gi = this.collisionIndex.placeCollisionBox(
                            b,
                            Fn,
                            si,
                            new d.Point(0, 0),
                            ee,
                            z,
                            S,
                            Y.predicate
                          );
                        return (
                          Gi &&
                            Gi.box &&
                            Gi.box.length &&
                            (this.markUsedOrientation(b, Tr, be),
                            (this.placedOrientations[je] = Tr)),
                          Gi
                        );
                      };
                      Pn(
                        () => hn(Hi, d.WritingMode.horizontal),
                        () => {
                          const si = Se.verticalTextBox;
                          return b.allowVerticalPlacement && we > 0 && si
                            ? (Sn(si), hn(si, d.WritingMode.vertical))
                            : { box: null, offscreen: null, occluded: null };
                        }
                      ),
                        Hn(!!(dt && dt.box && dt.box.length));
                    }
                  }
                  if (
                    ((Kt = dt),
                    (ke = Kt && Kt.box && Kt.box.length > 0),
                    (Ne = Kt && Kt.offscreen),
                    (Xe = Kt && Kt.occluded),
                    be.useRuntimeCollisionCircles)
                  ) {
                    const Hn = b.text.placedSymbolArray.get(
                        be.centerJustifiedTextSymbolIndex >= 0
                          ? be.centerJustifiedTextSymbolIndex
                          : be.verticalPlacedTextSymbolIndex
                      ),
                      Pn = d.evaluateSizeForFeature(b.textSizeData, X, Hn),
                      hn = D.get("text-padding");
                    (Ht = this.collisionIndex.placeCollisionCircles(
                      b,
                      ee,
                      Hn,
                      b.lineVertexArray,
                      b.glyphOffsetArray,
                      Pn,
                      S,
                      M,
                      R,
                      g,
                      de,
                      Y.predicate,
                      (be.collisionCircleDiameter * Pn) / d.ONE_EM,
                      hn,
                      this.retainedQueryData[b.bucketInstanceId].tileID
                    )),
                      (ke =
                        ee || (Ht.circles.length > 0 && !Ht.collisionDetected)),
                      (Ne = Ne && Ht.offscreen),
                      (Xe = Ht.occluded);
                  }
                  if (
                    (Se.iconFeatureIndex && (_n = Se.iconFeatureIndex),
                    Se.iconBox)
                  ) {
                    const Hn = (Pn) => {
                      Sn(Pn);
                      const hn =
                          ue && It
                            ? mc(It.x, It.y, he, de, this.transform.angle)
                            : new d.Point(0, 0),
                        si = b.getSymbolInstanceIconSize(
                          Z,
                          this.transform.zoom,
                          be.placedIconSymbolIndex
                        );
                      return this.collisionIndex.placeCollisionBox(
                        b,
                        si,
                        Pn,
                        hn,
                        te,
                        z,
                        S,
                        Y.predicate
                      );
                    };
                    Dt && Dt.box && Dt.box.length && Se.verticalIconBox
                      ? ((_t = Hn(Se.verticalIconBox)),
                        (He = _t.box.length > 0))
                      : ((_t = Hn(Se.iconBox)), (He = _t.box.length > 0)),
                      (Ne = Ne && _t.offscreen),
                      (mt = _t.occluded);
                  }
                  const vi =
                      B || (0 === be.numHorizontalGlyphVertices && 0 === we),
                    Er = W || 0 === be.numIconVertices;
                  if (
                    (vi || Er
                      ? Er
                        ? vi || (He = He && ke)
                        : (ke = He && ke)
                      : (He = ke = He && ke),
                    ke &&
                      Kt &&
                      Kt.box &&
                      this.collisionIndex.insertCollisionBox(
                        Kt.box,
                        D.get("text-ignore-placement"),
                        b.bucketInstanceId,
                        Dt && Dt.box && On ? On : en,
                        Y.ID
                      ),
                    He &&
                      _t &&
                      this.collisionIndex.insertCollisionBox(
                        _t.box,
                        D.get("icon-ignore-placement"),
                        b.bucketInstanceId,
                        _n,
                        Y.ID
                      ),
                    Ht &&
                      (ke &&
                        this.collisionIndex.insertCollisionCircles(
                          Ht.circles,
                          D.get("text-ignore-placement"),
                          b.bucketInstanceId,
                          en,
                          Y.ID
                        ),
                      g))
                  ) {
                    const Hn = b.bucketInstanceId;
                    let Pn = this.collisionCircleArrays[Hn];
                    void 0 === Pn &&
                      (Pn = this.collisionCircleArrays[Hn] = new fc());
                    for (let hn = 0; hn < Ht.circles.length; hn += 4)
                      Pn.circles.push(Ht.circles[hn + 0]),
                        Pn.circles.push(Ht.circles[hn + 1]),
                        Pn.circles.push(Ht.circles[hn + 2]),
                        Pn.circles.push(Ht.collisionDetected ? 1 : 0);
                  }
                  const Ko = "globe" !== b.projection.name;
                  (ge = ge && (Ko || !Xe)),
                    (Te = Te && (Ko || !mt)),
                    (this.placements[je] = new yu(
                      ke || ge,
                      He || Te,
                      Ne || b.justReloaded
                    )),
                    u.add(je);
                };
                if (_e) {
                  const be = b.getSortedSymbolIndexes(this.transform.angle);
                  for (let Le = be.length - 1; Le >= 0; --Le) {
                    const Se = be[Le];
                    Ge(b.symbolInstances.get(Se), Se, b.collisionArrays[Se]);
                  }
                } else for (let be = a.symbolInstanceStart; be < a.symbolInstanceEnd; be++) Ge(b.symbolInstances.get(be), be, b.collisionArrays[be]);
                if (g && b.bucketInstanceId in this.collisionCircleArrays) {
                  const be = this.collisionCircleArrays[b.bucketInstanceId];
                  d.invert(be.invProjMatrix, S),
                    (be.viewportMatrix =
                      this.collisionIndex.getViewportMatrix());
                }
                b.justReloaded = !1;
              }
              markUsedJustification(a, u, g, v) {
                const {
                    leftJustifiedTextSymbolIndex: b,
                    centerJustifiedTextSymbolIndex: D,
                    rightJustifiedTextSymbolIndex: S,
                    verticalPlacedTextSymbolIndex: M,
                    crossTileID: R,
                  } = g,
                  k = d.getAnchorJustification(u),
                  z =
                    v === d.WritingMode.vertical
                      ? M
                      : "left" === k
                      ? b
                      : "center" === k
                      ? D
                      : "right" === k
                      ? S
                      : -1;
                b >= 0 &&
                  (a.text.placedSymbolArray.get(b).crossTileID =
                    z >= 0 && b !== z ? 0 : R),
                  D >= 0 &&
                    (a.text.placedSymbolArray.get(D).crossTileID =
                      z >= 0 && D !== z ? 0 : R),
                  S >= 0 &&
                    (a.text.placedSymbolArray.get(S).crossTileID =
                      z >= 0 && S !== z ? 0 : R),
                  M >= 0 &&
                    (a.text.placedSymbolArray.get(M).crossTileID =
                      z >= 0 && M !== z ? 0 : R);
              }
              markUsedOrientation(a, u, g) {
                const v =
                    u === d.WritingMode.horizontal ||
                    u === d.WritingMode.horizontalOnly
                      ? u
                      : 0,
                  b = u === d.WritingMode.vertical ? u : 0,
                  {
                    leftJustifiedTextSymbolIndex: D,
                    centerJustifiedTextSymbolIndex: S,
                    rightJustifiedTextSymbolIndex: M,
                    verticalPlacedTextSymbolIndex: R,
                  } = g,
                  k = a.text.placedSymbolArray;
                D >= 0 && (k.get(D).placedOrientation = v),
                  S >= 0 && (k.get(S).placedOrientation = v),
                  M >= 0 && (k.get(M).placedOrientation = v),
                  R >= 0 && (k.get(R).placedOrientation = b);
              }
              commit(a) {
                (this.commitTime = a),
                  (this.zoomAtLastRecencyCheck = this.transform.zoom);
                const u = this.prevPlacement;
                let g = !1;
                this.prevZoomAdjustment = u
                  ? u.zoomAdjustment(this.transform.zoom)
                  : 0;
                const v = u ? u.symbolFadeChange(a) : 1,
                  b = u ? u.opacities : {},
                  D = u ? u.variableOffsets : {},
                  S = u ? u.placedOrientations : {};
                for (const M in this.placements) {
                  const R = this.placements[M],
                    k = b[M];
                  k
                    ? ((this.opacities[M] = new hs(
                        k,
                        v,
                        R.text,
                        R.icon,
                        null,
                        R.clipped
                      )),
                      (g =
                        g ||
                        R.text !== k.text.placed ||
                        R.icon !== k.icon.placed))
                    : ((this.opacities[M] = new hs(
                        null,
                        v,
                        R.text,
                        R.icon,
                        R.skipFade,
                        R.clipped
                      )),
                      (g = g || R.text || R.icon));
                }
                for (const M in b) {
                  const R = b[M];
                  if (!this.opacities[M]) {
                    const k = new hs(R, v, !1, !1);
                    k.isHidden() ||
                      ((this.opacities[M] = k),
                      (g = g || R.text.placed || R.icon.placed));
                  }
                }
                for (const M in D)
                  this.variableOffsets[M] ||
                    !this.opacities[M] ||
                    this.opacities[M].isHidden() ||
                    (this.variableOffsets[M] = D[M]);
                for (const M in S)
                  this.placedOrientations[M] ||
                    !this.opacities[M] ||
                    this.opacities[M].isHidden() ||
                    (this.placedOrientations[M] = S[M]);
                g
                  ? (this.lastPlacementChangeTime = a)
                  : "number" != typeof this.lastPlacementChangeTime &&
                    (this.lastPlacementChangeTime = u
                      ? u.lastPlacementChangeTime
                      : a);
              }
              updateLayerOpacities(a, u) {
                const g = new Set();
                for (const v of u) {
                  const b = v.getBucket(a);
                  b &&
                    v.latestFeatureIndex &&
                    a.id === b.layerIds[0] &&
                    this.updateBucketOpacities(b, g, v.collisionBoxArray);
                }
              }
              updateBucketOpacities(a, u, g) {
                a.hasTextData() && a.text.opacityVertexArray.clear(),
                  a.hasIconData() && a.icon.opacityVertexArray.clear(),
                  a.hasIconCollisionBoxData() &&
                    a.iconCollisionBox.collisionVertexArray.clear(),
                  a.hasTextCollisionBoxData() &&
                    a.textCollisionBox.collisionVertexArray.clear();
                const v = a.layers[0].layout,
                  b = !!a.layers[0].dynamicFilter(),
                  D = new hs(null, 0, !1, !1, !0),
                  S = v.get("text-allow-overlap"),
                  M = v.get("icon-allow-overlap"),
                  R = v.get("text-variable-anchor"),
                  k = "map" === v.get("text-rotation-alignment"),
                  z = "map" === v.get("text-pitch-alignment"),
                  H = "none" !== v.get("icon-text-fit"),
                  q = new hs(
                    null,
                    0,
                    S && (M || !a.hasIconData() || v.get("icon-optional")),
                    M && (S || !a.hasTextData() || v.get("text-optional")),
                    !0
                  );
                !a.collisionArrays &&
                  g &&
                  (a.hasIconCollisionBoxData() ||
                    a.hasTextCollisionBoxData()) &&
                  a.deserializeCollisionBoxes(g);
                const X = (Y, B, W) => {
                  for (let ee = 0; ee < B / 4; ee++)
                    Y.opacityVertexArray.emplaceBack(W);
                };
                let Z = 0;
                for (let Y = 0; Y < a.symbolInstances.length; Y++) {
                  const B = a.symbolInstances.get(Y),
                    {
                      numHorizontalGlyphVertices: W,
                      numVerticalGlyphVertices: ee,
                      crossTileID: te,
                      numIconVertices: he,
                    } = B,
                    de = u.has(te);
                  let ue = this.opacities[te];
                  de ? (ue = D) : ue || ((ue = q), (this.opacities[te] = ue)),
                    u.add(te);
                  const _e = W > 0 || ee > 0,
                    ge = he > 0,
                    Te = this.placedOrientations[te],
                    Ge = Te === d.WritingMode.vertical,
                    be =
                      Te === d.WritingMode.horizontal ||
                      Te === d.WritingMode.horizontalOnly;
                  if (((!_e && !ge) || ue.isHidden() || Z++, _e)) {
                    const Le = xu(ue.text);
                    X(a.text, W, Ge ? pn : Le), X(a.text, ee, be ? pn : Le);
                    const Se = ue.text.isHidden(),
                      {
                        leftJustifiedTextSymbolIndex: je,
                        centerJustifiedTextSymbolIndex: we,
                        rightJustifiedTextSymbolIndex: ke,
                        verticalPlacedTextSymbolIndex: He,
                      } = B,
                      Ne = a.text.placedSymbolArray,
                      Xe = Se || Ge ? 1 : 0;
                    je >= 0 && (Ne.get(je).hidden = Xe),
                      we >= 0 && (Ne.get(we).hidden = Xe),
                      ke >= 0 && (Ne.get(ke).hidden = Xe),
                      He >= 0 && (Ne.get(He).hidden = Se || be ? 1 : 0);
                    const mt = this.variableOffsets[te];
                    mt && this.markUsedJustification(a, mt.anchor, B, Te);
                    const It = this.placedOrientations[te];
                    It &&
                      (this.markUsedJustification(a, "left", B, It),
                      this.markUsedOrientation(a, It, B));
                  }
                  if (ge) {
                    const Le = xu(ue.icon),
                      {
                        placedIconSymbolIndex: Se,
                        verticalPlacedIconSymbolIndex: je,
                      } = B,
                      we = a.icon.placedSymbolArray,
                      ke = ue.icon.isHidden() ? 1 : 0;
                    Se >= 0 &&
                      (X(a.icon, he, Ge ? pn : Le), (we.get(Se).hidden = ke)),
                      je >= 0 &&
                        (X(a.icon, B.numVerticalIconVertices, be ? pn : Le),
                        (we.get(je).hidden = ke));
                  }
                  if (
                    a.hasIconCollisionBoxData() ||
                    a.hasTextCollisionBoxData()
                  ) {
                    const Le = a.collisionArrays[Y];
                    if (Le) {
                      let Se = new d.Point(0, 0),
                        je = !0;
                      if (Le.textBox || Le.verticalTextBox) {
                        if (R) {
                          const ke = this.variableOffsets[te];
                          ke
                            ? ((Se = vu(
                                ke.anchor,
                                ke.width,
                                ke.height,
                                ke.textOffset,
                                ke.textScale
                              )),
                              k &&
                                Se._rotate(
                                  z
                                    ? this.transform.angle
                                    : -this.transform.angle
                                ))
                            : (je = !1);
                        }
                        b && (je = !ue.clipped),
                          Le.textBox &&
                            kr(
                              a.textCollisionBox.collisionVertexArray,
                              ue.text.placed,
                              !je || Ge,
                              Se.x,
                              Se.y
                            ),
                          Le.verticalTextBox &&
                            kr(
                              a.textCollisionBox.collisionVertexArray,
                              ue.text.placed,
                              !je || be,
                              Se.x,
                              Se.y
                            );
                      }
                      const we = je && Boolean(!be && Le.verticalIconBox);
                      Le.iconBox &&
                        kr(
                          a.iconCollisionBox.collisionVertexArray,
                          ue.icon.placed,
                          we,
                          H ? Se.x : 0,
                          H ? Se.y : 0
                        ),
                        Le.verticalIconBox &&
                          kr(
                            a.iconCollisionBox.collisionVertexArray,
                            ue.icon.placed,
                            !we,
                            H ? Se.x : 0,
                            H ? Se.y : 0
                          );
                    }
                  }
                }
                if (
                  ((a.fullyClipped = 0 === Z),
                  a.sortFeatures(this.transform.angle),
                  this.retainedQueryData[a.bucketInstanceId] &&
                    (this.retainedQueryData[
                      a.bucketInstanceId
                    ].featureSortOrder = a.featureSortOrder),
                  a.hasTextData() &&
                    a.text.opacityVertexBuffer &&
                    a.text.opacityVertexBuffer.updateData(
                      a.text.opacityVertexArray
                    ),
                  a.hasIconData() &&
                    a.icon.opacityVertexBuffer &&
                    a.icon.opacityVertexBuffer.updateData(
                      a.icon.opacityVertexArray
                    ),
                  a.hasIconCollisionBoxData() &&
                    a.iconCollisionBox.collisionVertexBuffer &&
                    a.iconCollisionBox.collisionVertexBuffer.updateData(
                      a.iconCollisionBox.collisionVertexArray
                    ),
                  a.hasTextCollisionBoxData() &&
                    a.textCollisionBox.collisionVertexBuffer &&
                    a.textCollisionBox.collisionVertexBuffer.updateData(
                      a.textCollisionBox.collisionVertexArray
                    ),
                  a.bucketInstanceId in this.collisionCircleArrays)
                ) {
                  const Y = this.collisionCircleArrays[a.bucketInstanceId];
                  (a.placementInvProjMatrix = Y.invProjMatrix),
                    (a.placementViewportMatrix = Y.viewportMatrix),
                    (a.collisionCircleArray = Y.circles),
                    delete this.collisionCircleArrays[a.bucketInstanceId];
                }
              }
              symbolFadeChange(a) {
                return 0 === this.fadeDuration
                  ? 1
                  : (a - this.commitTime) / this.fadeDuration +
                      this.prevZoomAdjustment;
              }
              zoomAdjustment(a) {
                return Math.max(0, (this.transform.zoom - a) / 1.5);
              }
              hasTransitions(a) {
                return (
                  this.stale ||
                  a - this.lastPlacementChangeTime < this.fadeDuration
                );
              }
              stillRecent(a, u) {
                const g =
                  this.zoomAtLastRecencyCheck === u
                    ? 1 - this.zoomAdjustment(u)
                    : 1;
                return (
                  (this.zoomAtLastRecencyCheck = u),
                  this.commitTime + this.fadeDuration * g > a
                );
              }
              setStale() {
                this.stale = !0;
              }
            }
            function kr(f, a, u, g, v) {
              f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0),
                f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0),
                f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0),
                f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0);
            }
            const Gr = Math.pow(2, 25),
              gi = Math.pow(2, 24),
              ap = Math.pow(2, 17),
              lp = Math.pow(2, 16),
              Rr = Math.pow(2, 9),
              _o = Math.pow(2, 8),
              cp = Math.pow(2, 1);
            function xu(f) {
              if (0 === f.opacity && !f.placed) return 0;
              if (1 === f.opacity && f.placed) return 4294967295;
              const a = f.placed ? 1 : 0,
                u = Math.floor(127 * f.opacity);
              return (
                u * Gr + a * gi + u * ap + a * lp + u * Rr + a * _o + u * cp + a
              );
            }
            const pn = 0;
            class gn {
              constructor(a) {
                (this._sortAcrossTiles =
                  "viewport-y" !== a.layout.get("symbol-z-order") &&
                  void 0 !== a.layout.get("symbol-sort-key").constantOr(1)),
                  (this._currentTileIndex = 0),
                  (this._currentPartIndex = 0),
                  (this._seenCrossTileIDs = new Set()),
                  (this._bucketParts = []);
              }
              continuePlacement(a, u, g, v, b) {
                const D = this._bucketParts;
                for (; this._currentTileIndex < a.length; )
                  if (
                    (u.getBucketParts(
                      D,
                      v,
                      a[this._currentTileIndex],
                      this._sortAcrossTiles
                    ),
                    this._currentTileIndex++,
                    b())
                  )
                    return !0;
                for (
                  this._sortAcrossTiles &&
                  ((this._sortAcrossTiles = !1),
                  D.sort((S, M) => S.sortKey - M.sortKey));
                  this._currentPartIndex < D.length;

                ) {
                  const S = D[this._currentPartIndex];
                  if (
                    (u.placeLayerBucketPart(
                      S,
                      this._seenCrossTileIDs,
                      g,
                      0 === S.symbolInstanceStart
                    ),
                    this._currentPartIndex++,
                    b())
                  )
                    return !0;
                }
                return !1;
              }
            }
            class up {
              constructor(a, u, g, v, b, D, S, M) {
                (this.placement = new Ah(a, b, D, S, M)),
                  (this._currentPlacementIndex = u.length - 1),
                  (this._forceFullPlacement = g),
                  (this._showCollisionBoxes = v),
                  (this._done = !1);
              }
              isDone() {
                return this._done;
              }
              continuePlacement(a, u, g) {
                const v = d.exported.now(),
                  b = () => {
                    const D = d.exported.now() - v;
                    return !this._forceFullPlacement && D > 2;
                  };
                for (; this._currentPlacementIndex >= 0; ) {
                  const D = u[a[this._currentPlacementIndex]],
                    S = this.placement.collisionIndex.transform.zoom;
                  if (
                    "symbol" === D.type &&
                    (!D.minzoom || D.minzoom <= S) &&
                    (!D.maxzoom || D.maxzoom > S)
                  ) {
                    if (
                      (this._inProgressLayer ||
                        (this._inProgressLayer = new gn(D)),
                      this._inProgressLayer.continuePlacement(
                        g[D.source],
                        this.placement,
                        this._showCollisionBoxes,
                        D,
                        b
                      ))
                    )
                      return;
                    delete this._inProgressLayer;
                  }
                  this._currentPlacementIndex--;
                }
                this._done = !0;
              }
              commit(a) {
                return this.placement.commit(a), this.placement;
              }
            }
            const Cl = 512 / d.EXTENT / 2;
            class or {
              constructor(a, u, g) {
                (this.tileID = a),
                  (this.bucketInstanceId = g),
                  (this.index = new d.KDBush(u.length, 16, Int32Array)),
                  (this.keys = []),
                  (this.crossTileIDs = []);
                const v = a.canonical.x * d.EXTENT,
                  b = a.canonical.y * d.EXTENT;
                for (let D = 0; D < u.length; D++) {
                  const {
                      key: S,
                      crossTileID: M,
                      tileAnchorX: R,
                      tileAnchorY: k,
                    } = u.get(D),
                    z = Math.floor((v + R) * Cl),
                    H = Math.floor((b + k) * Cl);
                  this.index.add(z, H),
                    this.keys.push(S),
                    this.crossTileIDs.push(M);
                }
                this.index.finish();
              }
              findMatches(a, u, g) {
                const v =
                    this.tileID.canonical.z < u.canonical.z
                      ? 1
                      : Math.pow(2, this.tileID.canonical.z - u.canonical.z),
                  b = Cl / Math.pow(2, u.canonical.z - this.tileID.canonical.z),
                  D = u.canonical.x * d.EXTENT,
                  S = u.canonical.y * d.EXTENT;
                for (let M = 0; M < a.length; M++) {
                  const R = a.get(M);
                  if (R.crossTileID) continue;
                  const { key: k, tileAnchorX: z, tileAnchorY: H } = R,
                    q = Math.floor((D + z) * b),
                    X = Math.floor((S + H) * b),
                    Z = this.index.range(q - v, X - v, q + v, X + v);
                  for (const Y of Z) {
                    const B = this.crossTileIDs[Y];
                    if (this.keys[Y] === k && !g.has(B)) {
                      g.add(B), (R.crossTileID = B);
                      break;
                    }
                  }
                }
              }
            }
            class Mn {
              constructor() {
                this.maxCrossTileID = 0;
              }
              generate() {
                return ++this.maxCrossTileID;
              }
            }
            class hp {
              constructor() {
                (this.indexes = {}),
                  (this.usedCrossTileIDs = {}),
                  (this.lng = 0);
              }
              handleWrapJump(a) {
                const u = Math.round((a - this.lng) / 360);
                if (0 !== u)
                  for (const g in this.indexes) {
                    const v = this.indexes[g],
                      b = {};
                    for (const D in v) {
                      const S = v[D];
                      (S.tileID = S.tileID.unwrapTo(S.tileID.wrap + u)),
                        (b[S.tileID.key] = S);
                    }
                    this.indexes[g] = b;
                  }
                this.lng = a;
              }
              addBucket(a, u, g) {
                if (
                  this.indexes[a.overscaledZ] &&
                  this.indexes[a.overscaledZ][a.key]
                ) {
                  if (
                    this.indexes[a.overscaledZ][a.key].bucketInstanceId ===
                    u.bucketInstanceId
                  )
                    return !1;
                  this.removeBucketCrossTileIDs(
                    a.overscaledZ,
                    this.indexes[a.overscaledZ][a.key]
                  );
                }
                for (let b = 0; b < u.symbolInstances.length; b++)
                  u.symbolInstances.get(b).crossTileID = 0;
                this.usedCrossTileIDs[a.overscaledZ] ||
                  (this.usedCrossTileIDs[a.overscaledZ] = new Set());
                const v = this.usedCrossTileIDs[a.overscaledZ];
                for (const b in this.indexes) {
                  const D = this.indexes[b];
                  if (Number(b) > a.overscaledZ)
                    for (const S in D) {
                      const M = D[S];
                      M.tileID.isChildOf(a) &&
                        M.findMatches(u.symbolInstances, a, v);
                    }
                  else {
                    const S = D[a.scaledTo(Number(b)).key];
                    S && S.findMatches(u.symbolInstances, a, v);
                  }
                }
                for (let b = 0; b < u.symbolInstances.length; b++) {
                  const D = u.symbolInstances.get(b);
                  D.crossTileID ||
                    ((D.crossTileID = g.generate()), v.add(D.crossTileID));
                }
                return (
                  void 0 === this.indexes[a.overscaledZ] &&
                    (this.indexes[a.overscaledZ] = {}),
                  (this.indexes[a.overscaledZ][a.key] = new or(
                    a,
                    u.symbolInstances,
                    u.bucketInstanceId
                  )),
                  !0
                );
              }
              removeBucketCrossTileIDs(a, u) {
                for (const g of u.crossTileIDs)
                  this.usedCrossTileIDs[a].delete(g);
              }
              removeStaleBuckets(a) {
                let u = !1;
                for (const g in this.indexes) {
                  const v = this.indexes[g];
                  for (const b in v)
                    a[v[b].bucketInstanceId] ||
                      (this.removeBucketCrossTileIDs(g, v[b]),
                      delete v[b],
                      (u = !0));
                }
                return u;
              }
            }
            class ii {
              constructor() {
                (this.layerIndexes = {}),
                  (this.crossTileIDs = new Mn()),
                  (this.maxBucketInstanceId = 0),
                  (this.bucketsInCurrentPlacement = {});
              }
              addLayer(a, u, g, v) {
                let b = this.layerIndexes[a.id];
                void 0 === b && (b = this.layerIndexes[a.id] = new hp());
                let D = !1;
                const S = {};
                "globe" !== v.name && b.handleWrapJump(g);
                for (const M of u) {
                  const R = M.getBucket(a);
                  R &&
                    a.id === R.layerIds[0] &&
                    (R.bucketInstanceId ||
                      (R.bucketInstanceId = ++this.maxBucketInstanceId),
                    b.addBucket(M.tileID, R, this.crossTileIDs) && (D = !0),
                    (S[R.bucketInstanceId] = !0));
                }
                return b.removeStaleBuckets(S) && (D = !0), D;
              }
              pruneUnusedLayers(a) {
                const u = {};
                a.forEach((g) => {
                  u[g] = !0;
                });
                for (const g in this.layerIndexes)
                  u[g] || delete this.layerIndexes[g];
              }
            }
            const yo = (f, a) =>
                d.emitValidationErrors(
                  f,
                  a && a.filter((u) => "source.canvas" !== u.identifier)
                ),
              Ph = d.pick(xn, [
                "addLayer",
                "removeLayer",
                "setPaintProperty",
                "setLayoutProperty",
                "setFilter",
                "addSource",
                "removeSource",
                "setLayerZoomRange",
                "setLight",
                "setTransition",
                "setGeoJSONSourceData",
                "setTerrain",
                "setFog",
                "setProjection",
              ]),
              dp = d.pick(xn, [
                "setCenter",
                "setZoom",
                "setBearing",
                "setPitch",
              ]),
              Lh = { version: 8, layers: [], sources: {} },
              Sl = {
                fill: !0,
                line: !0,
                background: !0,
                hillshade: !0,
                raster: !0,
              };
            class vo extends d.Evented {
              constructor(a, u = {}) {
                super(),
                  (this.map = a),
                  (this.dispatcher = new Tn(ka(), this)),
                  (this.imageManager = new Sa()),
                  this.imageManager.setEventedParent(this),
                  (this.glyphManager = new d.GlyphManager(
                    a._requestManager,
                    u.localFontFamily
                      ? d.LocalGlyphMode.all
                      : u.localIdeographFontFamily
                      ? d.LocalGlyphMode.ideographs
                      : d.LocalGlyphMode.none,
                    u.localFontFamily || u.localIdeographFontFamily
                  )),
                  (this.crossTileSymbolIndex = new ii()),
                  (this._layers = {}),
                  (this._num3DLayers = 0),
                  (this._numSymbolLayers = 0),
                  (this._numCircleLayers = 0),
                  (this._serializedLayers = {}),
                  (this._sourceCaches = {}),
                  (this._otherSourceCaches = {}),
                  (this._symbolSourceCaches = {}),
                  (this._loaded = !1),
                  (this._availableImages = []),
                  (this._order = []),
                  (this._drapedFirstOrder = []),
                  (this._markersNeedUpdate = !1),
                  this._resetUpdates(),
                  this.dispatcher.broadcast("setReferrer", d.getReferrer());
                const g = this;
                (this._rtlTextPluginCallback = vo.registerForPluginStateChange(
                  (v) => {
                    g.dispatcher.broadcast(
                      "syncRTLPluginState",
                      { pluginStatus: v.pluginStatus, pluginURL: v.pluginURL },
                      (b, D) => {
                        if (
                          (d.triggerPluginCompletionEvent(b),
                          D && D.every((S) => S))
                        )
                          for (const S in g._sourceCaches) {
                            const M = g._sourceCaches[S],
                              R = M.getSource().type;
                            ("vector" !== R && "geojson" !== R) || M.reload();
                          }
                      }
                    );
                  }
                )),
                  this.on("data", (v) => {
                    if (
                      "source" !== v.dataType ||
                      "metadata" !== v.sourceDataType
                    )
                      return;
                    const b = this.getSource(v.sourceId);
                    if (b && b.vectorLayerIds)
                      for (const D in this._layers) {
                        const S = this._layers[D];
                        S.source === b.id && this._validateLayer(S);
                      }
                  });
              }
              loadURL(a, u = {}) {
                this.fire(new d.Event("dataloading", { dataType: "style" }));
                const g =
                  "boolean" == typeof u.validate
                    ? u.validate
                    : !d.isMapboxURL(a);
                a = this.map._requestManager.normalizeStyleURL(
                  a,
                  u.accessToken
                );
                const v = this.map._requestManager.transformRequest(
                  a,
                  d.ResourceType.Style
                );
                this._request = d.getJSON(v, (b, D) => {
                  (this._request = null),
                    b ? this.fire(new d.ErrorEvent(b)) : D && this._load(D, g);
                });
              }
              loadJSON(a, u = {}) {
                this.fire(new d.Event("dataloading", { dataType: "style" })),
                  (this._request = d.exported.frame(() => {
                    (this._request = null), this._load(a, !1 !== u.validate);
                  }));
              }
              loadEmpty() {
                this.fire(new d.Event("dataloading", { dataType: "style" })),
                  this._load(Lh, !1);
              }
              _updateLayerCount(a, u) {
                const g = u ? 1 : -1;
                a.is3D() && (this._num3DLayers += g),
                  "circle" === a.type && (this._numCircleLayers += g),
                  "symbol" === a.type && (this._numSymbolLayers += g);
              }
              _load(a, u) {
                if (u && yo(this, d.validateStyle(a))) return;
                (this._loaded = !0),
                  (this.stylesheet = d.clone$1(a)),
                  this._updateMapProjection();
                for (const v in a.sources)
                  this.addSource(v, a.sources[v], { validate: !1 });
                (this._changed = !1),
                  a.sprite
                    ? this._loadSprite(a.sprite)
                    : (this.imageManager.setLoaded(!0),
                      this.dispatcher.broadcast("spriteLoaded", !0)),
                  this.glyphManager.setURL(a.glyphs);
                const g = Ch(this.stylesheet.layers);
                (this._order = g.map((v) => v.id)),
                  (this._layers = {}),
                  (this._serializedLayers = {});
                for (const v of g) {
                  const b = d.createStyleLayer(v);
                  b.setEventedParent(this, { layer: { id: b.id } }),
                    (this._layers[b.id] = b),
                    (this._serializedLayers[b.id] = b.serialize()),
                    this._updateLayerCount(b, !0);
                }
                this.dispatcher.broadcast(
                  "setLayers",
                  this._serializeLayers(this._order)
                ),
                  (this.light = new zi(this.stylesheet.light)),
                  this.stylesheet.terrain &&
                    !this.terrainSetForDrapingOnly() &&
                    this._createTerrain(this.stylesheet.terrain, 1),
                  this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                  this._updateDrapeFirstLayers(),
                  this.fire(new d.Event("data", { dataType: "style" })),
                  this.fire(new d.Event("style.load"));
              }
              terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
              }
              setProjection(a) {
                a
                  ? (this.stylesheet.projection = a)
                  : delete this.stylesheet.projection,
                  this._updateMapProjection();
              }
              applyProjectionUpdate() {
                this._loaded &&
                  (this.dispatcher.broadcast(
                    "setProjection",
                    this.map.transform.projectionOptions
                  ),
                  this.map.transform.projection.requiresDraping
                    ? this.getTerrain() ||
                      this.stylesheet.terrain ||
                      this.setTerrainForDraping()
                    : this.terrainSetForDrapingOnly() && this.setTerrain(null));
              }
              _updateMapProjection() {
                this.map._useExplicitProjection
                  ? this.applyProjectionUpdate()
                  : this.map._prioritizeAndUpdateProjection(
                      null,
                      this.stylesheet.projection
                    );
              }
              _loadSprite(a) {
                this._spriteRequest = (function (u, g, v) {
                  let b, D, S;
                  const M = d.exported.devicePixelRatio > 1 ? "@2x" : "";
                  let R = d.getJSON(
                      g.transformRequest(
                        g.normalizeSpriteURL(u, M, ".json"),
                        d.ResourceType.SpriteJSON
                      ),
                      (H, q) => {
                        (R = null), S || ((S = H), (b = q), z());
                      }
                    ),
                    k = d.getImage(
                      g.transformRequest(
                        g.normalizeSpriteURL(u, M, ".png"),
                        d.ResourceType.SpriteImage
                      ),
                      (H, q) => {
                        (k = null), S || ((S = H), (D = q), z());
                      }
                    );
                  function z() {
                    if (S) v(S);
                    else if (b && D) {
                      const H = d.exported.getImageData(D),
                        q = {};
                      for (const X in b) {
                        const {
                            width: Z,
                            height: Y,
                            x: B,
                            y: W,
                            sdf: ee,
                            pixelRatio: te,
                            stretchX: he,
                            stretchY: de,
                            content: ue,
                          } = b[X],
                          _e = new d.RGBAImage({ width: Z, height: Y });
                        d.RGBAImage.copy(
                          H,
                          _e,
                          { x: B, y: W },
                          { x: 0, y: 0 },
                          { width: Z, height: Y }
                        ),
                          (q[X] = {
                            data: _e,
                            pixelRatio: te,
                            sdf: ee,
                            stretchX: he,
                            stretchY: de,
                            content: ue,
                          });
                      }
                      v(null, q);
                    }
                  }
                  return {
                    cancel() {
                      R && (R.cancel(), (R = null)),
                        k && (k.cancel(), (k = null));
                    },
                  };
                })(a, this.map._requestManager, (u, g) => {
                  if (((this._spriteRequest = null), u))
                    this.fire(new d.ErrorEvent(u));
                  else if (g)
                    for (const v in g) this.imageManager.addImage(v, g[v]);
                  this.imageManager.setLoaded(!0),
                    (this._availableImages = this.imageManager.listImages()),
                    this.dispatcher.broadcast(
                      "setImages",
                      this._availableImages
                    ),
                    this.dispatcher.broadcast("spriteLoaded", !0),
                    this.fire(new d.Event("data", { dataType: "style" }));
                });
              }
              _validateLayer(a) {
                const u = this.getSource(a.source);
                if (!u) return;
                const g = a.sourceLayer;
                g &&
                  ("geojson" === u.type ||
                    (u.vectorLayerIds && -1 === u.vectorLayerIds.indexOf(g))) &&
                  this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Source layer "${g}" does not exist on source "${u.id}" as specified by style layer "${a.id}"`
                      )
                    )
                  );
              }
              loaded() {
                if (!this._loaded || Object.keys(this._updatedSources).length)
                  return !1;
                for (const a in this._sourceCaches)
                  if (!this._sourceCaches[a].loaded()) return !1;
                return !!this.imageManager.isLoaded();
              }
              _serializeLayers(a) {
                const u = [];
                for (const g of a) {
                  const v = this._layers[g];
                  "custom" !== v.type && u.push(v.serialize());
                }
                return u;
              }
              hasTransitions() {
                if (
                  (this.light && this.light.hasTransition()) ||
                  (this.fog && this.fog.hasTransition())
                )
                  return !0;
                for (const a in this._sourceCaches)
                  if (this._sourceCaches[a].hasTransition()) return !0;
                for (const a in this._layers)
                  if (this._layers[a].hasTransition()) return !0;
                return !1;
              }
              get order() {
                return this.map._optimizeForTerrain && this.terrain
                  ? this._drapedFirstOrder
                  : this._order;
              }
              isLayerDraped(a) {
                return (
                  !!this.terrain &&
                  ("function" == typeof a.isLayerDraped
                    ? a.isLayerDraped()
                    : Sl[a.type])
                );
              }
              _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
              }
              update(a) {
                if (!this._loaded) return;
                const u = this._changed;
                if (this._changed) {
                  const v = Object.keys(this._updatedLayers),
                    b = Object.keys(this._removedLayers);
                  (v.length || b.length) && this._updateWorkerLayers(v, b);
                  for (const D in this._updatedSources) {
                    const S = this._updatedSources[D];
                    "reload" === S
                      ? this._reloadSource(D)
                      : "clear" === S && this._clearSource(D);
                  }
                  this._updateTilesForChangedImages();
                  for (const D in this._updatedPaintProps)
                    this._layers[D].updateTransitions(a);
                  this.light.updateTransitions(a),
                    this.fog && this.fog.updateTransitions(a),
                    this._resetUpdates();
                }
                const g = {};
                for (const v in this._sourceCaches) {
                  const b = this._sourceCaches[v];
                  (g[v] = b.used), (b.used = !1);
                }
                for (const v of this._order) {
                  const b = this._layers[v];
                  if (
                    (b.recalculate(a, this._availableImages),
                    !b.isHidden(a.zoom))
                  ) {
                    const S = this._getLayerSourceCache(b);
                    S && (S.used = !0);
                  }
                  const D = this.map.painter;
                  if (D) {
                    const S = b.getProgramIds();
                    if (!S) continue;
                    const M = b.getProgramConfiguration(a.zoom);
                    for (const R of S) D.useProgram(R, M);
                  }
                }
                for (const v in g) {
                  const b = this._sourceCaches[v];
                  g[v] !== b.used &&
                    b
                      .getSource()
                      .fire(
                        new d.Event("data", {
                          sourceDataType: "visibility",
                          dataType: "source",
                          sourceId: b.getSource().id,
                        })
                      );
                }
                this.light.recalculate(a),
                  this.terrain && this.terrain.recalculate(a),
                  this.fog && this.fog.recalculate(a),
                  (this.z = a.zoom),
                  this._markersNeedUpdate &&
                    (this._updateMarkersOpacity(),
                    (this._markersNeedUpdate = !1)),
                  u && this.fire(new d.Event("data", { dataType: "style" }));
              }
              _updateTilesForChangedImages() {
                const a = Object.keys(this._changedImages);
                if (a.length) {
                  for (const u in this._sourceCaches)
                    this._sourceCaches[u].reloadTilesForDependencies(
                      ["icons", "patterns"],
                      a
                    );
                  this._changedImages = {};
                }
              }
              _updateWorkerLayers(a, u) {
                this.dispatcher.broadcast("updateLayers", {
                  layers: this._serializeLayers(a),
                  removedIds: u,
                });
              }
              _resetUpdates() {
                (this._changed = !1),
                  (this._updatedLayers = {}),
                  (this._removedLayers = {}),
                  (this._updatedSources = {}),
                  (this._updatedPaintProps = {}),
                  (this._changedImages = {});
              }
              setState(a) {
                if ((this._checkLoaded(), yo(this, d.validateStyle(a))))
                  return !1;
                (a = d.clone$1(a)).layers = Ch(a.layers);
                const u = (function (v, b) {
                  if (!v) return [{ command: xn.setStyle, args: [b] }];
                  let D = [];
                  try {
                    if (!Be(v.version, b.version))
                      return [{ command: xn.setStyle, args: [b] }];
                    Be(v.center, b.center) ||
                      D.push({ command: xn.setCenter, args: [b.center] }),
                      Be(v.zoom, b.zoom) ||
                        D.push({ command: xn.setZoom, args: [b.zoom] }),
                      Be(v.bearing, b.bearing) ||
                        D.push({ command: xn.setBearing, args: [b.bearing] }),
                      Be(v.pitch, b.pitch) ||
                        D.push({ command: xn.setPitch, args: [b.pitch] }),
                      Be(v.sprite, b.sprite) ||
                        D.push({ command: xn.setSprite, args: [b.sprite] }),
                      Be(v.glyphs, b.glyphs) ||
                        D.push({ command: xn.setGlyphs, args: [b.glyphs] }),
                      Be(v.transition, b.transition) ||
                        D.push({
                          command: xn.setTransition,
                          args: [b.transition],
                        }),
                      Be(v.light, b.light) ||
                        D.push({ command: xn.setLight, args: [b.light] }),
                      Be(v.fog, b.fog) ||
                        D.push({ command: xn.setFog, args: [b.fog] }),
                      Be(v.projection, b.projection) ||
                        D.push({
                          command: xn.setProjection,
                          args: [b.projection],
                        });
                    const S = {},
                      M = [];
                    !(function (z, H, q, X) {
                      let Z;
                      for (Z in ((H = H || {}), (z = z || {})))
                        z.hasOwnProperty(Z) &&
                          (H.hasOwnProperty(Z) || hc(Z, q, X));
                      for (Z in H) {
                        if (!H.hasOwnProperty(Z)) continue;
                        const Y = H[Z];
                        z.hasOwnProperty(Z)
                          ? Be(z[Z], Y) ||
                            ("geojson" === z[Z].type &&
                            "geojson" === Y.type &&
                            Ih(z, H, Z)
                              ? q.push({
                                  command: xn.setGeoJSONSourceData,
                                  args: [Z, Y.data],
                                })
                              : dc(Z, H, q, X))
                          : Sh(Z, H, q);
                      }
                    })(v.sources, b.sources, M, S);
                    const R = [];
                    v.layers &&
                      v.layers.forEach((z) => {
                        z.source && S[z.source]
                          ? D.push({ command: xn.removeLayer, args: [z.id] })
                          : R.push(z);
                      });
                    let k = v.terrain;
                    k &&
                      S[k.source] &&
                      (D.push({ command: xn.setTerrain, args: [void 0] }),
                      (k = void 0)),
                      (D = D.concat(M)),
                      Be(k, b.terrain) ||
                        D.push({ command: xn.setTerrain, args: [b.terrain] }),
                      (function (z, H, q) {
                        H = H || [];
                        const X = (z = z || []).map(cs),
                          Z = H.map(cs),
                          Y = z.reduce(fu, {}),
                          B = H.reduce(fu, {}),
                          W = X.slice(),
                          ee = Object.create(null);
                        let te, he, de, ue, _e, ge, Te;
                        for (te = 0, he = 0; te < X.length; te++)
                          (de = X[te]),
                            B.hasOwnProperty(de)
                              ? he++
                              : (q.push({
                                  command: xn.removeLayer,
                                  args: [de],
                                }),
                                W.splice(W.indexOf(de, he), 1));
                        for (te = 0, he = 0; te < Z.length; te++)
                          (de = Z[Z.length - 1 - te]),
                            W[W.length - 1 - te] !== de &&
                              (Y.hasOwnProperty(de)
                                ? (q.push({
                                    command: xn.removeLayer,
                                    args: [de],
                                  }),
                                  W.splice(W.lastIndexOf(de, W.length - he), 1))
                                : he++,
                              (ge = W[W.length - te]),
                              q.push({
                                command: xn.addLayer,
                                args: [B[de], ge],
                              }),
                              W.splice(W.length - te, 0, de),
                              (ee[de] = !0));
                        for (te = 0; te < Z.length; te++)
                          if (
                            ((de = Z[te]),
                            (ue = Y[de]),
                            (_e = B[de]),
                            !ee[de] && !Be(ue, _e))
                          )
                            if (
                              Be(ue.source, _e.source) &&
                              Be(ue["source-layer"], _e["source-layer"]) &&
                              Be(ue.type, _e.type)
                            ) {
                              for (Te in (Bo(
                                ue.layout,
                                _e.layout,
                                q,
                                de,
                                null,
                                xn.setLayoutProperty
                              ),
                              Bo(
                                ue.paint,
                                _e.paint,
                                q,
                                de,
                                null,
                                xn.setPaintProperty
                              ),
                              Be(ue.filter, _e.filter) ||
                                q.push({
                                  command: xn.setFilter,
                                  args: [de, _e.filter],
                                }),
                              (Be(ue.minzoom, _e.minzoom) &&
                                Be(ue.maxzoom, _e.maxzoom)) ||
                                q.push({
                                  command: xn.setLayerZoomRange,
                                  args: [de, _e.minzoom, _e.maxzoom],
                                }),
                              ue))
                                ue.hasOwnProperty(Te) &&
                                  "layout" !== Te &&
                                  "paint" !== Te &&
                                  "filter" !== Te &&
                                  "metadata" !== Te &&
                                  "minzoom" !== Te &&
                                  "maxzoom" !== Te &&
                                  (0 === Te.indexOf("paint.")
                                    ? Bo(
                                        ue[Te],
                                        _e[Te],
                                        q,
                                        de,
                                        Te.slice(6),
                                        xn.setPaintProperty
                                      )
                                    : Be(ue[Te], _e[Te]) ||
                                      q.push({
                                        command: xn.setLayerProperty,
                                        args: [de, Te, _e[Te]],
                                      }));
                              for (Te in _e)
                                _e.hasOwnProperty(Te) &&
                                  !ue.hasOwnProperty(Te) &&
                                  "layout" !== Te &&
                                  "paint" !== Te &&
                                  "filter" !== Te &&
                                  "metadata" !== Te &&
                                  "minzoom" !== Te &&
                                  "maxzoom" !== Te &&
                                  (0 === Te.indexOf("paint.")
                                    ? Bo(
                                        ue[Te],
                                        _e[Te],
                                        q,
                                        de,
                                        Te.slice(6),
                                        xn.setPaintProperty
                                      )
                                    : Be(ue[Te], _e[Te]) ||
                                      q.push({
                                        command: xn.setLayerProperty,
                                        args: [de, Te, _e[Te]],
                                      }));
                            } else
                              q.push({ command: xn.removeLayer, args: [de] }),
                                (ge = W[W.lastIndexOf(de) + 1]),
                                q.push({
                                  command: xn.addLayer,
                                  args: [_e, ge],
                                });
                      })(R, b.layers, D);
                  } catch (S) {
                    console.warn("Unable to compute style diff:", S),
                      (D = [{ command: xn.setStyle, args: [b] }]);
                  }
                  return D;
                })(this.serialize(), a).filter((v) => !(v.command in dp));
                if (0 === u.length) return !1;
                const g = u.filter((v) => !(v.command in Ph));
                if (g.length > 0)
                  throw new Error(
                    `Unimplemented: ${g.map((v) => v.command).join(", ")}.`
                  );
                return (
                  u.forEach((v) => {
                    "setTransition" !== v.command &&
                      "setProjection" !== v.command &&
                      this[v.command].apply(this, v.args);
                  }),
                  (this.stylesheet = a),
                  this._updateMapProjection(),
                  !0
                );
              }
              addImage(a, u) {
                return this.getImage(a)
                  ? this.fire(
                      new d.ErrorEvent(
                        new Error("An image with this name already exists.")
                      )
                    )
                  : (this.imageManager.addImage(a, u),
                    this._afterImageUpdated(a),
                    this);
              }
              updateImage(a, u) {
                this.imageManager.updateImage(a, u);
              }
              getImage(a) {
                return this.imageManager.getImage(a);
              }
              removeImage(a) {
                return this.getImage(a)
                  ? (this.imageManager.removeImage(a),
                    this._afterImageUpdated(a),
                    this)
                  : this.fire(
                      new d.ErrorEvent(
                        new Error("No image with this name exists.")
                      )
                    );
              }
              _afterImageUpdated(a) {
                (this._availableImages = this.imageManager.listImages()),
                  (this._changedImages[a] = !0),
                  (this._changed = !0),
                  this.dispatcher.broadcast("setImages", this._availableImages),
                  this.fire(new d.Event("data", { dataType: "style" }));
              }
              listImages() {
                return this._checkLoaded(), this._availableImages.slice();
              }
              addSource(a, u, g = {}) {
                if ((this._checkLoaded(), void 0 !== this.getSource(a)))
                  throw new Error("There is already a source with this ID");
                if (!u.type)
                  throw new Error(
                    `The type property must be defined, but only the following properties were given: ${Object.keys(
                      u
                    ).join(", ")}.`
                  );
                if (
                  ["vector", "raster", "geojson", "video", "image"].indexOf(
                    u.type
                  ) >= 0 &&
                  this._validate(d.validateSource, `sources.${a}`, u, null, g)
                )
                  return;
                this.map &&
                  this.map._collectResourceTiming &&
                  (u.collectResourceTiming = !0);
                const v = Zt(a, u, this.dispatcher, this);
                v.setEventedParent(this, () => ({
                  isSourceLoaded: this._isSourceCacheLoaded(a),
                  source: v.serialize(),
                  sourceId: a,
                }));
                const b = (D) => {
                  const S = (D ? "symbol:" : "other:") + a,
                    M = (this._sourceCaches[S] = new d.SourceCache(S, v, D));
                  ((D ? this._symbolSourceCaches : this._otherSourceCaches)[a] =
                    M),
                    (M.style = this),
                    M.onAdd(this.map);
                };
                b(!1),
                  ("vector" !== u.type && "geojson" !== u.type) || b(!0),
                  v.onAdd && v.onAdd(this.map),
                  (this._changed = !0);
              }
              removeSource(a) {
                this._checkLoaded();
                const u = this.getSource(a);
                if (!u) throw new Error("There is no source with this ID");
                for (const v in this._layers)
                  if (this._layers[v].source === a)
                    return this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `Source "${a}" cannot be removed while layer "${v}" is using it.`
                        )
                      )
                    );
                if (this.terrain && this.terrain.get().source === a)
                  return this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Source "${a}" cannot be removed while terrain is using it.`
                      )
                    )
                  );
                const g = this._getSourceCaches(a);
                for (const v of g)
                  delete this._sourceCaches[v.id],
                    delete this._updatedSources[v.id],
                    v.fire(
                      new d.Event("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: v.getSource().id,
                      })
                    ),
                    v.setEventedParent(null),
                    v.clearTiles();
                return (
                  delete this._otherSourceCaches[a],
                  delete this._symbolSourceCaches[a],
                  u.setEventedParent(null),
                  u.onRemove && u.onRemove(this.map),
                  (this._changed = !0),
                  this
                );
              }
              setGeoJSONSourceData(a, u) {
                this._checkLoaded(),
                  this.getSource(a).setData(u),
                  (this._changed = !0);
              }
              getSource(a) {
                const u = this._getSourceCache(a);
                return u && u.getSource();
              }
              _getSources() {
                const a = [];
                for (const u in this._otherSourceCaches) {
                  const g = this._getSourceCache(u);
                  g && a.push(g.getSource());
                }
                return a;
              }
              addLayer(a, u, g = {}) {
                this._checkLoaded();
                const v = a.id;
                if (this.getLayer(v))
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Layer with id "${v}" already exists on this map`
                      )
                    )
                  );
                let b;
                if ("custom" === a.type) {
                  if (yo(this, d.validateCustomStyleLayer(a))) return;
                  b = d.createStyleLayer(a);
                } else {
                  if (
                    ("object" == typeof a.source &&
                      (this.addSource(v, a.source),
                      (a = d.clone$1(a)),
                      (a = d.extend(a, { source: v }))),
                    this._validate(
                      d.validateLayer,
                      `layers.${v}`,
                      a,
                      { arrayIndex: -1 },
                      g
                    ))
                  )
                    return;
                  (b = d.createStyleLayer(a)),
                    this._validateLayer(b),
                    b.setEventedParent(this, { layer: { id: v } }),
                    (this._serializedLayers[b.id] = b.serialize()),
                    this._updateLayerCount(b, !0);
                }
                const D = u ? this._order.indexOf(u) : this._order.length;
                if (u && -1 === D)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Layer with id "${u}" does not exist on this map.`
                      )
                    )
                  );
                this._order.splice(D, 0, v),
                  (this._layerOrderChanged = !0),
                  (this._layers[v] = b);
                const S = this._getLayerSourceCache(b);
                if (
                  this._removedLayers[v] &&
                  b.source &&
                  S &&
                  "custom" !== b.type
                ) {
                  const M = this._removedLayers[v];
                  delete this._removedLayers[v],
                    M.type !== b.type
                      ? (this._updatedSources[b.source] = "clear")
                      : ((this._updatedSources[b.source] = "reload"),
                        S.pause());
                }
                this._updateLayer(b),
                  b.onAdd && b.onAdd(this.map),
                  this._updateDrapeFirstLayers();
              }
              moveLayer(a, u) {
                if (
                  (this._checkLoaded(), (this._changed = !0), !this._layers[a])
                )
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The layer '${a}' does not exist in the map's style and cannot be moved.`
                      )
                    )
                  );
                if (a === u) return;
                const g = this._order.indexOf(a);
                this._order.splice(g, 1);
                const v = u ? this._order.indexOf(u) : this._order.length;
                u && -1 === v
                  ? this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `Layer with id "${u}" does not exist on this map.`
                        )
                      )
                    )
                  : (this._order.splice(v, 0, a),
                    (this._layerOrderChanged = !0),
                    this._updateDrapeFirstLayers());
              }
              removeLayer(a) {
                this._checkLoaded();
                const u = this._layers[a];
                if (!u)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The layer '${a}' does not exist in the map's style and cannot be removed.`
                      )
                    )
                  );
                u.setEventedParent(null), this._updateLayerCount(u, !1);
                const g = this._order.indexOf(a);
                this._order.splice(g, 1),
                  (this._layerOrderChanged = !0),
                  (this._changed = !0),
                  (this._removedLayers[a] = u),
                  delete this._layers[a],
                  delete this._serializedLayers[a],
                  delete this._updatedLayers[a],
                  delete this._updatedPaintProps[a],
                  u.onRemove && u.onRemove(this.map),
                  this._updateDrapeFirstLayers();
              }
              getLayer(a) {
                return this._layers[a];
              }
              hasLayer(a) {
                return a in this._layers;
              }
              hasLayerType(a) {
                for (const u in this._layers)
                  if (this._layers[u].type === a) return !0;
                return !1;
              }
              setLayerZoomRange(a, u, g) {
                this._checkLoaded();
                const v = this.getLayer(a);
                v
                  ? (v.minzoom === u && v.maxzoom === g) ||
                    (null != u && (v.minzoom = u),
                    null != g && (v.maxzoom = g),
                    this._updateLayer(v))
                  : this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `The layer '${a}' does not exist in the map's style and cannot have zoom extent.`
                        )
                      )
                    );
              }
              setFilter(a, u, g = {}) {
                this._checkLoaded();
                const v = this.getLayer(a);
                if (v) {
                  if (!Be(v.filter, u))
                    return null == u
                      ? ((v.filter = void 0), void this._updateLayer(v))
                      : void (
                          this._validate(
                            d.validateFilter,
                            `layers.${v.id}.filter`,
                            u,
                            { layerType: v.type },
                            g
                          ) || ((v.filter = d.clone$1(u)), this._updateLayer(v))
                        );
                } else this.fire(new d.ErrorEvent(new Error(`The layer '${a}' does not exist in the map's style and cannot be filtered.`)));
              }
              getFilter(a) {
                const u = this.getLayer(a);
                return u && d.clone$1(u.filter);
              }
              setLayoutProperty(a, u, g, v = {}) {
                this._checkLoaded();
                const b = this.getLayer(a);
                b
                  ? Be(b.getLayoutProperty(u), g) ||
                    (b.setLayoutProperty(u, g, v), this._updateLayer(b))
                  : this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `The layer '${a}' does not exist in the map's style and cannot be styled.`
                        )
                      )
                    );
              }
              getLayoutProperty(a, u) {
                const g = this.getLayer(a);
                if (g) return g.getLayoutProperty(u);
                this.fire(
                  new d.ErrorEvent(
                    new Error(
                      `The layer '${a}' does not exist in the map's style.`
                    )
                  )
                );
              }
              setPaintProperty(a, u, g, v = {}) {
                this._checkLoaded();
                const b = this.getLayer(a);
                b
                  ? Be(b.getPaintProperty(u), g) ||
                    (b.setPaintProperty(u, g, v) && this._updateLayer(b),
                    (this._changed = !0),
                    (this._updatedPaintProps[a] = !0))
                  : this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `The layer '${a}' does not exist in the map's style and cannot be styled.`
                        )
                      )
                    );
              }
              getPaintProperty(a, u) {
                const g = this.getLayer(a);
                return g && g.getPaintProperty(u);
              }
              setFeatureState(a, u) {
                this._checkLoaded();
                const g = a.source,
                  v = a.sourceLayer,
                  b = this.getSource(g);
                if (!b)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The source '${g}' does not exist in the map's style.`
                      )
                    )
                  );
                const D = b.type;
                if ("geojson" === D && v)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "GeoJSON sources cannot have a sourceLayer parameter."
                      )
                    )
                  );
                if ("vector" === D && !v)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                void 0 === a.id &&
                  this.fire(
                    new d.ErrorEvent(
                      new Error("The feature id parameter must be provided.")
                    )
                  );
                const S = this._getSourceCaches(g);
                for (const M of S) M.setFeatureState(v, a.id, u);
              }
              removeFeatureState(a, u) {
                this._checkLoaded();
                const g = a.source,
                  v = this.getSource(g);
                if (!v)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The source '${g}' does not exist in the map's style.`
                      )
                    )
                  );
                const b = v.type,
                  D = "vector" === b ? a.sourceLayer : void 0;
                if ("vector" === b && !D)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                if (u && "string" != typeof a.id && "number" != typeof a.id)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "A feature id is required to remove its specific state property."
                      )
                    )
                  );
                const S = this._getSourceCaches(g);
                for (const M of S) M.removeFeatureState(D, a.id, u);
              }
              getFeatureState(a) {
                this._checkLoaded();
                const u = a.source,
                  g = a.sourceLayer,
                  v = this.getSource(u);
                if (v) {
                  if ("vector" !== v.type || g)
                    return (
                      void 0 === a.id &&
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              "The feature id parameter must be provided."
                            )
                          )
                        ),
                      this._getSourceCaches(u)[0].getFeatureState(g, a.id)
                    );
                  this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                } else this.fire(new d.ErrorEvent(new Error(`The source '${u}' does not exist in the map's style.`)));
              }
              getTransition() {
                return d.extend(
                  { duration: 300, delay: 0 },
                  this.stylesheet && this.stylesheet.transition
                );
              }
              serialize() {
                const a = {};
                for (const u in this._sourceCaches) {
                  const g = this._sourceCaches[u].getSource();
                  a[g.id] || (a[g.id] = g.serialize());
                }
                return d.filterObject(
                  {
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.getTerrain() || void 0,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: a,
                    layers: this._serializeLayers(this._order),
                  },
                  (u) => void 0 !== u
                );
              }
              _updateLayer(a) {
                this._updatedLayers[a.id] = !0;
                const u = this._getLayerSourceCache(a);
                a.source &&
                  !this._updatedSources[a.source] &&
                  u &&
                  "raster" !== u.getSource().type &&
                  ((this._updatedSources[a.source] = "reload"), u.pause()),
                  (this._changed = !0),
                  a.invalidateCompiledFilter();
              }
              _flattenAndSortRenderedFeatures(a) {
                const u = (D) => "fill-extrusion" === this._layers[D].type,
                  g = {},
                  v = [];
                for (let D = this._order.length - 1; D >= 0; D--) {
                  const S = this._order[D];
                  if (u(S)) {
                    g[S] = D;
                    for (const M of a) {
                      const R = M[S];
                      if (R) for (const k of R) v.push(k);
                    }
                  }
                }
                v.sort((D, S) => S.intersectionZ - D.intersectionZ);
                const b = [];
                for (let D = this._order.length - 1; D >= 0; D--) {
                  const S = this._order[D];
                  if (u(S))
                    for (let M = v.length - 1; M >= 0; M--) {
                      const R = v[M].feature;
                      if (g[R.layer.id] < D) break;
                      b.push(R), v.pop();
                    }
                  else
                    for (const M of a) {
                      const R = M[S];
                      if (R) for (const k of R) b.push(k.feature);
                    }
                }
                return b;
              }
              queryRenderedFeatures(a, u, g) {
                u &&
                  u.filter &&
                  this._validate(
                    d.validateFilter,
                    "queryRenderedFeatures.filter",
                    u.filter,
                    null,
                    u
                  );
                const v = {};
                if (u && u.layers) {
                  if (!Array.isArray(u.layers))
                    return (
                      this.fire(
                        new d.ErrorEvent(
                          new Error("parameters.layers must be an Array.")
                        )
                      ),
                      []
                    );
                  for (const M of u.layers) {
                    const R = this._layers[M];
                    if (!R)
                      return (
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              `The layer '${M}' does not exist in the map's style and cannot be queried for features.`
                            )
                          )
                        ),
                        []
                      );
                    v[R.source] = !0;
                  }
                }
                const b = [];
                u.availableImages = this._availableImages;
                const D =
                    u && u.layers
                      ? u.layers.some((M) => {
                          const R = this.getLayer(M);
                          return R && R.is3D();
                        })
                      : this.has3DLayers(),
                  S = Rs.createFromScreenPoints(a, g);
                for (const M in this._sourceCaches) {
                  const R = this._sourceCaches[M].getSource().id;
                  (u.layers && !v[R]) ||
                    b.push(
                      Zn(
                        this._sourceCaches[M],
                        this._layers,
                        this._serializedLayers,
                        S,
                        u,
                        g,
                        D,
                        !!this.map._showQueryGeometry
                      )
                    );
                }
                return (
                  this.placement &&
                    b.push(
                      (function (M, R, k, z, H, q, X) {
                        const Z = {},
                          Y = q.queryRenderedSymbols(z),
                          B = [];
                        for (const W of Object.keys(Y).map(Number))
                          B.push(X[W]);
                        B.sort(Ki);
                        for (const W of B) {
                          const ee = W.featureIndex.lookupSymbolFeatures(
                            Y[W.bucketInstanceId],
                            R,
                            W.bucketIndex,
                            W.sourceLayerIndex,
                            H.filter,
                            H.layers,
                            H.availableImages,
                            M
                          );
                          for (const te in ee) {
                            const he = (Z[te] = Z[te] || []),
                              de = ee[te];
                            de.sort((ue, _e) => {
                              const ge = W.featureSortOrder;
                              if (ge) {
                                const Te = ge.indexOf(ue.featureIndex);
                                return ge.indexOf(_e.featureIndex) - Te;
                              }
                              return _e.featureIndex - ue.featureIndex;
                            });
                            for (const ue of de) he.push(ue);
                          }
                        }
                        for (const W in Z)
                          Z[W].forEach((ee) => {
                            const te = ee.feature,
                              he = k(M[W]);
                            if (!he) return;
                            const de = he.getFeatureState(
                              te.layer["source-layer"],
                              te.id
                            );
                            (te.source = te.layer.source),
                              te.layer["source-layer"] &&
                                (te.sourceLayer = te.layer["source-layer"]),
                              (te.state = de);
                          });
                        return Z;
                      })(
                        this._layers,
                        this._serializedLayers,
                        this._getLayerSourceCache.bind(this),
                        S.screenGeometry,
                        u,
                        this.placement.collisionIndex,
                        this.placement.retainedQueryData
                      )
                    ),
                  this._flattenAndSortRenderedFeatures(b)
                );
              }
              querySourceFeatures(a, u) {
                u &&
                  u.filter &&
                  this._validate(
                    d.validateFilter,
                    "querySourceFeatures.filter",
                    u.filter,
                    null,
                    u
                  );
                const g = this._getSourceCaches(a);
                let v = [];
                for (const b of g) v = v.concat(fi(b, u));
                return v;
              }
              addSourceType(a, u, g) {
                return vo.getSourceType(a)
                  ? g(new Error(`A source type called "${a}" already exists.`))
                  : (vo.setSourceType(a, u),
                    u.workerSourceURL
                      ? void this.dispatcher.broadcast(
                          "loadWorkerSource",
                          { name: a, url: u.workerSourceURL },
                          g
                        )
                      : g(null, null));
              }
              getLight() {
                return this.light.getLight();
              }
              setLight(a, u = {}) {
                this._checkLoaded();
                const g = this.light.getLight();
                let v = !1;
                for (const D in a)
                  if (!Be(a[D], g[D])) {
                    v = !0;
                    break;
                  }
                if (!v) return;
                const b = this._setTransitionParameters({
                  duration: 300,
                  delay: 0,
                });
                this.light.setLight(a, u), this.light.updateTransitions(b);
              }
              getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode
                  ? this.terrain.get()
                  : null;
              }
              setTerrainForDraping() {
                this.setTerrain({ source: "", exaggeration: 0 }, 0);
              }
              setTerrain(a, u = 1) {
                if ((this._checkLoaded(), !a))
                  return (
                    delete this.terrain,
                    delete this.stylesheet.terrain,
                    this.dispatcher.broadcast("enableTerrain", !1),
                    this._force3DLayerUpdate(),
                    void (this._markersNeedUpdate = !0)
                  );
                let g = a;
                if (1 === u) {
                  if ("object" == typeof g.source) {
                    const v = "terrain-dem-src";
                    this.addSource(v, g.source),
                      (g = d.clone$1(g)),
                      (g = d.extend(g, { source: v }));
                  }
                  if (this._validate(d.validateTerrain, "terrain", g)) return;
                }
                if (
                  !this.terrain ||
                  (this.terrain && u !== this.terrain.drapeRenderMode)
                ) {
                  if (!g) return;
                  this._createTerrain(g, u);
                } else {
                  const v = this.terrain,
                    b = v.get();
                  for (const D of Object.keys(d.spec.terrain))
                    !g.hasOwnProperty(D) &&
                      d.spec.terrain[D].default &&
                      (g[D] = d.spec.terrain[D].default);
                  for (const D in g)
                    if (!Be(g[D], b[D])) {
                      v.set(g), (this.stylesheet.terrain = g);
                      const S = this._setTransitionParameters({ duration: 0 });
                      v.updateTransitions(S);
                      break;
                    }
                }
                this._updateDrapeFirstLayers(), (this._markersNeedUpdate = !0);
              }
              _createFog(a) {
                const u = (this.fog = new Ma(a, this.map.transform));
                this.stylesheet.fog = a;
                const g = this._setTransitionParameters({ duration: 0 });
                u.updateTransitions(g);
              }
              _updateMarkersOpacity() {
                0 !== this.map._markers.length &&
                  this.map._requestDomTask(() => {
                    for (const a of this.map._markers) a._evaluateOpacity();
                  });
              }
              getFog() {
                return this.fog ? this.fog.get() : null;
              }
              setFog(a) {
                if ((this._checkLoaded(), !a))
                  return (
                    delete this.fog,
                    delete this.stylesheet.fog,
                    void (this._markersNeedUpdate = !0)
                  );
                if (this.fog) {
                  const u = this.fog,
                    g = u.get();
                  0 === Object.keys(a).length && u.set(a);
                  for (const v in a)
                    if (!Be(a[v], g[v])) {
                      u.set(a), (this.stylesheet.fog = a);
                      const b = this._setTransitionParameters({ duration: 0 });
                      u.updateTransitions(b);
                      break;
                    }
                } else this._createFog(a);
                this._markersNeedUpdate = !0;
              }
              _setTransitionParameters(a) {
                return {
                  now: d.exported.now(),
                  transition: d.extend(a, this.stylesheet.transition),
                };
              }
              _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain) return;
                const a = this._order.filter((g) =>
                    this.isLayerDraped(this._layers[g])
                  ),
                  u = this._order.filter(
                    (g) => !this.isLayerDraped(this._layers[g])
                  );
                (this._drapedFirstOrder = []),
                  this._drapedFirstOrder.push(...a),
                  this._drapedFirstOrder.push(...u);
              }
              _createTerrain(a, u) {
                const g = (this.terrain = new cu(a, u));
                (this.stylesheet.terrain = a),
                  this.dispatcher.broadcast(
                    "enableTerrain",
                    !this.terrainSetForDrapingOnly()
                  ),
                  this._force3DLayerUpdate();
                const v = this._setTransitionParameters({ duration: 0 });
                g.updateTransitions(v);
              }
              _force3DLayerUpdate() {
                for (const a in this._layers) {
                  const u = this._layers[a];
                  "fill-extrusion" === u.type && this._updateLayer(u);
                }
              }
              _forceSymbolLayerUpdate() {
                for (const a in this._layers) {
                  const u = this._layers[a];
                  "symbol" === u.type && this._updateLayer(u);
                }
              }
              _validate(a, u, g, v, b = {}) {
                return (
                  (!b || !1 !== b.validate) &&
                  yo(
                    this,
                    a.call(
                      d.validateStyle,
                      d.extend(
                        {
                          key: u,
                          style: this.serialize(),
                          value: g,
                          styleSpec: d.spec,
                        },
                        v
                      )
                    )
                  )
                );
              }
              _remove() {
                this._request &&
                  (this._request.cancel(), (this._request = null)),
                  this._spriteRequest &&
                    (this._spriteRequest.cancel(),
                    (this._spriteRequest = null)),
                  d.evented.off(
                    "pluginStateChange",
                    this._rtlTextPluginCallback
                  );
                for (const a in this._layers)
                  this._layers[a].setEventedParent(null);
                for (const a in this._sourceCaches)
                  this._sourceCaches[a].clearTiles(),
                    this._sourceCaches[a].setEventedParent(null);
                this.imageManager.setEventedParent(null),
                  this.setEventedParent(null),
                  this.dispatcher.remove();
              }
              _clearSource(a) {
                const u = this._getSourceCaches(a);
                for (const g of u) g.clearTiles();
              }
              _reloadSource(a) {
                const u = this._getSourceCaches(a);
                for (const g of u) g.resume(), g.reload();
              }
              _reloadSources() {
                for (const a of this._getSources()) a.reload && a.reload();
              }
              _updateSources(a) {
                for (const u in this._sourceCaches)
                  this._sourceCaches[u].update(a);
              }
              _generateCollisionBoxes() {
                for (const a in this._sourceCaches) {
                  const u = this._sourceCaches[a];
                  u.resume(), u.reload();
                }
              }
              _updatePlacement(a, u, g, v, b = !1) {
                let D = !1,
                  S = !1;
                const M = {};
                for (const R of this._order) {
                  const k = this._layers[R];
                  if ("symbol" !== k.type) continue;
                  if (!M[k.source]) {
                    const H = this._getLayerSourceCache(k);
                    if (!H) continue;
                    M[k.source] = H.getRenderableIds(!0)
                      .map((q) => H.getTileByID(q))
                      .sort(
                        (q, X) =>
                          X.tileID.overscaledZ - q.tileID.overscaledZ ||
                          (q.tileID.isLessThan(X.tileID) ? -1 : 1)
                      );
                  }
                  const z = this.crossTileSymbolIndex.addLayer(
                    k,
                    M[k.source],
                    a.center.lng,
                    a.projection
                  );
                  D = D || z;
                }
                if (
                  (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                  (b = b || this._layerOrderChanged || 0 === g),
                  this._layerOrderChanged && this.fire(new d.Event("neworder")),
                  (b ||
                    !this.pauseablePlacement ||
                    (this.pauseablePlacement.isDone() &&
                      !this.placement.stillRecent(d.exported.now(), a.zoom))) &&
                    ((this.pauseablePlacement = new up(
                      a,
                      this._order,
                      b,
                      u,
                      g,
                      v,
                      this.placement,
                      this.fog && a.projection.supportsFog
                        ? this.fog.state
                        : null
                    )),
                    (this._layerOrderChanged = !1)),
                  this.pauseablePlacement.isDone()
                    ? this.placement.setStale()
                    : (this.pauseablePlacement.continuePlacement(
                        this._order,
                        this._layers,
                        M
                      ),
                      this.pauseablePlacement.isDone() &&
                        ((this.placement = this.pauseablePlacement.commit(
                          d.exported.now()
                        )),
                        (S = !0)),
                      D && this.pauseablePlacement.placement.setStale()),
                  S || D)
                )
                  for (const R of this._order) {
                    const k = this._layers[R];
                    "symbol" === k.type &&
                      this.placement.updateLayerOpacities(k, M[k.source]);
                  }
                return (
                  !this.pauseablePlacement.isDone() ||
                  this.placement.hasTransitions(d.exported.now())
                );
              }
              _releaseSymbolFadeTiles() {
                for (const a in this._sourceCaches)
                  this._sourceCaches[a].releaseSymbolFadeTiles();
              }
              getImages(a, u, g) {
                this.imageManager.getImages(u.icons, g),
                  this._updateTilesForChangedImages();
                const v = (b) => {
                  b && b.setDependencies(u.tileID.key, u.type, u.icons);
                };
                v(this._otherSourceCaches[u.source]),
                  v(this._symbolSourceCaches[u.source]);
              }
              getGlyphs(a, u, g) {
                this.glyphManager.getGlyphs(u.stacks, g);
              }
              getResource(a, u, g) {
                return d.makeRequest(u, g);
              }
              _getSourceCache(a) {
                return this._otherSourceCaches[a];
              }
              _getLayerSourceCache(a) {
                return "symbol" === a.type
                  ? this._symbolSourceCaches[a.source]
                  : this._otherSourceCaches[a.source];
              }
              _getSourceCaches(a) {
                const u = [];
                return (
                  this._otherSourceCaches[a] &&
                    u.push(this._otherSourceCaches[a]),
                  this._symbolSourceCaches[a] &&
                    u.push(this._symbolSourceCaches[a]),
                  u
                );
              }
              _isSourceCacheLoaded(a) {
                const u = this._getSourceCaches(a);
                return 0 === u.length
                  ? (this.fire(
                      new d.ErrorEvent(
                        new Error(`There is no source with ID '${a}'`)
                      )
                    ),
                    !1)
                  : u.every((g) => g.loaded());
              }
              has3DLayers() {
                return this._num3DLayers > 0;
              }
              hasSymbolLayers() {
                return this._numSymbolLayers > 0;
              }
              hasCircleLayers() {
                return this._numCircleLayers > 0;
              }
              _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
              }
              destroy() {
                this._clearWorkerCaches(),
                  this.terrainSetForDrapingOnly() &&
                    (delete this.terrain, delete this.stylesheet.terrain);
              }
            }
            (vo.getSourceType = function (f) {
              return Ct[f];
            }),
              (vo.setSourceType = function (f, a) {
                Ct[f] = a;
              }),
              (vo.registerForPluginStateChange =
                d.registerForPluginStateChange);
            var Il =
                "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0",
              ds =
                "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",
              Uo =
                "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",
              gc =
                "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",
              St =
                "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
            let Ml = {},
              Al = {};
            const sr = [];
            _c(Il, sr),
              _c(Uo, sr),
              _c(gc, sr),
              _c(St, sr),
              (Ml = bn("", Uo)),
              (Al = bn(St, gc));
            const kh = bn(
                "\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}",
                "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."
              ),
              Rh = Il,
              $o =
                "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
            var qr = {
              background: bn(
                "uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              backgroundPattern: bn(
                "uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              circle: bn(
                "varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"
              ),
              clippingMask: bn(
                "void main() {gl_FragColor=vec4(1.0);}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"
              ),
              heatmap: bn(
                "uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              heatmapTexture: bn(
                "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}",
                "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"
              ),
              collisionBox: bn(
                "varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}",
                "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"
              ),
              collisionCircle: bn(
                "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}",
                "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"
              ),
              debug: bn(
                "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}",
                "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"
              ),
              fill: bn(
                "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillOutline: bn(
                "varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillOutlinePattern: bn(
                "uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillPattern: bn(
                "uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillExtrusion: bn(
                "varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              fillExtrusionPattern: bn(
                "uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"
              ),
              hillshadePrepare: bn(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"
              ),
              hillshade: bn(
                "uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              line: bn(
                "uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              linePattern: bn(
                "uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              raster: bn(
                "uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              symbolIcon: bn(
                "uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"
              ),
              symbolSDF: bn(
                "#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"
              ),
              symbolTextAndIcon: bn(
                "#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"
              ),
              terrainRaster: bn(
                "uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"
              ),
              terrainDepth: bn(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}",
                "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"
              ),
              skybox: bn(
                "\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                ds
              ),
              skyboxGradient: bn(
                "varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                ds
              ),
              skyboxCapture: bn(
                "\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}",
                "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"
              ),
              globeRaster: bn(
                "uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"
              ),
              globeAtmosphere: bn(
                "uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}",
                "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"
              ),
            };
            function _c(f, a) {
              const u = f.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
              for (let g of u)
                if (
                  ((g = g.trim()),
                  "#" === g[0] && g.includes("if") && !g.includes("endif"))
                ) {
                  g = g
                    .replace("#", "")
                    .replace(/ifdef|ifndef|elif|if/g, "")
                    .replace(/!|defined|\(|\)|\|\||&&/g, "")
                    .replace(/\s+/g, " ")
                    .trim();
                  const v = g.split(" ");
                  for (const b of v) a.includes(b) || a.push(b);
                }
            }
            function bn(f, a) {
              const u = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
                g = a.match(
                  /attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g
                ),
                v = {},
                b = [...sr];
              return (
                _c(f, b),
                _c(a, b),
                {
                  fragmentSource: (f = f.replace(
                    u,
                    (D, S, M, R, k) => (
                      (v[k] = !0),
                      "define" === S
                        ? `\n#ifndef HAS_UNIFORM_u_${k}\nvarying ${M} ${R} ${k};\n#else\nuniform ${M} ${R} u_${k};\n#endif\n`
                        : `\n#ifdef HAS_UNIFORM_u_${k}\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                    )
                  )),
                  vertexSource: (a = a.replace(u, (D, S, M, R, k) => {
                    const z = "float" === R ? "vec2" : "vec4",
                      H = k.match(/color/) ? "color" : z;
                    return v[k]
                      ? "define" === S
                        ? `\n#ifndef HAS_UNIFORM_u_${k}\nuniform lowp float u_${k}_t;\nattribute ${M} ${z} a_${k};\nvarying ${M} ${R} ${k};\n#else\nuniform ${M} ${R} u_${k};\n#endif\n`
                        : "vec4" === H
                        ? `\n#ifndef HAS_UNIFORM_u_${k}\n    ${k} = a_${k};\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                        : `\n#ifndef HAS_UNIFORM_u_${k}\n    ${k} = unpack_mix_${H}(a_${k}, u_${k}_t);\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                      : "define" === S
                      ? `\n#ifndef HAS_UNIFORM_u_${k}\nuniform lowp float u_${k}_t;\nattribute ${M} ${z} a_${k};\n#else\nuniform ${M} ${R} u_${k};\n#endif\n`
                      : "vec4" === H
                      ? `\n#ifndef HAS_UNIFORM_u_${k}\n    ${M} ${R} ${k} = a_${k};\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                      : `\n#ifndef HAS_UNIFORM_u_${k}\n    ${M} ${R} ${k} = unpack_mix_${H}(a_${k}, u_${k}_t);\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`;
                  })),
                  staticAttributes: g,
                  usedDefines: b,
                }
              );
            }
            class xo {
              constructor() {
                (this.boundProgram = null),
                  (this.boundLayoutVertexBuffer = null),
                  (this.boundPaintVertexBuffers = []),
                  (this.boundIndexBuffer = null),
                  (this.boundVertexOffset = null),
                  (this.boundDynamicVertexBuffers = []),
                  (this.vao = null);
              }
              bind(a, u, g, v, b, D, S) {
                this.context = a;
                let M = this.boundPaintVertexBuffers.length !== v.length;
                for (let k = 0; !M && k < v.length; k++)
                  this.boundPaintVertexBuffers[k] !== v[k] && (M = !0);
                let R = this.boundDynamicVertexBuffers.length !== S.length;
                for (let k = 0; !R && k < S.length; k++)
                  this.boundDynamicVertexBuffers[k] !== S[k] && (R = !0);
                if (
                  !a.extVertexArrayObject ||
                  !this.vao ||
                  this.boundProgram !== u ||
                  this.boundLayoutVertexBuffer !== g ||
                  M ||
                  R ||
                  this.boundIndexBuffer !== b ||
                  this.boundVertexOffset !== D
                )
                  this.freshBind(u, g, v, b, D, S);
                else {
                  a.bindVertexArrayOES.set(this.vao);
                  for (const k of S) k && k.bind();
                  b && b.dynamicDraw && b.bind();
                }
              }
              freshBind(a, u, g, v, b, D) {
                let S;
                const M = a.numAttributes,
                  R = this.context,
                  k = R.gl;
                if (R.extVertexArrayObject)
                  this.vao && this.destroy(),
                    (this.vao = R.extVertexArrayObject.createVertexArrayOES()),
                    R.bindVertexArrayOES.set(this.vao),
                    (S = 0),
                    (this.boundProgram = a),
                    (this.boundLayoutVertexBuffer = u),
                    (this.boundPaintVertexBuffers = g),
                    (this.boundIndexBuffer = v),
                    (this.boundVertexOffset = b),
                    (this.boundDynamicVertexBuffers = D);
                else {
                  S = R.currentNumAttributes || 0;
                  for (let z = M; z < S; z++) k.disableVertexAttribArray(z);
                }
                u.enableAttributes(k, a),
                  u.bind(),
                  u.setVertexAttribPointers(k, a, b);
                for (const z of g)
                  z.enableAttributes(k, a),
                    z.bind(),
                    z.setVertexAttribPointers(k, a, b);
                for (const z of D)
                  z &&
                    (z.enableAttributes(k, a),
                    z.bind(),
                    z.setVertexAttribPointers(k, a, b));
                v && v.bind(), (R.currentNumAttributes = M);
              }
              destroy() {
                this.vao &&
                  (this.context.extVertexArrayObject.deleteVertexArrayOES(
                    this.vao
                  ),
                  (this.vao = null));
              }
            }
            function $n(f, a) {
              const u = Math.pow(2, a.canonical.z),
                g = a.canonical.y;
              return [
                new d.MercatorCoordinate(0, g / u).toLngLat().lat,
                new d.MercatorCoordinate(0, (g + 1) / u).toLngLat().lat,
              ];
            }
            function kf(f, a, u, g, v, b, D) {
              const S = f.context,
                M = S.gl,
                R = u.fbo;
              if (!R) return;
              f.prepareDrawTile();
              const k = f.useProgram("hillshade");
              S.activeTexture.set(M.TEXTURE0),
                M.bindTexture(M.TEXTURE_2D, R.colorAttachment.get());
              const z = ((Z, Y, B, W) => {
                const ee = B.paint.get("hillshade-shadow-color"),
                  te = B.paint.get("hillshade-highlight-color"),
                  he = B.paint.get("hillshade-accent-color");
                let de =
                  B.paint.get("hillshade-illumination-direction") *
                  (Math.PI / 180);
                "viewport" === B.paint.get("hillshade-illumination-anchor") &&
                  (de -= Z.transform.angle);
                const ue = !Z.options.moving;
                return {
                  u_matrix:
                    W ||
                    Z.transform.calculateProjMatrix(Y.tileID.toUnwrapped(), ue),
                  u_image: 0,
                  u_latrange: $n(0, Y.tileID),
                  u_light: [B.paint.get("hillshade-exaggeration"), de],
                  u_shadow: ee,
                  u_highlight: te,
                  u_accent: he,
                };
              })(f, u, g, f.terrain ? a.projMatrix : null);
              f.prepareDrawProgram(S, k, a.toUnwrapped());
              const {
                tileBoundsBuffer: H,
                tileBoundsIndexBuffer: q,
                tileBoundsSegments: X,
              } = f.getTileBoundsBuffers(u);
              k.draw(
                S,
                M.TRIANGLES,
                v,
                b,
                D,
                d.CullFaceMode.disabled,
                z,
                g.id,
                H,
                q,
                X
              );
            }
            function pp(f, a, u) {
              if (!a.needsDEMTextureUpload) return;
              const g = f.context,
                v = g.gl;
              g.pixelStoreUnpackPremultiplyAlpha.set(!1),
                (a.demTexture = a.demTexture || f.getTileTexture(u.stride));
              const b = u.getPixels();
              a.demTexture
                ? a.demTexture.update(b, { premultiply: !1 })
                : (a.demTexture = new d.Texture(g, b, v.RGBA, {
                    premultiply: !1,
                  })),
                (a.needsDEMTextureUpload = !1);
            }
            function Oa(f, a, u, g, v, b) {
              const D = f.context,
                S = D.gl;
              if (!a.dem) return;
              const M = a.dem;
              if ((D.activeTexture.set(S.TEXTURE1), pp(f, a, M), !a.demTexture))
                return;
              a.demTexture.bind(S.NEAREST, S.CLAMP_TO_EDGE);
              const R = M.dim;
              D.activeTexture.set(S.TEXTURE0);
              let k = a.fbo;
              if (!k) {
                const X = new d.Texture(
                  D,
                  { width: R, height: R, data: null },
                  S.RGBA
                );
                X.bind(S.LINEAR, S.CLAMP_TO_EDGE),
                  (k = a.fbo = D.createFramebuffer(R, R, !0)),
                  k.colorAttachment.set(X.texture);
              }
              D.bindFramebuffer.set(k.framebuffer),
                D.viewport.set([0, 0, R, R]);
              const {
                tileBoundsBuffer: z,
                tileBoundsIndexBuffer: H,
                tileBoundsSegments: q,
              } = f.getMercatorTileBoundsBuffers();
              f.useProgram("hillshadePrepare").draw(
                D,
                S.TRIANGLES,
                g,
                v,
                b,
                d.CullFaceMode.disabled,
                ((X, Z) => {
                  const Y = Z.stride,
                    B = d.create();
                  return (
                    d.ortho(B, 0, d.EXTENT, -d.EXTENT, 0, 0, 1),
                    d.translate(B, B, [0, -d.EXTENT, 0]),
                    {
                      u_matrix: B,
                      u_image: 1,
                      u_dimension: [Y, Y],
                      u_zoom: X.overscaledZ,
                      u_unpack: Z.unpackVector,
                    }
                  );
                })(a.tileID, M),
                u.id,
                z,
                H,
                q
              ),
                (a.needsHillshadePrepare = !1);
            }
            const wn = (f) => ({
                u_matrix: new d.UniformMatrix4f(f),
                u_image0: new d.Uniform1i(f),
                u_skirt_height: new d.Uniform1f(f),
              }),
              ps = (f, a) => ({ u_matrix: f, u_image0: 0, u_skirt_height: a }),
              Pl = (f, a, u, g, v, b, D, S, M, R, k, z, H, q, X) => ({
                u_proj_matrix: Float32Array.from(f),
                u_globe_matrix: a,
                u_normalize_matrix: Float32Array.from(g),
                u_merc_matrix: u,
                u_zoom_transition: v,
                u_merc_center: b,
                u_image0: 0,
                u_frustum_tl: D,
                u_frustum_tr: S,
                u_frustum_br: M,
                u_frustum_bl: R,
                u_globe_pos: k,
                u_globe_radius: z,
                u_viewport: H,
                u_grid_matrix: X ? Float32Array.from(X) : new Float32Array(9),
                u_skirt_height: q,
              });
            function Us(f, a) {
              return (
                null != f &&
                null != a &&
                !(!f.hasData() || !a.hasData()) &&
                null != f.demTexture &&
                null != a.demTexture &&
                f.tileID.key !== a.tileID.key
              );
            }
            const Ho = new (class {
                constructor() {
                  this.operations = {};
                }
                newMorphing(f, a, u, g, v) {
                  if (f in this.operations) {
                    const b = this.operations[f];
                    b.to.tileID.key !== u.tileID.key && (b.queued = u);
                  } else
                    this.operations[f] = {
                      startTime: g,
                      phase: 0,
                      duration: v,
                      from: a,
                      to: u,
                      queued: null,
                    };
                }
                getMorphValuesForProxy(f) {
                  if (!(f in this.operations)) return null;
                  const a = this.operations[f];
                  return { from: a.from, to: a.to, phase: a.phase };
                }
                update(f) {
                  for (const a in this.operations) {
                    const u = this.operations[a];
                    for (
                      u.phase = (f - u.startTime) / u.duration;
                      u.phase >= 1 || !this._validOp(u);

                    )
                      if (!this._nextOp(u, f)) {
                        delete this.operations[a];
                        break;
                      }
                  }
                }
                _nextOp(f, a) {
                  return (
                    !!f.queued &&
                    ((f.from = f.to),
                    (f.to = f.queued),
                    (f.queued = null),
                    (f.phase = 0),
                    (f.startTime = a),
                    !0)
                  );
                }
                _validOp(f) {
                  return f.from.hasData() && f.to.hasData();
                }
              })(),
              vr = {
                0: null,
                1: "TERRAIN_VERTEX_MORPHING",
                2: "TERRAIN_WIREFRAME",
              };
            function $s(f) {
              return 6 * Math.pow(1.5, 22 - f);
            }
            function fp(f, a) {
              const u = 1 << f.z;
              return (
                (!a && (0 === f.x || f.x === u - 1)) ||
                0 === f.y ||
                f.y === u - 1
              );
            }
            const Yi = (f) => ({ u_matrix: f });
            function Oh(f, a, u, g, v) {
              if (v > 0) {
                const b = d.exported.now(),
                  D = (b - f.timeAdded) / v,
                  S = a ? (b - a.timeAdded) / v : -1,
                  M = u.getSource(),
                  R = g.coveringZoomLevel({
                    tileSize: M.tileSize,
                    roundZoom: M.roundZoom,
                  }),
                  k =
                    !a ||
                    Math.abs(a.tileID.overscaledZ - R) >
                      Math.abs(f.tileID.overscaledZ - R),
                  z =
                    k && f.refreshedUponExpiration
                      ? 1
                      : d.clamp(k ? D : 1 - S, 0, 1);
                return (
                  f.refreshedUponExpiration &&
                    D >= 1 &&
                    (f.refreshedUponExpiration = !1),
                  a ? { opacity: 1, mix: 1 - z } : { opacity: z, mix: 0 }
                );
              }
              return { opacity: 1, mix: 0 };
            }
            class bu extends d.SourceCache {
              constructor(a) {
                const u = { type: "raster-dem", maxzoom: a.transform.maxZoom },
                  g = new Tn(ka(), null),
                  v = Zt("mock-dem", u, g, a.style);
                super("mock-dem", v, !1),
                  v.setEventedParent(this),
                  (this._sourceLoaded = !0);
              }
              _loadTile(a, u) {
                (a.state = "loaded"), u(null);
              }
            }
            class yc extends d.SourceCache {
              constructor(a) {
                const u = Zt(
                  "proxy",
                  { type: "geojson", maxzoom: a.transform.maxZoom },
                  new Tn(ka(), null),
                  a.style
                );
                super("proxy", u, !1),
                  u.setEventedParent(this),
                  (this.map = this.getSource().map = a),
                  (this.used = this._sourceLoaded = !0),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
              update(a, u, g) {
                if (a.freezeTileCoverage) return;
                this.transform = a;
                const v = a
                  .coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled,
                  })
                  .reduce((b, D) => {
                    if (((b[D.key] = ""), !this._tiles[D.key])) {
                      const S = new d.Tile(
                        D,
                        this._source.tileSize * D.overscaleFactor(),
                        a.tileZoom
                      );
                      (S.state = "loaded"), (this._tiles[D.key] = S);
                    }
                    return b;
                  }, {});
                for (const b in this._tiles)
                  b in v ||
                    (this.freeFBO(b),
                    this._tiles[b].unloadVectorData(),
                    delete this._tiles[b]);
              }
              freeFBO(a) {
                const u = this.proxyCachedFBO[a];
                if (void 0 !== u) {
                  const g = Object.values(u);
                  this.renderCachePool.push(...g),
                    delete this.proxyCachedFBO[a];
                }
              }
              deallocRenderCache() {
                this.renderCache.forEach((a) => a.fb.destroy()),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
            }
            class ar extends d.OverscaledTileID {
              constructor(a, u, g) {
                super(
                  a.overscaledZ,
                  a.wrap,
                  a.canonical.z,
                  a.canonical.x,
                  a.canonical.y
                ),
                  (this.proxyTileKey = u),
                  (this.projMatrix = g);
              }
            }
            class Fh extends d.Elevation {
              constructor(a, u) {
                super(),
                  (this.painter = a),
                  (this.terrainTileForTile = {}),
                  (this.prevTerrainTileForTile = {});
                const [g, v, b] = (function (M) {
                    const R = new d.StructArrayLayout2i4(),
                      k = new d.StructArrayLayout3ui6(),
                      z = 131;
                    R.reserve(17161), k.reserve(33800);
                    const H = d.EXTENT / 128,
                      q = d.EXTENT + H / 2,
                      X = q + H;
                    for (let Y = -H; Y < X; Y += H)
                      for (let B = -H; B < X; B += H) {
                        const W = B < 0 || B > q || Y < 0 || Y > q ? 24575 : 0,
                          ee = d.clamp(Math.round(B), 0, d.EXTENT),
                          te = d.clamp(Math.round(Y), 0, d.EXTENT);
                        R.emplaceBack(ee + W, te);
                      }
                    const Z = (Y, B) => {
                      const W = B * z + Y;
                      k.emplaceBack(W + 1, W, W + z),
                        k.emplaceBack(W + z, W + z + 1, W + 1);
                    };
                    for (let Y = 1; Y < 129; Y++)
                      for (let B = 1; B < 129; B++) Z(B, Y);
                    return (
                      [0, 129].forEach((Y) => {
                        for (let B = 0; B < 130; B++) Z(B, Y), Z(Y, B);
                      }),
                      [R, k, 32768]
                    );
                  })(),
                  D = a.context;
                (this.gridBuffer = D.createVertexBuffer(
                  g,
                  d.posAttributes.members
                )),
                  (this.gridIndexBuffer = D.createIndexBuffer(v)),
                  (this.gridSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    g.length,
                    v.length
                  )),
                  (this.gridNoSkirtSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    g.length,
                    b
                  )),
                  (this.proxyCoords = []),
                  (this.proxiedCoords = {}),
                  (this._visibleDemTiles = []),
                  (this._drapedRenderBatches = []),
                  (this._sourceTilesOverlap = {}),
                  (this.proxySourceCache = new yc(u.map)),
                  (this.orthoMatrix = d.create()),
                  d.ortho(
                    this.orthoMatrix,
                    "globe" === this.painter.transform.projection.name
                      ? 0.015
                      : 0,
                    d.EXTENT,
                    0,
                    d.EXTENT,
                    0,
                    1
                  );
                const S = D.gl;
                (this._overlapStencilMode = new d.StencilMode(
                  { func: S.GEQUAL, mask: 255 },
                  0,
                  255,
                  S.KEEP,
                  S.KEEP,
                  S.REPLACE
                )),
                  (this._previousZoom = a.transform.zoom),
                  (this.pool = []),
                  (this._findCoveringTileCache = {}),
                  (this._tilesDirty = {}),
                  (this.style = u),
                  (this._useVertexMorphing = !0),
                  (this._exaggeration = 1),
                  (this._mockSourceCache = new bu(u.map));
              }
              set style(a) {
                a.on("data", this._onStyleDataEvent.bind(this)),
                  a.on("neworder", this._checkRenderCacheEfficiency.bind(this)),
                  (this._style = a),
                  this._checkRenderCacheEfficiency(),
                  this._style.map.on("moveend", () => {
                    this._clearLineLayersFromRenderCache();
                  });
              }
              update(a, u, g) {
                if (a && a.terrain) {
                  this._style !== a && (this.style = a), (this.enabled = !0);
                  const v = a.terrain.properties;
                  (this.sourceCache =
                    0 === a.terrain.drapeRenderMode
                      ? this._mockSourceCache
                      : a._getSourceCache(v.get("source"))),
                    (this._exaggeration = v.get("exaggeration"));
                  const b = () => {
                    this.sourceCache.used &&
                      d.warnOnce(
                        `Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`
                      );
                    const D = this.getScaledDemTileSize();
                    this.sourceCache.update(u, D, !0),
                      this.resetTileLookupCache(this.sourceCache.id);
                  };
                  this.sourceCache.usedForTerrain ||
                    (this.resetTileLookupCache(this.sourceCache.id),
                    (this.sourceCache.usedForTerrain = !0),
                    b(),
                    (this._initializing = !0)),
                    b(),
                    u.updateElevation(!0, g),
                    this.resetTileLookupCache(this.proxySourceCache.id),
                    this.proxySourceCache.update(u),
                    (this._emptyDEMTextureDirty = !0);
                } else this._disable();
              }
              resetTileLookupCache(a) {
                this._findCoveringTileCache[a] = {};
              }
              getScaledDemTileSize() {
                return (
                  (this.sourceCache.getSource().tileSize / 128) *
                  this.proxySourceCache.getSource().tileSize
                );
              }
              _checkRenderCacheEfficiency() {
                const a = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain ||
                  (100 !== a.efficiency &&
                    d.warnOnce(
                      `Terrain render cache efficiency is not optimal (${a.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${a.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`
                    ));
              }
              _onStyleDataEvent(a) {
                a.coord && "source" === a.dataType
                  ? this._clearRenderCacheForTile(a.sourceCacheId, a.coord)
                  : "style" === a.dataType &&
                    (this._invalidateRenderCache = !0);
              }
              _disable() {
                if (
                  this.enabled &&
                  ((this.enabled = !1),
                  (this._sharedDepthStencil = void 0),
                  this.proxySourceCache.deallocRenderCache(),
                  this._style)
                )
                  for (const a in this._style._sourceCaches)
                    this._style._sourceCaches[a].usedForTerrain = !1;
              }
              destroy() {
                this._disable(),
                  this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                  this._emptyDepthBufferTexture &&
                    this._emptyDepthBufferTexture.destroy(),
                  this.pool.forEach((a) => a.fb.destroy()),
                  (this.pool = []),
                  this._depthFBO &&
                    (this._depthFBO.destroy(),
                    (this._depthFBO = void 0),
                    (this._depthTexture = void 0));
              }
              _source() {
                return this.enabled ? this.sourceCache : null;
              }
              isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
              }
              exaggeration() {
                return this._exaggeration;
              }
              get visibleDemTiles() {
                return this._visibleDemTiles;
              }
              get drapeBufferSize() {
                const a = 2 * this.proxySourceCache.getSource().tileSize;
                return [a, a];
              }
              set useVertexMorphing(a) {
                this._useVertexMorphing = a;
              }
              updateTileBinding(a) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const u = this.proxySourceCache,
                  g = this.painter.transform;
                this._initializing &&
                  ((this._initializing =
                    0 === g._centerAltitude &&
                    -1 ===
                      this.getAtPointOrZero(
                        d.MercatorCoordinate.fromLngLat(g.center),
                        -1
                      )),
                  (this._emptyDEMTextureDirty = !this._initializing));
                const v = (this.proxyCoords = u.getIds().map((M) => {
                  const R = u.getTileByID(M).tileID;
                  return (
                    (R.projMatrix = g.calculateProjMatrix(R.toUnwrapped())), R
                  );
                }));
                (function (M, R) {
                  const k = R.transform.pointCoordinate(
                      R.transform.getCameraPoint()
                    ),
                    z = new d.Point(k.x, k.y);
                  M.sort((H, q) => {
                    if (q.overscaledZ - H.overscaledZ)
                      return q.overscaledZ - H.overscaledZ;
                    const X = new d.Point(
                        H.canonical.x + (1 << H.canonical.z) * H.wrap,
                        H.canonical.y
                      ),
                      Z = new d.Point(
                        q.canonical.x + (1 << q.canonical.z) * q.wrap,
                        q.canonical.y
                      ),
                      Y = z.mult(1 << H.canonical.z);
                    return (
                      (Y.x -= 0.5), (Y.y -= 0.5), Y.distSqr(X) - Y.distSqr(Z)
                    );
                  });
                })(v, this.painter),
                  (this._previousZoom = g.zoom);
                const b = this.proxyToSource || {};
                (this.proxyToSource = {}),
                  v.forEach((M) => {
                    this.proxyToSource[M.key] = {};
                  }),
                  (this.terrainTileForTile = {});
                const D = this._style._sourceCaches;
                for (const M in D) {
                  const R = D[M];
                  if (
                    !R.used ||
                    (R !== this.sourceCache && this.resetTileLookupCache(R.id),
                    this._setupProxiedCoordsForOrtho(R, a[M], b),
                    R.usedForTerrain)
                  )
                    continue;
                  const k = a[M];
                  R.getSource().reparseOverscaled &&
                    this._assignTerrainTiles(k);
                }
                (this.proxiedCoords[u.id] = v.map(
                  (M) => new ar(M, M.key, this.orthoMatrix)
                )),
                  this._assignTerrainTiles(v),
                  this._prepareDEMTextures(),
                  this._setupDrapedRenderBatches(),
                  this._initFBOPool(),
                  this._setupRenderCache(b),
                  (this.renderingToTexture = !1),
                  (this._updateTimestamp = d.exported.now());
                const S = {};
                this._visibleDemTiles = [];
                for (const M of this.proxyCoords) {
                  const R = this.terrainTileForTile[M.key];
                  if (!R) continue;
                  const k = R.tileID.key;
                  k in S || (this._visibleDemTiles.push(R), (S[k] = k));
                }
              }
              _assignTerrainTiles(a) {
                this._initializing ||
                  a.forEach((u) => {
                    if (this.terrainTileForTile[u.key]) return;
                    const g = this._findTileCoveringTileID(u, this.sourceCache);
                    g && (this.terrainTileForTile[u.key] = g);
                  });
              }
              _prepareDEMTextures() {
                const a = this.painter.context,
                  u = a.gl;
                for (const g in this.terrainTileForTile) {
                  const v = this.terrainTileForTile[g],
                    b = v.dem;
                  !b ||
                    (v.demTexture && !v.needsDEMTextureUpload) ||
                    (a.activeTexture.set(u.TEXTURE1), pp(this.painter, v, b));
                }
              }
              _prepareDemTileUniforms(a, u, g, v) {
                if (!u || null == u.demTexture) return !1;
                const b = a.tileID.canonical,
                  D = Math.pow(2, u.tileID.canonical.z - b.z),
                  S = v || "";
                return (
                  (g[`u_dem_tl${S}`] = [(b.x * D) % 1, (b.y * D) % 1]),
                  (g[`u_dem_scale${S}`] = D),
                  !0
                );
              }
              get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture
                  ? this._emptyDEMTexture
                  : this._updateEmptyDEMTexture();
              }
              get emptyDepthBufferTexture() {
                const a = this.painter.context,
                  u = a.gl;
                if (!this._emptyDepthBufferTexture) {
                  const g = new d.RGBAImage(
                    { width: 1, height: 1 },
                    Uint8Array.of(255, 255, 255, 255)
                  );
                  this._emptyDepthBufferTexture = new d.Texture(a, g, u.RGBA, {
                    premultiply: !1,
                  });
                }
                return this._emptyDepthBufferTexture;
              }
              _getLoadedAreaMinimum() {
                let a = 0;
                const u = this._visibleDemTiles.reduce((g, v) => {
                  if (!v.dem) return g;
                  const b = v.dem.tree.minimums[0];
                  return b > 0 && a++, g + b;
                }, 0);
                return a ? u / a : 0;
              }
              _updateEmptyDEMTexture() {
                const a = this.painter.context,
                  u = a.gl;
                a.activeTexture.set(u.TEXTURE2);
                const g = this._getLoadedAreaMinimum(),
                  v = new d.RGBAImage(
                    { width: 1, height: 1 },
                    new Uint8Array(
                      d.DEMData.pack(g, this.sourceCache.getSource().encoding)
                    )
                  );
                this._emptyDEMTextureDirty = !1;
                let b = this._emptyDEMTexture;
                return (
                  b
                    ? b.update(v, { premultiply: !1 })
                    : (b = this._emptyDEMTexture =
                        new d.Texture(a, v, u.RGBA, { premultiply: !1 })),
                  b
                );
              }
              setupElevationDraw(a, u, g) {
                const v = this.painter.context,
                  b = v.gl,
                  D =
                    ((S = this.sourceCache.getSource().encoding),
                    {
                      u_dem: 2,
                      u_dem_prev: 4,
                      u_dem_unpack: d.DEMData.getUnpackVector(S),
                      u_dem_tl: [0, 0],
                      u_dem_tl_prev: [0, 0],
                      u_dem_scale: 0,
                      u_dem_scale_prev: 0,
                      u_dem_size: 0,
                      u_dem_lerp: 1,
                      u_depth: 3,
                      u_depth_size_inv: [0, 0],
                      u_exaggeration: 0,
                    });
                var S;
                (D.u_dem_size = this.sourceCache.getSource().tileSize),
                  (D.u_exaggeration = this.exaggeration());
                let M = null,
                  R = null,
                  k = 1;
                if (g && g.morphing && this._useVertexMorphing) {
                  const z = g.morphing.srcDemTile,
                    H = g.morphing.dstDemTile;
                  (k = g.morphing.phase),
                    z &&
                      H &&
                      (this._prepareDemTileUniforms(a, z, D, "_prev") &&
                        (R = z),
                      this._prepareDemTileUniforms(a, H, D) && (M = H));
                }
                if (
                  (R && M
                    ? (v.activeTexture.set(b.TEXTURE2),
                      M.demTexture.bind(b.NEAREST, b.CLAMP_TO_EDGE, b.NEAREST),
                      v.activeTexture.set(b.TEXTURE4),
                      R.demTexture.bind(b.NEAREST, b.CLAMP_TO_EDGE, b.NEAREST),
                      (D.u_dem_lerp = k))
                    : ((M = this.terrainTileForTile[a.tileID.key]),
                      v.activeTexture.set(b.TEXTURE2),
                      (this._prepareDemTileUniforms(a, M, D)
                        ? M.demTexture
                        : this.emptyDEMTexture
                      ).bind(b.NEAREST, b.CLAMP_TO_EDGE)),
                  v.activeTexture.set(b.TEXTURE3),
                  g && g.useDepthForOcclusion
                    ? (this._depthTexture &&
                        this._depthTexture.bind(b.NEAREST, b.CLAMP_TO_EDGE),
                      this._depthFBO &&
                        (D.u_depth_size_inv = [
                          1 / this._depthFBO.width,
                          1 / this._depthFBO.height,
                        ]))
                    : (this.emptyDepthBufferTexture.bind(
                        b.NEAREST,
                        b.CLAMP_TO_EDGE
                      ),
                      (D.u_depth_size_inv = [1, 1])),
                  g && g.useMeterToDem && M)
                ) {
                  const z =
                    (1 << M.tileID.canonical.z) *
                    d.mercatorZfromAltitude(
                      1,
                      this.painter.transform.center.lat
                    ) *
                    this.sourceCache.getSource().tileSize;
                  D.u_meter_to_dem = z;
                }
                if (
                  (g &&
                    g.labelPlaneMatrixInv &&
                    (D.u_label_plane_matrix_inv = g.labelPlaneMatrixInv),
                  u.setTerrainUniformValues(v, D),
                  "globe" === this.painter.transform.projection.name)
                ) {
                  const z = this.globeUniformValues(
                    this.painter.transform,
                    a.tileID.canonical,
                    g && g.useDenormalizedUpVectorScale
                  );
                  u.setGlobeUniformValues(v, z);
                }
              }
              globeUniformValues(a, u, g) {
                const v = a.projection;
                return {
                  u_tile_tl_up: v.upVector(u, 0, 0),
                  u_tile_tr_up: v.upVector(u, d.EXTENT, 0),
                  u_tile_br_up: v.upVector(u, d.EXTENT, d.EXTENT),
                  u_tile_bl_up: v.upVector(u, 0, d.EXTENT),
                  u_tile_up_scale: g
                    ? d.globeMetersToEcef(1)
                    : v.upVectorScale(u, a.center.lat, a.worldSize)
                        .metersToTile,
                };
              }
              renderToBackBuffer(a) {
                const u = this.painter,
                  g = this.painter.context;
                0 !== a.length &&
                  (g.bindFramebuffer.set(null),
                  g.viewport.set([0, 0, u.width, u.height]),
                  u.gpuTimingDeferredRenderStart(),
                  (this.renderingToTexture = !1),
                  (function (v, b, D, S, M) {
                    if ("globe" === v.transform.projection.name)
                      !(function (R, k, z, H, q) {
                        const X = R.context,
                          Z = X.gl;
                        let Y, B;
                        const W = R.options.showTerrainWireframe ? 2 : 0,
                          ee = R.transform,
                          te = d.globeUseCustomAntiAliasing(R, X, ee),
                          he = (je, we) => {
                            if (B === je) return;
                            const ke = [vr[je], "PROJECTION_GLOBE_VIEW"];
                            te && ke.push("CUSTOM_ANTIALIASING"),
                              we && ke.push(vr[W]),
                              (Y = R.useProgram("globeRaster", null, ke)),
                              (B = je);
                          },
                          de = R.colorModeForRenderPass(),
                          ue = new d.DepthMode(
                            Z.LEQUAL,
                            d.DepthMode.ReadWrite,
                            R.depthRangeFor3D
                          );
                        Ho.update(q);
                        const _e = d.calculateGlobeMercatorMatrix(ee),
                          ge = [
                            d.mercatorXfromLng(ee.center.lng),
                            d.mercatorYfromLat(ee.center.lat),
                          ],
                          Te = W ? [!1, !0] : [!1],
                          Ge = R.globeSharedBuffers,
                          be = [
                            ee.width * d.exported.devicePixelRatio,
                            ee.height * d.exported.devicePixelRatio,
                          ],
                          Le = Float32Array.from(ee.globeMatrix),
                          Se = { useDenormalizedUpVectorScale: !0 };
                        if (
                          (Te.forEach((je) => {
                            const we = R.transform,
                              ke = $s(we.zoom) * k.exaggeration();
                            B = -1;
                            const He = je ? Z.LINES : Z.TRIANGLES;
                            for (const Ne of H) {
                              const Xe = z.getTile(Ne),
                                mt = d.StencilMode.disabled,
                                It = k.prevTerrainTileForTile[Ne.key],
                                dt = k.terrainTileForTile[Ne.key];
                              Us(It, dt) &&
                                Ho.newMorphing(Ne.key, It, dt, q, 250),
                                X.activeTexture.set(Z.TEXTURE0),
                                Xe.texture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE);
                              const Dt = Ho.getMorphValuesForProxy(Ne.key),
                                Kt = Dt ? 1 : 0;
                              Dt &&
                                d.extend$1(Se, {
                                  morphing: {
                                    srcDemTile: Dt.from,
                                    dstDemTile: Dt.to,
                                    phase: d.easeCubicInOut(Dt.phase),
                                  },
                                });
                              const Ht = d.tileCornersToBounds(Ne.canonical),
                                _t = d.getLatitudinalLod(Ht.getCenter().lat),
                                en = d.getGridMatrix(
                                  Ne.canonical,
                                  Ht,
                                  _t,
                                  we.worldSize / we._pixelsPerMercatorPixel
                                ),
                                On = d.globeNormalizeECEF(
                                  d.globeTileBounds(Ne.canonical)
                                ),
                                _n = Pl(
                                  we.projMatrix,
                                  Le,
                                  _e,
                                  On,
                                  d.globeToMercatorTransition(we.zoom),
                                  ge,
                                  we.frustumCorners.TL,
                                  we.frustumCorners.TR,
                                  we.frustumCorners.BR,
                                  we.frustumCorners.BL,
                                  we.globeCenterInViewSpace,
                                  we.globeRadius,
                                  be,
                                  ke,
                                  en
                                );
                              if (
                                (he(Kt, je),
                                k.setupElevationDraw(Xe, Y, Se),
                                R.prepareDrawProgram(X, Y, Ne.toUnwrapped()),
                                Ge)
                              ) {
                                const [Sn, Hi, vi] = je
                                  ? Ge.getWirefameBuffers(R.context, _t)
                                  : Ge.getGridBuffers(_t, 0 !== ke);
                                Y.draw(
                                  X,
                                  He,
                                  ue,
                                  mt,
                                  de,
                                  d.CullFaceMode.backCCW,
                                  _n,
                                  "globe_raster",
                                  Sn,
                                  Hi,
                                  vi
                                );
                              }
                            }
                          }),
                          Ge)
                        ) {
                          const je = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                          te && je.push("CUSTOM_ANTIALIASING"),
                            (Y = R.useProgram("globeRaster", null, je));
                          for (const we of H) {
                            const { x: ke, y: He, z: Ne } = we.canonical,
                              Xe = 0 === He,
                              mt = He === (1 << Ne) - 1,
                              [It, dt, Dt, Kt] = Ge.getPoleBuffers(Ne);
                            if (Kt && (Xe || mt)) {
                              const Ht = z.getTile(we);
                              X.activeTexture.set(Z.TEXTURE0),
                                Ht.texture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE);
                              let _t = d.globePoleMatrixForTile(Ne, ke, ee);
                              const en = d.globeNormalizeECEF(
                                  d.globeTileBounds(we.canonical)
                                ),
                                On = (_n, Sn) =>
                                  _n.draw(
                                    X,
                                    Z.TRIANGLES,
                                    ue,
                                    d.StencilMode.disabled,
                                    de,
                                    d.CullFaceMode.disabled,
                                    Pl(
                                      ee.projMatrix,
                                      _t,
                                      _t,
                                      en,
                                      0,
                                      ge,
                                      ee.frustumCorners.TL,
                                      ee.frustumCorners.TR,
                                      ee.frustumCorners.BR,
                                      ee.frustumCorners.BL,
                                      ee.globeCenterInViewSpace,
                                      ee.globeRadius,
                                      be,
                                      0
                                    ),
                                    "globe_pole_raster",
                                    Sn,
                                    Dt,
                                    Kt
                                  );
                              k.setupElevationDraw(Ht, Y, Se),
                                R.prepareDrawProgram(X, Y, we.toUnwrapped()),
                                Xe && On(Y, It),
                                mt &&
                                  ((_t = d.scale(d.create(), _t, [1, -1, 1])),
                                  On(Y, dt));
                            }
                          }
                        }
                      })(v, b, D, S, M);
                    else {
                      const R = v.context,
                        k = R.gl;
                      let z, H;
                      const q = v.options.showTerrainWireframe ? 2 : 0,
                        X = (ee, te) => {
                          if (H === ee) return;
                          const he = [vr[ee]];
                          te && he.push(vr[q]),
                            (z = v.useProgram("terrainRaster", null, he)),
                            (H = ee);
                        },
                        Z = v.colorModeForRenderPass(),
                        Y = new d.DepthMode(
                          k.LEQUAL,
                          d.DepthMode.ReadWrite,
                          v.depthRangeFor3D
                        );
                      Ho.update(M);
                      const B = v.transform,
                        W = $s(B.zoom) * b.exaggeration();
                      (q ? [!1, !0] : [!1]).forEach((ee) => {
                        H = -1;
                        const te = ee ? k.LINES : k.TRIANGLES,
                          [he, de] = ee
                            ? b.getWirefameBuffer()
                            : [b.gridIndexBuffer, b.gridSegments];
                        for (const ue of S) {
                          const _e = D.getTile(ue),
                            ge = d.StencilMode.disabled,
                            Te = b.prevTerrainTileForTile[ue.key],
                            Ge = b.terrainTileForTile[ue.key];
                          Us(Te, Ge) && Ho.newMorphing(ue.key, Te, Ge, M, 250),
                            R.activeTexture.set(k.TEXTURE0),
                            _e.texture.bind(
                              k.LINEAR,
                              k.CLAMP_TO_EDGE,
                              k.LINEAR_MIPMAP_NEAREST
                            );
                          const be = Ho.getMorphValuesForProxy(ue.key),
                            Le = be ? 1 : 0;
                          let Se;
                          be &&
                            (Se = {
                              morphing: {
                                srcDemTile: be.from,
                                dstDemTile: be.to,
                                phase: d.easeCubicInOut(be.phase),
                              },
                            });
                          const je = ps(
                            ue.projMatrix,
                            fp(ue.canonical, B.renderWorldCopies) ? W / 10 : W
                          );
                          X(Le, ee),
                            b.setupElevationDraw(_e, z, Se),
                            v.prepareDrawProgram(R, z, ue.toUnwrapped()),
                            z.draw(
                              R,
                              te,
                              Y,
                              ge,
                              Z,
                              d.CullFaceMode.backCCW,
                              je,
                              "terrain_raster",
                              b.gridBuffer,
                              he,
                              de
                            );
                        }
                      });
                    }
                  })(u, this, this.proxySourceCache, a, this._updateTimestamp),
                  (this.renderingToTexture = !0),
                  u.gpuTimingDeferredRenderEnd(),
                  a.splice(0, a.length));
              }
              renderBatch(a) {
                if (0 === this._drapedRenderBatches.length) return a + 1;
                this.renderingToTexture = !0;
                const u = this.painter,
                  g = this.painter.context,
                  v = this.proxySourceCache,
                  b = this.proxiedCoords[v.id],
                  D = this._drapedRenderBatches.shift(),
                  S = [],
                  M = u.style.order;
                let R = 0;
                for (const k of b) {
                  const z = v.getTileByID(k.proxyTileKey),
                    H = v.proxyCachedFBO[k.key]
                      ? v.proxyCachedFBO[k.key][a]
                      : void 0,
                    q = void 0 !== H ? v.renderCache[H] : this.pool[R++],
                    X = void 0 !== H;
                  if (((z.texture = q.tex), X && !q.dirty)) {
                    S.push(z.tileID);
                    continue;
                  }
                  let Z;
                  g.bindFramebuffer.set(q.fb.framebuffer),
                    (this.renderedToTile = !1),
                    q.dirty &&
                      (g.clear({ color: d.Color.transparent, stencil: 0 }),
                      (q.dirty = !1));
                  for (let Y = D.start; Y <= D.end; ++Y) {
                    const B = u.style._layers[M[Y]];
                    if (B.isHidden(u.transform.zoom)) continue;
                    const W = u.style._getLayerSourceCache(B),
                      ee = W ? this.proxyToSource[k.key][W.id] : [k];
                    if (!ee) continue;
                    const te = ee;
                    g.viewport.set([0, 0, q.fb.width, q.fb.height]),
                      Z !== (W ? W.id : null) &&
                        (this._setupStencil(q, ee, B, W),
                        (Z = W ? W.id : null)),
                      u.renderLayer(u, W, B, te);
                  }
                  this.renderedToTile
                    ? ((q.dirty = !0), S.push(z.tileID))
                    : X || --R,
                    5 === R && ((R = 0), this.renderToBackBuffer(S));
                }
                return (
                  this.renderToBackBuffer(S),
                  (this.renderingToTexture = !1),
                  g.bindFramebuffer.set(null),
                  g.viewport.set([0, 0, u.width, u.height]),
                  D.end + 1
                );
              }
              postRender() {}
              renderCacheEfficiency(a) {
                const u = a.order.length;
                if (0 === u) return { efficiency: 100 };
                let g,
                  v = 0,
                  b = 0,
                  D = !1;
                for (let S = 0; S < u; ++S) {
                  const M = a._layers[a.order[S]];
                  this._style.isLayerDraped(M)
                    ? (D && ++v, ++b)
                    : D || ((D = !0), (g = M.id));
                }
                return 0 === b
                  ? { efficiency: 100 }
                  : { efficiency: 100 * (1 - v / b), firstUndrapedLayer: g };
              }
              getMinElevationBelowMSL() {
                let a = 0;
                return (
                  this._visibleDemTiles
                    .filter((u) => u.dem)
                    .forEach((u) => {
                      a = Math.min(a, u.dem.tree.minimums[0]);
                    }),
                  0 === a ? a : (a - 30) * this._exaggeration
                );
              }
              raycast(a, u, g) {
                if (!this._visibleDemTiles) return null;
                const v = this._visibleDemTiles
                  .filter((b) => b.dem)
                  .map((b) => {
                    const D = b.tileID,
                      S = 1 << D.overscaledZ,
                      { x: M, y: R } = D.canonical,
                      k = M / S,
                      z = (M + 1) / S,
                      H = R / S,
                      q = (R + 1) / S;
                    return {
                      minx: k,
                      miny: H,
                      maxx: z,
                      maxy: q,
                      t: b.dem.tree.raycastRoot(k, H, z, q, a, u, g),
                      tile: b,
                    };
                  });
                v.sort(
                  (b, D) =>
                    (null !== b.t ? b.t : Number.MAX_VALUE) -
                    (null !== D.t ? D.t : Number.MAX_VALUE)
                );
                for (const b of v) {
                  if (null == b.t) return null;
                  const D = b.tile.dem.tree.raycast(
                    b.minx,
                    b.miny,
                    b.maxx,
                    b.maxy,
                    a,
                    u,
                    g
                  );
                  if (null != D) return D;
                }
                return null;
              }
              _createFBO() {
                const a = this.painter.context,
                  u = a.gl,
                  g = this.drapeBufferSize;
                a.activeTexture.set(u.TEXTURE0);
                const v = new d.Texture(
                  a,
                  { width: g[0], height: g[1], data: null },
                  u.RGBA
                );
                v.bind(u.LINEAR, u.CLAMP_TO_EDGE);
                const b = a.createFramebuffer(g[0], g[1], !1);
                return (
                  b.colorAttachment.set(v.texture),
                  (b.depthAttachment = new fe(a, b.framebuffer)),
                  void 0 === this._sharedDepthStencil
                    ? ((this._sharedDepthStencil = a.createRenderbuffer(
                        a.gl.DEPTH_STENCIL,
                        g[0],
                        g[1]
                      )),
                      (this._stencilRef = 0),
                      b.depthAttachment.set(this._sharedDepthStencil),
                      a.clear({ stencil: 0 }))
                    : b.depthAttachment.set(this._sharedDepthStencil),
                  a.extTextureFilterAnisotropic &&
                    !a.extTextureFilterAnisotropicForceOff &&
                    u.texParameterf(
                      u.TEXTURE_2D,
                      a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                      a.extTextureFilterAnisotropicMax
                    ),
                  { fb: b, tex: v, dirty: !1 }
                );
              }
              _initFBOPool() {
                for (
                  ;
                  this.pool.length < Math.min(5, this.proxyCoords.length);

                )
                  this.pool.push(this._createFBO());
              }
              _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition())
                  return !0;
                for (const a in this._style._sourceCaches)
                  if (this._style._sourceCaches[a].hasTransition()) return !0;
                return this._style.order.some((a) => {
                  const u = this._style._layers[a],
                    g = u.isHidden(this.painter.transform.zoom);
                  return "custom" === u.type
                    ? !g && u.shouldRedrape()
                    : !g && u.hasTransition();
                });
              }
              _clearLineLayersFromRenderCache() {
                let a = !1;
                for (const g of this._style._getSources())
                  if (g instanceof et) {
                    a = !0;
                    break;
                  }
                if (!a) return;
                const u = {};
                for (let g = 0; g < this._style.order.length; ++g) {
                  const v = this._style._layers[this._style.order[g]],
                    b = this._style._getLayerSourceCache(v);
                  if (
                    b &&
                    !u[b.id] &&
                    !v.isHidden(this.painter.transform.zoom) &&
                    "line" === v.type &&
                    v.widthExpression() instanceof d.ZoomDependentExpression
                  ) {
                    u[b.id] = !0;
                    for (const D of this.proxyCoords) {
                      const S = this.proxyToSource[D.key][b.id];
                      if (S)
                        for (const M of S)
                          this._clearRenderCacheForTile(b.id, M);
                    }
                  }
                }
              }
              _clearRasterLayersFromRenderCache() {
                let a = !1;
                for (const g in this._style._sourceCaches)
                  if (this._style._sourceCaches[g]._source instanceof We) {
                    a = !0;
                    break;
                  }
                if (!a) return;
                const u = {};
                for (let g = 0; g < this._style.order.length; ++g) {
                  const v = this._style._layers[this._style.order[g]],
                    b = this._style._getLayerSourceCache(v);
                  if (
                    !b ||
                    u[b.id] ||
                    v.isHidden(this.painter.transform.zoom) ||
                    "raster" !== v.type
                  )
                    continue;
                  const D = v.paint.get("raster-fade-duration");
                  for (const S of this.proxyCoords) {
                    const M = this.proxyToSource[S.key][b.id];
                    if (M)
                      for (const R of M) {
                        const k = Oh(
                          b.getTile(R),
                          b.findLoadedParent(R, 0),
                          b,
                          this.painter.transform,
                          D
                        );
                        (1 !== k.opacity || 0 !== k.mix) &&
                          this._clearRenderCacheForTile(b.id, R);
                      }
                  }
                }
              }
              _setupDrapedRenderBatches() {
                const a = this._style.order,
                  u = a.length;
                if (0 === u) return;
                const g = [];
                let v,
                  b = 0,
                  D = this._style._layers[a[b]];
                for (
                  ;
                  !this._style.isLayerDraped(D) &&
                  D.isHidden(this.painter.transform.zoom) &&
                  ++b < u;

                )
                  D = this._style._layers[a[b]];
                for (; b < u; ++b) {
                  const S = this._style._layers[a[b]];
                  S.isHidden(this.painter.transform.zoom) ||
                    (this._style.isLayerDraped(S)
                      ? void 0 === v && (v = b)
                      : void 0 !== v &&
                        (g.push({ start: v, end: b - 1 }), (v = void 0)));
                }
                void 0 !== v && g.push({ start: v, end: b - 1 }),
                  (this._drapedRenderBatches = g);
              }
              _setupRenderCache(a) {
                const u = this.proxySourceCache;
                if (
                  this._shouldDisableRenderCache() ||
                  this._invalidateRenderCache
                ) {
                  if (
                    ((this._invalidateRenderCache = !1),
                    u.renderCache.length > u.renderCachePool.length)
                  ) {
                    const D = Object.values(u.proxyCachedFBO);
                    u.proxyCachedFBO = {};
                    for (let S = 0; S < D.length; ++S) {
                      const M = Object.values(D[S]);
                      u.renderCachePool.push(...M);
                    }
                  }
                  return;
                }
                this._clearRasterLayersFromRenderCache();
                const g = this.proxyCoords,
                  v = this._tilesDirty;
                for (let D = g.length - 1; D >= 0; D--) {
                  const S = g[D];
                  if (
                    (u.getTileByID(S.key), void 0 !== u.proxyCachedFBO[S.key])
                  ) {
                    const M = a[S.key],
                      R = this.proxyToSource[S.key];
                    let k = 0;
                    for (const z in R) {
                      const H = R[z],
                        q = M[z];
                      if (
                        !q ||
                        q.length !== H.length ||
                        H.some(
                          (X, Z) =>
                            X !== q[Z] || (v[z] && v[z].hasOwnProperty(X.key))
                        )
                      ) {
                        k = -1;
                        break;
                      }
                      ++k;
                    }
                    for (const z in u.proxyCachedFBO[S.key])
                      u.renderCache[u.proxyCachedFBO[S.key][z]].dirty =
                        k < 0 || k !== Object.values(M).length;
                  }
                }
                const b = [...this._drapedRenderBatches];
                b.sort((D, S) => S.end - S.start - (D.end - D.start));
                for (const D of b)
                  for (const S of g) {
                    if (u.proxyCachedFBO[S.key]) continue;
                    let M = u.renderCachePool.pop();
                    void 0 === M &&
                      u.renderCache.length < 50 &&
                      ((M = u.renderCache.length),
                      u.renderCache.push(this._createFBO())),
                      void 0 !== M &&
                        ((u.proxyCachedFBO[S.key] = {}),
                        (u.proxyCachedFBO[S.key][D.start] = M),
                        (u.renderCache[M].dirty = !0));
                  }
                this._tilesDirty = {};
              }
              _setupStencil(a, u, g, v) {
                if (!v || !this._sourceTilesOverlap[v.id])
                  return void (
                    this._overlapStencilType && (this._overlapStencilType = !1)
                  );
                const b = this.painter.context,
                  D = b.gl;
                if (u.length <= 1) return void (this._overlapStencilType = !1);
                let S;
                if (g.isTileClipped())
                  (S = u.length),
                    (this._overlapStencilMode.test = {
                      func: D.EQUAL,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Clip");
                else {
                  if (!(u[0].overscaledZ > u[u.length - 1].overscaledZ))
                    return void (this._overlapStencilType = !1);
                  (S = 1),
                    (this._overlapStencilMode.test = {
                      func: D.GREATER,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Mask");
                }
                this._stencilRef + S > 255 &&
                  (b.clear({ stencil: 0 }), (this._stencilRef = 0)),
                  (this._stencilRef += S),
                  (this._overlapStencilMode.ref = this._stencilRef),
                  g.isTileClipped() &&
                    this._renderTileClippingMasks(
                      u,
                      this._overlapStencilMode.ref
                    );
              }
              clipOrMaskOverlapStencilType() {
                return (
                  "Clip" === this._overlapStencilType ||
                  "Mask" === this._overlapStencilType
                );
              }
              stencilModeForRTTOverlap(a) {
                return this.renderingToTexture && this._overlapStencilType
                  ? ("Clip" === this._overlapStencilType &&
                      (this._overlapStencilMode.ref =
                        this.painter._tileClippingMaskIDs[a.key]),
                    this._overlapStencilMode)
                  : d.StencilMode.disabled;
              }
              _renderTileClippingMasks(a, u) {
                const g = this.painter,
                  v = this.painter.context,
                  b = v.gl;
                (g._tileClippingMaskIDs = {}),
                  v.setColorMode(d.ColorMode.disabled),
                  v.setDepthMode(d.DepthMode.disabled);
                const D = g.useProgram("clippingMask");
                for (const S of a) {
                  const M = (g._tileClippingMaskIDs[S.key] = --u);
                  D.draw(
                    v,
                    b.TRIANGLES,
                    d.DepthMode.disabled,
                    new d.StencilMode(
                      { func: b.ALWAYS, mask: 0 },
                      M,
                      255,
                      b.KEEP,
                      b.KEEP,
                      b.REPLACE
                    ),
                    d.ColorMode.disabled,
                    d.CullFaceMode.disabled,
                    Yi(S.projMatrix),
                    "$clipping",
                    g.tileExtentBuffer,
                    g.quadTriangleIndexBuffer,
                    g.tileExtentSegments
                  );
                }
              }
              pointCoordinate(a) {
                const u = this.painter.transform;
                if (a.x < 0 || a.x > u.width || a.y < 0 || a.y > u.height)
                  return null;
                const g = [a.x, a.y, 1, 1];
                d.transformMat4$1(g, g, u.pixelMatrixInverse),
                  d.scale$1(g, g, 1 / g[3]),
                  (g[0] /= u.worldSize),
                  (g[1] /= u.worldSize);
                const v = u._camera.position,
                  b = d.mercatorZfromAltitude(1, u.center.lat),
                  D = [v[0], v[1], v[2] / b, 0],
                  S = d.subtract([], g.slice(0, 3), D);
                d.normalize(S, S);
                const M = this.raycast(D, S, this._exaggeration);
                return null !== M && M
                  ? (d.scaleAndAdd(D, D, S, M), (D[3] = D[2]), (D[2] *= b), D)
                  : null;
              }
              drawDepth() {
                const a = this.painter,
                  u = a.context,
                  g = this.proxySourceCache,
                  v = Math.ceil(a.width),
                  b = Math.ceil(a.height);
                if (
                  (!this._depthFBO ||
                    (this._depthFBO.width === v &&
                      this._depthFBO.height === b) ||
                    (this._depthFBO.destroy(),
                    (this._depthFBO = void 0),
                    (this._depthTexture = void 0)),
                  !this._depthFBO)
                ) {
                  const D = u.gl,
                    S = u.createFramebuffer(v, b, !0);
                  u.activeTexture.set(D.TEXTURE0);
                  const M = new d.Texture(
                    u,
                    { width: v, height: b, data: null },
                    D.RGBA
                  );
                  M.bind(D.NEAREST, D.CLAMP_TO_EDGE),
                    S.colorAttachment.set(M.texture);
                  const R = u.createRenderbuffer(u.gl.DEPTH_COMPONENT16, v, b);
                  S.depthAttachment.set(R),
                    (this._depthFBO = S),
                    (this._depthTexture = M);
                }
                u.bindFramebuffer.set(this._depthFBO.framebuffer),
                  u.viewport.set([0, 0, v, b]),
                  (function (D, S, M, R) {
                    if ("globe" === D.transform.projection.name) return;
                    const k = D.context,
                      z = k.gl;
                    k.clear({ depth: 1 });
                    const H = D.useProgram("terrainDepth"),
                      q = new d.DepthMode(
                        z.LESS,
                        d.DepthMode.ReadWrite,
                        D.depthRangeFor3D
                      );
                    for (const X of R) {
                      const Z = M.getTile(X),
                        Y = ps(X.projMatrix, 0);
                      S.setupElevationDraw(Z, H),
                        H.draw(
                          k,
                          z.TRIANGLES,
                          q,
                          d.StencilMode.disabled,
                          d.ColorMode.unblended,
                          d.CullFaceMode.backCCW,
                          Y,
                          "terrain_depth",
                          S.gridBuffer,
                          S.gridIndexBuffer,
                          S.gridNoSkirtSegments
                        );
                    }
                  })(a, this, g, this.proxyCoords);
              }
              _setupProxiedCoordsForOrtho(a, u, g) {
                if (a.getSource() instanceof Ut)
                  return this._setupProxiedCoordsForImageSource(a, u, g);
                this._findCoveringTileCache[a.id] =
                  this._findCoveringTileCache[a.id] || {};
                const v = (this.proxiedCoords[a.id] = []),
                  b = this.proxyCoords;
                for (let S = 0; S < b.length; S++) {
                  const M = b[S],
                    R = this._findTileCoveringTileID(M, a);
                  if (R) {
                    const k = this._createProxiedId(
                      M,
                      R,
                      g[M.key] && g[M.key][a.id]
                    );
                    v.push(k), (this.proxyToSource[M.key][a.id] = [k]);
                  }
                }
                let D = !1;
                for (let S = 0; S < u.length; S++) {
                  const M = a.getTile(u[S]);
                  if (!M || !M.hasData()) continue;
                  const R = this._findTileCoveringTileID(
                    M.tileID,
                    this.proxySourceCache
                  );
                  if (R && R.tileID.canonical.z !== M.tileID.canonical.z) {
                    const k = this.proxyToSource[R.tileID.key][a.id],
                      z = this._createProxiedId(
                        R.tileID,
                        M,
                        g[R.tileID.key] && g[R.tileID.key][a.id]
                      );
                    k
                      ? k.splice(k.length - 1, 0, z)
                      : (this.proxyToSource[R.tileID.key][a.id] = [z]),
                      v.push(z),
                      (D = !0);
                  }
                }
                this._sourceTilesOverlap[a.id] = D;
              }
              _setupProxiedCoordsForImageSource(a, u, g) {
                if (!a.getSource().loaded()) return;
                const v = (this.proxiedCoords[a.id] = []),
                  b = this.proxyCoords,
                  D = a.getSource(),
                  S = new d.Point(D.tileID.x, D.tileID.y)._div(1 << D.tileID.z),
                  M = D.coordinates
                    .map(d.MercatorCoordinate.fromLngLat)
                    .reduce(
                      (k, z) => (
                        (k.min.x = Math.min(k.min.x, z.x - S.x)),
                        (k.min.y = Math.min(k.min.y, z.y - S.y)),
                        (k.max.x = Math.max(k.max.x, z.x - S.x)),
                        (k.max.y = Math.max(k.max.y, z.y - S.y)),
                        k
                      ),
                      {
                        min: new d.Point(Number.MAX_VALUE, Number.MAX_VALUE),
                        max: new d.Point(-Number.MAX_VALUE, -Number.MAX_VALUE),
                      }
                    ),
                  R = (k, z) => {
                    const H = k.wrap + k.canonical.x / (1 << k.canonical.z),
                      q = k.canonical.y / (1 << k.canonical.z),
                      X = d.EXTENT / (1 << k.canonical.z),
                      Z = z.wrap + z.canonical.x / (1 << z.canonical.z),
                      Y = z.canonical.y / (1 << z.canonical.z);
                    return (
                      H + X < Z + M.min.x ||
                      H > Z + M.max.x ||
                      q + X < Y + M.min.y ||
                      q > Y + M.max.y
                    );
                  };
                for (let k = 0; k < b.length; k++) {
                  const z = b[k];
                  for (let H = 0; H < u.length; H++) {
                    const q = a.getTile(u[H]);
                    if (!q || !q.hasData() || R(z, q.tileID)) continue;
                    const X = this._createProxiedId(
                        z,
                        q,
                        g[z.key] && g[z.key][a.id]
                      ),
                      Z = this.proxyToSource[z.key][a.id];
                    Z ? Z.push(X) : (this.proxyToSource[z.key][a.id] = [X]),
                      v.push(X);
                  }
                }
              }
              _createProxiedId(a, u, g) {
                let v = this.orthoMatrix;
                if (g) {
                  const b = g.find((D) => D.key === u.tileID.key);
                  if (b) return b;
                }
                if (u.tileID.key !== a.key) {
                  const b = a.canonical.z - u.tileID.canonical.z;
                  let D, S, M;
                  v = d.create();
                  const R = (u.tileID.wrap - a.wrap) << a.overscaledZ;
                  b > 0
                    ? ((D = d.EXTENT >> b),
                      (S =
                        D * ((u.tileID.canonical.x << b) - a.canonical.x + R)),
                      (M = D * ((u.tileID.canonical.y << b) - a.canonical.y)))
                    : ((D = d.EXTENT << -b),
                      (S =
                        d.EXTENT *
                        (u.tileID.canonical.x - ((a.canonical.x + R) << -b))),
                      (M =
                        d.EXTENT *
                        (u.tileID.canonical.y - (a.canonical.y << -b)))),
                    d.ortho(v, 0, D, 0, D, 0, 1),
                    d.translate(v, v, [S, M, 0]);
                }
                return new ar(u.tileID, a.key, v);
              }
              _findTileCoveringTileID(a, u) {
                let g = u.getTile(a);
                if (g && g.hasData()) return g;
                const v = this._findCoveringTileCache[u.id],
                  b = v[a.key];
                if (
                  ((g = b ? u.getTileByID(b) : null),
                  (g && g.hasData()) || null === b)
                )
                  return g;
                let D = g ? g.tileID : a,
                  S = D.overscaledZ;
                const M = u.getSource().minzoom,
                  R = [];
                if (!b) {
                  const z = u.getSource().maxzoom;
                  if (a.canonical.z >= z) {
                    const H = a.canonical.z - z;
                    u.getSource().reparseOverscaled
                      ? ((S = Math.max(
                          a.canonical.z + 2,
                          u.transform.tileZoom
                        )),
                        (D = new d.OverscaledTileID(
                          S,
                          a.wrap,
                          z,
                          a.canonical.x >> H,
                          a.canonical.y >> H
                        )))
                      : 0 !== H &&
                        ((S = z),
                        (D = new d.OverscaledTileID(
                          S,
                          a.wrap,
                          z,
                          a.canonical.x >> H,
                          a.canonical.y >> H
                        )));
                  }
                  D.key !== a.key && (R.push(D.key), (g = u.getTile(D)));
                }
                const k = (z) => {
                  R.forEach((H) => {
                    v[H] = z;
                  }),
                    (R.length = 0);
                };
                for (S -= 1; S >= M && (!g || !g.hasData()); S--) {
                  g && k(g.tileID.key);
                  const z = D.calculateScaledKey(S);
                  if (((g = u.getTileByID(z)), g && g.hasData())) break;
                  const H = v[z];
                  if (null === H) break;
                  void 0 === H ? R.push(z) : (g = u.getTileByID(H));
                }
                return k(g ? g.tileID.key : null), g && g.hasData() ? g : null;
              }
              findDEMTileFor(a) {
                return this.enabled
                  ? this._findTileCoveringTileID(a, this.sourceCache)
                  : null;
              }
              prepareDrawTile() {
                this.renderedToTile = !0;
              }
              _clearRenderCacheForTile(a, u) {
                let g = this._tilesDirty[a];
                g || (g = this._tilesDirty[a] = {}), (g[u.key] = !0);
              }
              getWirefameBuffer() {
                if (!this.wireframeSegments) {
                  const a = (function (u) {
                    let g = 0;
                    const v = new d.StructArrayLayout2ui4(),
                      b = 131;
                    for (let D = 1; D < 129; D++) {
                      for (let S = 1; S < 129; S++)
                        (g = D * b + S),
                          v.emplaceBack(g, g + 1),
                          v.emplaceBack(g, g + b),
                          v.emplaceBack(g + 1, g + b),
                          128 === D && v.emplaceBack(g + b, g + b + 1);
                      v.emplaceBack(g + 1, g + 1 + b);
                    }
                    return v;
                  })();
                  (this.wireframeIndexBuffer =
                    this.painter.context.createIndexBuffer(a)),
                    (this.wireframeSegments = d.SegmentVector.simpleSegment(
                      0,
                      0,
                      this.gridBuffer.length,
                      a.length
                    ));
                }
                return [this.wireframeIndexBuffer, this.wireframeSegments];
              }
            }
            class ln {
              static cacheKey(a, u, g, v) {
                let b = `${u}${v ? v.cacheKey : ""}`;
                for (const D of g) a.usedDefines.includes(D) && (b += `/${D}`);
                return b;
              }
              constructor(a, u, g, v, b, D) {
                const S = a.gl;
                this.program = S.createProgram();
                const M = (function (B) {
                    const W = [];
                    for (let ee = 0; ee < B.length; ee++) {
                      if (null === B[ee]) continue;
                      const te = B[ee].split(" ");
                      W.push(te.pop());
                    }
                    return W;
                  })(g.staticAttributes),
                  R = v ? v.getBinderAttributes() : [],
                  k = M.concat(R);
                let z = v ? v.defines() : [];
                z = z.concat(D.map((B) => `#define ${B}`));
                const H = a.isWebGL2 ? "#version 300 es\n" : "",
                  q =
                    H +
                    z
                      .concat(
                        a.extStandardDerivatives && 0 === H.length
                          ? "#extension GL_OES_standard_derivatives : enable\n".concat(
                              $o
                            )
                          : $o,
                        $o,
                        Rh,
                        kh.fragmentSource,
                        Al.fragmentSource,
                        g.fragmentSource
                      )
                      .join("\n"),
                  X =
                    H +
                    z
                      .concat(
                        "\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif",
                        Rh,
                        kh.vertexSource,
                        Al.vertexSource,
                        Ml.vertexSource,
                        g.vertexSource
                      )
                      .join("\n"),
                  Z = S.createShader(S.FRAGMENT_SHADER);
                if (S.isContextLost()) return void (this.failedToCreate = !0);
                S.shaderSource(Z, q),
                  S.compileShader(Z),
                  S.attachShader(this.program, Z);
                const Y = S.createShader(S.VERTEX_SHADER);
                if (S.isContextLost()) this.failedToCreate = !0;
                else {
                  S.shaderSource(Y, X),
                    S.compileShader(Y),
                    S.attachShader(this.program, Y),
                    (this.attributes = {}),
                    (this.numAttributes = k.length);
                  for (let B = 0; B < this.numAttributes; B++)
                    k[B] &&
                      (S.bindAttribLocation(this.program, B, k[B]),
                      (this.attributes[k[B]] = B));
                  S.linkProgram(this.program),
                    S.deleteShader(Y),
                    S.deleteShader(Z),
                    (this.fixedUniforms = b(a)),
                    (this.binderUniforms = v ? v.getUniforms(a) : []),
                    D.includes("TERRAIN") &&
                      (this.terrainUniforms = {
                        u_dem: new d.Uniform1i((B = a)),
                        u_dem_prev: new d.Uniform1i(B),
                        u_dem_unpack: new d.Uniform4f(B),
                        u_dem_tl: new d.Uniform2f(B),
                        u_dem_scale: new d.Uniform1f(B),
                        u_dem_tl_prev: new d.Uniform2f(B),
                        u_dem_scale_prev: new d.Uniform1f(B),
                        u_dem_size: new d.Uniform1f(B),
                        u_dem_lerp: new d.Uniform1f(B),
                        u_exaggeration: new d.Uniform1f(B),
                        u_depth: new d.Uniform1i(B),
                        u_depth_size_inv: new d.Uniform2f(B),
                        u_meter_to_dem: new d.Uniform1f(B),
                        u_label_plane_matrix_inv: new d.UniformMatrix4f(B),
                      }),
                    D.includes("GLOBE") &&
                      (this.globeUniforms = ((B) => ({
                        u_tile_tl_up: new d.Uniform3f(B),
                        u_tile_tr_up: new d.Uniform3f(B),
                        u_tile_br_up: new d.Uniform3f(B),
                        u_tile_bl_up: new d.Uniform3f(B),
                        u_tile_up_scale: new d.Uniform1f(B),
                      }))(a)),
                    D.includes("FOG") &&
                      (this.fogUniforms = ((B) => ({
                        u_fog_matrix: new d.UniformMatrix4f(B),
                        u_fog_range: new d.Uniform2f(B),
                        u_fog_color: new d.Uniform4f(B),
                        u_fog_horizon_blend: new d.Uniform1f(B),
                        u_fog_temporal_offset: new d.Uniform1f(B),
                        u_frustum_tl: new d.Uniform3f(B),
                        u_frustum_tr: new d.Uniform3f(B),
                        u_frustum_br: new d.Uniform3f(B),
                        u_frustum_bl: new d.Uniform3f(B),
                        u_globe_pos: new d.Uniform3f(B),
                        u_globe_radius: new d.Uniform1f(B),
                        u_globe_transition: new d.Uniform1f(B),
                        u_is_globe: new d.Uniform1i(B),
                        u_viewport: new d.Uniform2f(B),
                      }))(a));
                }
                var B;
              }
              setTerrainUniformValues(a, u) {
                if (!this.terrainUniforms) return;
                const g = this.terrainUniforms;
                if (!this.failedToCreate) {
                  a.program.set(this.program);
                  for (const v in u) g[v] && g[v].set(this.program, v, u[v]);
                }
              }
              setGlobeUniformValues(a, u) {
                if (!this.globeUniforms) return;
                const g = this.globeUniforms;
                if (!this.failedToCreate) {
                  a.program.set(this.program);
                  for (const v in u) g[v] && g[v].set(this.program, v, u[v]);
                }
              }
              setFogUniformValues(a, u) {
                if (!this.fogUniforms) return;
                const g = this.fogUniforms;
                if (!this.failedToCreate) {
                  a.program.set(this.program);
                  for (const v in u) g[v].set(this.program, v, u[v]);
                }
              }
              draw(a, u, g, v, b, D, S, M, R, k, z, H, q, X, Z) {
                const Y = a.gl;
                if (this.failedToCreate) return;
                a.program.set(this.program),
                  a.setDepthMode(g),
                  a.setStencilMode(v),
                  a.setColorMode(b),
                  a.setCullFace(D);
                for (const W of Object.keys(this.fixedUniforms))
                  this.fixedUniforms[W].set(this.program, W, S[W]);
                X &&
                  X.setUniforms(this.program, a, this.binderUniforms, H, {
                    zoom: q,
                  });
                const B = { [Y.LINES]: 2, [Y.TRIANGLES]: 3, [Y.LINE_STRIP]: 1 }[
                  u
                ];
                for (const W of z.get()) {
                  const ee = W.vaos || (W.vaos = {});
                  (ee[M] || (ee[M] = new xo())).bind(
                    a,
                    this,
                    R,
                    X ? X.getPaintVertexBuffers() : [],
                    k,
                    W.vertexOffset,
                    Z || []
                  ),
                    Y.drawElements(
                      u,
                      W.primitiveLength * B,
                      Y.UNSIGNED_SHORT,
                      W.primitiveOffset * B * 2
                    );
                }
              }
            }
            function Pi(f, a) {
              const u = Math.pow(2, a.tileID.overscaledZ),
                g = (a.tileSize * Math.pow(2, f.transform.tileZoom)) / u,
                v = g * (a.tileID.canonical.x + a.tileID.wrap * u),
                b = g * a.tileID.canonical.y;
              return {
                u_image: 0,
                u_texsize: a.imageAtlasTexture.size,
                u_tile_units_to_pixels: 1 / Ai(a, 1, f.transform.tileZoom),
                u_pixel_coord_upper: [v >> 16, b >> 16],
                u_pixel_coord_lower: [65535 & v, 65535 & b],
              };
            }
            const xr = d.create(),
              An = (f, a, u, g, v, b, D, S, M, R, k) => {
                const z = a.style.light,
                  H = z.properties.get("position"),
                  q = [H.x, H.y, H.z],
                  X = d.create$1();
                "viewport" === z.properties.get("anchor") &&
                  (d.fromRotation(X, -a.transform.angle),
                  d.transformMat3(q, q, X));
                const Z = z.properties.get("color"),
                  Y = a.transform,
                  B = {
                    u_matrix: f,
                    u_lightpos: q,
                    u_lightintensity: z.properties.get("intensity"),
                    u_lightcolor: [Z.r, Z.g, Z.b],
                    u_vertical_gradient: +u,
                    u_opacity: g,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: xr,
                    u_merc_center: [0, 0],
                    u_up_dir: [0, 0, 0],
                    u_height_lift: 0,
                    u_ao: v,
                    u_edge_radius: b,
                  };
                return (
                  "globe" === Y.projection.name &&
                    ((B.u_tile_id = [
                      D.canonical.x,
                      D.canonical.y,
                      1 << D.canonical.z,
                    ]),
                    (B.u_zoom_transition = M),
                    (B.u_inv_rot_matrix = k),
                    (B.u_merc_center = R),
                    (B.u_up_dir = Y.projection.upVector(
                      new d.CanonicalTileID(0, 0, 0),
                      R[0] * d.EXTENT,
                      R[1] * d.EXTENT
                    )),
                    (B.u_height_lift = S)),
                  B
                );
              },
              lr = (f, a, u, g, v, b, D, S, M, R, k, z) => {
                const H = An(f, a, u, g, v, b, D, M, R, k, z),
                  q = {
                    u_height_factor:
                      -Math.pow(2, D.overscaledZ) / S.tileSize / 8,
                  };
                return d.extend(H, Pi(a, S), q);
              },
              _i = (f) => ({ u_matrix: f }),
              Fa = (f, a, u) => d.extend(_i(f), Pi(a, u)),
              Wr = (f, a) => ({ u_matrix: f, u_world: a }),
              oo = (f, a, u, g) => d.extend(Fa(f, a, u), { u_world: g }),
              ft = d.create(),
              Xt = (f, a, u, g, v, b) => {
                const D = f.transform,
                  S = "globe" === D.projection.name;
                let M;
                if ("map" === b.paint.get("circle-pitch-alignment"))
                  if (S) {
                    const k =
                      d.globePixelsToTileUnits(D.zoom, a.canonical) *
                      D._pixelsPerMercatorPixel;
                    M = Float32Array.from([k, 0, 0, k]);
                  } else M = D.calculatePixelsToTileUnitsMatrix(u);
                else
                  M = new Float32Array([
                    D.pixelsToGLUnits[0],
                    0,
                    0,
                    D.pixelsToGLUnits[1],
                  ]);
                const R = {
                  u_camera_to_center_distance: D.cameraToCenterDistance,
                  u_matrix: f.translatePosMatrix(
                    a.projMatrix,
                    u,
                    b.paint.get("circle-translate"),
                    b.paint.get("circle-translate-anchor")
                  ),
                  u_device_pixel_ratio: d.exported.devicePixelRatio,
                  u_extrude_scale: M,
                  u_inv_rot_matrix: ft,
                  u_merc_center: [0, 0],
                  u_tile_id: [0, 0, 0],
                  u_zoom_transition: 0,
                  u_up_dir: [0, 0, 0],
                };
                if (S) {
                  (R.u_inv_rot_matrix = g),
                    (R.u_merc_center = v),
                    (R.u_tile_id = [
                      a.canonical.x,
                      a.canonical.y,
                      1 << a.canonical.z,
                    ]),
                    (R.u_zoom_transition = d.globeToMercatorTransition(D.zoom));
                  const k = v[0] * d.EXTENT,
                    z = v[1] * d.EXTENT;
                  R.u_up_dir = D.projection.upVector(
                    new d.CanonicalTileID(0, 0, 0),
                    k,
                    z
                  );
                }
                return R;
              },
              qn = (f) => {
                const a = [];
                return (
                  "map" === f.paint.get("circle-pitch-alignment") &&
                    a.push("PITCH_WITH_MAP"),
                  "map" === f.paint.get("circle-pitch-scale") &&
                    a.push("SCALE_WITH_MAP"),
                  a
                );
              },
              br = (f, a, u, g) => {
                const v = d.EXTENT / u.tileSize;
                return {
                  u_matrix: f,
                  u_camera_to_center_distance: a.getCameraToCenterDistance(g),
                  u_extrude_scale: [
                    a.pixelsToGLUnits[0] / v,
                    a.pixelsToGLUnits[1] / v,
                  ],
                };
              },
              Go = (f, a, u = 1) => ({
                u_matrix: f,
                u_color: a,
                u_overlay: 0,
                u_overlay_scale: u,
              }),
              Li = d.create(),
              Hs = (f, a, u, g, v, b, D) => {
                const S = f.transform,
                  M = "globe" === S.projection.name,
                  R = M
                    ? d.globePixelsToTileUnits(S.zoom, a.canonical) *
                      S._pixelsPerMercatorPixel
                    : Ai(u, 1, b),
                  k = {
                    u_matrix: a.projMatrix,
                    u_extrude_scale: R,
                    u_intensity: D,
                    u_inv_rot_matrix: Li,
                    u_merc_center: [0, 0],
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_up_dir: [0, 0, 0],
                  };
                if (M) {
                  (k.u_inv_rot_matrix = g),
                    (k.u_merc_center = v),
                    (k.u_tile_id = [
                      a.canonical.x,
                      a.canonical.y,
                      1 << a.canonical.z,
                    ]),
                    (k.u_zoom_transition = d.globeToMercatorTransition(S.zoom));
                  const z = v[0] * d.EXTENT,
                    H = v[1] * d.EXTENT;
                  k.u_up_dir = S.projection.upVector(
                    new d.CanonicalTileID(0, 0, 0),
                    z,
                    H
                  );
                }
                return k;
              },
              ri = (f, a, u, g, v, b, D) => {
                const S = f.transform,
                  M = S.calculatePixelsToTileUnitsMatrix(a);
                return {
                  u_matrix: Jt(f, a, u, g),
                  u_pixels_to_tile_units: M,
                  u_device_pixel_ratio: b,
                  u_units_to_pixels: [
                    1 / S.pixelsToGLUnits[0],
                    1 / S.pixelsToGLUnits[1],
                  ],
                  u_dash_image: 0,
                  u_gradient_image: 1,
                  u_image_height: v,
                  u_texsize: Gs(u) ? a.lineAtlasTexture.size : [0, 0],
                  u_tile_units_to_pixels: qo(a, f.transform),
                  u_alpha_discard_threshold: 0,
                  u_trim_offset: D,
                };
              },
              fs = (f, a, u, g, v) => {
                const b = f.transform;
                return {
                  u_matrix: Jt(f, a, u, g),
                  u_texsize: a.imageAtlasTexture.size,
                  u_pixels_to_tile_units: b.calculatePixelsToTileUnitsMatrix(a),
                  u_device_pixel_ratio: v,
                  u_image: 0,
                  u_tile_units_to_pixels: qo(a, b),
                  u_units_to_pixels: [
                    1 / b.pixelsToGLUnits[0],
                    1 / b.pixelsToGLUnits[1],
                  ],
                  u_alpha_discard_threshold: 0,
                };
              };
            function qo(f, a) {
              return 1 / Ai(f, 1, a.tileZoom);
            }
            function Jt(f, a, u, g) {
              return f.translatePosMatrix(
                g || a.tileID.projMatrix,
                a,
                u.paint.get("line-translate"),
                u.paint.get("line-translate-anchor")
              );
            }
            function Gs(f) {
              const a = f.paint.get("line-dasharray").value;
              return a.value || "constant" !== a.kind;
            }
            const qs = (f, a, u, g, v, b) => {
              return {
                u_matrix: f,
                u_tl_parent: a,
                u_scale_parent: u,
                u_fade_t: g.mix,
                u_opacity: g.opacity * v.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: v.paint.get("raster-brightness-min"),
                u_brightness_high: v.paint.get("raster-brightness-max"),
                u_saturation_factor:
                  ((S = v.paint.get("raster-saturation")),
                  S > 0 ? 1 - 1 / (1.001 - S) : -S),
                u_contrast_factor:
                  ((D = v.paint.get("raster-contrast")),
                  D > 0 ? 1 / (1 - D) : 1 + D),
                u_spin_weights: so(v.paint.get("raster-hue-rotate")),
                u_perspective_transform: b,
              };
              var D, S;
            };
            function so(f) {
              f *= Math.PI / 180;
              const a = Math.sin(f),
                u = Math.cos(f);
              return [
                (2 * u + 1) / 3,
                (-Math.sqrt(3) * a - u + 1) / 3,
                (Math.sqrt(3) * a - u + 1) / 3,
              ];
            }
            const Wo = d.create(),
              Vi = (f, a, u, g, v, b, D, S, M, R, k, z, H, q, X, Z) => {
                const Y = v.transform,
                  B = {
                    u_is_size_zoom_constant: +(
                      "constant" === f || "source" === f
                    ),
                    u_is_size_feature_constant: +(
                      "constant" === f || "camera" === f
                    ),
                    u_size_t: a ? a.uSizeT : 0,
                    u_size: a ? a.uSize : 0,
                    u_camera_to_center_distance: Y.cameraToCenterDistance,
                    u_rotate_symbol: +u,
                    u_aspect_ratio: Y.width / Y.height,
                    u_fade_change: v.options.fadeDuration
                      ? v.symbolFadeChange
                      : 1,
                    u_matrix: b,
                    u_label_plane_matrix: D,
                    u_coord_matrix: S,
                    u_is_text: +M,
                    u_pitch_with_map: +g,
                    u_texsize: R,
                    u_texture: 0,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: Wo,
                    u_merc_center: [0, 0],
                    u_camera_forward: [0, 0, 0],
                    u_ecef_origin: [0, 0, 0],
                    u_tile_matrix: Wo,
                    u_up_vector: [0, -1, 0],
                  };
                return (
                  "globe" === Z.name &&
                    ((B.u_tile_id = [
                      k.canonical.x,
                      k.canonical.y,
                      1 << k.canonical.z,
                    ]),
                    (B.u_zoom_transition = z),
                    (B.u_inv_rot_matrix = q),
                    (B.u_merc_center = H),
                    (B.u_camera_forward = Y._camera.forward()),
                    (B.u_ecef_origin = d.globeECEFOrigin(
                      Y.globeMatrix,
                      k.toUnwrapped()
                    )),
                    (B.u_tile_matrix = Float32Array.from(Y.globeMatrix)),
                    (B.u_up_vector = X)),
                  B
                );
              },
              Ws = (f, a, u, g, v, b, D, S, M, R, k, z, H, q, X, Z, Y) =>
                d.extend(Vi(f, a, u, g, v, b, D, S, M, R, z, H, q, X, Z, Y), {
                  u_gamma_scale: g
                    ? v.transform.cameraToCenterDistance *
                      Math.cos(v.terrain ? 0 : v.transform._pitch)
                    : 1,
                  u_device_pixel_ratio: d.exported.devicePixelRatio,
                  u_is_halo: +k,
                }),
              Na = (f, a, u, g, v, b, D, S, M, R, k, z, H, q, X, Z) =>
                d.extend(
                  Ws(f, a, u, g, v, b, D, S, !0, M, !0, k, z, H, q, X, Z),
                  { u_texsize_icon: R, u_texture_icon: 1 }
                ),
              Zr = (f, a, u) => ({ u_matrix: f, u_opacity: a, u_color: u }),
              Ll = (f, a, u, g, v) =>
                d.extend(
                  (function (b, D, S) {
                    const M = D.imageManager.getPattern(b.toString()),
                      { width: R, height: k } = D.imageManager.getPixelSize(),
                      z = Math.pow(2, S.tileID.overscaledZ),
                      H = (S.tileSize * Math.pow(2, D.transform.tileZoom)) / z,
                      q = H * (S.tileID.canonical.x + S.tileID.wrap * z),
                      X = H * S.tileID.canonical.y;
                    return {
                      u_image: 0,
                      u_pattern_tl: M.tl,
                      u_pattern_br: M.br,
                      u_texsize: [R, k],
                      u_pattern_size: M.displaySize,
                      u_tile_units_to_pixels:
                        1 / Ai(S, 1, D.transform.tileZoom),
                      u_pixel_coord_upper: [q >> 16, X >> 16],
                      u_pixel_coord_lower: [65535 & q, 65535 & X],
                    };
                  })(g, u, v),
                  { u_matrix: f, u_opacity: a }
                ),
              wu = {
                fillExtrusion: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_lightpos: new d.Uniform3f(f),
                  u_lightintensity: new d.Uniform1f(f),
                  u_lightcolor: new d.Uniform3f(f),
                  u_vertical_gradient: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_edge_radius: new d.Uniform1f(f),
                  u_ao: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_up_dir: new d.Uniform3f(f),
                  u_height_lift: new d.Uniform1f(f),
                }),
                fillExtrusionPattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_lightpos: new d.Uniform3f(f),
                  u_lightintensity: new d.Uniform1f(f),
                  u_lightcolor: new d.Uniform3f(f),
                  u_vertical_gradient: new d.Uniform1f(f),
                  u_height_factor: new d.Uniform1f(f),
                  u_edge_radius: new d.Uniform1f(f),
                  u_ao: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_up_dir: new d.Uniform3f(f),
                  u_height_lift: new d.Uniform1f(f),
                  u_image: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                }),
                fill: (f) => ({ u_matrix: new d.UniformMatrix4f(f) }),
                fillPattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_image: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                }),
                fillOutline: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_world: new d.Uniform2f(f),
                }),
                fillOutlinePattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_world: new d.Uniform2f(f),
                  u_image: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                }),
                circle: (f) => ({
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_extrude_scale: new d.UniformMatrix2f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_up_dir: new d.Uniform3f(f),
                }),
                collisionBox: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_extrude_scale: new d.Uniform2f(f),
                }),
                collisionCircle: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_inv_matrix: new d.UniformMatrix4f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_viewport_size: new d.Uniform2f(f),
                }),
                debug: (f) => ({
                  u_color: new d.UniformColor(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_overlay: new d.Uniform1i(f),
                  u_overlay_scale: new d.Uniform1f(f),
                }),
                clippingMask: (f) => ({ u_matrix: new d.UniformMatrix4f(f) }),
                heatmap: (f) => ({
                  u_extrude_scale: new d.Uniform1f(f),
                  u_intensity: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_up_dir: new d.Uniform3f(f),
                }),
                heatmapTexture: (f) => ({
                  u_image: new d.Uniform1i(f),
                  u_color_ramp: new d.Uniform1i(f),
                  u_opacity: new d.Uniform1f(f),
                }),
                hillshade: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_image: new d.Uniform1i(f),
                  u_latrange: new d.Uniform2f(f),
                  u_light: new d.Uniform2f(f),
                  u_shadow: new d.UniformColor(f),
                  u_highlight: new d.UniformColor(f),
                  u_accent: new d.UniformColor(f),
                }),
                hillshadePrepare: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_image: new d.Uniform1i(f),
                  u_dimension: new d.Uniform2f(f),
                  u_zoom: new d.Uniform1f(f),
                  u_unpack: new d.Uniform4f(f),
                }),
                line: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_pixels_to_tile_units: new d.UniformMatrix2f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_units_to_pixels: new d.Uniform2f(f),
                  u_dash_image: new d.Uniform1i(f),
                  u_gradient_image: new d.Uniform1i(f),
                  u_image_height: new d.Uniform1f(f),
                  u_texsize: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                  u_alpha_discard_threshold: new d.Uniform1f(f),
                  u_trim_offset: new d.Uniform2f(f),
                }),
                linePattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixels_to_tile_units: new d.UniformMatrix2f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_image: new d.Uniform1i(f),
                  u_units_to_pixels: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                  u_alpha_discard_threshold: new d.Uniform1f(f),
                }),
                raster: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_tl_parent: new d.Uniform2f(f),
                  u_scale_parent: new d.Uniform1f(f),
                  u_fade_t: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_image0: new d.Uniform1i(f),
                  u_image1: new d.Uniform1i(f),
                  u_brightness_low: new d.Uniform1f(f),
                  u_brightness_high: new d.Uniform1f(f),
                  u_saturation_factor: new d.Uniform1f(f),
                  u_contrast_factor: new d.Uniform1f(f),
                  u_spin_weights: new d.Uniform3f(f),
                  u_perspective_transform: new d.Uniform2f(f),
                }),
                symbolIcon: (f) => ({
                  u_is_size_zoom_constant: new d.Uniform1i(f),
                  u_is_size_feature_constant: new d.Uniform1i(f),
                  u_size_t: new d.Uniform1f(f),
                  u_size: new d.Uniform1f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_rotate_symbol: new d.Uniform1i(f),
                  u_aspect_ratio: new d.Uniform1f(f),
                  u_fade_change: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_label_plane_matrix: new d.UniformMatrix4f(f),
                  u_coord_matrix: new d.UniformMatrix4f(f),
                  u_is_text: new d.Uniform1i(f),
                  u_pitch_with_map: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_camera_forward: new d.Uniform3f(f),
                  u_tile_matrix: new d.UniformMatrix4f(f),
                  u_up_vector: new d.Uniform3f(f),
                  u_ecef_origin: new d.Uniform3f(f),
                  u_texture: new d.Uniform1i(f),
                }),
                symbolSDF: (f) => ({
                  u_is_size_zoom_constant: new d.Uniform1i(f),
                  u_is_size_feature_constant: new d.Uniform1i(f),
                  u_size_t: new d.Uniform1f(f),
                  u_size: new d.Uniform1f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_rotate_symbol: new d.Uniform1i(f),
                  u_aspect_ratio: new d.Uniform1f(f),
                  u_fade_change: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_label_plane_matrix: new d.UniformMatrix4f(f),
                  u_coord_matrix: new d.UniformMatrix4f(f),
                  u_is_text: new d.Uniform1i(f),
                  u_pitch_with_map: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_texture: new d.Uniform1i(f),
                  u_gamma_scale: new d.Uniform1f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_camera_forward: new d.Uniform3f(f),
                  u_tile_matrix: new d.UniformMatrix4f(f),
                  u_up_vector: new d.Uniform3f(f),
                  u_ecef_origin: new d.Uniform3f(f),
                  u_is_halo: new d.Uniform1i(f),
                }),
                symbolTextAndIcon: (f) => ({
                  u_is_size_zoom_constant: new d.Uniform1i(f),
                  u_is_size_feature_constant: new d.Uniform1i(f),
                  u_size_t: new d.Uniform1f(f),
                  u_size: new d.Uniform1f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_rotate_symbol: new d.Uniform1i(f),
                  u_aspect_ratio: new d.Uniform1f(f),
                  u_fade_change: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_label_plane_matrix: new d.UniformMatrix4f(f),
                  u_coord_matrix: new d.UniformMatrix4f(f),
                  u_is_text: new d.Uniform1i(f),
                  u_pitch_with_map: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_texsize_icon: new d.Uniform2f(f),
                  u_texture: new d.Uniform1i(f),
                  u_texture_icon: new d.Uniform1i(f),
                  u_gamma_scale: new d.Uniform1f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_is_halo: new d.Uniform1i(f),
                }),
                background: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_color: new d.UniformColor(f),
                }),
                backgroundPattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_image: new d.Uniform1i(f),
                  u_pattern_tl: new d.Uniform2f(f),
                  u_pattern_br: new d.Uniform2f(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pattern_size: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                }),
                terrainRaster: wn,
                terrainDepth: wn,
                skybox: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_sun_direction: new d.Uniform3f(f),
                  u_cubemap: new d.Uniform1i(f),
                  u_opacity: new d.Uniform1f(f),
                  u_temporal_offset: new d.Uniform1f(f),
                }),
                skyboxGradient: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_color_ramp: new d.Uniform1i(f),
                  u_center_direction: new d.Uniform3f(f),
                  u_radius: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_temporal_offset: new d.Uniform1f(f),
                }),
                skyboxCapture: (f) => ({
                  u_matrix_3f: new d.UniformMatrix3f(f),
                  u_sun_direction: new d.Uniform3f(f),
                  u_sun_intensity: new d.Uniform1f(f),
                  u_color_tint_r: new d.Uniform4f(f),
                  u_color_tint_m: new d.Uniform4f(f),
                  u_luminance: new d.Uniform1f(f),
                }),
                globeRaster: (f) => ({
                  u_proj_matrix: new d.UniformMatrix4f(f),
                  u_globe_matrix: new d.UniformMatrix4f(f),
                  u_normalize_matrix: new d.UniformMatrix4f(f),
                  u_merc_matrix: new d.UniformMatrix4f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_image0: new d.Uniform1i(f),
                  u_grid_matrix: new d.UniformMatrix3f(f),
                  u_skirt_height: new d.Uniform1f(f),
                  u_frustum_tl: new d.Uniform3f(f),
                  u_frustum_tr: new d.Uniform3f(f),
                  u_frustum_br: new d.Uniform3f(f),
                  u_frustum_bl: new d.Uniform3f(f),
                  u_globe_pos: new d.Uniform3f(f),
                  u_globe_radius: new d.Uniform1f(f),
                  u_viewport: new d.Uniform2f(f),
                }),
                globeAtmosphere: (f) => ({
                  u_frustum_tl: new d.Uniform3f(f),
                  u_frustum_tr: new d.Uniform3f(f),
                  u_frustum_br: new d.Uniform3f(f),
                  u_frustum_bl: new d.Uniform3f(f),
                  u_horizon: new d.Uniform1f(f),
                  u_transition: new d.Uniform1f(f),
                  u_fadeout_range: new d.Uniform1f(f),
                  u_color: new d.Uniform4f(f),
                  u_high_color: new d.Uniform4f(f),
                  u_space_color: new d.Uniform4f(f),
                  u_star_intensity: new d.Uniform1f(f),
                  u_star_density: new d.Uniform1f(f),
                  u_star_size: new d.Uniform1f(f),
                  u_temporal_offset: new d.Uniform1f(f),
                  u_horizon_angle: new d.Uniform1f(f),
                  u_rotation_matrix: new d.UniformMatrix4f(f),
                }),
              };
            let Nn;
            function vc(f, a, u, g, v, b, D) {
              const S = f.context,
                M = S.gl,
                R = f.transform,
                k = f.useProgram("collisionBox"),
                z = [];
              let H = 0,
                q = 0;
              for (let te = 0; te < g.length; te++) {
                const he = g[te],
                  de = a.getTile(he),
                  ue = de.getBucket(u);
                if (!ue) continue;
                const _e = yr(he, ue, R);
                let ge = _e;
                (0 === v[0] && 0 === v[1]) ||
                  (ge = f.translatePosMatrix(_e, de, v, b));
                const Te = D ? ue.textCollisionBox : ue.iconCollisionBox,
                  Ge = ue.collisionCircleArray;
                if (Ge.length > 0) {
                  const be = d.create(),
                    Le = ge;
                  d.mul(be, ue.placementInvProjMatrix, R.glCoordMatrix),
                    d.mul(be, be, ue.placementViewportMatrix),
                    z.push({
                      circleArray: Ge,
                      circleOffset: q,
                      transform: Le,
                      invTransform: be,
                      projection: ue.getProjection(),
                    }),
                    (H += Ge.length / 4),
                    (q = H);
                }
                Te &&
                  (f.terrain && f.terrain.setupElevationDraw(de, k),
                  k.draw(
                    S,
                    M.LINES,
                    d.DepthMode.disabled,
                    d.StencilMode.disabled,
                    f.colorModeForRenderPass(),
                    d.CullFaceMode.disabled,
                    br(ge, R, de, ue.getProjection()),
                    u.id,
                    Te.layoutVertexBuffer,
                    Te.indexBuffer,
                    Te.segments,
                    null,
                    R.zoom,
                    null,
                    [Te.collisionVertexBuffer, Te.collisionVertexBufferExt]
                  ));
              }
              if (!D || !z.length) return;
              const X = f.useProgram("collisionCircle"),
                Z = new d.StructArrayLayout2f1f2i16();
              Z.resize(4 * H), Z._trim();
              let Y = 0;
              for (const te of z)
                for (let he = 0; he < te.circleArray.length / 4; he++) {
                  const de = 4 * he,
                    ue = te.circleArray[de + 0],
                    _e = te.circleArray[de + 1],
                    ge = te.circleArray[de + 2],
                    Te = te.circleArray[de + 3];
                  Z.emplace(Y++, ue, _e, ge, Te, 0),
                    Z.emplace(Y++, ue, _e, ge, Te, 1),
                    Z.emplace(Y++, ue, _e, ge, Te, 2),
                    Z.emplace(Y++, ue, _e, ge, Te, 3);
                }
              (!Nn || Nn.length < 2 * H) &&
                (Nn = (function (te) {
                  const he = 2 * te,
                    de = new d.StructArrayLayout3ui6();
                  de.resize(he), de._trim();
                  for (let ue = 0; ue < he; ue++) {
                    const _e = 6 * ue;
                    (de.uint16[_e + 0] = 4 * ue + 0),
                      (de.uint16[_e + 1] = 4 * ue + 1),
                      (de.uint16[_e + 2] = 4 * ue + 2),
                      (de.uint16[_e + 3] = 4 * ue + 2),
                      (de.uint16[_e + 4] = 4 * ue + 3),
                      (de.uint16[_e + 5] = 4 * ue + 0);
                  }
                  return de;
                })(H));
              const B = S.createIndexBuffer(Nn, !0),
                W = S.createVertexBuffer(
                  Z,
                  d.collisionCircleLayout.members,
                  !0
                );
              for (const te of z) {
                const he = {
                  u_matrix: te.transform,
                  u_inv_matrix: te.invTransform,
                  u_camera_to_center_distance: (ee =
                    R).getCameraToCenterDistance(te.projection),
                  u_viewport_size: [ee.width, ee.height],
                };
                X.draw(
                  S,
                  M.TRIANGLES,
                  d.DepthMode.disabled,
                  d.StencilMode.disabled,
                  f.colorModeForRenderPass(),
                  d.CullFaceMode.disabled,
                  he,
                  u.id,
                  W,
                  B,
                  d.SegmentVector.simpleSegment(
                    0,
                    2 * te.circleOffset,
                    te.circleArray.length,
                    te.circleArray.length / 2
                  ),
                  null,
                  R.zoom
                );
              }
              var ee;
              W.destroy(), B.destroy();
            }
            const mp = d.create();
            function kl(
              { width: f, height: a, anchor: u, textOffset: g, textScale: v },
              b
            ) {
              const { horizontalAlign: D, verticalAlign: S } =
                  d.getAnchorAlignment(u),
                M = -(D - 0.5) * f,
                R = -(S - 0.5) * a,
                k = d.evaluateVariableOffset(u, g);
              return new d.Point((M / v + k[0]) * b, (R / v + k[1]) * b);
            }
            function Nh(f, a, u, g, v, b, D, S, M, R, k) {
              const z = f.text.placedSymbolArray,
                H = f.text.dynamicLayoutVertexArray,
                q = f.icon.dynamicLayoutVertexArray,
                X = {},
                Z = f.getProjection(),
                Y = gt(S, Z, b),
                B = b.elevation,
                W = Z.upVectorScale(
                  S.canonical,
                  b.center.lat,
                  b.worldSize
                ).metersToTile;
              H.clear();
              for (let ee = 0; ee < z.length; ee++) {
                const te = z.get(ee),
                  { tileAnchorX: he, tileAnchorY: de, numGlyphs: ue } = te,
                  _e =
                    te.hidden ||
                    !te.crossTileID ||
                    (f.allowVerticalPlacement && !te.placedOrientation)
                      ? null
                      : g[te.crossTileID];
                if (_e) {
                  let ge = 0,
                    Te = 0,
                    Ge = 0;
                  if (B) {
                    const Xe = B ? B.getAtTileOffset(S, he, de) : 0,
                      [mt, It, dt] = Z.upVector(S.canonical, he, de);
                    (ge = Xe * mt * W), (Te = Xe * It * W), (Ge = Xe * dt * W);
                  }
                  let [be, Le, Se, je] = Bi(
                    te.projectedAnchorX + ge,
                    te.projectedAnchorY + Te,
                    te.projectedAnchorZ + Ge,
                    u ? Y : D
                  );
                  const we = sp(b.getCameraToCenterDistance(Z), je);
                  let ke =
                    (v.evaluateSizeForFeature(f.textSizeData, R, te) * we) /
                    d.ONE_EM;
                  u && (ke *= f.tilePixelRatio / M);
                  const He = kl(_e, ke);
                  u
                    ? (({
                        x: be,
                        y: Le,
                        z: Se,
                      } = Z.projectTilePoint(
                        he + He.x,
                        de + He.y,
                        S.canonical
                      )),
                      ([be, Le, Se] = Bi(be + ge, Le + Te, Se + Ge, D)))
                    : (a && He._rotate(-b.angle),
                      (be += He.x),
                      (Le += He.y),
                      (Se = 0));
                  const Ne =
                    f.allowVerticalPlacement &&
                    te.placedOrientation === d.WritingMode.vertical
                      ? Math.PI / 2
                      : 0;
                  for (let Xe = 0; Xe < ue; Xe++)
                    d.addDynamicAttributes(H, be, Le, Se, Ne);
                  k &&
                    te.associatedIconIndex >= 0 &&
                    (X[te.associatedIconIndex] = {
                      x: be,
                      y: Le,
                      z: Se,
                      angle: Ne,
                    });
                } else Pr(ue, H);
              }
              if (k) {
                q.clear();
                const ee = f.icon.placedSymbolArray;
                for (let te = 0; te < ee.length; te++) {
                  const he = ee.get(te),
                    { numGlyphs: de } = he,
                    ue = X[te];
                  if (he.hidden || !ue) Pr(de, q);
                  else {
                    const { x: _e, y: ge, z: Te, angle: Ge } = ue;
                    for (let be = 0; be < de; be++)
                      d.addDynamicAttributes(q, _e, ge, Te, Ge);
                  }
                }
                f.icon.dynamicLayoutVertexBuffer.updateData(q);
              }
              f.text.dynamicLayoutVertexBuffer.updateData(H);
            }
            function za(f, a, u) {
              return u.iconsInText && a
                ? "symbolTextAndIcon"
                : f
                ? "symbolSDF"
                : "symbolIcon";
            }
            function xc(f, a, u, g, v, b, D, S, M, R, k, z) {
              const H = f.context,
                q = H.gl,
                X = f.transform,
                Z = "map" === S,
                Y = "map" === M,
                B = Z && "point" !== u.layout.get("symbol-placement"),
                W = Z && !Y && !B,
                ee = void 0 !== u.layout.get("symbol-sort-key").constantOr(1);
              let te = !1;
              const he = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                de = [
                  d.mercatorXfromLng(X.center.lng),
                  d.mercatorYfromLat(X.center.lat),
                ],
                ue = u.layout.get("text-variable-anchor"),
                _e = "globe" === X.projection.name,
                ge = [],
                Te = [0, -1, 0];
              let Ge = Te;
              (!_e && !X.mercatorFromTransition) ||
                Z ||
                (Ge = (function (be) {
                  const Le = be._camera.getWorldToCamera(be.worldSize, 1),
                    Se = d.multiply([], Le, be.globeMatrix);
                  d.invert(Se, Se);
                  const je = [0, 0, 0],
                    we = [0, 1, 0, 0];
                  return (
                    d.transformMat4$1(we, we, Se),
                    (je[0] = we[0]),
                    (je[1] = we[1]),
                    (je[2] = we[2]),
                    d.normalize(je, je),
                    je
                  );
                })(X));
              for (const be of g) {
                const Le = a.getTile(be),
                  Se = Le.getBucket(u);
                if (!Se || ("mercator" === Se.projection.name && _e)) continue;
                const je = v ? Se.text : Se.icon;
                if (!je || Se.fullyClipped || !je.segments.get().length)
                  continue;
                const we = je.programConfigurations.get(u.id),
                  ke = v || Se.sdfIcons,
                  He = v ? Se.textSizeData : Se.iconSizeData,
                  Ne = Y || 0 !== X.pitch,
                  Xe = d.evaluateSizeForZoom(He, X.zoom);
                let mt,
                  It,
                  dt,
                  Dt,
                  Kt = [0, 0],
                  Ht = null;
                if (v)
                  (It = Le.glyphAtlasTexture),
                    (dt = q.LINEAR),
                    (mt = Le.glyphAtlasTexture.size),
                    Se.iconsInText &&
                      ((Kt = Le.imageAtlasTexture.size),
                      (Ht = Le.imageAtlasTexture),
                      (Dt =
                        Ne ||
                        f.options.rotating ||
                        f.options.zooming ||
                        "composite" === He.kind ||
                        "camera" === He.kind
                          ? q.LINEAR
                          : q.NEAREST));
                else {
                  const Nr =
                    1 !== u.layout.get("icon-size").constantOr(0) ||
                    Se.iconsNeedLinear;
                  (It = Le.imageAtlasTexture),
                    (dt =
                      ke || f.options.rotating || f.options.zooming || Nr || Ne
                        ? q.LINEAR
                        : q.NEAREST),
                    (mt = Le.imageAtlasTexture.size);
                }
                const _t = "globe" === Se.projection.name,
                  en = _t ? Ge : Te,
                  On = _t ? d.globeToMercatorTransition(X.zoom) : 0,
                  _n = gt(be, Se.getProjection(), X),
                  Sn = X.calculatePixelsToTileUnitsMatrix(Le),
                  Hi = Ae(
                    _n,
                    Le.tileID.canonical,
                    Y,
                    Z,
                    X,
                    Se.getProjection(),
                    Sn
                  ),
                  vi = f.terrain && Y && B ? d.invert(d.create(), Hi) : mp,
                  Er = mi(
                    _n,
                    Le.tileID.canonical,
                    Y,
                    Z,
                    X,
                    Se.getProjection(),
                    Sn
                  ),
                  Ko = ue && Se.hasTextData(),
                  Hn =
                    "none" !== u.layout.get("icon-text-fit") &&
                    Ko &&
                    Se.hasIconData();
                if (B) {
                  const Nr = X.elevation,
                    na = Nr
                      ? Nr.getAtTileOffsetFunc(
                          be,
                          X.center.lat,
                          X.worldSize,
                          Se.getProjection()
                        )
                      : null,
                    Wa = Vo(
                      _n,
                      Le.tileID.canonical,
                      Y,
                      Z,
                      X,
                      Se.getProjection(),
                      Sn
                    );
                  Mh(Se, _n, f, v, Wa, Er, Y, R, na, be);
                }
                const Pn = B || (v && ue) || Hn,
                  hn = f.translatePosMatrix(_n, Le, b, D),
                  si = Pn ? mp : Hi,
                  Tr = f.translatePosMatrix(Er, Le, b, D, !0),
                  Fn = Se.getProjection().createInversionMatrix(
                    X,
                    be.canonical
                  ),
                  Gi = [];
                f.terrainRenderModeElevated() &&
                  Y &&
                  Gi.push("PITCH_WITH_MAP_TERRAIN"),
                  _t && Gi.push("PROJECTION_GLOBE_VIEW"),
                  Pn && Gi.push("PROJECTED_POS_ON_VIEWPORT");
                const zu =
                  ke &&
                  0 !==
                    u.paint
                      .get(v ? "text-halo-width" : "icon-halo-width")
                      .constantOr(1);
                let ta;
                ta = ke
                  ? Se.iconsInText
                    ? Na(
                        He.kind,
                        Xe,
                        W,
                        Y,
                        f,
                        hn,
                        si,
                        Tr,
                        mt,
                        Kt,
                        be,
                        On,
                        de,
                        Fn,
                        en,
                        Se.getProjection()
                      )
                    : Ws(
                        He.kind,
                        Xe,
                        W,
                        Y,
                        f,
                        hn,
                        si,
                        Tr,
                        v,
                        mt,
                        !0,
                        be,
                        On,
                        de,
                        Fn,
                        en,
                        Se.getProjection()
                      )
                  : Vi(
                      He.kind,
                      Xe,
                      W,
                      Y,
                      f,
                      hn,
                      si,
                      Tr,
                      v,
                      mt,
                      be,
                      On,
                      de,
                      Fn,
                      en,
                      Se.getProjection()
                    );
                const Bl = {
                  program: f.useProgram(za(ke, v, Se), we, Gi),
                  buffers: je,
                  uniformValues: ta,
                  atlasTexture: It,
                  atlasTextureIcon: Ht,
                  atlasInterpolation: dt,
                  atlasInterpolationIcon: Dt,
                  isSDF: ke,
                  hasHalo: zu,
                  tile: Le,
                  labelPlaneMatrixInv: vi,
                };
                if (ee && Se.canOverlap) {
                  te = !0;
                  const Nr = je.segments.get();
                  for (const na of Nr)
                    ge.push({
                      segments: new d.SegmentVector([na]),
                      sortKey: na.sortKey,
                      state: Bl,
                    });
                } else
                  ge.push({ segments: je.segments, sortKey: 0, state: Bl });
              }
              te && ge.sort((be, Le) => be.sortKey - Le.sortKey);
              for (const be of ge) {
                const Le = be.state;
                if (
                  (f.terrain &&
                    f.terrain.setupElevationDraw(Le.tile, Le.program, {
                      useDepthForOcclusion: !_e,
                      labelPlaneMatrixInv: Le.labelPlaneMatrixInv,
                    }),
                  H.activeTexture.set(q.TEXTURE0),
                  Le.atlasTexture.bind(Le.atlasInterpolation, q.CLAMP_TO_EDGE),
                  Le.atlasTextureIcon &&
                    (H.activeTexture.set(q.TEXTURE1),
                    Le.atlasTextureIcon &&
                      Le.atlasTextureIcon.bind(
                        Le.atlasInterpolationIcon,
                        q.CLAMP_TO_EDGE
                      )),
                  Le.isSDF)
                ) {
                  const Se = Le.uniformValues;
                  Le.hasHalo &&
                    ((Se.u_is_halo = 1),
                    bo(
                      Le.buffers,
                      be.segments,
                      u,
                      f,
                      Le.program,
                      he,
                      k,
                      z,
                      Se
                    )),
                    (Se.u_is_halo = 0);
                }
                bo(
                  Le.buffers,
                  be.segments,
                  u,
                  f,
                  Le.program,
                  he,
                  k,
                  z,
                  Le.uniformValues
                );
              }
            }
            function bo(f, a, u, g, v, b, D, S, M) {
              const R = g.context,
                k = [
                  f.dynamicLayoutVertexBuffer,
                  f.opacityVertexBuffer,
                  f.globeExtVertexBuffer,
                ];
              v.draw(
                R,
                R.gl.TRIANGLES,
                b,
                D,
                S,
                d.CullFaceMode.disabled,
                M,
                u.id,
                f.layoutVertexBuffer,
                f.indexBuffer,
                a,
                u.paint,
                g.transform.zoom,
                f.programConfigurations.get(u.id),
                k
              );
            }
            function Qi(f, a, u, g, v, b, D) {
              const S = f.context.gl,
                M = u.paint.get("fill-pattern"),
                R = M && M.constantOr(1);
              let k, z, H, q, X;
              D
                ? ((z =
                    R && !u.getPaintProperty("fill-outline-color")
                      ? "fillOutlinePattern"
                      : "fillOutline"),
                  (k = S.LINES))
                : ((z = R ? "fillPattern" : "fill"), (k = S.TRIANGLES));
              for (const Z of g) {
                const Y = a.getTile(Z);
                if (R && !Y.patternsLoaded()) continue;
                const B = Y.getBucket(u);
                if (!B) continue;
                f.prepareDrawTile();
                const W = B.programConfigurations.get(u.id),
                  ee = f.useProgram(z, W);
                R &&
                  (f.context.activeTexture.set(S.TEXTURE0),
                  Y.imageAtlasTexture.bind(S.LINEAR, S.CLAMP_TO_EDGE),
                  W.updatePaintBuffers());
                const te = M.constantOr(null);
                if (te && Y.imageAtlas) {
                  const de = Y.imageAtlas.patternPositions[te.toString()];
                  de && W.setConstantPatternPositions(de);
                }
                const he = f.translatePosMatrix(
                  Z.projMatrix,
                  Y,
                  u.paint.get("fill-translate"),
                  u.paint.get("fill-translate-anchor")
                );
                if (D) {
                  (q = B.indexBuffer2), (X = B.segments2);
                  const de =
                    f.terrain && f.terrain.renderingToTexture
                      ? f.terrain.drapeBufferSize
                      : [S.drawingBufferWidth, S.drawingBufferHeight];
                  H =
                    "fillOutlinePattern" === z && R
                      ? oo(he, f, Y, de)
                      : Wr(he, de);
                } else
                  (q = B.indexBuffer),
                    (X = B.segments),
                    (H = R ? Fa(he, f, Y) : _i(he));
                f.prepareDrawProgram(f.context, ee, Z.toUnwrapped()),
                  ee.draw(
                    f.context,
                    k,
                    v,
                    f.stencilModeForClipping(Z),
                    b,
                    d.CullFaceMode.disabled,
                    H,
                    u.id,
                    B.layoutVertexBuffer,
                    q,
                    X,
                    u.paint,
                    f.transform.zoom,
                    W
                  );
              }
            }
            function Eu(f, a, u, g, v, b, D) {
              const S = f.context,
                M = S.gl,
                R = f.transform,
                k = u.paint.get("fill-extrusion-pattern"),
                z = k.constantOr(1),
                H = u.paint.get("fill-extrusion-opacity"),
                q = [
                  u.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                  u.paint.get("fill-extrusion-ambient-occlusion-radius"),
                ],
                X = u.layout.get("fill-extrusion-edge-radius"),
                Z = X > 0 && !u.paint.get("fill-extrusion-rounded-roof"),
                Y = Z ? 0 : X,
                B =
                  "globe" === R.projection.name
                    ? d.fillExtrusionHeightLift()
                    : 0,
                W = "globe" === R.projection.name,
                ee = W ? d.globeToMercatorTransition(R.zoom) : 0,
                te = [
                  d.mercatorXfromLng(R.center.lng),
                  d.mercatorYfromLat(R.center.lat),
                ],
                he = [];
              W && he.push("PROJECTION_GLOBE_VIEW"),
                q[0] > 0 && he.push("FAUX_AO"),
                Z && he.push("ZERO_ROOF_RADIUS");
              for (const de of g) {
                const ue = a.getTile(de),
                  _e = ue.getBucket(u);
                if (!_e || _e.projection.name !== R.projection.name) continue;
                const ge = _e.programConfigurations.get(u.id),
                  Te = f.useProgram(
                    z ? "fillExtrusionPattern" : "fillExtrusion",
                    ge,
                    he
                  );
                if (f.terrain) {
                  const ke = f.terrain;
                  if (f.style.terrainSetForDrapingOnly())
                    ke.setupElevationDraw(ue, Te, { useMeterToDem: !0 });
                  else {
                    if (!_e.enableTerrain) continue;
                    if (
                      (ke.setupElevationDraw(ue, Te, { useMeterToDem: !0 }),
                      wr(S, a, de, _e, u, ke),
                      !_e.centroidVertexBuffer)
                    ) {
                      const He = Te.attributes.a_centroid_pos;
                      void 0 !== He && M.vertexAttrib2f(He, 0, 0);
                    }
                  }
                }
                z &&
                  (f.context.activeTexture.set(M.TEXTURE0),
                  ue.imageAtlasTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE),
                  ge.updatePaintBuffers());
                const Ge = k.constantOr(null);
                if (Ge && ue.imageAtlas) {
                  const ke = ue.imageAtlas.patternPositions[Ge.toString()];
                  ke && ge.setConstantPatternPositions(ke);
                }
                const be = f.translatePosMatrix(
                    de.projMatrix,
                    ue,
                    u.paint.get("fill-extrusion-translate"),
                    u.paint.get("fill-extrusion-translate-anchor")
                  ),
                  Le = R.projection.createInversionMatrix(R, de.canonical),
                  Se = u.paint.get("fill-extrusion-vertical-gradient"),
                  je = z
                    ? lr(be, f, Se, H, q, Y, de, ue, B, ee, te, Le)
                    : An(be, f, Se, H, q, Y, de, B, ee, te, Le);
                f.prepareDrawProgram(S, Te, de.toUnwrapped());
                const we = [];
                f.terrain && we.push(_e.centroidVertexBuffer),
                  W && we.push(_e.layoutVertexExtBuffer),
                  Te.draw(
                    S,
                    S.gl.TRIANGLES,
                    v,
                    b,
                    D,
                    d.CullFaceMode.backCCW,
                    je,
                    u.id,
                    _e.layoutVertexBuffer,
                    _e.indexBuffer,
                    _e.segments,
                    u.paint,
                    f.transform.zoom,
                    ge,
                    we
                  );
              }
            }
            function wr(f, a, u, g, v, b) {
              const D = [
                  (B) => {
                    let W = B.canonical.x - 1,
                      ee = B.wrap;
                    return (
                      W < 0 && ((W = (1 << B.canonical.z) - 1), ee--),
                      new d.OverscaledTileID(
                        B.overscaledZ,
                        ee,
                        B.canonical.z,
                        W,
                        B.canonical.y
                      )
                    );
                  },
                  (B) => {
                    let W = B.canonical.x + 1,
                      ee = B.wrap;
                    return (
                      W === 1 << B.canonical.z && ((W = 0), ee++),
                      new d.OverscaledTileID(
                        B.overscaledZ,
                        ee,
                        B.canonical.z,
                        W,
                        B.canonical.y
                      )
                    );
                  },
                  (B) =>
                    new d.OverscaledTileID(
                      B.overscaledZ,
                      B.wrap,
                      B.canonical.z,
                      B.canonical.x,
                      (0 === B.canonical.y
                        ? 1 << B.canonical.z
                        : B.canonical.y) - 1
                    ),
                  (B) =>
                    new d.OverscaledTileID(
                      B.overscaledZ,
                      B.wrap,
                      B.canonical.z,
                      B.canonical.x,
                      B.canonical.y === (1 << B.canonical.z) - 1
                        ? 0
                        : B.canonical.y + 1
                    ),
                ],
                S = (B) => {
                  const W = a.getSource().minzoom,
                    ee = (he) => {
                      const de = a.getTileByID(he);
                      if (de && de.hasData()) return de.getBucket(v);
                    },
                    te = [0, -1, 1];
                  for (const he of te) {
                    if (B.overscaledZ + he < W) continue;
                    const de = ee(B.calculateScaledKey(B.overscaledZ + he));
                    if (de) return de;
                  }
                },
                M = [0, 0, 0],
                R = (B, W) => (
                  (M[0] = Math.min(B.min.y, W.min.y)),
                  (M[1] = Math.max(B.max.y, W.max.y)),
                  (M[2] =
                    d.EXTENT - W.min.x > B.max.x
                      ? W.min.x - d.EXTENT
                      : B.max.x),
                  M
                ),
                k = (B, W) => (
                  (M[0] = Math.min(B.min.x, W.min.x)),
                  (M[1] = Math.max(B.max.x, W.max.x)),
                  (M[2] =
                    d.EXTENT - W.min.y > B.max.y
                      ? W.min.y - d.EXTENT
                      : B.max.y),
                  M
                ),
                z = [
                  (B, W) => R(B, W),
                  (B, W) => R(W, B),
                  (B, W) => k(B, W),
                  (B, W) => k(W, B),
                ],
                H = new d.Point(0, 0);
              let q, X, Z;
              const Y = (B, W, ee, te, he) => {
                const de = [
                    [te ? ee : B, te ? B : ee, 0],
                    [te ? ee : W, te ? W : ee, 0],
                  ],
                  ue = he < 0 ? d.EXTENT + he : he,
                  _e = [te ? ue : (B + W) / 2, te ? (B + W) / 2 : ue, 0];
                return (
                  (0 === ee && he < 0) || (0 !== ee && he > 0)
                    ? b.getForTilePoints(Z, [_e], !0, X)
                    : de.push(_e),
                  b.getForTilePoints(u, de, !0, q),
                  Math.max(de[0][2], de[1][2], _e[2]) / b.exaggeration()
                );
              };
              for (let B = 0; B < 4; B++) {
                const W = (B < 2 ? 1 : 5) - B,
                  ee = g.borders[B];
                if (0 === ee.length) continue;
                const te = (Z = D[B](u)),
                  he = S(te);
                if (
                  !(
                    he &&
                    he instanceof d.FillExtrusionBucket &&
                    he.enableTerrain
                  ) ||
                  (g.borderDoneWithNeighborZ[B] === he.canonical.z &&
                    he.borderDoneWithNeighborZ[W] === g.canonical.z) ||
                  ((X = b.findDEMTileFor(te)), !X || !X.dem)
                )
                  continue;
                if (!q) {
                  const ge = b.findDEMTileFor(u);
                  if (!ge || !ge.dem) return;
                  q = ge;
                }
                const de = he.borders[W];
                let ue = 0;
                const _e = he.borderDoneWithNeighborZ[W] !== g.canonical.z;
                if (g.canonical.z === he.canonical.z) {
                  for (let ge = 0; ge < ee.length; ge++) {
                    const Te = g.featuresOnBorder[ee[ge]],
                      Ge = Te.borders[B];
                    let be;
                    for (
                      ;
                      ue < de.length &&
                      ((be = he.featuresOnBorder[de[ue]]),
                      !(be.borders[W][1] > Ge[0] + 3));

                    )
                      _e && he.encodeCentroid(void 0, be, !1), ue++;
                    if (be && ue < de.length) {
                      const Le = ue;
                      let Se = 0;
                      for (
                        ;
                        !(be.borders[W][0] > Ge[1] - 3) &&
                        (Se++, ++ue !== de.length);

                      )
                        be = he.featuresOnBorder[de[ue]];
                      if (
                        ((be = he.featuresOnBorder[de[Le]]),
                        Te.intersectsCount() > 1 ||
                          be.intersectsCount() > 1 ||
                          1 !== Se)
                      ) {
                        1 !== Se && (ue = Le),
                          g.encodeCentroid(void 0, Te, !1),
                          _e && he.encodeCentroid(void 0, be, !1);
                        continue;
                      }
                      const je = z[B](Te, be),
                        we = B % 2 ? d.EXTENT - 1 : 0;
                      (H.x = Y(
                        je[0],
                        Math.min(d.EXTENT - 1, je[1]),
                        we,
                        B < 2,
                        je[2]
                      )),
                        (H.y = 0),
                        g.encodeCentroid(H, Te, !1),
                        _e && he.encodeCentroid(H, be, !1);
                    } else g.encodeCentroid(void 0, Te, !1);
                  }
                  (g.borderDoneWithNeighborZ[B] = he.canonical.z),
                    (g.needsCentroidUpdate = !0),
                    _e &&
                      ((he.borderDoneWithNeighborZ[W] = g.canonical.z),
                      (he.needsCentroidUpdate = !0));
                } else {
                  for (const ge of ee)
                    g.encodeCentroid(void 0, g.featuresOnBorder[ge], !1);
                  if (_e) {
                    for (const ge of de)
                      he.encodeCentroid(void 0, he.featuresOnBorder[ge], !1);
                    (he.borderDoneWithNeighborZ[W] = g.canonical.z),
                      (he.needsCentroidUpdate = !0);
                  }
                  (g.borderDoneWithNeighborZ[B] = he.canonical.z),
                    (g.needsCentroidUpdate = !0);
                }
              }
              (g.needsCentroidUpdate ||
                (!g.centroidVertexBuffer &&
                  0 !== g.centroidVertexArray.length)) &&
                g.uploadCentroid(f);
            }
            const cr = new d.Color(1, 0, 0, 1),
              zh = new d.Color(0, 1, 0, 1),
              Tu = new d.Color(0, 0, 1, 1),
              Du = new d.Color(1, 0, 1, 1),
              wo = new d.Color(0, 1, 1, 1);
            function Rf(f, a, u) {
              const g = f.context,
                v = f.transform,
                b = g.gl,
                D = "globe" === v.projection.name,
                S = D ? ["PROJECTION_GLOBE_VIEW"] : null;
              let M = u.projMatrix;
              if (D && d.globeToMercatorTransition(v.zoom) > 0) {
                const Te = d.transitionTileAABBinECEF(u.canonical, v),
                  Ge = d.globeDenormalizeECEF(Te);
                (M = d.multiply(new Float32Array(16), v.globeMatrix, Ge)),
                  d.multiply(M, v.projMatrix, M);
              }
              const R = f.useProgram("debug", null, S),
                k = a.getTileByID(u.key);
              f.terrain && f.terrain.setupElevationDraw(k, R);
              const z = d.DepthMode.disabled,
                H = d.StencilMode.disabled,
                q = f.colorModeForRenderPass(),
                X = "$debug";
              g.activeTexture.set(b.TEXTURE0),
                f.emptyTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE),
                D
                  ? k._makeGlobeTileDebugBuffers(f.context, v)
                  : k._makeDebugTileBoundsBuffers(f.context, v.projection);
              const Z = k._tileDebugBuffer || f.debugBuffer,
                Y = k._tileDebugIndexBuffer || f.debugIndexBuffer,
                B = k._tileDebugSegments || f.debugSegments;
              R.draw(
                g,
                b.LINE_STRIP,
                z,
                H,
                q,
                d.CullFaceMode.disabled,
                Go(M, d.Color.red),
                X,
                Z,
                Y,
                B,
                null,
                null,
                null,
                [k._globeTileDebugBorderBuffer]
              );
              const W = k.latestRawTileData,
                ee = Math.floor(((W && W.byteLength) || 0) / 1024),
                te = a.getTile(u).tileSize,
                he = (512 / Math.min(te, 512)) * (u.overscaledZ / v.zoom) * 0.5;
              let de = u.canonical.toString();
              u.overscaledZ !== u.canonical.z && (de += ` => ${u.overscaledZ}`),
                (de += ` ${ee}kb`),
                (function (Te, Ge) {
                  Te.initDebugOverlayCanvas();
                  const be = Te.debugOverlayCanvas,
                    Le = Te.context.gl,
                    Se = Te.debugOverlayCanvas.getContext("2d");
                  Se.clearRect(0, 0, be.width, be.height),
                    (Se.shadowColor = "white"),
                    (Se.shadowBlur = 2),
                    (Se.lineWidth = 1.5),
                    (Se.strokeStyle = "white"),
                    (Se.textBaseline = "top"),
                    (Se.font = "bold 36px Open Sans, sans-serif"),
                    Se.fillText(Ge, 5, 5),
                    Se.strokeText(Ge, 5, 5),
                    Te.debugOverlayTexture.update(be),
                    Te.debugOverlayTexture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE);
                })(f, de);
              const ue = k._tileDebugTextBuffer || f.debugBuffer,
                _e = k._tileDebugTextIndexBuffer || f.quadTriangleIndexBuffer,
                ge = k._tileDebugTextSegments || f.debugSegments;
              R.draw(
                g,
                b.TRIANGLES,
                z,
                H,
                d.ColorMode.alphaBlended,
                d.CullFaceMode.disabled,
                Go(M, d.Color.transparent, he),
                X,
                ue,
                _e,
                ge,
                null,
                null,
                null,
                [k._globeTileDebugTextBuffer]
              );
            }
            function Of(f, a, u, g) {
              Rl(f, 0, a + u / 2, f.transform.width, u, g);
            }
            function Cu(f, a, u, g) {
              Rl(f, a - u / 2, 0, u, f.transform.height, g);
            }
            function Rl(f, a, u, g, v, b) {
              const D = f.context,
                S = D.gl;
              S.enable(S.SCISSOR_TEST),
                S.scissor(
                  a * d.exported.devicePixelRatio,
                  u * d.exported.devicePixelRatio,
                  g * d.exported.devicePixelRatio,
                  v * d.exported.devicePixelRatio
                ),
                D.clear({ color: b }),
                S.disable(S.SCISSOR_TEST);
            }
            const Ff = d.createLayout([
                { name: "a_pos_3f", components: 3, type: "Float32" },
              ]),
              { members: Nf } = Ff;
            function Zs(f, a, u, g) {
              f.emplaceBack(a, u, g);
            }
            class Bh {
              constructor(a) {
                (this.vertexArray = new d.StructArrayLayout3f12()),
                  (this.indices = new d.StructArrayLayout3ui6()),
                  Zs(this.vertexArray, -1, -1, 1),
                  Zs(this.vertexArray, 1, -1, 1),
                  Zs(this.vertexArray, -1, 1, 1),
                  Zs(this.vertexArray, 1, 1, 1),
                  Zs(this.vertexArray, -1, -1, -1),
                  Zs(this.vertexArray, 1, -1, -1),
                  Zs(this.vertexArray, -1, 1, -1),
                  Zs(this.vertexArray, 1, 1, -1),
                  this.indices.emplaceBack(5, 1, 3),
                  this.indices.emplaceBack(3, 7, 5),
                  this.indices.emplaceBack(6, 2, 0),
                  this.indices.emplaceBack(0, 4, 6),
                  this.indices.emplaceBack(2, 6, 7),
                  this.indices.emplaceBack(7, 3, 2),
                  this.indices.emplaceBack(5, 4, 0),
                  this.indices.emplaceBack(0, 1, 5),
                  this.indices.emplaceBack(0, 2, 3),
                  this.indices.emplaceBack(3, 1, 0),
                  this.indices.emplaceBack(7, 6, 4),
                  this.indices.emplaceBack(4, 5, 7),
                  (this.vertexBuffer = a.createVertexBuffer(
                    this.vertexArray,
                    Nf
                  )),
                  (this.indexBuffer = a.createIndexBuffer(this.indices)),
                  (this.segment = d.SegmentVector.simpleSegment(0, 0, 36, 12));
              }
            }
            function Eo(f, a, u, g, v, b) {
              const D = f.gl,
                S = a.paint.get("sky-atmosphere-color"),
                M = a.paint.get("sky-atmosphere-halo-color"),
                R = a.paint.get("sky-atmosphere-sun-intensity"),
                k = {
                  u_matrix_3f: d.fromMat4(d.create$1(), g),
                  u_sun_direction: v,
                  u_sun_intensity: R,
                  u_color_tint_r: [(X = S).r, X.g, X.b, X.a],
                  u_color_tint_m: [(Z = M).r, Z.g, Z.b, Z.a],
                  u_luminance: 5e-5,
                };
              var X, Z;
              D.framebufferTexture2D(
                D.FRAMEBUFFER,
                D.COLOR_ATTACHMENT0,
                D.TEXTURE_CUBE_MAP_POSITIVE_X + b,
                a.skyboxTexture,
                0
              ),
                u.draw(
                  f,
                  D.TRIANGLES,
                  d.DepthMode.disabled,
                  d.StencilMode.disabled,
                  d.ColorMode.unblended,
                  d.CullFaceMode.frontCW,
                  k,
                  "skyboxCapture",
                  a.skyboxGeometry.vertexBuffer,
                  a.skyboxGeometry.indexBuffer,
                  a.skyboxGeometry.segment
                );
            }
            const Su = d.createLayout([
              { type: "Float32", name: "a_pos", components: 3 },
              { type: "Float32", name: "a_uv", components: 2 },
            ]);
            class zf {
              constructor(a) {
                const u = new d.StructArrayLayout5f20();
                u.emplaceBack(-1, 1, 1, 0, 0),
                  u.emplaceBack(1, 1, 1, 1, 0),
                  u.emplaceBack(1, -1, 1, 1, 1),
                  u.emplaceBack(-1, -1, 1, 0, 1);
                const g = new d.StructArrayLayout3ui6();
                g.emplaceBack(0, 1, 2),
                  g.emplaceBack(2, 3, 0),
                  (this.vertexBuffer = a.createVertexBuffer(u, Su.members)),
                  (this.indexBuffer = a.createIndexBuffer(g)),
                  (this.segments = d.SegmentVector.simpleSegment(0, 0, 4, 2));
              }
              destroy() {
                this.vertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy();
              }
            }
            const Ol = {
              symbol: function (f, a, u, g, v) {
                if ("translucent" !== f.renderPass) return;
                const b = d.StencilMode.disabled,
                  D = f.colorModeForRenderPass();
                u.layout.get("text-variable-anchor") &&
                  (function (S, M, R, k, z, H, q) {
                    const X = M.transform,
                      Z = "map" === z,
                      Y = "map" === H;
                    for (const B of S) {
                      const W = k.getTile(B),
                        ee = W.getBucket(R);
                      if (!ee || !ee.text || !ee.text.segments.get().length)
                        continue;
                      const te = d.evaluateSizeForZoom(ee.textSizeData, X.zoom),
                        he = gt(B, ee.getProjection(), X),
                        de = X.calculatePixelsToTileUnitsMatrix(W),
                        ue = Ae(
                          he,
                          W.tileID.canonical,
                          Y,
                          Z,
                          X,
                          ee.getProjection(),
                          de
                        ),
                        _e =
                          "none" !== R.layout.get("icon-text-fit") &&
                          ee.hasIconData();
                      if (te) {
                        const ge = Math.pow(2, X.zoom - W.tileID.overscaledZ);
                        Nh(ee, Z, Y, q, d.symbolSize, X, ue, B, ge, te, _e);
                      }
                    }
                  })(
                    g,
                    f,
                    u,
                    a,
                    u.layout.get("text-rotation-alignment"),
                    u.layout.get("text-pitch-alignment"),
                    v
                  ),
                  0 !== u.paint.get("icon-opacity").constantOr(1) &&
                    xc(
                      f,
                      a,
                      u,
                      g,
                      !1,
                      u.paint.get("icon-translate"),
                      u.paint.get("icon-translate-anchor"),
                      u.layout.get("icon-rotation-alignment"),
                      u.layout.get("icon-pitch-alignment"),
                      u.layout.get("icon-keep-upright"),
                      b,
                      D
                    ),
                  0 !== u.paint.get("text-opacity").constantOr(1) &&
                    xc(
                      f,
                      a,
                      u,
                      g,
                      !0,
                      u.paint.get("text-translate"),
                      u.paint.get("text-translate-anchor"),
                      u.layout.get("text-rotation-alignment"),
                      u.layout.get("text-pitch-alignment"),
                      u.layout.get("text-keep-upright"),
                      b,
                      D
                    ),
                  a.map.showCollisionBoxes &&
                    (vc(
                      f,
                      a,
                      u,
                      g,
                      u.paint.get("text-translate"),
                      u.paint.get("text-translate-anchor"),
                      !0
                    ),
                    vc(
                      f,
                      a,
                      u,
                      g,
                      u.paint.get("icon-translate"),
                      u.paint.get("icon-translate-anchor"),
                      !1
                    ));
              },
              circle: function (f, a, u, g) {
                if ("translucent" !== f.renderPass) return;
                const v = u.paint.get("circle-opacity"),
                  b = u.paint.get("circle-stroke-width"),
                  D = u.paint.get("circle-stroke-opacity"),
                  S = void 0 !== u.layout.get("circle-sort-key").constantOr(1);
                if (
                  0 === v.constantOr(1) &&
                  (0 === b.constantOr(1) || 0 === D.constantOr(1))
                )
                  return;
                const M = f.context,
                  R = M.gl,
                  k = f.transform,
                  z = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                  H = d.StencilMode.disabled,
                  q = f.colorModeForRenderPass(),
                  X = "globe" === k.projection.name,
                  Z = [
                    d.mercatorXfromLng(k.center.lng),
                    d.mercatorYfromLat(k.center.lat),
                  ],
                  Y = [];
                for (let W = 0; W < g.length; W++) {
                  const ee = g[W],
                    te = a.getTile(ee),
                    he = te.getBucket(u);
                  if (!he || he.projection.name !== k.projection.name) continue;
                  const de = he.programConfigurations.get(u.id),
                    ue = qn(u);
                  X && ue.push("PROJECTION_GLOBE_VIEW");
                  const _e = f.useProgram("circle", de, ue),
                    ge = he.layoutVertexBuffer,
                    Te = he.globeExtVertexBuffer,
                    Ge = he.indexBuffer,
                    be = k.projection.createInversionMatrix(k, ee.canonical),
                    Le = {
                      programConfiguration: de,
                      program: _e,
                      layoutVertexBuffer: ge,
                      globeExtVertexBuffer: Te,
                      indexBuffer: Ge,
                      uniformValues: Xt(f, ee, te, be, Z, u),
                      tile: te,
                    };
                  if (S) {
                    const Se = he.segments.get();
                    for (const je of Se)
                      Y.push({
                        segments: new d.SegmentVector([je]),
                        sortKey: je.sortKey,
                        state: Le,
                      });
                  } else
                    Y.push({ segments: he.segments, sortKey: 0, state: Le });
                }
                S && Y.sort((W, ee) => W.sortKey - ee.sortKey);
                const B = { useDepthForOcclusion: !X };
                for (const W of Y) {
                  const {
                      programConfiguration: ee,
                      program: te,
                      layoutVertexBuffer: he,
                      globeExtVertexBuffer: de,
                      indexBuffer: ue,
                      uniformValues: _e,
                      tile: ge,
                    } = W.state,
                    Te = W.segments;
                  f.terrain && f.terrain.setupElevationDraw(ge, te, B),
                    f.prepareDrawProgram(M, te, ge.tileID.toUnwrapped()),
                    te.draw(
                      M,
                      R.TRIANGLES,
                      z,
                      H,
                      q,
                      d.CullFaceMode.disabled,
                      _e,
                      u.id,
                      he,
                      ue,
                      Te,
                      u.paint,
                      k.zoom,
                      ee,
                      [de]
                    );
                }
              },
              heatmap: function (f, a, u, g) {
                if (0 !== u.paint.get("heatmap-opacity"))
                  if ("offscreen" === f.renderPass) {
                    const v = f.context,
                      b = v.gl,
                      D = d.StencilMode.disabled,
                      S = new d.ColorMode([b.ONE, b.ONE], d.Color.transparent, [
                        !0,
                        !0,
                        !0,
                        !0,
                      ]);
                    (function (q, X, Z, Y) {
                      const B = q.gl,
                        W = X.width * Y,
                        ee = X.height * Y;
                      q.activeTexture.set(B.TEXTURE1),
                        q.viewport.set([0, 0, W, ee]);
                      let te = Z.heatmapFbo;
                      if (!te || (te && (te.width !== W || te.height !== ee))) {
                        te && te.destroy();
                        const he = B.createTexture();
                        B.bindTexture(B.TEXTURE_2D, he),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_WRAP_S,
                            B.CLAMP_TO_EDGE
                          ),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_WRAP_T,
                            B.CLAMP_TO_EDGE
                          ),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_MIN_FILTER,
                            B.LINEAR
                          ),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_MAG_FILTER,
                            B.LINEAR
                          ),
                          (te = Z.heatmapFbo = q.createFramebuffer(W, ee, !1)),
                          (function (de, ue, _e, ge, Te, Ge) {
                            const be = de.gl;
                            be.texImage2D(
                              be.TEXTURE_2D,
                              0,
                              de.isWebGL2 && de.extRenderToTextureHalfFloat
                                ? be.RGBA16F
                                : be.RGBA,
                              Te,
                              Ge,
                              0,
                              be.RGBA,
                              de.extRenderToTextureHalfFloat
                                ? de.isWebGL2
                                  ? be.HALF_FLOAT
                                  : de.extTextureHalfFloat.HALF_FLOAT_OES
                                : be.UNSIGNED_BYTE,
                              null
                            ),
                              ge.colorAttachment.set(_e);
                          })(q, 0, he, te, W, ee);
                      } else
                        B.bindTexture(B.TEXTURE_2D, te.colorAttachment.get()),
                          q.bindFramebuffer.set(te.framebuffer);
                    })(
                      v,
                      f,
                      u,
                      "globe" === f.transform.projection.name ? 0.5 : 0.25
                    ),
                      v.clear({ color: d.Color.transparent });
                    const M = f.transform,
                      R = "globe" === M.projection.name,
                      k = R ? ["PROJECTION_GLOBE_VIEW"] : null,
                      z = R ? d.CullFaceMode.frontCCW : d.CullFaceMode.disabled,
                      H = [
                        d.mercatorXfromLng(M.center.lng),
                        d.mercatorYfromLat(M.center.lat),
                      ];
                    for (let q = 0; q < g.length; q++) {
                      const X = g[q];
                      if (a.hasRenderableParent(X)) continue;
                      const Z = a.getTile(X),
                        Y = Z.getBucket(u);
                      if (!Y || Y.projection.name !== M.projection.name)
                        continue;
                      const B = Y.programConfigurations.get(u.id),
                        W = f.useProgram("heatmap", B, k),
                        { zoom: ee } = f.transform;
                      f.terrain && f.terrain.setupElevationDraw(Z, W),
                        f.prepareDrawProgram(v, W, X.toUnwrapped());
                      const te = M.projection.createInversionMatrix(
                        M,
                        X.canonical
                      );
                      W.draw(
                        v,
                        b.TRIANGLES,
                        d.DepthMode.disabled,
                        D,
                        S,
                        z,
                        Hs(
                          f,
                          X,
                          Z,
                          te,
                          H,
                          ee,
                          u.paint.get("heatmap-intensity")
                        ),
                        u.id,
                        Y.layoutVertexBuffer,
                        Y.indexBuffer,
                        Y.segments,
                        u.paint,
                        f.transform.zoom,
                        B,
                        R ? [Y.globeExtVertexBuffer] : null
                      );
                    }
                    v.viewport.set([0, 0, f.width, f.height]);
                  } else
                    "translucent" === f.renderPass &&
                      (f.context.setColorMode(f.colorModeForRenderPass()),
                      (function (v, b) {
                        const D = v.context,
                          S = D.gl,
                          M = b.heatmapFbo;
                        if (!M) return;
                        D.activeTexture.set(S.TEXTURE0),
                          S.bindTexture(S.TEXTURE_2D, M.colorAttachment.get()),
                          D.activeTexture.set(S.TEXTURE1);
                        let R = b.colorRampTexture;
                        R ||
                          (R = b.colorRampTexture =
                            new d.Texture(D, b.colorRamp, S.RGBA)),
                          R.bind(S.LINEAR, S.CLAMP_TO_EDGE),
                          v
                            .useProgram("heatmapTexture")
                            .draw(
                              D,
                              S.TRIANGLES,
                              d.DepthMode.disabled,
                              d.StencilMode.disabled,
                              v.colorModeForRenderPass(),
                              d.CullFaceMode.disabled,
                              {
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: b.paint.get("heatmap-opacity"),
                              },
                              b.id,
                              v.viewportBuffer,
                              v.quadTriangleIndexBuffer,
                              v.viewportSegments,
                              b.paint,
                              v.transform.zoom
                            );
                      })(f, u));
              },
              line: function (f, a, u, g) {
                if ("translucent" !== f.renderPass) return;
                const v = u.paint.get("line-opacity"),
                  b = u.paint.get("line-width");
                if (0 === v.constantOr(1) || 0 === b.constantOr(1)) return;
                const D = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                  S = f.colorModeForRenderPass(),
                  M =
                    f.terrain && f.terrain.renderingToTexture
                      ? 1
                      : d.exported.devicePixelRatio,
                  R = u.paint.get("line-dasharray"),
                  k = R.constantOr(1),
                  z = u.layout.get("line-cap"),
                  H = u.paint.get("line-pattern"),
                  q = H.constantOr(1),
                  X = u.paint.get("line-gradient"),
                  Z = q ? "linePattern" : "line",
                  Y = f.context,
                  B = Y.gl,
                  W = ((te) => {
                    const he = [];
                    Gs(te) && he.push("RENDER_LINE_DASH"),
                      te.paint.get("line-gradient") &&
                        he.push("RENDER_LINE_GRADIENT");
                    const de = te.paint.get("line-trim-offset");
                    (0 === de[0] && 0 === de[1]) ||
                      he.push("RENDER_LINE_TRIM_OFFSET");
                    const ue = te.paint.get("line-pattern").constantOr(1),
                      _e = 1 !== te.paint.get("line-opacity").constantOr(1);
                    return (
                      !ue && _e && he.push("RENDER_LINE_ALPHA_DISCARD"), he
                    );
                  })(u);
                let ee = W.includes("RENDER_LINE_ALPHA_DISCARD");
                f.terrain &&
                  f.terrain.clipOrMaskOverlapStencilType() &&
                  (ee = !1);
                for (const te of g) {
                  const he = a.getTile(te);
                  if (q && !he.patternsLoaded()) continue;
                  const de = he.getBucket(u);
                  if (!de) continue;
                  f.prepareDrawTile();
                  const ue = de.programConfigurations.get(u.id),
                    _e = f.useProgram(Z, ue, W),
                    ge = H.constantOr(null);
                  if (ge && he.imageAtlas) {
                    const ke = he.imageAtlas.patternPositions[ge.toString()];
                    ke && ue.setConstantPatternPositions(ke);
                  }
                  const Te = R.constantOr(null),
                    Ge = z.constantOr(null);
                  if (!q && Te && Ge && he.lineAtlas) {
                    const ke = he.lineAtlas.getDash(Te, Ge);
                    ke && ue.setConstantPatternPositions(ke);
                  }
                  let [be, Le] = u.paint.get("line-trim-offset");
                  ("round" === Ge || "square" === Ge) &&
                    be !== Le &&
                    (0 === be && (be -= 1), 1 === Le && (Le += 1));
                  const Se = f.terrain ? te.projMatrix : null,
                    je = q
                      ? fs(f, he, u, Se, M)
                      : ri(f, he, u, Se, de.lineClipsArray.length, M, [be, Le]);
                  if (X) {
                    const ke = de.gradients[u.id];
                    let He = ke.texture;
                    if (u.gradientVersion !== ke.version) {
                      let Ne = 256;
                      if (u.stepInterpolant) {
                        const Xe = a.getSource().maxzoom,
                          mt =
                            te.canonical.z === Xe
                              ? Math.ceil(
                                  1 << (f.transform.maxZoom - te.canonical.z)
                                )
                              : 1;
                        Ne = d.clamp(
                          d.nextPowerOfTwo(
                            (de.maxLineLength / d.EXTENT) * 1024 * mt
                          ),
                          256,
                          Y.maxTextureSize
                        );
                      }
                      (ke.gradient = d.renderColorRamp({
                        expression: u.gradientExpression(),
                        evaluationKey: "lineProgress",
                        resolution: Ne,
                        image: ke.gradient || void 0,
                        clips: de.lineClipsArray,
                      })),
                        ke.texture
                          ? ke.texture.update(ke.gradient)
                          : (ke.texture = new d.Texture(
                              Y,
                              ke.gradient,
                              B.RGBA
                            )),
                        (ke.version = u.gradientVersion),
                        (He = ke.texture);
                    }
                    Y.activeTexture.set(B.TEXTURE1),
                      He.bind(
                        u.stepInterpolant ? B.NEAREST : B.LINEAR,
                        B.CLAMP_TO_EDGE
                      );
                  }
                  k &&
                    (Y.activeTexture.set(B.TEXTURE0),
                    he.lineAtlasTexture.bind(B.LINEAR, B.REPEAT),
                    ue.updatePaintBuffers()),
                    q &&
                      (Y.activeTexture.set(B.TEXTURE0),
                      he.imageAtlasTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE),
                      ue.updatePaintBuffers()),
                    f.prepareDrawProgram(Y, _e, te.toUnwrapped());
                  const we = (ke) => {
                    _e.draw(
                      Y,
                      B.TRIANGLES,
                      D,
                      ke,
                      S,
                      d.CullFaceMode.disabled,
                      je,
                      u.id,
                      de.layoutVertexBuffer,
                      de.indexBuffer,
                      de.segments,
                      u.paint,
                      f.transform.zoom,
                      ue,
                      [de.layoutVertexBuffer2]
                    );
                  };
                  if (ee) {
                    const ke = f.stencilModeForClipping(te).ref;
                    0 === ke && f.terrain && Y.clear({ stencil: 0 });
                    const He = { func: B.EQUAL, mask: 255 };
                    (je.u_alpha_discard_threshold = 0.8),
                      we(
                        new d.StencilMode(He, ke, 255, B.KEEP, B.KEEP, B.INVERT)
                      ),
                      (je.u_alpha_discard_threshold = 0),
                      we(
                        new d.StencilMode(He, ke, 255, B.KEEP, B.KEEP, B.KEEP)
                      );
                  } else we(f.stencilModeForClipping(te));
                }
                ee &&
                  (f.resetStencilClippingMasks(),
                  f.terrain && Y.clear({ stencil: 0 }));
              },
              fill: function (f, a, u, g) {
                const v = u.paint.get("fill-color"),
                  b = u.paint.get("fill-opacity");
                if (0 === b.constantOr(1)) return;
                const D = f.colorModeForRenderPass(),
                  S = u.paint.get("fill-pattern"),
                  M =
                    f.opaquePassEnabledForLayer() &&
                    !S.constantOr(1) &&
                    1 === v.constantOr(d.Color.transparent).a &&
                    1 === b.constantOr(0)
                      ? "opaque"
                      : "translucent";
                if (f.renderPass === M) {
                  const R = f.depthModeForSublayer(
                    1,
                    "opaque" === f.renderPass
                      ? d.DepthMode.ReadWrite
                      : d.DepthMode.ReadOnly
                  );
                  Qi(f, a, u, g, R, D, !1);
                }
                if (
                  "translucent" === f.renderPass &&
                  u.paint.get("fill-antialias")
                ) {
                  const R = f.depthModeForSublayer(
                    u.getPaintProperty("fill-outline-color") ? 2 : 0,
                    d.DepthMode.ReadOnly
                  );
                  Qi(f, a, u, g, R, D, !0);
                }
              },
              "fill-extrusion": function (f, a, u, g) {
                const v = u.paint.get("fill-extrusion-opacity");
                if (0 !== v && "translucent" === f.renderPass) {
                  const b = new d.DepthMode(
                    f.context.gl.LEQUAL,
                    d.DepthMode.ReadWrite,
                    f.depthRangeFor3D
                  );
                  if (
                    1 !== v ||
                    u.paint.get("fill-extrusion-pattern").constantOr(1)
                  )
                    Eu(
                      f,
                      a,
                      u,
                      g,
                      b,
                      d.StencilMode.disabled,
                      d.ColorMode.disabled
                    ),
                      Eu(
                        f,
                        a,
                        u,
                        g,
                        b,
                        f.stencilModeFor3D(),
                        f.colorModeForRenderPass()
                      ),
                      f.resetStencilClippingMasks();
                  else {
                    const D = f.colorModeForRenderPass();
                    Eu(f, a, u, g, b, d.StencilMode.disabled, D);
                  }
                }
              },
              hillshade: function (f, a, u, g) {
                if (
                  "offscreen" !== f.renderPass &&
                  "translucent" !== f.renderPass
                )
                  return;
                const v = f.context,
                  b = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                  D = f.colorModeForRenderPass(),
                  S = f.terrain && f.terrain.renderingToTexture,
                  [M, R] =
                    "translucent" !== f.renderPass || S
                      ? [{}, g]
                      : f.stencilConfigForOverlap(g);
                for (const k of R) {
                  const z = a.getTile(k);
                  if (z.needsHillshadePrepare && "offscreen" === f.renderPass)
                    Oa(f, z, u, b, d.StencilMode.disabled, D);
                  else if ("translucent" === f.renderPass) {
                    const H =
                      S && f.terrain
                        ? f.terrain.stencilModeForRTTOverlap(k)
                        : M[k.overscaledZ];
                    kf(f, k, z, u, b, H, D);
                  }
                }
                v.viewport.set([0, 0, f.width, f.height]),
                  f.resetStencilClippingMasks();
              },
              raster: function (f, a, u, g, v, b) {
                if (
                  "translucent" !== f.renderPass ||
                  0 === u.paint.get("raster-opacity") ||
                  !g.length
                )
                  return;
                const D = f.context,
                  S = D.gl,
                  M = a.getSource(),
                  R = f.useProgram("raster"),
                  k = f.colorModeForRenderPass(),
                  z = f.terrain && f.terrain.renderingToTexture,
                  [H, q] =
                    M instanceof Ut || z
                      ? [{}, g]
                      : f.stencilConfigForOverlap(g),
                  X = q[q.length - 1].overscaledZ,
                  Z = !f.options.moving;
                for (const Y of q) {
                  const B = z
                      ? d.DepthMode.disabled
                      : f.depthModeForSublayer(
                          Y.overscaledZ - X,
                          1 === u.paint.get("raster-opacity")
                            ? d.DepthMode.ReadWrite
                            : d.DepthMode.ReadOnly,
                          S.LESS
                        ),
                    W = Y.toUnwrapped(),
                    ee = a.getTile(Y);
                  if (z && (!ee || !ee.hasData())) continue;
                  const te = z
                      ? Y.projMatrix
                      : f.transform.calculateProjMatrix(W, Z),
                    he =
                      f.terrain && z
                        ? f.terrain.stencilModeForRTTOverlap(Y)
                        : H[Y.overscaledZ],
                    de = b ? 0 : u.paint.get("raster-fade-duration");
                  ee.registerFadeDuration(de);
                  const ue = a.findLoadedParent(Y, 0),
                    _e = Oh(ee, ue, a, f.transform, de);
                  let ge, Te;
                  f.terrain && f.terrain.prepareDrawTile();
                  const Ge =
                    "nearest" === u.paint.get("raster-resampling")
                      ? S.NEAREST
                      : S.LINEAR;
                  D.activeTexture.set(S.TEXTURE0),
                    ee.texture.bind(Ge, S.CLAMP_TO_EDGE),
                    D.activeTexture.set(S.TEXTURE1),
                    ue
                      ? (ue.texture.bind(Ge, S.CLAMP_TO_EDGE),
                        (ge = Math.pow(
                          2,
                          ue.tileID.overscaledZ - ee.tileID.overscaledZ
                        )),
                        (Te = [
                          (ee.tileID.canonical.x * ge) % 1,
                          (ee.tileID.canonical.y * ge) % 1,
                        ]))
                      : ee.texture.bind(Ge, S.CLAMP_TO_EDGE),
                    ee.texture.useMipmap &&
                      D.extTextureFilterAnisotropic &&
                      f.transform.pitch > 20 &&
                      S.texParameterf(
                        S.TEXTURE_2D,
                        D.extTextureFilterAnisotropic
                          .TEXTURE_MAX_ANISOTROPY_EXT,
                        D.extTextureFilterAnisotropicMax
                      );
                  const be = qs(
                    te,
                    Te || [0, 0],
                    ge || 1,
                    _e,
                    u,
                    M instanceof Ut ? M.perspectiveTransform : [0, 0]
                  );
                  if ((f.prepareDrawProgram(D, R, W), M instanceof Ut))
                    M.boundsBuffer &&
                      M.boundsSegments &&
                      R.draw(
                        D,
                        S.TRIANGLES,
                        B,
                        d.StencilMode.disabled,
                        k,
                        d.CullFaceMode.disabled,
                        be,
                        u.id,
                        M.boundsBuffer,
                        f.quadTriangleIndexBuffer,
                        M.boundsSegments
                      );
                  else {
                    const {
                      tileBoundsBuffer: Le,
                      tileBoundsIndexBuffer: Se,
                      tileBoundsSegments: je,
                    } = f.getTileBoundsBuffers(ee);
                    R.draw(
                      D,
                      S.TRIANGLES,
                      B,
                      he,
                      k,
                      d.CullFaceMode.disabled,
                      be,
                      u.id,
                      Le,
                      Se,
                      je
                    );
                  }
                }
                f.resetStencilClippingMasks();
              },
              background: function (f, a, u, g) {
                const v = u.paint.get("background-color"),
                  b = u.paint.get("background-opacity");
                if (0 === b) return;
                const D = f.context,
                  S = D.gl,
                  M = f.transform,
                  R = M.tileSize,
                  k = u.paint.get("background-pattern");
                if (f.isPatternMissing(k)) return;
                const z =
                  !k && 1 === v.a && 1 === b && f.opaquePassEnabledForLayer()
                    ? "opaque"
                    : "translucent";
                if (f.renderPass !== z) return;
                const H = d.StencilMode.disabled,
                  q = f.depthModeForSublayer(
                    0,
                    "opaque" === z
                      ? d.DepthMode.ReadWrite
                      : d.DepthMode.ReadOnly
                  ),
                  X = f.colorModeForRenderPass(),
                  Z = f.useProgram(k ? "backgroundPattern" : "background");
                let Y,
                  B = g;
                B ||
                  ((Y = f.getBackgroundTiles()),
                  (B = Object.values(Y).map((W) => W.tileID))),
                  k &&
                    (D.activeTexture.set(S.TEXTURE0),
                    f.imageManager.bind(f.context));
                for (const W of B) {
                  const ee = W.toUnwrapped(),
                    te = g ? W.projMatrix : f.transform.calculateProjMatrix(ee);
                  f.prepareDrawTile();
                  const he = a
                      ? a.getTile(W)
                      : Y
                      ? Y[W.key]
                      : new d.Tile(W, R, M.zoom, f),
                    de = k
                      ? Ll(te, b, f, k, { tileID: W, tileSize: R })
                      : Zr(te, b, v);
                  f.prepareDrawProgram(D, Z, ee);
                  const {
                    tileBoundsBuffer: ue,
                    tileBoundsIndexBuffer: _e,
                    tileBoundsSegments: ge,
                  } = f.getTileBoundsBuffers(he);
                  Z.draw(
                    D,
                    S.TRIANGLES,
                    q,
                    H,
                    X,
                    d.CullFaceMode.disabled,
                    de,
                    u.id,
                    ue,
                    _e,
                    ge
                  );
                }
              },
              sky: function (f, a, u) {
                const g = f.transform,
                  v =
                    "mercator" === g.projection.name ||
                    "globe" === g.projection.name
                      ? 1
                      : d.smoothstep(7, 8, g.zoom),
                  b = u.paint.get("sky-opacity") * v;
                if (0 === b) return;
                const D = f.context,
                  S = u.paint.get("sky-type"),
                  M = new d.DepthMode(
                    D.gl.LEQUAL,
                    d.DepthMode.ReadOnly,
                    [0, 1]
                  ),
                  R = (f.frameCounter / 1e3) % 1;
                "atmosphere" === S
                  ? "offscreen" === f.renderPass
                    ? u.needsSkyboxCapture(f) &&
                      ((function (k, z, H, q) {
                        const X = k.context,
                          Z = X.gl;
                        let Y = z.skyboxFbo;
                        if (!Y) {
                          (Y = z.skyboxFbo = X.createFramebuffer(32, 32, !1)),
                            (z.skyboxGeometry = new Bh(X)),
                            (z.skyboxTexture = X.gl.createTexture()),
                            Z.bindTexture(Z.TEXTURE_CUBE_MAP, z.skyboxTexture),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_WRAP_S,
                              Z.CLAMP_TO_EDGE
                            ),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_WRAP_T,
                              Z.CLAMP_TO_EDGE
                            ),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_MIN_FILTER,
                              Z.LINEAR
                            ),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_MAG_FILTER,
                              Z.LINEAR
                            );
                          for (let te = 0; te < 6; ++te)
                            Z.texImage2D(
                              Z.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                              0,
                              Z.RGBA,
                              32,
                              32,
                              0,
                              Z.RGBA,
                              Z.UNSIGNED_BYTE,
                              null
                            );
                        }
                        X.bindFramebuffer.set(Y.framebuffer),
                          X.viewport.set([0, 0, 32, 32]);
                        const B = z.getCenter(k, !0),
                          W = k.useProgram("skyboxCapture"),
                          ee = new Float64Array(16);
                        d.identity(ee),
                          d.rotateY(ee, ee, 0.5 * -Math.PI),
                          Eo(X, z, W, ee, B, 0),
                          d.identity(ee),
                          d.rotateY(ee, ee, 0.5 * Math.PI),
                          Eo(X, z, W, ee, B, 1),
                          d.identity(ee),
                          d.rotateX(ee, ee, 0.5 * -Math.PI),
                          Eo(X, z, W, ee, B, 2),
                          d.identity(ee),
                          d.rotateX(ee, ee, 0.5 * Math.PI),
                          Eo(X, z, W, ee, B, 3),
                          d.identity(ee),
                          Eo(X, z, W, ee, B, 4),
                          d.identity(ee),
                          d.rotateY(ee, ee, Math.PI),
                          Eo(X, z, W, ee, B, 5),
                          X.viewport.set([0, 0, k.width, k.height]);
                      })(f, u),
                      u.markSkyboxValid(f))
                    : "sky" === f.renderPass &&
                      (function (k, z, H, q, X) {
                        const Z = k.context,
                          Y = Z.gl,
                          B = k.transform,
                          W = k.useProgram("skybox");
                        Z.activeTexture.set(Y.TEXTURE0),
                          Y.bindTexture(Y.TEXTURE_CUBE_MAP, z.skyboxTexture);
                        const ee = {
                          u_matrix: B.skyboxMatrix,
                          u_sun_direction: z.getCenter(k, !1),
                          u_cubemap: 0,
                          u_opacity: q,
                          u_temporal_offset: X,
                        };
                        k.prepareDrawProgram(Z, W),
                          W.draw(
                            Z,
                            Y.TRIANGLES,
                            H,
                            d.StencilMode.disabled,
                            k.colorModeForRenderPass(),
                            d.CullFaceMode.backCW,
                            ee,
                            "skybox",
                            z.skyboxGeometry.vertexBuffer,
                            z.skyboxGeometry.indexBuffer,
                            z.skyboxGeometry.segment
                          );
                      })(f, u, M, b, R)
                  : "gradient" === S &&
                    "sky" === f.renderPass &&
                    (function (k, z, H, q, X) {
                      const Z = k.context,
                        Y = Z.gl,
                        B = k.transform,
                        W = k.useProgram("skyboxGradient");
                      z.skyboxGeometry || (z.skyboxGeometry = new Bh(Z)),
                        Z.activeTexture.set(Y.TEXTURE0);
                      let ee = z.colorRampTexture;
                      ee ||
                        (ee = z.colorRampTexture =
                          new d.Texture(Z, z.colorRamp, Y.RGBA)),
                        ee.bind(Y.LINEAR, Y.CLAMP_TO_EDGE);
                      const te =
                        ((he = B.skyboxMatrix),
                        (de = z.getCenter(k, !1)),
                        (ue = z.paint.get("sky-gradient-radius")),
                        (_e = q),
                        (ge = X),
                        {
                          u_matrix: he,
                          u_color_ramp: 0,
                          u_center_direction: de,
                          u_radius: d.degToRad(ue),
                          u_opacity: _e,
                          u_temporal_offset: ge,
                        });
                      var he, de, ue, _e, ge;
                      k.prepareDrawProgram(Z, W),
                        W.draw(
                          Z,
                          Y.TRIANGLES,
                          H,
                          d.StencilMode.disabled,
                          k.colorModeForRenderPass(),
                          d.CullFaceMode.backCW,
                          te,
                          "skyboxGradient",
                          z.skyboxGeometry.vertexBuffer,
                          z.skyboxGeometry.indexBuffer,
                          z.skyboxGeometry.segment
                        );
                    })(f, u, M, b, R);
              },
              debug: function (f, a, u) {
                for (let g = 0; g < u.length; g++) Rf(f, a, u[g]);
              },
              custom: function (f, a, u, g) {
                const v = f.context,
                  b = u.implementation;
                if (
                  !f.transform.projection.unsupportedLayers ||
                  !f.transform.projection.unsupportedLayers.includes(
                    "custom"
                  ) ||
                  (f.terrain &&
                    (f.terrain.renderingToTexture ||
                      "offscreen" === f.renderPass) &&
                    u.isLayerDraped())
                ) {
                  if ("offscreen" === f.renderPass) {
                    const D = b.prerender;
                    if (D) {
                      if (
                        (f.setCustomLayerDefaults(),
                        v.setColorMode(f.colorModeForRenderPass()),
                        "globe" === f.transform.projection.name)
                      ) {
                        const S = f.transform.pointMerc;
                        D.call(
                          b,
                          v.gl,
                          f.transform.customLayerMatrix(),
                          f.transform.getProjection(),
                          f.transform.globeToMercatorMatrix(),
                          d.globeToMercatorTransition(f.transform.zoom),
                          [S.x, S.y],
                          f.transform.pixelsPerMeterRatio
                        );
                      } else D.call(b, v.gl, f.transform.customLayerMatrix());
                      v.setDirty(), f.setBaseState();
                    }
                  } else if ("translucent" === f.renderPass) {
                    if (f.terrain && f.terrain.renderingToTexture) {
                      const S = b.renderToTile;
                      if (S) {
                        const M = g[0].canonical,
                          R = new d.MercatorCoordinate(
                            M.x + g[0].wrap * (1 << M.z),
                            M.y,
                            M.z
                          );
                        v.setDepthMode(d.DepthMode.disabled),
                          v.setStencilMode(d.StencilMode.disabled),
                          v.setColorMode(f.colorModeForRenderPass()),
                          f.setCustomLayerDefaults(),
                          S.call(b, v.gl, R),
                          v.setDirty(),
                          f.setBaseState();
                      }
                      return;
                    }
                    f.setCustomLayerDefaults(),
                      v.setColorMode(f.colorModeForRenderPass()),
                      v.setStencilMode(d.StencilMode.disabled);
                    const D =
                      "3d" === b.renderingMode
                        ? new d.DepthMode(
                            f.context.gl.LEQUAL,
                            d.DepthMode.ReadWrite,
                            f.depthRangeFor3D
                          )
                        : f.depthModeForSublayer(0, d.DepthMode.ReadOnly);
                    if (
                      (v.setDepthMode(D),
                      "globe" === f.transform.projection.name)
                    ) {
                      const S = f.transform.pointMerc;
                      b.render(
                        v.gl,
                        f.transform.customLayerMatrix(),
                        f.transform.getProjection(),
                        f.transform.globeToMercatorMatrix(),
                        d.globeToMercatorTransition(f.transform.zoom),
                        [S.x, S.y],
                        f.transform.pixelsPerMeterRatio
                      );
                    } else b.render(v.gl, f.transform.customLayerMatrix());
                    v.setDirty(), f.setBaseState(), v.bindFramebuffer.set(null);
                  }
                } else
                  d.warnOnce(
                    "Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers."
                  );
              },
            };
            class bc {
              constructor(a, u, g = !1) {
                (this.context = new Qe(a, g)),
                  (this.transform = u),
                  (this._tileTextures = {}),
                  (this.frameCopies = []),
                  (this.loadTimeStamps = []),
                  this.setup(),
                  (this.numSublayers =
                    d.SourceCache.maxUnderzooming +
                    d.SourceCache.maxOverzooming +
                    1),
                  (this.depthEpsilon = 1 / Math.pow(2, 16)),
                  (this.deferredRenderGpuTimeQueries = []),
                  (this.gpuTimers = {}),
                  (this.frameCounter = 0),
                  (this._backgroundTiles = {});
              }
              updateTerrain(a, u) {
                const g =
                  !!a &&
                  !!a.terrain &&
                  this.transform.projection.supportsTerrain;
                if (!(g || (this._terrain && this._terrain.enabled))) return;
                this._terrain || (this._terrain = new Fh(this, a));
                const v = this._terrain;
                (this.transform.elevation = g ? v : null),
                  v.update(a, this.transform, u);
              }
              _updateFog(a) {
                const u = a.fog;
                if (
                  !u ||
                  "globe" === this.transform.projection.name ||
                  u.getOpacity(this.transform.pitch) < 1 ||
                  u.properties.get("horizon-blend") < 0.03
                )
                  return void (this.transform.fogCullDistSq = null);
                const [g, v] = u.getFovAdjustedRange(this.transform._fov);
                if (g > v) return void (this.transform.fogCullDistSq = null);
                const b = g + 0.78 * (v - g);
                this.transform.fogCullDistSq = b * b;
              }
              get terrain() {
                return this.transform._terrainEnabled() &&
                  this._terrain &&
                  this._terrain.enabled
                  ? this._terrain
                  : null;
              }
              resize(a, u) {
                if (
                  ((this.width = a * d.exported.devicePixelRatio),
                  (this.height = u * d.exported.devicePixelRatio),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.style)
                )
                  for (const g of this.style.order)
                    this.style._layers[g].resize();
              }
              setup() {
                const a = this.context,
                  u = new d.StructArrayLayout2i4();
                u.emplaceBack(0, 0),
                  u.emplaceBack(d.EXTENT, 0),
                  u.emplaceBack(0, d.EXTENT),
                  u.emplaceBack(d.EXTENT, d.EXTENT),
                  (this.tileExtentBuffer = a.createVertexBuffer(
                    u,
                    d.posAttributes.members
                  )),
                  (this.tileExtentSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const g = new d.StructArrayLayout2i4();
                g.emplaceBack(0, 0),
                  g.emplaceBack(d.EXTENT, 0),
                  g.emplaceBack(0, d.EXTENT),
                  g.emplaceBack(d.EXTENT, d.EXTENT),
                  (this.debugBuffer = a.createVertexBuffer(
                    g,
                    d.posAttributes.members
                  )),
                  (this.debugSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    5
                  ));
                const v = new d.StructArrayLayout2i4();
                v.emplaceBack(-1, -1),
                  v.emplaceBack(1, -1),
                  v.emplaceBack(-1, 1),
                  v.emplaceBack(1, 1),
                  (this.viewportBuffer = a.createVertexBuffer(
                    v,
                    d.posAttributes.members
                  )),
                  (this.viewportSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const b = new d.StructArrayLayout4i8();
                b.emplaceBack(0, 0, 0, 0),
                  b.emplaceBack(d.EXTENT, 0, d.EXTENT, 0),
                  b.emplaceBack(0, d.EXTENT, 0, d.EXTENT),
                  b.emplaceBack(d.EXTENT, d.EXTENT, d.EXTENT, d.EXTENT),
                  (this.mercatorBoundsBuffer = a.createVertexBuffer(
                    b,
                    d.boundsAttributes.members
                  )),
                  (this.mercatorBoundsSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const D = new d.StructArrayLayout3ui6();
                D.emplaceBack(0, 1, 2),
                  D.emplaceBack(2, 1, 3),
                  (this.quadTriangleIndexBuffer = a.createIndexBuffer(D));
                const S = new d.StructArrayLayout1ui2();
                for (const R of [0, 1, 3, 2, 0]) S.emplaceBack(R);
                (this.debugIndexBuffer = a.createIndexBuffer(S)),
                  (this.emptyTexture = new d.Texture(
                    a,
                    new d.RGBAImage(
                      { width: 1, height: 1 },
                      Uint8Array.of(0, 0, 0, 0)
                    ),
                    a.gl.RGBA
                  )),
                  (this.identityMat = d.create());
                const M = this.context.gl;
                (this.stencilClearMode = new d.StencilMode(
                  { func: M.ALWAYS, mask: 0 },
                  0,
                  255,
                  M.ZERO,
                  M.ZERO,
                  M.ZERO
                )),
                  this.loadTimeStamps.push(d.window.performance.now()),
                  (this.atmosphereBuffer = new zf(this.context));
              }
              getMercatorTileBoundsBuffers() {
                return {
                  tileBoundsBuffer: this.mercatorBoundsBuffer,
                  tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                  tileBoundsSegments: this.mercatorBoundsSegments,
                };
              }
              getTileBoundsBuffers(a) {
                return (
                  a._makeTileBoundsBuffers(
                    this.context,
                    this.transform.projection
                  ),
                  a._tileBoundsBuffer
                    ? {
                        tileBoundsBuffer: a._tileBoundsBuffer,
                        tileBoundsIndexBuffer: a._tileBoundsIndexBuffer,
                        tileBoundsSegments: a._tileBoundsSegments,
                      }
                    : this.getMercatorTileBoundsBuffers()
                );
              }
              clearStencil() {
                const a = this.context,
                  u = a.gl;
                (this.nextStencilID = 1),
                  (this.currentStencilSource = void 0),
                  (this._tileClippingMaskIDs = {}),
                  this.useProgram("clippingMask").draw(
                    a,
                    u.TRIANGLES,
                    d.DepthMode.disabled,
                    this.stencilClearMode,
                    d.ColorMode.disabled,
                    d.CullFaceMode.disabled,
                    Yi(this.identityMat),
                    "$clipping",
                    this.viewportBuffer,
                    this.quadTriangleIndexBuffer,
                    this.viewportSegments
                  );
              }
              resetStencilClippingMasks() {
                this.terrain ||
                  ((this.currentStencilSource = void 0),
                  (this._tileClippingMaskIDs = {}));
              }
              _renderTileClippingMasks(a, u, g) {
                if (
                  !u ||
                  this.currentStencilSource === u.id ||
                  !a.isTileClipped() ||
                  !g ||
                  0 === g.length
                )
                  return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                  let S = !1;
                  for (const M of g)
                    if (void 0 === this._tileClippingMaskIDs[M.key]) {
                      S = !0;
                      break;
                    }
                  if (!S) return;
                }
                this.currentStencilSource = u.id;
                const v = this.context,
                  b = v.gl;
                this.nextStencilID + g.length > 256 && this.clearStencil(),
                  v.setColorMode(d.ColorMode.disabled),
                  v.setDepthMode(d.DepthMode.disabled);
                const D = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const S of g) {
                  const M = u.getTile(S),
                    R = (this._tileClippingMaskIDs[S.key] = this
                      .nextStencilID++),
                    {
                      tileBoundsBuffer: k,
                      tileBoundsIndexBuffer: z,
                      tileBoundsSegments: H,
                    } = this.getTileBoundsBuffers(M);
                  D.draw(
                    v,
                    b.TRIANGLES,
                    d.DepthMode.disabled,
                    new d.StencilMode(
                      { func: b.ALWAYS, mask: 0 },
                      R,
                      255,
                      b.KEEP,
                      b.KEEP,
                      b.REPLACE
                    ),
                    d.ColorMode.disabled,
                    d.CullFaceMode.disabled,
                    Yi(S.projMatrix),
                    "$clipping",
                    k,
                    z,
                    H
                  );
                }
              }
              stencilModeFor3D() {
                (this.currentStencilSource = void 0),
                  this.nextStencilID + 1 > 256 && this.clearStencil();
                const a = this.nextStencilID++,
                  u = this.context.gl;
                return new d.StencilMode(
                  { func: u.NOTEQUAL, mask: 255 },
                  a,
                  255,
                  u.KEEP,
                  u.KEEP,
                  u.REPLACE
                );
              }
              stencilModeForClipping(a) {
                if (this.terrain)
                  return this.terrain.stencilModeForRTTOverlap(a);
                const u = this.context.gl;
                return new d.StencilMode(
                  { func: u.EQUAL, mask: 255 },
                  this._tileClippingMaskIDs[a.key],
                  0,
                  u.KEEP,
                  u.KEEP,
                  u.REPLACE
                );
              }
              stencilConfigForOverlap(a) {
                const u = this.context.gl,
                  g = a.sort((D, S) => S.overscaledZ - D.overscaledZ),
                  v = g[g.length - 1].overscaledZ,
                  b = g[0].overscaledZ - v + 1;
                if (b > 1) {
                  (this.currentStencilSource = void 0),
                    this.nextStencilID + b > 256 && this.clearStencil();
                  const D = {};
                  for (let S = 0; S < b; S++)
                    D[S + v] = new d.StencilMode(
                      { func: u.GEQUAL, mask: 255 },
                      S + this.nextStencilID,
                      255,
                      u.KEEP,
                      u.KEEP,
                      u.REPLACE
                    );
                  return (this.nextStencilID += b), [D, g];
                }
                return [{ [v]: d.StencilMode.disabled }, g];
              }
              colorModeForRenderPass() {
                const a = this.context.gl;
                return this._showOverdrawInspector
                  ? new d.ColorMode(
                      [a.CONSTANT_COLOR, a.ONE],
                      new d.Color(0.125, 0.125, 0.125, 0),
                      [!0, !0, !0, !0]
                    )
                  : "opaque" === this.renderPass
                  ? d.ColorMode.unblended
                  : d.ColorMode.alphaBlended;
              }
              depthModeForSublayer(a, u, g) {
                if (!this.opaquePassEnabledForLayer())
                  return d.DepthMode.disabled;
                const v =
                  1 -
                  ((1 + this.currentLayer) * this.numSublayers + a) *
                    this.depthEpsilon;
                return new d.DepthMode(g || this.context.gl.LEQUAL, u, [v, v]);
              }
              opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
              }
              render(a, u) {
                (this.style = a),
                  (this.options = u),
                  (this.imageManager = a.imageManager),
                  (this.glyphManager = a.glyphManager),
                  (this.symbolFadeChange = a.placement.symbolFadeChange(
                    d.exported.now()
                  )),
                  this.imageManager.beginFrame();
                const g = this.style.order,
                  v = this.style._sourceCaches;
                for (const R in v) {
                  const k = v[R];
                  k.used && k.prepare(this.context);
                }
                const b = {},
                  D = {},
                  S = {};
                for (const R in v) {
                  const k = v[R];
                  (b[R] = k.getVisibleCoordinates()),
                    (D[R] = b[R].slice().reverse()),
                    (S[R] = k.getVisibleCoordinates(!0).reverse());
                }
                this.opaquePassCutoff = 1 / 0;
                for (let R = 0; R < g.length; R++)
                  if (this.style._layers[g[R]].is3D()) {
                    this.opaquePassCutoff = R;
                    break;
                  }
                if (
                  (this.terrain &&
                    (this.terrain.updateTileBinding(S),
                    (this.opaquePassCutoff = 0)),
                  "globe" !== this.transform.projection.name ||
                    this.globeSharedBuffers ||
                    (this.globeSharedBuffers = new d.GlobeSharedBuffers(
                      this.context
                    )),
                  !d.isMapAuthenticated(this.context.gl))
                )
                  return;
                this.renderPass = "offscreen";
                for (const R of g) {
                  const k = this.style._layers[R],
                    z = a._getLayerSourceCache(k);
                  if (!k.hasOffscreenPass() || k.isHidden(this.transform.zoom))
                    continue;
                  const H = z ? D[z.id] : void 0;
                  ("custom" === k.type || k.isSky() || (H && H.length)) &&
                    this.renderLayer(this, z, k, H);
                }
                this.depthRangeFor3D = [
                  0,
                  1 -
                    (a.order.length + 2) *
                      this.numSublayers *
                      this.depthEpsilon,
                ];
                const M = this.terrain;
                if (
                  (M &&
                    (this.style.hasSymbolLayers() ||
                      this.style.hasCircleLayers()) &&
                    M.drawDepth(),
                  this.context.bindFramebuffer.set(null),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.context.clear({
                    color: u.showOverdrawInspector
                      ? d.Color.black
                      : d.Color.transparent,
                    depth: 1,
                  }),
                  this.clearStencil(),
                  (this._showOverdrawInspector = u.showOverdrawInspector),
                  (this.renderPass = "opaque"),
                  !this.terrain)
                )
                  for (
                    this.currentLayer = g.length - 1;
                    this.currentLayer >= 0;
                    this.currentLayer--
                  ) {
                    const R = this.style._layers[g[this.currentLayer]],
                      k = a._getLayerSourceCache(R);
                    if (R.isSky()) continue;
                    const z = k ? D[k.id] : void 0;
                    this._renderTileClippingMasks(R, k, z),
                      this.renderLayer(this, k, R, z);
                  }
                if (
                  (this.style.fog &&
                    this.transform.projection.supportsFog &&
                    (function (R, k) {
                      const z = R.context,
                        H = z.gl,
                        q = R.transform,
                        X = new d.DepthMode(
                          H.LEQUAL,
                          d.DepthMode.ReadOnly,
                          [0, 1]
                        ),
                        Z = R.useProgram(
                          "globeAtmosphere",
                          null,
                          "globe" === q.projection.name
                            ? ["PROJECTION_GLOBE_VIEW", "FOG"]
                            : ["FOG"]
                        ),
                        Y = d.globeToMercatorTransition(q.zoom),
                        B = k.properties.get("color").toArray01(),
                        W = k.properties.get("high-color").toArray01(),
                        ee = k.properties
                          .get("space-color")
                          .toArray01PremultipliedAlpha(),
                        te = d.identity$1([]);
                      d.rotateY$1(te, te, -d.degToRad(q._center.lng)),
                        d.rotateX$1(te, te, d.degToRad(q._center.lat)),
                        d.rotateZ$1(te, te, q.angle),
                        d.rotateX$1(te, te, -q._pitch);
                      const he = d.fromQuat(new Float32Array(16), te),
                        de = d.mapValue(
                          k.properties.get("star-intensity"),
                          0,
                          1,
                          0,
                          0.25
                        ),
                        _e = d.mapValue(
                          k.properties.get("horizon-blend"),
                          0,
                          1,
                          5e-4,
                          0.25
                        ),
                        ge =
                          d.globeUseCustomAntiAliasing(R, z, q) && 5e-4 === _e
                            ? q.worldSize / (2 * Math.PI * 1.025) - 1
                            : q.globeRadius,
                        Te = (R.frameCounter / 1e3) % 1,
                        Ge = d.length(q.globeCenterInViewSpace),
                        be = Math.sqrt(Math.pow(Ge, 2) - Math.pow(ge, 2)),
                        Le = Math.acos(be / Ge),
                        Se = {
                          u_frustum_tl: q.frustumCorners.TL,
                          u_frustum_tr: q.frustumCorners.TR,
                          u_frustum_br: q.frustumCorners.BR,
                          u_frustum_bl: q.frustumCorners.BL,
                          u_horizon: q.frustumCorners.horizon,
                          u_transition: Y,
                          u_fadeout_range: _e,
                          u_color: B,
                          u_high_color: W,
                          u_space_color: ee,
                          u_star_intensity: de,
                          u_star_size: 5 * d.exported.devicePixelRatio,
                          u_star_density: 0,
                          u_temporal_offset: Te,
                          u_horizon_angle: Le,
                          u_rotation_matrix: he,
                        };
                      R.prepareDrawProgram(z, Z);
                      const je = R.atmosphereBuffer;
                      je &&
                        Z.draw(
                          z,
                          H.TRIANGLES,
                          X,
                          d.StencilMode.disabled,
                          d.ColorMode.alphaBlended,
                          d.CullFaceMode.backCW,
                          Se,
                          "skybox",
                          je.vertexBuffer,
                          je.indexBuffer,
                          je.segments
                        );
                    })(this, this.style.fog),
                  (this.renderPass = "sky"),
                  (d.globeToMercatorTransition(this.transform.zoom) > 0 ||
                    "globe" !== this.transform.projection.name) &&
                    this.transform.isHorizonVisible())
                )
                  for (
                    this.currentLayer = 0;
                    this.currentLayer < g.length;
                    this.currentLayer++
                  ) {
                    const R = this.style._layers[g[this.currentLayer]],
                      k = a._getLayerSourceCache(R);
                    R.isSky() &&
                      this.renderLayer(this, k, R, k ? D[k.id] : void 0);
                  }
                for (
                  this.renderPass = "translucent", this.currentLayer = 0;
                  this.currentLayer < g.length;

                ) {
                  const R = this.style._layers[g[this.currentLayer]],
                    k = a._getLayerSourceCache(R);
                  if (R.isSky()) {
                    ++this.currentLayer;
                    continue;
                  }
                  if (this.terrain && this.style.isLayerDraped(R)) {
                    if (R.isHidden(this.transform.zoom)) {
                      ++this.currentLayer;
                      continue;
                    }
                    this.currentLayer = this.terrain.renderBatch(
                      this.currentLayer
                    );
                    continue;
                  }
                  const z = k ? ("symbol" === R.type ? S : D)[k.id] : void 0;
                  this._renderTileClippingMasks(R, k, k ? b[k.id] : void 0),
                    this.renderLayer(this, k, R, z),
                    ++this.currentLayer;
                }
                if (
                  (this.terrain && this.terrain.postRender(),
                  this.options.showTileBoundaries ||
                    this.options.showQueryGeometry ||
                    this.options.showTileAABBs)
                ) {
                  let R = null;
                  d.values(this.style._layers).forEach((k) => {
                    const z = a._getLayerSourceCache(k);
                    z &&
                      !k.isHidden(this.transform.zoom) &&
                      (!R || R.getSource().maxzoom < z.getSource().maxzoom) &&
                      (R = z);
                  }),
                    R &&
                      this.options.showTileBoundaries &&
                      Ol.debug(this, R, R.getVisibleCoordinates());
                }
                this.options.showPadding &&
                  (function (R) {
                    const k = R.transform.padding;
                    Of(R, R.transform.height - (k.top || 0), 3, cr),
                      Of(R, k.bottom || 0, 3, zh),
                      Cu(R, k.left || 0, 3, Tu),
                      Cu(R, R.transform.width - (k.right || 0), 3, Du);
                    const z = R.transform.centerPoint;
                    var H, q, X, Z;
                    Rl(
                      (H = R),
                      (q = z.x) - 1,
                      (X = R.transform.height - z.y) - 10,
                      2,
                      20,
                      (Z = wo)
                    ),
                      Rl(H, q - 10, X - 1, 20, 2, Z);
                  })(this),
                  this.context.setDefault(),
                  (this.frameCounter =
                    (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER),
                  this.tileLoaded &&
                    this.options.speedIndexTiming &&
                    (this.loadTimeStamps.push(d.window.performance.now()),
                    this.saveCanvasCopy());
              }
              renderLayer(a, u, g, v) {
                g.isHidden(this.transform.zoom) ||
                  (("background" === g.type ||
                    "sky" === g.type ||
                    "custom" === g.type ||
                    (v && v.length)) &&
                    ((this.id = g.id),
                    this.gpuTimingStart(g),
                    (!a.transform.projection.unsupportedLayers ||
                      !a.transform.projection.unsupportedLayers.includes(
                        g.type
                      ) ||
                      (a.terrain && "custom" === g.type)) &&
                      Ol[g.type](
                        a,
                        u,
                        g,
                        v,
                        this.style.placement.variableOffsets,
                        this.options.isInitialLoad
                      ),
                    this.gpuTimingEnd()));
              }
              gpuTimingStart(a) {
                if (!this.options.gpuTiming) return;
                const u = this.context.extTimerQuery;
                let g = this.gpuTimers[a.id];
                g ||
                  (g = this.gpuTimers[a.id] =
                    { calls: 0, cpuTime: 0, query: u.createQueryEXT() }),
                  g.calls++,
                  u.beginQueryEXT(u.TIME_ELAPSED_EXT, g.query);
              }
              gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                  const a = this.context.extTimerQuery,
                    u = a.createQueryEXT();
                  this.deferredRenderGpuTimeQueries.push(u),
                    a.beginQueryEXT(a.TIME_ELAPSED_EXT, u);
                }
              }
              gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender) return;
                const a = this.context.extTimerQuery;
                a.endQueryEXT(a.TIME_ELAPSED_EXT);
              }
              gpuTimingEnd() {
                if (!this.options.gpuTiming) return;
                const a = this.context.extTimerQuery;
                a.endQueryEXT(a.TIME_ELAPSED_EXT);
              }
              collectGpuTimers() {
                const a = this.gpuTimers;
                return (this.gpuTimers = {}), a;
              }
              collectDeferredRenderGpuQueries() {
                const a = this.deferredRenderGpuTimeQueries;
                return (this.deferredRenderGpuTimeQueries = []), a;
              }
              queryGpuTimers(a) {
                const u = {};
                for (const g in a) {
                  const v = a[g],
                    b = this.context.extTimerQuery,
                    D = b.getQueryObjectEXT(v.query, b.QUERY_RESULT_EXT) / 1e6;
                  b.deleteQueryEXT(v.query), (u[g] = D);
                }
                return u;
              }
              queryGpuTimeDeferredRender(a) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const u = this.context.extTimerQuery;
                let g = 0;
                for (const v of a)
                  (g += u.getQueryObjectEXT(v, u.QUERY_RESULT_EXT) / 1e6),
                    u.deleteQueryEXT(v);
                return g;
              }
              translatePosMatrix(a, u, g, v, b) {
                if (!g[0] && !g[1]) return a;
                const D = b
                  ? "map" === v
                    ? this.transform.angle
                    : 0
                  : "viewport" === v
                  ? -this.transform.angle
                  : 0;
                if (D) {
                  const R = Math.sin(D),
                    k = Math.cos(D);
                  g = [g[0] * k - g[1] * R, g[0] * R + g[1] * k];
                }
                const S = [
                    b ? g[0] : Ai(u, g[0], this.transform.zoom),
                    b ? g[1] : Ai(u, g[1], this.transform.zoom),
                    0,
                  ],
                  M = new Float32Array(16);
                return d.translate(M, a, S), M;
              }
              saveTileTexture(a) {
                const u = this._tileTextures[a.size[0]];
                u ? u.push(a) : (this._tileTextures[a.size[0]] = [a]);
              }
              getTileTexture(a) {
                const u = this._tileTextures[a];
                return u && u.length > 0 ? u.pop() : null;
              }
              isPatternMissing(a) {
                return (
                  null === a ||
                  (void 0 !== a && !this.imageManager.getPattern(a.toString()))
                );
              }
              terrainRenderModeElevated() {
                return (
                  this.style &&
                  !!this.style.getTerrain() &&
                  !!this.terrain &&
                  !this.terrain.renderingToTexture
                );
              }
              currentGlobalDefines() {
                const a = this.terrain && this.terrain.renderingToTexture,
                  u = this.terrain && 0 === this.terrain.exaggeration(),
                  g = this.style && this.style.fog,
                  v = [];
                return (
                  this.terrainRenderModeElevated() && v.push("TERRAIN"),
                  "globe" === this.transform.projection.name && v.push("GLOBE"),
                  u && v.push("ZERO_EXAGGERATION"),
                  g &&
                    !a &&
                    0 !== g.getOpacity(this.transform.pitch) &&
                    v.push("FOG"),
                  a && v.push("RENDER_TO_TEXTURE"),
                  this._showOverdrawInspector && v.push("OVERDRAW_INSPECTOR"),
                  v
                );
              }
              useProgram(a, u, g) {
                this.cache = this.cache || {};
                const v = g || [],
                  b = this.currentGlobalDefines().concat(v),
                  D = ln.cacheKey(qr[a], a, b, u);
                return (
                  this.cache[D] ||
                    (this.cache[D] = new ln(
                      this.context,
                      a,
                      qr[a],
                      u,
                      wu[a],
                      b
                    )),
                  this.cache[D]
                );
              }
              setCustomLayerDefaults() {
                this.context.unbindVAO(),
                  this.context.cullFace.setDefault(),
                  this.context.frontFace.setDefault(),
                  this.context.cullFaceSide.setDefault(),
                  this.context.activeTexture.setDefault(),
                  this.context.pixelStoreUnpack.setDefault(),
                  this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.context.pixelStoreUnpackFlipY.setDefault();
              }
              setBaseState() {
                const a = this.context.gl;
                this.context.cullFace.set(!1),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.context.blendEquation.set(a.FUNC_ADD);
              }
              initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas &&
                  ((this.debugOverlayCanvas =
                    d.window.document.createElement("canvas")),
                  (this.debugOverlayCanvas.width = 512),
                  (this.debugOverlayCanvas.height = 512),
                  (this.debugOverlayTexture = new d.Texture(
                    this.context,
                    this.debugOverlayCanvas,
                    this.context.gl.RGBA
                  )));
              }
              destroy() {
                this._terrain && this._terrain.destroy(),
                  this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                  this.emptyTexture.destroy(),
                  this.debugOverlayTexture &&
                    this.debugOverlayTexture.destroy(),
                  this.atmosphereBuffer && this.atmosphereBuffer.destroy();
              }
              prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
              }
              prepareDrawProgram(a, u, g) {
                if (this.terrain && this.terrain.renderingToTexture) return;
                const v = this.style.fog;
                if (v) {
                  const b = v.getOpacity(this.transform.pitch),
                    D = ((S, M, R, k, z, H, q, X, Z, Y, B) => {
                      const W = S.transform,
                        ee = M.properties.get("color").toArray01();
                      ee[3] = k;
                      const te = (S.frameCounter / 1e3) % 1;
                      return {
                        u_fog_matrix: R
                          ? W.calculateFogTileMatrix(R)
                          : S.identityMat,
                        u_fog_range: M.getFovAdjustedRange(W._fov),
                        u_fog_color: ee,
                        u_fog_horizon_blend: M.properties.get("horizon-blend"),
                        u_fog_temporal_offset: te,
                        u_frustum_tl: z,
                        u_frustum_tr: H,
                        u_frustum_br: q,
                        u_frustum_bl: X,
                        u_globe_pos: Z,
                        u_globe_radius: Y,
                        u_viewport: B,
                        u_globe_transition: d.globeToMercatorTransition(W.zoom),
                        u_is_globe: +("globe" === W.projection.name),
                      };
                    })(
                      this,
                      v,
                      g,
                      b,
                      this.transform.frustumCorners.TL,
                      this.transform.frustumCorners.TR,
                      this.transform.frustumCorners.BR,
                      this.transform.frustumCorners.BL,
                      this.transform.globeCenterInViewSpace,
                      this.transform.globeRadius,
                      [
                        this.transform.width * d.exported.devicePixelRatio,
                        this.transform.height * d.exported.devicePixelRatio,
                      ]
                    );
                  u.setFogUniformValues(a, D);
                }
              }
              setTileLoadedFlag(a) {
                this.tileLoaded = a;
              }
              saveCanvasCopy() {
                const a = this.canvasCopy();
                a && (this.frameCopies.push(a), (this.tileLoaded = !1));
              }
              canvasCopy() {
                const a = this.context.gl,
                  u = a.createTexture();
                return (
                  a.bindTexture(a.TEXTURE_2D, u),
                  a.copyTexImage2D(
                    a.TEXTURE_2D,
                    0,
                    a.RGBA,
                    0,
                    0,
                    a.drawingBufferWidth,
                    a.drawingBufferHeight,
                    0
                  ),
                  u
                );
              }
              getCanvasCopiesAndTimestamps() {
                return {
                  canvasCopies: this.frameCopies,
                  timeStamps: this.loadTimeStamps,
                };
              }
              averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const a = this.style && this.style.fog;
                return !!a && 0 !== a.getOpacity(this.transform.pitch);
              }
              getBackgroundTiles() {
                const a = this._backgroundTiles,
                  u = (this._backgroundTiles = {}),
                  g = this.transform.coveringTiles({ tileSize: 512 });
                for (const v of g)
                  u[v.key] =
                    a[v.key] ||
                    new d.Tile(v, 512, this.transform.tileZoom, this);
                return u;
              }
              clearBackgroundTiles() {
                this._backgroundTiles = {};
              }
            }
            class Vh {
              constructor(a = 0, u = 0, g = 0, v = 0) {
                if (
                  isNaN(a) ||
                  a < 0 ||
                  isNaN(u) ||
                  u < 0 ||
                  isNaN(g) ||
                  g < 0 ||
                  isNaN(v) ||
                  v < 0
                )
                  throw new Error(
                    "Invalid value for edge-insets, top, bottom, left and right must all be numbers"
                  );
                (this.top = a),
                  (this.bottom = u),
                  (this.left = g),
                  (this.right = v);
              }
              interpolate(a, u, g) {
                return (
                  null != u.top &&
                    null != a.top &&
                    (this.top = d.number(a.top, u.top, g)),
                  null != u.bottom &&
                    null != a.bottom &&
                    (this.bottom = d.number(a.bottom, u.bottom, g)),
                  null != u.left &&
                    null != a.left &&
                    (this.left = d.number(a.left, u.left, g)),
                  null != u.right &&
                    null != a.right &&
                    (this.right = d.number(a.right, u.right, g)),
                  this
                );
              }
              getCenter(a, u) {
                const g = d.clamp((this.left + a - this.right) / 2, 0, a),
                  v = d.clamp((this.top + u - this.bottom) / 2, 0, u);
                return new d.Point(g, v);
              }
              equals(a) {
                return (
                  this.top === a.top &&
                  this.bottom === a.bottom &&
                  this.left === a.left &&
                  this.right === a.right
                );
              }
              clone() {
                return new Vh(this.top, this.bottom, this.left, this.right);
              }
              toJSON() {
                return {
                  top: this.top,
                  bottom: this.bottom,
                  left: this.left,
                  right: this.right,
                };
              }
            }
            function jh(f, a) {
              const u = d.getColumn(f, 3);
              d.fromQuat(f, a), d.setColumn(f, 3, u);
            }
            function fn(f, a) {
              const u = d.identity$1([]);
              return d.rotateZ$1(u, u, -a), d.rotateX$1(u, u, -f), u;
            }
            function Iu(f, a) {
              const u = [f[0], f[1], 0],
                g = [a[0], a[1], 0];
              if (d.length(u) >= 1e-15) {
                const D = d.normalize([], u);
                d.scale$2(g, D, d.dot(g, D)), (a[0] = g[0]), (a[1] = g[1]);
              }
              const v = d.cross([], a, f);
              if (d.len(v) < 1e-15) return null;
              const b = Math.atan2(-v[1], v[0]);
              return fn(
                Math.atan2(Math.sqrt(f[0] * f[0] + f[1] * f[1]), -f[2]),
                b
              );
            }
            class Bf {
              constructor(a, u) {
                (this.position = a), (this.orientation = u);
              }
              get position() {
                return this._position;
              }
              set position(a) {
                if (a) {
                  const u =
                    a instanceof d.MercatorCoordinate
                      ? a
                      : new d.MercatorCoordinate(a[0], a[1], a[2]);
                  this._renderWorldCopies && (u.x = d.wrap(u.x, 0, 1)),
                    (this._position = u);
                } else this._position = null;
              }
              lookAtPoint(a, u) {
                if (((this.orientation = null), !this.position)) return;
                const g = this.position,
                  v = this._elevation
                    ? this._elevation.getAtPointOrZero(
                        d.MercatorCoordinate.fromLngLat(a)
                      )
                    : 0,
                  b = d.MercatorCoordinate.fromLngLat(a, v),
                  D = [b.x - g.x, b.y - g.y, b.z - g.z];
                u || (u = [0, 0, 1]),
                  (u[2] = Math.abs(u[2])),
                  (this.orientation = Iu(D, u));
              }
              setPitchBearing(a, u) {
                this.orientation = fn(d.degToRad(a), d.degToRad(-u));
              }
            }
            class wc {
              constructor(a, u) {
                (this._transform = d.identity([])),
                  (this.orientation = u),
                  (this.position = a);
              }
              get mercatorPosition() {
                const a = this.position;
                return new d.MercatorCoordinate(a[0], a[1], a[2]);
              }
              get position() {
                const a = d.getColumn(this._transform, 3);
                return [a[0], a[1], a[2]];
              }
              set position(a) {
                var u;
                a &&
                  d.setColumn(this._transform, 3, [(u = a)[0], u[1], u[2], 1]);
              }
              get orientation() {
                return this._orientation;
              }
              set orientation(a) {
                (this._orientation = a || d.identity$1([])),
                  a && jh(this._transform, this._orientation);
              }
              getPitchBearing() {
                const a = this.forward(),
                  u = this.right();
                return {
                  bearing: Math.atan2(-u[1], u[0]),
                  pitch: Math.atan2(
                    Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                    -a[2]
                  ),
                };
              }
              setPitchBearing(a, u) {
                (this._orientation = fn(a, u)),
                  jh(this._transform, this._orientation);
              }
              forward() {
                const a = d.getColumn(this._transform, 2);
                return [-a[0], -a[1], -a[2]];
              }
              up() {
                const a = d.getColumn(this._transform, 1);
                return [-a[0], -a[1], -a[2]];
              }
              right() {
                const a = d.getColumn(this._transform, 0);
                return [a[0], a[1], a[2]];
              }
              getCameraToWorld(a, u) {
                const g = new Float64Array(16);
                return d.invert(g, this.getWorldToCamera(a, u)), g;
              }
              getWorldToCameraPosition(a, u, g) {
                const v = this.position;
                d.scale$2(v, v, -a);
                const b = new Float64Array(16);
                return (
                  d.fromScaling(b, [g, g, g]),
                  d.translate(b, b, v),
                  (b[10] *= u),
                  b
                );
              }
              getWorldToCamera(a, u) {
                const g = new Float64Array(16),
                  v = new Float64Array(4),
                  b = this.position;
                return (
                  d.conjugate(v, this._orientation),
                  d.scale$2(b, b, -a),
                  d.fromQuat(g, v),
                  d.translate(g, g, b),
                  (g[1] *= -1),
                  (g[5] *= -1),
                  (g[9] *= -1),
                  (g[13] *= -1),
                  (g[8] *= u),
                  (g[9] *= u),
                  (g[10] *= u),
                  (g[11] *= u),
                  g
                );
              }
              getCameraToClipPerspective(a, u, g, v) {
                const b = new Float64Array(16);
                return d.perspective(b, a, u, g, v), b;
              }
              getDistanceToElevation(a, u = !1) {
                const g =
                    0 === a
                      ? 0
                      : d.mercatorZfromAltitude(
                          a,
                          u
                            ? d.latFromMercatorY(this.position[1])
                            : this.position[1]
                        ),
                  v = this.forward();
                return (g - this.position[2]) / v[2];
              }
              clone() {
                return new wc([...this.position], [...this.orientation]);
              }
            }
            function Xs(f, a) {
              const u = Uh(f.projection, f.zoom, f.width, f.height),
                g = (function (b, D, S, M, R) {
                  const k = new d.LngLat(S.lng - 180 * Ks, S.lat),
                    z = new d.LngLat(S.lng + 180 * Ks, S.lat),
                    H = b.project(k.lng, k.lat),
                    q = b.project(z.lng, z.lat),
                    X = -Math.atan2(q.y - H.y, q.x - H.x),
                    Z = d.MercatorCoordinate.fromLngLat(S);
                  Z.y = d.clamp(Z.y, -1 + Ks, 1 - Ks);
                  const Y = Z.toLngLat(),
                    B = b.project(Y.lng, Y.lat),
                    W = d.MercatorCoordinate.fromLngLat(Y);
                  W.x += Ks;
                  const ee = W.toLngLat(),
                    te = b.project(ee.lng, ee.lat),
                    he = Mu(te.x - B.x, te.y - B.y, X),
                    de = d.MercatorCoordinate.fromLngLat(Y);
                  de.y += Ks;
                  const ue = de.toLngLat(),
                    _e = b.project(ue.lng, ue.lat),
                    ge = Mu(_e.x - B.x, _e.y - B.y, X),
                    Te = Math.abs(he.x) / Math.abs(ge.y),
                    Ge = d.identity([]);
                  d.rotateZ(Ge, Ge, -X * (1 - (R ? 0 : M)));
                  const be = d.identity([]);
                  return (
                    d.scale(be, be, [1, 1 - (1 - Te) * M, 1]),
                    (be[4] = (-ge.x / ge.y) * M),
                    d.rotateZ(be, be, X),
                    d.multiply(be, Ge, be),
                    be
                  );
                })(f.projection, 0, f.center, u, a),
                v = Vf(f);
              return d.scale(g, g, [v, v, 1]), g;
            }
            function Vf(f) {
              const a = f.projection,
                u = Uh(f.projection, f.zoom, f.width, f.height),
                g = Ys(a, f.center),
                v = Ys(a, d.LngLat.convert(a.center));
              return Math.pow(2, g * u + (1 - u) * v);
            }
            function Uh(f, a, u, g, v = 1 / 0) {
              const b = f.range;
              if (!b) return 0;
              const D = Math.min(v, Math.max(u, g)),
                S = Math.log(D / 1024) / Math.LN2;
              return d.smoothstep(b[0] + S, b[1] + S, a);
            }
            const Ks = 1 / 4e4;
            function Ys(f, a) {
              const u = d.clamp(
                  a.lat,
                  -d.MAX_MERCATOR_LATITUDE,
                  d.MAX_MERCATOR_LATITUDE
                ),
                g = new d.LngLat(a.lng - 180 * Ks, u),
                v = new d.LngLat(a.lng + 180 * Ks, u),
                b = f.project(g.lng, u),
                D = f.project(v.lng, u),
                S = d.MercatorCoordinate.fromLngLat(g),
                M = d.MercatorCoordinate.fromLngLat(v),
                R = D.x - b.x,
                k = D.y - b.y,
                z = M.x - S.x,
                H = M.y - S.y,
                q = Math.sqrt((z * z + H * H) / (R * R + k * k));
              return Math.log(q) / Math.LN2;
            }
            function Mu(f, a, u) {
              const g = Math.cos(u),
                v = Math.sin(u);
              return { x: f * g - a * v, y: f * v + a * g };
            }
            class Zo {
              constructor(a, u, g, v, b, D, S) {
                (this.tileSize = 512),
                  (this._renderWorldCopies = void 0 === b || b),
                  (this._minZoom = a || 0),
                  (this._maxZoom = u || 22),
                  (this._minPitch = g ?? 0),
                  (this._maxPitch = v ?? 60),
                  this.setProjection(D),
                  this.setMaxBounds(S),
                  (this.width = 0),
                  (this.height = 0),
                  (this._center = new d.LngLat(0, 0)),
                  (this.zoom = 0),
                  (this.angle = 0),
                  (this._fov = 0.6435011087932844),
                  (this._pitch = 0),
                  (this._nearZ = 0),
                  (this._farZ = 0),
                  (this._unmodified = !0),
                  (this._edgeInsets = new Vh()),
                  (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {}),
                  (this._fogTileMatrixCache = {}),
                  (this._distanceTileDataCache = {}),
                  (this._camera = new wc()),
                  (this._centerAltitude = 0),
                  (this._averageElevation = 0),
                  (this.cameraElevationReference = "ground"),
                  (this._pixelsPerMercatorPixel = 1),
                  (this.globeRadius = 0),
                  (this.globeCenterInViewSpace = [0, 0, 0]),
                  (this._horizonShift = 0.1);
              }
              clone() {
                const a = new Zo(
                  this._minZoom,
                  this._maxZoom,
                  this._minPitch,
                  this.maxPitch,
                  this._renderWorldCopies,
                  this.getProjection()
                );
                return (
                  (a._elevation = this._elevation),
                  (a._centerAltitude = this._centerAltitude),
                  (a._centerAltitudeValidForExaggeration =
                    this._centerAltitudeValidForExaggeration),
                  (a.tileSize = this.tileSize),
                  (a.mercatorFromTransition = this.mercatorFromTransition),
                  (a.width = this.width),
                  (a.height = this.height),
                  (a.cameraElevationReference = this.cameraElevationReference),
                  (a._center = this._center),
                  a._setZoom(this.zoom),
                  (a._seaLevelZoom = this._seaLevelZoom),
                  (a.angle = this.angle),
                  (a._fov = this._fov),
                  (a._pitch = this._pitch),
                  (a._nearZ = this._nearZ),
                  (a._farZ = this._farZ),
                  (a._averageElevation = this._averageElevation),
                  (a._unmodified = this._unmodified),
                  (a._edgeInsets = this._edgeInsets.clone()),
                  (a._camera = this._camera.clone()),
                  a._calcMatrices(),
                  (a.freezeTileCoverage = this.freezeTileCoverage),
                  (a.frustumCorners = this.frustumCorners),
                  a
                );
              }
              get elevation() {
                return this._elevation;
              }
              set elevation(a) {
                this._elevation !== a &&
                  ((this._elevation = a),
                  this._updateCameraOnTerrain(),
                  this._calcMatrices());
              }
              updateElevation(a, u = !1) {
                const g =
                  this._elevation &&
                  this._elevation.exaggeration() !==
                    this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || g) &&
                  this._updateCameraOnTerrain(),
                  (a || g) && this._constrainCamera(u),
                  this._calcMatrices();
              }
              getProjection() {
                return d.pick(this.projection, ["name", "center", "parallels"]);
              }
              setProjection(a) {
                this.projectionOptions = a || { name: "mercator" };
                const u = this.projection ? this.getProjection() : void 0;
                this.projection = d.getProjection(this.projectionOptions);
                const g = !Be(u, this.getProjection());
                return (
                  g && this._calcMatrices(),
                  (this.mercatorFromTransition = !1),
                  g
                );
              }
              setMercatorFromTransition() {
                const a = this.projection.name;
                (this.mercatorFromTransition = !0),
                  (this.projectionOptions = { name: "mercator" }),
                  (this.projection = d.getProjection({ name: "mercator" }));
                const u = a !== this.projection.name;
                return u && this._calcMatrices(), u;
              }
              get minZoom() {
                return this._minZoom;
              }
              set minZoom(a) {
                this._minZoom !== a &&
                  ((this._minZoom = a), (this.zoom = Math.max(this.zoom, a)));
              }
              get maxZoom() {
                return this._maxZoom;
              }
              set maxZoom(a) {
                this._maxZoom !== a &&
                  ((this._maxZoom = a), (this.zoom = Math.min(this.zoom, a)));
              }
              get minPitch() {
                return this._minPitch;
              }
              set minPitch(a) {
                this._minPitch !== a &&
                  ((this._minPitch = a),
                  (this.pitch = Math.max(this.pitch, a)));
              }
              get maxPitch() {
                return this._maxPitch;
              }
              set maxPitch(a) {
                this._maxPitch !== a &&
                  ((this._maxPitch = a),
                  (this.pitch = Math.min(this.pitch, a)));
              }
              get renderWorldCopies() {
                return (
                  this._renderWorldCopies &&
                  !0 === this.projection.supportsWorldCopies
                );
              }
              set renderWorldCopies(a) {
                void 0 === a ? (a = !0) : null === a && (a = !1),
                  (this._renderWorldCopies = a);
              }
              get worldSize() {
                return this.tileSize * this.scale;
              }
              get cameraWorldSizeForFog() {
                const a = Math.max(
                  this._camera.getDistanceToElevation(this._averageElevation),
                  Number.EPSILON
                );
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(a));
              }
              get cameraWorldSize() {
                const a = Math.max(
                  this._camera.getDistanceToElevation(
                    this._averageElevation,
                    !0
                  ),
                  Number.EPSILON
                );
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(a));
              }
              get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(
                  this.center.lat,
                  this.worldSize
                );
              }
              get cameraPixelsPerMeter() {
                return d.mercatorZfromAltitude(
                  this.center.lat,
                  this.cameraWorldSizeForFog
                );
              }
              get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
              }
              get size() {
                return new d.Point(this.width, this.height);
              }
              get bearing() {
                return d.wrap(this.rotation, -180, 180);
              }
              set bearing(a) {
                this.rotation = a;
              }
              get rotation() {
                return (-this.angle / Math.PI) * 180;
              }
              set rotation(a) {
                const u = (-a * Math.PI) / 180;
                var g, v, b, D, S, M, R, k, z, H;
                this.angle !== u &&
                  ((this._unmodified = !1),
                  (this.angle = u),
                  this._calcMatrices(),
                  (this.rotationMatrix =
                    ((g = new d.ARRAY_TYPE(4)),
                    d.ARRAY_TYPE != Float32Array && ((g[1] = 0), (g[2] = 0)),
                    (g[0] = 1),
                    (g[3] = 1),
                    g)),
                  (v = this.rotationMatrix),
                  (D = this.angle),
                  (S = (b = this.rotationMatrix)[0]),
                  (M = b[1]),
                  (R = b[2]),
                  (k = b[3]),
                  (z = Math.sin(D)),
                  (H = Math.cos(D)),
                  (v[0] = S * H + R * z),
                  (v[1] = M * H + k * z),
                  (v[2] = S * -z + R * H),
                  (v[3] = M * -z + k * H));
              }
              get pitch() {
                return (this._pitch / Math.PI) * 180;
              }
              set pitch(a) {
                const u =
                  (d.clamp(a, this.minPitch, this.maxPitch) / 180) * Math.PI;
                this._pitch !== u &&
                  ((this._unmodified = !1),
                  (this._pitch = u),
                  this._calcMatrices());
              }
              get aspect() {
                return this.width / this.height;
              }
              get fov() {
                return (this._fov / Math.PI) * 180;
              }
              get fovX() {
                return this._fov;
              }
              get fovY() {
                const a = 1 / Math.tan(0.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / a);
              }
              set fov(a) {
                (a = Math.max(0.01, Math.min(60, a))),
                  this._fov !== a &&
                    ((this._unmodified = !1),
                    (this._fov = d.degToRad(a)),
                    this._calcMatrices());
              }
              get averageElevation() {
                return this._averageElevation;
              }
              set averageElevation(a) {
                (this._averageElevation = a),
                  this._calcFogMatrices(),
                  (this._distanceTileDataCache = {});
              }
              get zoom() {
                return this._zoom;
              }
              set zoom(a) {
                const u = Math.min(Math.max(a, this.minZoom), this.maxZoom);
                this._zoom !== u &&
                  ((this._unmodified = !1),
                  this._setZoom(u),
                  this._updateSeaLevelZoom(),
                  this._constrain(),
                  this._calcMatrices());
              }
              _setZoom(a) {
                (this._zoom = a),
                  (this.scale = this.zoomScale(a)),
                  (this.tileZoom = Math.floor(a)),
                  (this.zoomFraction = a - this.tileZoom);
              }
              _updateCameraOnTerrain() {
                if (
                  !this._elevation ||
                  !this._elevation.isDataAvailableAtPoint(
                    this.locationCoordinate(this.center)
                  )
                )
                  return (
                    (this._centerAltitude = 0),
                    (this._seaLevelZoom = null),
                    void (this._centerAltitudeValidForExaggeration = void 0)
                  );
                const a = this._elevation;
                (this._centerAltitude = a.getAtPointOrZero(
                  this.locationCoordinate(this.center)
                )),
                  (this._centerAltitudeValidForExaggeration = a.exaggeration()),
                  this._updateSeaLevelZoom();
              }
              _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration &&
                  (this._seaLevelZoom = this._zoomFromMercatorZ(
                    (this.pixelsPerMeter * this._centerAltitude +
                      this.cameraToCenterDistance) /
                      this.worldSize
                  ));
              }
              sampleAverageElevation() {
                if (!this._elevation) return 0;
                const a = this._elevation,
                  u = [
                    [0.5, 0.2],
                    [0.3, 0.5],
                    [0.5, 0.5],
                    [0.7, 0.5],
                    [0.5, 0.8],
                  ],
                  g = this.horizonLineFromTop();
                let v = 0,
                  b = 0;
                for (let D = 0; D < u.length; D++) {
                  const S = new d.Point(
                      u[D][0] * this.width,
                      g + u[D][1] * (this.height - g)
                    ),
                    M = a.pointCoordinate(S);
                  if (!M) continue;
                  const R =
                    1 /
                    Math.hypot(
                      M[0] - this._camera.position[0],
                      M[1] - this._camera.position[1]
                    );
                  (v += M[3] * R), (b += R);
                }
                return 0 === b ? NaN : v / b;
              }
              get center() {
                return this._center;
              }
              set center(a) {
                (a.lat === this._center.lat && a.lng === this._center.lng) ||
                  ((this._unmodified = !1),
                  (this._center = a),
                  this._terrainEnabled() &&
                    ("ground" === this.cameraElevationReference
                      ? this._updateCameraOnTerrain()
                      : this._updateZoomFromElevation()),
                  this._constrain(),
                  this._calcMatrices());
              }
              _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const a = this._seaLevelZoom,
                  u = this._elevation.getAtPointOrZero(
                    this.locationCoordinate(this.center)
                  ),
                  g = (this.pixelsPerMeter / this.worldSize) * u,
                  v = this._mercatorZfromZoom(a),
                  b = this._mercatorZfromZoom(this._maxZoom),
                  D = Math.max(v - g, b);
                this._setZoom(this._zoomFromMercatorZ(D));
              }
              get padding() {
                return this._edgeInsets.toJSON();
              }
              set padding(a) {
                this._edgeInsets.equals(a) ||
                  ((this._unmodified = !1),
                  this._edgeInsets.interpolate(this._edgeInsets, a, 1),
                  this._calcMatrices());
              }
              computeZoomRelativeTo(a) {
                const u = this.rayIntersectionCoordinate(
                  this.pointRayIntersection(this.centerPoint, a.toAltitude())
                );
                let g;
                g =
                  a.z < this._camera.position[2]
                    ? [u.x, u.y, u.z]
                    : [a.x, a.y, a.z];
                const v = d.length(d.sub([], this._camera.position, g));
                return d.clamp(
                  this._zoomFromMercatorZ(v),
                  this._minZoom,
                  this._maxZoom
                );
              }
              setFreeCameraOptions(a) {
                if (!this.height || (!a.position && !a.orientation)) return;
                this._updateCameraState();
                let u = !1;
                if (
                  (a.orientation &&
                    !d.exactEquals(a.orientation, this._camera.orientation) &&
                    (u = this._setCameraOrientation(a.orientation)),
                  a.position)
                ) {
                  const g = [a.position.x, a.position.y, a.position.z];
                  d.exactEquals$1(g, this._camera.position) ||
                    (this._setCameraPosition(g), (u = !0));
                }
                u && (this._updateStateFromCamera(), this.recenterOnTerrain());
              }
              getFreeCameraOptions() {
                this._updateCameraState();
                const a = this._camera.position,
                  u = new Bf();
                return (
                  (u.position = new d.MercatorCoordinate(a[0], a[1], a[2])),
                  (u.orientation = this._camera.orientation),
                  (u._elevation = this.elevation),
                  (u._renderWorldCopies = this.renderWorldCopies),
                  u
                );
              }
              _setCameraOrientation(a) {
                if (!d.length$1(a)) return !1;
                d.normalize$1(a, a);
                const u = d.transformQuat([], [0, 0, -1], a),
                  g = d.transformQuat([], [0, -1, 0], a);
                if (g[2] < 0) return !1;
                const v = Iu(u, g);
                return !!v && ((this._camera.orientation = v), !0);
              }
              _setCameraPosition(a) {
                const u = this.zoomScale(this.minZoom) * this.tileSize,
                  g = this.zoomScale(this.maxZoom) * this.tileSize,
                  v = this.cameraToCenterDistance;
                (a[2] = d.clamp(a[2], v / g, v / u)),
                  (this._camera.position = a);
              }
              get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
              }
              get fovAboveCenter() {
                return this._fov * (0.5 + this.centerOffset.y / this.height);
              }
              isPaddingEqual(a) {
                return this._edgeInsets.equals(a);
              }
              interpolatePadding(a, u, g) {
                (this._unmodified = !1),
                  this._edgeInsets.interpolate(a, u, g),
                  this._constrain(),
                  this._calcMatrices();
              }
              coveringZoomLevel(a) {
                const u = (a.roundZoom ? Math.round : Math.floor)(
                  this.zoom + this.scaleZoom(this.tileSize / a.tileSize)
                );
                return Math.max(0, u);
              }
              getVisibleUnwrappedCoordinates(a) {
                const u = [new d.UnwrappedTileID(0, a)];
                if (this.renderWorldCopies) {
                  const g = this.pointCoordinate(new d.Point(0, 0)),
                    v = this.pointCoordinate(new d.Point(this.width, 0)),
                    b = this.pointCoordinate(
                      new d.Point(this.width, this.height)
                    ),
                    D = this.pointCoordinate(new d.Point(0, this.height)),
                    S = Math.floor(Math.min(g.x, v.x, b.x, D.x)),
                    M = Math.floor(Math.max(g.x, v.x, b.x, D.x)),
                    R = 1;
                  for (let k = S - R; k <= M + R; k++)
                    0 !== k && u.push(new d.UnwrappedTileID(k, a));
                }
                return u;
              }
              coveringTiles(a) {
                let u = this.coveringZoomLevel(a);
                const g = u,
                  v = this.elevation && !a.isTerrainDEM,
                  b = "mercator" === this.projection.name;
                if (void 0 !== a.minzoom && u < a.minzoom) return [];
                void 0 !== a.maxzoom && u > a.maxzoom && (u = a.maxzoom);
                const D = this.locationCoordinate(this.center),
                  S = this.center.lat,
                  M = 1 << u,
                  R = [M * D.x, M * D.y, 0],
                  k = "globe" === this.projection.name,
                  z = !k,
                  H = d.Frustum.fromInvProjectionMatrix(
                    this.invProjMatrix,
                    this.worldSize,
                    u,
                    z
                  ),
                  q = k
                    ? this._camera.mercatorPosition
                    : this.pointCoordinate(this.getCameraPoint()),
                  X = M * d.mercatorZfromAltitude(1, this.center.lat),
                  Z =
                    this._camera.position[2] /
                    d.mercatorZfromAltitude(1, this.center.lat),
                  Y = [M * q.x, M * q.y, Z * (z ? 1 : X)],
                  B =
                    (this.cameraToCenterDistance / a.tileSize) *
                    (a.roundZoom ? 1 : 0.502),
                  W =
                    this.pitch <= 60 &&
                    this._edgeInsets.top <= this._edgeInsets.bottom &&
                    !this._elevation &&
                    !this.projection.isReprojectedInTileSpace
                      ? u
                      : 0,
                  ee =
                    a.isTerrainDEM && this._elevation
                      ? 1e4 * this._elevation.exaggeration()
                      : this._centerAltitude,
                  te = a.isTerrainDEM
                    ? -ee
                    : this._elevation
                    ? this._elevation.getMinElevationBelowMSL()
                    : 0,
                  he = this.projection.isReprojectedInTileSpace ? Vf(this) : 1,
                  de = (we) => {
                    const He = new d.MercatorCoordinate(
                        we.x + 25e-6,
                        we.y,
                        we.z
                      ),
                      Ne = new d.MercatorCoordinate(we.x, we.y + 25e-6, we.z),
                      Xe = we.toLngLat(),
                      mt = He.toLngLat(),
                      It = Ne.toLngLat(),
                      dt = this.locationCoordinate(Xe),
                      Dt = this.locationCoordinate(mt),
                      Kt = this.locationCoordinate(It),
                      Ht = Math.hypot(Dt.x - dt.x, Dt.y - dt.y),
                      _t = Math.hypot(Kt.x - dt.x, Kt.y - dt.y);
                    return (Math.sqrt(Ht * _t) * he) / 25e-6;
                  },
                  ue = (we) => {
                    const ke = ee,
                      He = te;
                    return {
                      aabb: d.tileAABB(
                        this,
                        M,
                        0,
                        0,
                        0,
                        we,
                        He,
                        ke,
                        this.projection
                      ),
                      zoom: 0,
                      x: 0,
                      y: 0,
                      minZ: He,
                      maxZ: ke,
                      wrap: we,
                      fullyVisible: !1,
                    };
                  },
                  _e = [];
                let ge = [];
                const Te = u,
                  Ge = a.reparseOverscaled ? g : u,
                  be = (we) => we * we,
                  Le = be((Z - this._centerAltitude) * X),
                  Se = (we) => {
                    if (!this._elevation || !we.tileID || !b) return;
                    const ke = this._elevation.getMinMaxForTile(we.tileID),
                      He = we.aabb;
                    ke
                      ? ((He.min[2] = ke.min),
                        (He.max[2] = ke.max),
                        (He.center[2] = (He.min[2] + He.max[2]) / 2))
                      : ((we.shouldSplit = je(we)),
                        we.shouldSplit ||
                          (He.min[2] =
                            He.max[2] =
                            He.center[2] =
                              this._centerAltitude));
                  },
                  je = (we) => {
                    if (we.zoom < W) return !0;
                    if (we.zoom === Te) return !1;
                    if (null != we.shouldSplit) return we.shouldSplit;
                    const ke = we.aabb.distanceX(Y),
                      He = we.aabb.distanceY(Y);
                    let Ne = Le,
                      Xe = 1;
                    if (k) {
                      Ne = be(we.aabb.distanceZ(Y));
                      const dt = Math.pow(2, we.zoom),
                        Dt = d.latFromMercatorY((we.y + 1) / dt),
                        Kt = d.latFromMercatorY(we.y / dt),
                        Ht = Math.min(Math.max(S, Dt), Kt),
                        _t =
                          d.circumferenceAtLatitude(Ht) /
                          d.circumferenceAtLatitude(S);
                      if (
                        ((Xe =
                          Ht === S
                            ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3)
                            : Math.min(1, _t / this._mercatorScaleRatio)),
                        this.zoom <= d.GLOBE_ZOOM_THRESHOLD_MIN &&
                          we.zoom === Te - 1 &&
                          _t >= 0.9)
                      )
                        return !0;
                    } else if (
                      (v && (Ne = be(we.aabb.distanceZ(Y) * X)),
                      this.projection.isReprojectedInTileSpace && g <= 5)
                    ) {
                      const dt = Math.pow(2, we.zoom),
                        Dt = de(
                          new d.MercatorCoordinate(
                            (we.x + 0.5) / dt,
                            (we.y + 0.5) / dt
                          )
                        );
                      Xe = Dt > 0.85 ? 1 : Dt;
                    }
                    const mt = ke * ke + He * He + Ne;
                    return (
                      mt <
                      be(
                        (1 << (Te - we.zoom)) *
                          B *
                          Xe *
                          ((dt, Dt) => {
                            if (Dt * be(0.707) < dt) return 1;
                            const Kt = Math.sqrt(Dt / dt);
                            return (
                              Kt /
                              (1.4144271570014144 +
                                (Math.pow(1.1, Kt - 1.4144271570014144 + 1) -
                                  1) /
                                  (1.1 - 1) -
                                1)
                            );
                          })(Math.max(Ne, Le), mt)
                      )
                    );
                  };
                if (this.renderWorldCopies)
                  for (let we = 1; we <= 3; we++)
                    _e.push(ue(-we)), _e.push(ue(we));
                for (_e.push(ue(0)); _e.length > 0; ) {
                  const we = _e.pop(),
                    ke = we.x,
                    He = we.y;
                  let Ne = we.fullyVisible;
                  if (!Ne) {
                    const Xe = we.aabb.intersects(H);
                    if (0 === Xe) continue;
                    Ne = 2 === Xe;
                  }
                  if (we.zoom !== Te && je(we))
                    for (let Xe = 0; Xe < 4; Xe++) {
                      const mt = (ke << 1) + (Xe % 2),
                        It = (He << 1) + (Xe >> 1),
                        dt = {
                          aabb: b
                            ? we.aabb.quadrant(Xe)
                            : d.tileAABB(
                                this,
                                M,
                                we.zoom + 1,
                                mt,
                                It,
                                we.wrap,
                                we.minZ,
                                we.maxZ,
                                this.projection
                              ),
                          zoom: we.zoom + 1,
                          x: mt,
                          y: It,
                          wrap: we.wrap,
                          fullyVisible: Ne,
                          tileID: void 0,
                          shouldSplit: void 0,
                          minZ: we.minZ,
                          maxZ: we.maxZ,
                        };
                      v &&
                        !k &&
                        ((dt.tileID = new d.OverscaledTileID(
                          we.zoom + 1 === Te ? Ge : we.zoom + 1,
                          we.wrap,
                          we.zoom + 1,
                          mt,
                          It
                        )),
                        Se(dt)),
                        _e.push(dt);
                    }
                  else {
                    const Xe = we.zoom === Te ? Ge : we.zoom;
                    if (a.minzoom && a.minzoom > Xe) continue;
                    const mt =
                        R[0] -
                        (0.5 + ke + (we.wrap << we.zoom)) *
                          (1 << (u - we.zoom)),
                      It = R[1] - 0.5 - He,
                      dt = we.tileID
                        ? we.tileID
                        : new d.OverscaledTileID(Xe, we.wrap, we.zoom, ke, He);
                    ge.push({ tileID: dt, distanceSq: mt * mt + It * It });
                  }
                }
                if (this.fogCullDistSq) {
                  const we = this.fogCullDistSq,
                    ke = this.horizonLineFromTop();
                  ge = ge.filter((He) => {
                    const Ne = [0, 0, 0, 1],
                      Xe = [d.EXTENT, d.EXTENT, 0, 1],
                      mt = this.calculateFogTileMatrix(He.tileID.toUnwrapped());
                    d.transformMat4$1(Ne, Ne, mt),
                      d.transformMat4$1(Xe, Xe, mt);
                    const It = d.getAABBPointSquareDist(Ne, Xe);
                    if (0 === It) return !0;
                    let dt = !1;
                    const Dt = this._elevation;
                    if (Dt && It > we && 0 !== ke) {
                      const Kt = this.calculateProjMatrix(
                        He.tileID.toUnwrapped()
                      );
                      let Ht;
                      a.isTerrainDEM || (Ht = Dt.getMinMaxForTile(He.tileID)),
                        Ht || (Ht = { min: te, max: ee });
                      const _t = d.furthestTileCorner(this.rotation),
                        en = [_t[0] * d.EXTENT, _t[1] * d.EXTENT, Ht.max];
                      d.transformMat4(en, en, Kt),
                        (dt = (1 - en[1]) * this.height * 0.5 < ke);
                    }
                    return It < we || dt;
                  });
                }
                return ge
                  .sort((we, ke) => we.distanceSq - ke.distanceSq)
                  .map((we) => we.tileID);
              }
              resize(a, u) {
                (this.width = a),
                  (this.height = u),
                  (this.pixelsToGLUnits = [2 / a, -2 / u]),
                  this._constrain(),
                  this._calcMatrices();
              }
              get unmodified() {
                return this._unmodified;
              }
              zoomScale(a) {
                return Math.pow(2, a);
              }
              scaleZoom(a) {
                return Math.log(a) / Math.LN2;
              }
              project(a) {
                const u = d.clamp(
                    a.lat,
                    -d.MAX_MERCATOR_LATITUDE,
                    d.MAX_MERCATOR_LATITUDE
                  ),
                  g = this.projection.project(a.lng, u);
                return new d.Point(g.x * this.worldSize, g.y * this.worldSize);
              }
              unproject(a) {
                return this.projection.unproject(
                  a.x / this.worldSize,
                  a.y / this.worldSize
                );
              }
              get point() {
                return this.project(this.center);
              }
              get pointMerc() {
                return this.point._div(this.worldSize);
              }
              get pixelsPerMeterRatio() {
                return (
                  this.pixelsPerMeter /
                  d.mercatorZfromAltitude(1, this.center.lat) /
                  this.worldSize
                );
              }
              setLocationAtPoint(a, u) {
                let g, v;
                const b = this.centerPoint;
                if ("globe" === this.projection.name) {
                  const S = this.worldSize;
                  (g = (u.x - b.x) / S), (v = (u.y - b.y) / S);
                } else {
                  const S = this.pointCoordinate(u),
                    M = this.pointCoordinate(b);
                  (g = S.x - M.x), (v = S.y - M.y);
                }
                const D = this.locationCoordinate(a);
                this.setLocation(new d.MercatorCoordinate(D.x - g, D.y - v));
              }
              setLocation(a) {
                (this.center = this.coordinateLocation(a)),
                  this.projection.wrap && (this.center = this.center.wrap());
              }
              locationPoint(a) {
                return this.projection.locationPoint(this, a);
              }
              locationPoint3D(a) {
                return this.projection.locationPoint(this, a, !0);
              }
              pointLocation(a) {
                return this.coordinateLocation(this.pointCoordinate(a));
              }
              pointLocation3D(a) {
                return this.coordinateLocation(this.pointCoordinate3D(a));
              }
              locationCoordinate(a, u) {
                const g = u ? d.mercatorZfromAltitude(u, a.lat) : void 0,
                  v = this.projection.project(a.lng, a.lat);
                return new d.MercatorCoordinate(v.x, v.y, g);
              }
              coordinateLocation(a) {
                return this.projection.unproject(a.x, a.y);
              }
              pointRayIntersection(a, u) {
                const g = u ?? this._centerAltitude,
                  v = [a.x, a.y, 0, 1],
                  b = [a.x, a.y, 1, 1];
                d.transformMat4$1(v, v, this.pixelMatrixInverse),
                  d.transformMat4$1(b, b, this.pixelMatrixInverse);
                const D = b[3];
                d.scale$1(v, v, 1 / v[3]), d.scale$1(b, b, 1 / D);
                const S = v[2],
                  M = b[2];
                return { p0: v, p1: b, t: S === M ? 0 : (g - S) / (M - S) };
              }
              screenPointToMercatorRay(a) {
                const u = [a.x, a.y, 0, 1],
                  g = [a.x, a.y, 1, 1];
                return (
                  d.transformMat4$1(u, u, this.pixelMatrixInverse),
                  d.transformMat4$1(g, g, this.pixelMatrixInverse),
                  d.scale$1(u, u, 1 / u[3]),
                  d.scale$1(g, g, 1 / g[3]),
                  (u[2] =
                    d.mercatorZfromAltitude(u[2], this._center.lat) *
                    this.worldSize),
                  (g[2] =
                    d.mercatorZfromAltitude(g[2], this._center.lat) *
                    this.worldSize),
                  d.scale$1(u, u, 1 / this.worldSize),
                  d.scale$1(g, g, 1 / this.worldSize),
                  new d.Ray(
                    [u[0], u[1], u[2]],
                    d.normalize([], d.sub([], g, u))
                  )
                );
              }
              rayIntersectionCoordinate(a) {
                const { p0: u, p1: g, t: v } = a,
                  b = d.mercatorZfromAltitude(u[2], this._center.lat),
                  D = d.mercatorZfromAltitude(g[2], this._center.lat);
                return new d.MercatorCoordinate(
                  d.number(u[0], g[0], v) / this.worldSize,
                  d.number(u[1], g[1], v) / this.worldSize,
                  d.number(b, D, v)
                );
              }
              pointCoordinate(a, u = this._centerAltitude) {
                return this.projection.pointCoordinate(this, a.x, a.y, u);
              }
              pointCoordinate3D(a) {
                if (!this.elevation) return this.pointCoordinate(a);
                let u = this.projection.pointCoordinate3D(this, a.x, a.y);
                if (u) return new d.MercatorCoordinate(u[0], u[1], u[2]);
                let g = 0,
                  v = this.horizonLineFromTop();
                if (a.y > v) return this.pointCoordinate(a);
                const b = 0.02 * v,
                  D = a.clone();
                for (let S = 0; S < 10 && v - g > b; S++) {
                  D.y = d.number(g, v, 0.66);
                  const M = this.projection.pointCoordinate3D(this, D.x, D.y);
                  M ? ((v = D.y), (u = M)) : (g = D.y);
                }
                return u
                  ? new d.MercatorCoordinate(u[0], u[1], u[2])
                  : this.pointCoordinate(a);
              }
              isPointAboveHorizon(a) {
                return this.projection.isPointAboveHorizon(this, a);
              }
              isPointOnSurface(a) {
                if (a.y < 0 || a.y > this.height || a.x < 0 || a.x > this.width)
                  return !1;
                if (this.elevation || this.zoom >= d.GLOBE_ZOOM_THRESHOLD_MAX)
                  return !this.isPointAboveHorizon(a);
                const u = this.pointCoordinate(a);
                return u.y >= 0 && u.y <= 1;
              }
              _coordinatePoint(a, u) {
                const g =
                    u && this.elevation
                      ? this.elevation.getAtPointOrZero(a, this._centerAltitude)
                      : this._centerAltitude,
                  v = [
                    a.x * this.worldSize,
                    a.y * this.worldSize,
                    g + a.toAltitude(),
                    1,
                  ];
                return (
                  d.transformMat4$1(v, v, this.pixelMatrix),
                  v[3] > 0
                    ? new d.Point(v[0] / v[3], v[1] / v[3])
                    : new d.Point(Number.MAX_VALUE, Number.MAX_VALUE)
                );
              }
              _getBoundsNonRectangular() {
                const { top: a, left: u } = this._edgeInsets,
                  g = this.height - this._edgeInsets.bottom,
                  v = this.width - this._edgeInsets.right,
                  b = this.pointLocation3D(new d.Point(u, a)),
                  D = this.pointLocation3D(new d.Point(v, a)),
                  S = this.pointLocation3D(new d.Point(v, g)),
                  M = this.pointLocation3D(new d.Point(u, g));
                let R = Math.min(b.lng, D.lng, S.lng, M.lng),
                  k = Math.max(b.lng, D.lng, S.lng, M.lng),
                  z = Math.min(b.lat, D.lat, S.lat, M.lat),
                  H = Math.max(b.lat, D.lat, S.lat, M.lat);
                const q = (Math.pow(2, -this.zoom) / 16) * 270,
                  X = "globe" === this.projection.name ? 1 : 4,
                  Z = (Y, B, W, ee, te) => {
                    const he = (Y + W) / 2,
                      de = (B + ee) / 2,
                      ue = new d.Point(he, de),
                      { lng: _e, lat: ge } = this.pointLocation3D(ue),
                      Te = Math.max(0, R - _e, z - ge, _e - k, ge - H);
                    (R = Math.min(R, _e)),
                      (k = Math.max(k, _e)),
                      (z = Math.min(z, ge)),
                      (H = Math.max(H, ge)),
                      (te < X || Te > q) &&
                        (Z(Y, B, he, de, te + 1), Z(he, de, W, ee, te + 1));
                  };
                if (
                  (Z(u, a, v, a, 1),
                  Z(v, a, v, g, 1),
                  Z(v, g, u, g, 1),
                  Z(u, g, u, a, 1),
                  "globe" === this.projection.name)
                ) {
                  const [Y, B] = d.polesInViewport(this);
                  Y
                    ? ((H = 90), (k = 180), (R = -180))
                    : B && ((z = -90), (k = 180), (R = -180));
                }
                return new d.LngLatBounds(
                  new d.LngLat(R, z),
                  new d.LngLat(k, H)
                );
              }
              _getBoundsRectangular(a, u) {
                const { top: g, left: v } = this._edgeInsets,
                  b = this.height - this._edgeInsets.bottom,
                  D = this.width - this._edgeInsets.right,
                  S = new d.Point(v, g),
                  M = new d.Point(D, g),
                  R = new d.Point(D, b),
                  k = new d.Point(v, b);
                let z = this.pointCoordinate(S, a),
                  H = this.pointCoordinate(M, a);
                const q = this.pointCoordinate(R, u),
                  X = this.pointCoordinate(k, u),
                  Z = (Y, B) => (B.y - Y.y) / (B.x - Y.x);
                return (
                  z.y > 1 && H.y >= 0
                    ? (z = new d.MercatorCoordinate(
                        (1 - X.y) / Z(X, z) + X.x,
                        1
                      ))
                    : z.y < 0 &&
                      H.y <= 1 &&
                      (z = new d.MercatorCoordinate(-X.y / Z(X, z) + X.x, 0)),
                  H.y > 1 && z.y >= 0
                    ? (H = new d.MercatorCoordinate(
                        (1 - q.y) / Z(q, H) + q.x,
                        1
                      ))
                    : H.y < 0 &&
                      z.y <= 1 &&
                      (H = new d.MercatorCoordinate(-q.y / Z(q, H) + q.x, 0)),
                  new d.LngLatBounds()
                    .extend(this.coordinateLocation(z))
                    .extend(this.coordinateLocation(H))
                    .extend(this.coordinateLocation(X))
                    .extend(this.coordinateLocation(q))
                );
              }
              _getBoundsRectangularTerrain() {
                const a = this.elevation;
                if (!a.visibleDemTiles.length || a.isUsingMockSource())
                  return this._getBoundsRectangular(0, 0);
                const u = a.visibleDemTiles.reduce(
                  (g, v) => {
                    if (v.dem) {
                      const b = v.dem.tree;
                      (g.min = Math.min(g.min, b.minimums[0])),
                        (g.max = Math.max(g.max, b.maximums[0]));
                    }
                    return g;
                  },
                  { min: Number.MAX_VALUE, max: 0 }
                );
                return this._getBoundsRectangular(
                  u.min * a.exaggeration(),
                  u.max * a.exaggeration()
                );
              }
              getBounds() {
                return "mercator" === this.projection.name ||
                  "equirectangular" === this.projection.name
                  ? this._terrainEnabled()
                    ? this._getBoundsRectangularTerrain()
                    : this._getBoundsRectangular(0, 0)
                  : this._getBoundsNonRectangular();
              }
              horizonLineFromTop(a = !0) {
                const u =
                    this.height /
                      2 /
                      Math.tan(this._fov / 2) /
                      Math.tan(Math.max(this._pitch, 0.1)) +
                    this.centerOffset.y,
                  g = this.height / 2 - u * (1 - this._horizonShift);
                return a ? Math.max(0, g) : g;
              }
              getMaxBounds() {
                return this.maxBounds;
              }
              setMaxBounds(a) {
                (this.maxBounds = a),
                  (this.minLat = -d.MAX_MERCATOR_LATITUDE),
                  (this.maxLat = d.MAX_MERCATOR_LATITUDE),
                  (this.minLng = -180),
                  (this.maxLng = 180),
                  a &&
                    ((this.minLat = a.getSouth()),
                    (this.maxLat = a.getNorth()),
                    (this.minLng = a.getWest()),
                    (this.maxLng = a.getEast()),
                    this.maxLng < this.minLng && (this.maxLng += 360)),
                  (this.worldMinX =
                    d.mercatorXfromLng(this.minLng) * this.tileSize),
                  (this.worldMaxX =
                    d.mercatorXfromLng(this.maxLng) * this.tileSize),
                  (this.worldMinY =
                    d.mercatorYfromLat(this.maxLat) * this.tileSize),
                  (this.worldMaxY =
                    d.mercatorYfromLat(this.minLat) * this.tileSize),
                  this._constrain();
              }
              calculatePosMatrix(a, u) {
                return this.projection.createTileMatrix(this, u, a);
              }
              calculateDistanceTileData(a) {
                const u = a.key,
                  g = this._distanceTileDataCache;
                if (g[u]) return g[u];
                const v = a.canonical,
                  b = 1 / this.height,
                  D = this.cameraWorldSize,
                  S = D / this.zoomScale(v.z),
                  M = (v.x + Math.pow(2, v.z) * a.wrap) * S,
                  R = v.y * S,
                  k = this.point;
                (k.x *= D / this.worldSize), (k.y *= D / this.worldSize);
                const z = this.angle,
                  H = Math.sin(-z),
                  q = -Math.cos(-z);
                return (
                  (g[u] = {
                    bearing: [H, q],
                    center: [(k.x - M) * b, (k.y - R) * b],
                    scale: (S / d.EXTENT) * b,
                  }),
                  g[u]
                );
              }
              calculateFogTileMatrix(a) {
                const u = a.key,
                  g = this._fogTileMatrixCache;
                if (g[u]) return g[u];
                const v = this.projection.createTileMatrix(
                  this,
                  this.cameraWorldSizeForFog,
                  a
                );
                return (
                  d.multiply(v, this.worldToFogMatrix, v),
                  (g[u] = new Float32Array(v)),
                  g[u]
                );
              }
              calculateProjMatrix(a, u = !1) {
                const g = a.key,
                  v = u ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (v[g]) return v[g];
                const b = this.calculatePosMatrix(a, this.worldSize);
                return (
                  d.multiply(
                    b,
                    this.projection.isReprojectedInTileSpace
                      ? this.mercatorMatrix
                      : u
                      ? this.alignedProjMatrix
                      : this.projMatrix,
                    b
                  ),
                  (v[g] = new Float32Array(b)),
                  v[g]
                );
              }
              calculatePixelsToTileUnitsMatrix(a) {
                const u = a.tileID.key,
                  g = this._pixelsToTileUnitsCache;
                if (g[u]) return g[u];
                const v = (function (b, D) {
                  const { scale: S } = b.tileTransform,
                    M =
                      (S * d.EXTENT) /
                      (b.tileSize *
                        Math.pow(
                          2,
                          D.zoom - b.tileID.overscaledZ + b.tileID.canonical.z
                        ));
                  return (
                    (R = new Float32Array(4)),
                    (H = (k = D.inverseAdjustmentMatrix)[1]),
                    (q = k[2]),
                    (X = k[3]),
                    (Y = (z = [M, M])[1]),
                    (R[0] = k[0] * (Z = z[0])),
                    (R[1] = H * Z),
                    (R[2] = q * Y),
                    (R[3] = X * Y),
                    R
                  );
                  var R, k, z, H, q, X, Z, Y;
                })(a, this);
                return (g[u] = v), g[u];
              }
              customLayerMatrix() {
                return this.mercatorMatrix.slice();
              }
              globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                  const a = 1 / this.worldSize,
                    u = d.fromScaling([], [a, a, a]);
                  return d.multiply(u, u, this.globeMatrix), u;
                }
              }
              recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name)
                  return;
                const a = this._elevation;
                this._updateCameraState();
                const u =
                    d.mercatorZfromAltitude(1, this._center.lat) *
                    this.worldSize,
                  g = this._computeCameraPosition(u),
                  v = this._camera.forward(),
                  b = d.mercatorZfromAltitude(1, this._center.lat);
                (g[2] /= b), (v[2] /= b), d.normalize(v, v);
                const D = a.raycast(g, v, a.exaggeration());
                if (D) {
                  const S = d.scaleAndAdd([], g, v, D),
                    M = new d.MercatorCoordinate(
                      S[0],
                      S[1],
                      d.mercatorZfromAltitude(S[2], d.latFromMercatorY(S[1]))
                    ),
                    R =
                      (M.z +
                        d.length([M.x - g[0], M.y - g[1], M.z - g[2] * b])) *
                      this._pixelsPerMercatorPixel;
                  (this._seaLevelZoom = this._zoomFromMercatorZ(R)),
                    (this._centerAltitude = M.toAltitude()),
                    (this._center = this.coordinateLocation(M)),
                    this._updateZoomFromElevation(),
                    this._constrain(),
                    this._calcMatrices();
                }
              }
              _constrainCamera(a = !1) {
                if (!this._elevation) return;
                const u = this._elevation,
                  g =
                    d.mercatorZfromAltitude(1, this._center.lat) *
                    this.worldSize,
                  v = this._computeCameraPosition(g),
                  b = u.getAtPointOrZero(new d.MercatorCoordinate(...v)),
                  D = (this.pixelsPerMeter / this.worldSize) * b,
                  S = this._minimumHeightOverTerrain(),
                  M = v[2] - D;
                if (M <= S)
                  if (M < 0 || a) {
                    const R = this.locationCoordinate(
                        this._center,
                        this._centerAltitude
                      ),
                      k = [v[0], v[1], R.z - v[2]],
                      z = d.length(k);
                    k[2] -= (S - M) / this._pixelsPerMercatorPixel;
                    const H = d.length(k);
                    if (0 === H) return;
                    d.scale$2(k, k, (z / H) * this._pixelsPerMercatorPixel),
                      (this._camera.position = [
                        v[0],
                        v[1],
                        R.z * this._pixelsPerMercatorPixel - k[2],
                      ]),
                      this._updateStateFromCamera();
                  } else this._isCameraConstrained = !0;
              }
              _constrain() {
                if (
                  !this.center ||
                  !this.width ||
                  !this.height ||
                  this._constraining
                )
                  return;
                this._constraining = !0;
                const a =
                  "globe" === this.projection.name ||
                  this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || a) {
                  const H = this.center;
                  return (
                    (H.lat = d.clamp(H.lat, this.minLat, this.maxLat)),
                    (this.maxBounds || (!this.renderWorldCopies && !a)) &&
                      (H.lng = d.clamp(H.lng, this.minLng, this.maxLng)),
                    (this.center = H),
                    void (this._constraining = !1)
                  );
                }
                const u = this._unmodified,
                  { x: g, y: v } = this.point;
                let b = 0,
                  D = g,
                  S = v;
                const M = this.width / 2,
                  R = this.height / 2,
                  k = this.worldMinY * this.scale,
                  z = this.worldMaxY * this.scale;
                if (
                  (v - R < k && (S = k + R),
                  v + R > z && (S = z - R),
                  z - k < this.height &&
                    ((b = Math.max(b, this.height / (z - k))),
                    (S = (z + k) / 2)),
                  this.maxBounds ||
                    !this._renderWorldCopies ||
                    !this.projection.wrap)
                ) {
                  const H = this.worldMinX * this.scale,
                    q = this.worldMaxX * this.scale,
                    X = this.worldSize / 2 - (H + q) / 2;
                  (D = ((g + X + this.worldSize) % this.worldSize) - X),
                    D - M < H && (D = H + M),
                    D + M > q && (D = q - M),
                    q - H < this.width &&
                      ((b = Math.max(b, this.width / (q - H))),
                      (D = (q + H) / 2));
                }
                (D === g && S === v) ||
                  (this.center = this.unproject(new d.Point(D, S))),
                  b && (this.zoom += this.scaleZoom(b)),
                  this._constrainCamera(),
                  (this._unmodified = u),
                  (this._constraining = !1);
              }
              _minZoomForBounds() {
                let a = Math.max(
                  0,
                  this.scaleZoom(
                    this.height / (this.worldMaxY - this.worldMinY)
                  )
                );
                return (
                  this.maxBounds &&
                    (a = Math.max(
                      a,
                      this.scaleZoom(
                        this.width / (this.worldMaxX - this.worldMinX)
                      )
                    )),
                  a
                );
              }
              _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
              }
              _calcMatrices() {
                if (!this.height) return;
                const a = this.centerOffset,
                  u = this.pixelsPerMeter;
                "globe" === this.projection.name &&
                  (this._mercatorScaleRatio =
                    d.mercatorZfromAltitude(1, this.center.lat) /
                    d.mercatorZfromAltitude(1, d.GLOBE_SCALE_MATCH_LATITUDE));
                const g = Uh(
                  this.projection,
                  this.zoom,
                  this.width,
                  this.height,
                  1024
                );
                (this._pixelsPerMercatorPixel =
                  this.projection.pixelSpaceConversion(
                    this.center.lat,
                    this.worldSize,
                    g
                  )),
                  (this.cameraToCenterDistance =
                    (0.5 / Math.tan(0.5 * this._fov)) *
                    this.height *
                    this._pixelsPerMercatorPixel),
                  this._updateCameraState(),
                  (this._farZ = this.projection.farthestPixelDistance(this)),
                  (this._nearZ = this.height / 50);
                const v = "meters" === this.projection.zAxisUnit ? u : 1,
                  b = this._camera.getWorldToCamera(this.worldSize, v),
                  D = this._camera.getCameraToClipPerspective(
                    this._fov,
                    this.width / this.height,
                    this._nearZ,
                    this._farZ
                  );
                (D[8] = (2 * -a.x) / this.width),
                  (D[9] = (2 * a.y) / this.height);
                let S = d.mul([], D, b);
                if (this.projection.isReprojectedInTileSpace) {
                  const de = this.locationCoordinate(this.center),
                    ue = d.identity([]);
                  d.translate(ue, ue, [
                    de.x * this.worldSize,
                    de.y * this.worldSize,
                    0,
                  ]),
                    d.multiply(ue, ue, Xs(this)),
                    d.translate(ue, ue, [
                      -de.x * this.worldSize,
                      -de.y * this.worldSize,
                      0,
                    ]),
                    d.multiply(S, S, ue),
                    (this.inverseAdjustmentMatrix = (function (_e) {
                      const ge = Xs(_e, !0);
                      return nt([], [ge[0], ge[1], ge[4], ge[5]]);
                    })(this));
                } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                (this.mercatorMatrix = d.scale([], S, [
                  this.worldSize,
                  this.worldSize,
                  this.worldSize / v,
                  1,
                ])),
                  (this.projMatrix = S),
                  (this.invProjMatrix = d.invert(
                    new Float64Array(16),
                    this.projMatrix
                  ));
                const M = d.invert([], D);
                this.frustumCorners = d.FrustumCorners.fromInvProjectionMatrix(
                  M,
                  this.horizonLineFromTop(),
                  this.height
                );
                const R = new Float32Array(16);
                d.identity(R),
                  d.scale(R, R, [1, -1, 1]),
                  d.rotateX(R, R, this._pitch),
                  d.rotateZ(R, R, this.angle);
                const k = d.perspective(
                    new Float32Array(16),
                    this._fov,
                    this.width / this.height,
                    this._nearZ,
                    this._farZ
                  ),
                  z =
                    (Math.PI / 2 - this._pitch) *
                    (this.height / this._fov) *
                    this._horizonShift;
                (k[8] = (2 * -a.x) / this.width),
                  (k[9] = (2 * (a.y + z)) / this.height),
                  (this.skyboxMatrix = d.multiply(R, k, R));
                const H = this.point,
                  q = H.x,
                  X = H.y,
                  Z = (this.width % 2) / 2,
                  Y = (this.height % 2) / 2,
                  B = Math.cos(this.angle),
                  W = Math.sin(this.angle),
                  ee = q - Math.round(q) + B * Z + W * Y,
                  te = X - Math.round(X) + B * Y + W * Z,
                  he = new Float64Array(S);
                if (
                  (d.translate(he, he, [
                    ee > 0.5 ? ee - 1 : ee,
                    te > 0.5 ? te - 1 : te,
                    0,
                  ]),
                  (this.alignedProjMatrix = he),
                  (S = d.create()),
                  d.scale(S, S, [this.width / 2, -this.height / 2, 1]),
                  d.translate(S, S, [1, -1, 0]),
                  (this.labelPlaneMatrix = S),
                  (S = d.create()),
                  d.scale(S, S, [1, -1, 1]),
                  d.translate(S, S, [-1, -1, 0]),
                  d.scale(S, S, [2 / this.width, 2 / this.height, 1]),
                  (this.glCoordMatrix = S),
                  (this.pixelMatrix = d.multiply(
                    new Float64Array(16),
                    this.labelPlaneMatrix,
                    this.projMatrix
                  )),
                  this._calcFogMatrices(),
                  (this._distanceTileDataCache = {}),
                  (S = d.invert(new Float64Array(16), this.pixelMatrix)),
                  !S)
                )
                  throw new Error("failed to invert matrix");
                if (
                  ((this.pixelMatrixInverse = S),
                  "globe" === this.projection.name ||
                    this.mercatorFromTransition)
                ) {
                  this.globeMatrix = d.calculateGlobeMatrix(this);
                  const de = [
                    this.globeMatrix[12],
                    this.globeMatrix[13],
                    this.globeMatrix[14],
                  ];
                  (this.globeCenterInViewSpace = d.transformMat4(de, de, b)),
                    (this.globeRadius = this.worldSize / 2 / Math.PI - 1);
                } else this.globeMatrix = S;
                (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {}),
                  (this._pixelsToTileUnitsCache = {});
              }
              _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const a = this.cameraWorldSizeForFog,
                  u = this.cameraPixelsPerMeter,
                  g = this._camera.position,
                  v = 1 / this.height / this._pixelsPerMercatorPixel,
                  b = [a, a, u];
                d.scale$2(b, b, v), d.scale$2(g, g, -1), d.multiply$2(g, g, b);
                const D = d.create();
                d.translate(D, D, g),
                  d.scale(D, D, b),
                  (this.mercatorFogMatrix = D),
                  (this.worldToFogMatrix =
                    this._camera.getWorldToCameraPosition(a, u, v));
              }
              _computeCameraPosition(a) {
                const u = (a = a || this.pixelsPerMeter) / this.pixelsPerMeter,
                  g = this._camera.forward(),
                  v = this.point,
                  b =
                    this._mercatorZfromZoom(
                      this._seaLevelZoom ? this._seaLevelZoom : this._zoom
                    ) *
                      u -
                    (a / this.worldSize) * this._centerAltitude;
                return [
                  v.x / this.worldSize - g[0] * b,
                  v.y / this.worldSize - g[1] * b,
                  (a / this.worldSize) * this._centerAltitude - g[2] * b,
                ];
              }
              _updateCameraState() {
                this.height &&
                  (this._camera.setPitchBearing(this._pitch, this.angle),
                  (this._camera.position = this._computeCameraPosition()));
              }
              _translateCameraConstrained(a) {
                const u =
                    this._maxCameraBoundsDistance() * Math.cos(this._pitch),
                  g = this._camera.position[2],
                  v = a[2];
                let b = 1;
                this.projection.wrap && (this.center = this.center.wrap()),
                  v > 0 && (b = Math.min((u - g) / v, 1)),
                  (this._camera.position = d.scaleAndAdd(
                    [],
                    this._camera.position,
                    a,
                    b
                  )),
                  this._updateStateFromCamera();
              }
              _updateStateFromCamera() {
                const a = this._camera.position,
                  u = this._camera.forward(),
                  { pitch: g, bearing: v } = this._camera.getPitchBearing(),
                  b =
                    d.mercatorZfromAltitude(
                      this._centerAltitude,
                      this.center.lat
                    ) * this._pixelsPerMercatorPixel,
                  D =
                    this._mercatorZfromZoom(this._maxZoom) *
                    Math.cos(d.degToRad(this._maxPitch)),
                  S = Math.max((a[2] - b) / Math.cos(g), D),
                  M = this._zoomFromMercatorZ(S);
                d.scaleAndAdd(a, a, u, S),
                  (this._pitch = d.clamp(
                    g,
                    d.degToRad(this.minPitch),
                    d.degToRad(this.maxPitch)
                  )),
                  (this.angle = d.wrap(v, -Math.PI, Math.PI)),
                  this._setZoom(d.clamp(M, this._minZoom, this._maxZoom)),
                  this._updateSeaLevelZoom(),
                  (this._center = this.coordinateLocation(
                    new d.MercatorCoordinate(a[0], a[1], a[2])
                  )),
                  (this._unmodified = !1),
                  this._constrain(),
                  this._calcMatrices();
              }
              _worldSizeFromZoom(a) {
                return Math.pow(2, a) * this.tileSize;
              }
              _mercatorZfromZoom(a) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(a);
              }
              _minimumHeightOverTerrain() {
                const a = Math.min(
                  (null != this._seaLevelZoom
                    ? this._seaLevelZoom
                    : this._zoom) + 4,
                  this._maxZoom
                );
                return this._mercatorZfromZoom(a);
              }
              _zoomFromMercatorZ(a) {
                return this.scaleZoom(
                  this.cameraToCenterDistance / (a * this.tileSize)
                );
              }
              zoomFromMercatorZAdjusted(a) {
                let u = 0,
                  g = d.GLOBE_ZOOM_THRESHOLD_MAX,
                  v = 0,
                  b = 1 / 0;
                for (; g - u > 1e-6 && g > u; ) {
                  const D = u + 0.5 * (g - u),
                    S = this.tileSize * Math.pow(2, D),
                    M = this.getCameraToCenterDistance(this.projection, D, S),
                    R = this.scaleZoom(M / (a * this.tileSize)),
                    k = Math.abs(D - R);
                  k < b && ((b = k), (v = D)), D < R ? (u = D) : (g = D);
                }
                return v;
              }
              _terrainEnabled() {
                return !(
                  !this._elevation ||
                  (!this.projection.supportsTerrain &&
                    (d.warnOnce(
                      "Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."
                    ),
                    1))
                );
              }
              anyCornerOffEdge(a, u) {
                const g = Math.min(a.x, u.x),
                  v = Math.max(a.x, u.x),
                  b = Math.min(a.y, u.y),
                  D = Math.max(a.y, u.y);
                if (b < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const S = [
                    new d.Point(g, b),
                    new d.Point(v, D),
                    new d.Point(g, D),
                    new d.Point(v, b),
                  ],
                  M = this.renderWorldCopies ? -3 : 0,
                  R = this.renderWorldCopies ? 4 : 1;
                for (const k of S) {
                  const z = this.pointRayIntersection(k);
                  if (z.t < 0) return !0;
                  const H = this.rayIntersectionCoordinate(z);
                  if (H.x < M || H.y < 0 || H.x > R || H.y > 1) return !0;
                }
                return !1;
              }
              isHorizonVisible() {
                return (
                  this.pitch + d.radToDeg(this.fovAboveCenter) > 88 ||
                  this.anyCornerOffEdge(
                    new d.Point(0, 0),
                    new d.Point(this.width, this.height)
                  )
                );
              }
              zoomDeltaToMovement(a, u) {
                const g = d.length(d.sub([], this._camera.position, a)),
                  v = this._zoomFromMercatorZ(g) + u;
                return g - this._mercatorZfromZoom(v);
              }
              getCameraPoint() {
                if ("globe" === this.projection.name) {
                  const a = (function ([u, g, v], b) {
                    const D = [u, g, v, 1];
                    d.transformMat4$1(D, D, b);
                    const S = (D[3] = Math.max(D[3], 1e-6));
                    return (D[0] /= S), (D[1] /= S), (D[2] /= S), D;
                  })(
                    [
                      this.globeMatrix[12],
                      this.globeMatrix[13],
                      this.globeMatrix[14],
                    ],
                    this.pixelMatrix
                  );
                  return new d.Point(a[0], a[1]);
                }
                {
                  const a =
                    Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                  return this.centerPoint.add(new d.Point(0, a));
                }
              }
              getCameraToCenterDistance(a, u = this.zoom, g = this.worldSize) {
                const v = Uh(a, u, this.width, this.height, 1024),
                  b = a.pixelSpaceConversion(this.center.lat, g, v);
                return (0.5 / Math.tan(0.5 * this._fov)) * this.height * b;
              }
              getWorldToCameraMatrix() {
                const a = this._camera.getWorldToCamera(
                  this.worldSize,
                  "meters" === this.projection.zAxisUnit
                    ? this.pixelsPerMeter
                    : 1
                );
                return (
                  "globe" === this.projection.name &&
                    d.multiply(a, a, this.globeMatrix),
                  a
                );
              }
            }
            function Ba(f, a) {
              let u = !1,
                g = null;
              const v = () => {
                (g = null), u && (f(), (g = setTimeout(v, a)), (u = !1));
              };
              return () => ((u = !0), g || v(), g);
            }
            class $h {
              constructor(a) {
                (this._hashName = a && encodeURIComponent(a)),
                  d.bindAll(
                    ["_getCurrentHash", "_onHashChange", "_updateHash"],
                    this
                  ),
                  (this._updateHash = Ba(
                    this._updateHashUnthrottled.bind(this),
                    300
                  ));
              }
              addTo(a) {
                return (
                  (this._map = a),
                  d.window.addEventListener(
                    "hashchange",
                    this._onHashChange,
                    !1
                  ),
                  a.on("moveend", this._updateHash),
                  this
                );
              }
              remove() {
                return this._map
                  ? (this._map.off("moveend", this._updateHash),
                    d.window.removeEventListener(
                      "hashchange",
                      this._onHashChange,
                      !1
                    ),
                    clearTimeout(this._updateHash()),
                    (this._map = void 0),
                    this)
                  : this;
              }
              getHashString() {
                const a = this._map;
                if (!a) return "";
                const u = Ec(a);
                if (this._hashName) {
                  const g = this._hashName;
                  let v = !1;
                  const b = d.window.location.hash
                    .slice(1)
                    .split("&")
                    .map((D) => {
                      const S = D.split("=")[0];
                      return S === g ? ((v = !0), `${S}=${u}`) : D;
                    })
                    .filter((D) => D);
                  return v || b.push(`${g}=${u}`), `#${b.join("&")}`;
                }
                return `#${u}`;
              }
              _getCurrentHash() {
                const a = d.window.location.hash.replace("#", "");
                if (this._hashName) {
                  let u;
                  return (
                    a
                      .split("&")
                      .map((g) => g.split("="))
                      .forEach((g) => {
                        g[0] === this._hashName && (u = g);
                      }),
                    ((u && u[1]) || "").split("/")
                  );
                }
                return a.split("/");
              }
              _onHashChange() {
                const a = this._map;
                if (!a) return !1;
                const u = this._getCurrentHash();
                if (u.length >= 3 && !u.some((g) => isNaN(g))) {
                  const g =
                    a.dragRotate.isEnabled() && a.touchZoomRotate.isEnabled()
                      ? +(u[3] || 0)
                      : a.getBearing();
                  return (
                    a.jumpTo({
                      center: [+u[2], +u[1]],
                      zoom: +u[0],
                      bearing: g,
                      pitch: +(u[4] || 0),
                    }),
                    !0
                  );
                }
                return !1;
              }
              _updateHashUnthrottled() {
                const a = d.window.location.href.replace(
                  /(#.+)?$/,
                  this.getHashString()
                );
                d.window.history.replaceState(d.window.history.state, null, a);
              }
            }
            function Ec(f, a) {
              const u = f.getCenter(),
                g = Math.round(100 * f.getZoom()) / 100,
                v = Math.ceil(
                  (g * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10
                ),
                b = Math.pow(10, v),
                D = Math.round(u.lng * b) / b,
                S = Math.round(u.lat * b) / b,
                M = f.getBearing(),
                R = f.getPitch();
              let k = a ? `/${D}/${S}/${g}` : `${g}/${S}/${D}`;
              return (
                (M || R) && (k += "/" + Math.round(10 * M) / 10),
                R && (k += `/${Math.round(R)}`),
                k
              );
            }
            const Fl = { linearity: 0.3, easing: d.bezier(0, 0, 0.3, 1) },
              Tc = d.extend({ deceleration: 2500, maxSpeed: 1400 }, Fl),
              Au = d.extend({ deceleration: 20, maxSpeed: 1400 }, Fl),
              ct = d.extend({ deceleration: 1e3, maxSpeed: 360 }, Fl),
              To = d.extend({ deceleration: 1e3, maxSpeed: 90 }, Fl);
            class Xr {
              constructor(a) {
                (this._map = a), this.clear();
              }
              clear() {
                this._inertiaBuffer = [];
              }
              record(a) {
                this._drainInertiaBuffer(),
                  this._inertiaBuffer.push({
                    time: d.exported.now(),
                    settings: a,
                  });
              }
              _drainInertiaBuffer() {
                const a = this._inertiaBuffer,
                  u = d.exported.now();
                for (; a.length > 0 && u - a[0].time > 160; ) a.shift();
              }
              _onMoveEnd(a) {
                if (
                  this._map._prefersReducedMotion() ||
                  (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                )
                  return;
                const u = {
                  zoom: 0,
                  bearing: 0,
                  pitch: 0,
                  pan: new d.Point(0, 0),
                  pinchAround: void 0,
                  around: void 0,
                };
                for (const { settings: b } of this._inertiaBuffer)
                  (u.zoom += b.zoomDelta || 0),
                    (u.bearing += b.bearingDelta || 0),
                    (u.pitch += b.pitchDelta || 0),
                    b.panDelta && u.pan._add(b.panDelta),
                    b.around && (u.around = b.around),
                    b.pinchAround && (u.pinchAround = b.pinchAround);
                const g =
                    this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                    this._inertiaBuffer[0].time,
                  v = {};
                if (u.pan.mag()) {
                  const b = Dc(u.pan.mag(), g, d.extend({}, Tc, a || {}));
                  (v.offset = u.pan.mult(b.amount / u.pan.mag())),
                    (v.center = this._map.transform.center),
                    Va(v, b);
                }
                if (u.zoom) {
                  const b = Dc(u.zoom, g, Au);
                  (v.zoom = this._map.transform.zoom + b.amount), Va(v, b);
                }
                if (u.bearing) {
                  const b = Dc(u.bearing, g, ct);
                  (v.bearing =
                    this._map.transform.bearing + d.clamp(b.amount, -179, 179)),
                    Va(v, b);
                }
                if (u.pitch) {
                  const b = Dc(u.pitch, g, To);
                  (v.pitch = this._map.transform.pitch + b.amount), Va(v, b);
                }
                if (v.zoom || v.bearing) {
                  const b = void 0 === u.pinchAround ? u.around : u.pinchAround;
                  v.around = b ? this._map.unproject(b) : this._map.getCenter();
                }
                return this.clear(), (v.noMoveStart = !0), v;
              }
            }
            function Va(f, a) {
              (!f.duration || f.duration < a.duration) &&
                ((f.duration = a.duration), (f.easing = a.easing));
            }
            function Dc(f, a, u) {
              const { maxSpeed: g, linearity: v, deceleration: b } = u,
                D = d.clamp((f * v) / (a / 1e3), -g, g),
                S = Math.abs(D) / (b * v);
              return {
                easing: u.easing,
                duration: 1e3 * S,
                amount: D * (S / 2),
              };
            }
            class Ci extends d.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(a, u, g, v = {}) {
                const b = Mr(u.getCanvasContainer(), g),
                  D = u.unproject(b);
                super(
                  a,
                  d.extend({ point: b, lngLat: D, originalEvent: g }, v)
                ),
                  (this._defaultPrevented = !1),
                  (this.target = u);
              }
            }
            class Cc extends d.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(a, u, g) {
                const v = "touchend" === a ? g.changedTouches : g.touches,
                  b = Ca(u.getCanvasContainer(), v),
                  D = b.map((M) => u.unproject(M)),
                  S = b.reduce(
                    (M, R, k, z) => M.add(R.div(z.length)),
                    new d.Point(0, 0)
                  );
                super(a, {
                  points: b,
                  point: S,
                  lngLats: D,
                  lngLat: u.unproject(S),
                  originalEvent: g,
                }),
                  (this._defaultPrevented = !1);
              }
            }
            class Hh extends d.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(a, u, g) {
                super(a, { originalEvent: g }), (this._defaultPrevented = !1);
              }
            }
            class oi {
              constructor(a, u) {
                (this._map = a), (this._clickTolerance = u.clickTolerance);
              }
              reset() {
                this._mousedownPos = void 0;
              }
              wheel(a) {
                return this._firePreventable(new Hh(a.type, this._map, a));
              }
              mousedown(a, u) {
                return (
                  (this._mousedownPos = u),
                  this._firePreventable(new Ci(a.type, this._map, a))
                );
              }
              mouseup(a) {
                this._map.fire(new Ci(a.type, this._map, a));
              }
              preclick(a) {
                const u = d.extend({}, a);
                (u.type = "preclick"),
                  this._map.fire(new Ci(u.type, this._map, u));
              }
              click(a, u) {
                (this._mousedownPos &&
                  this._mousedownPos.dist(u) >= this._clickTolerance) ||
                  (this.preclick(a),
                  this._map.fire(new Ci(a.type, this._map, a)));
              }
              dblclick(a) {
                return this._firePreventable(new Ci(a.type, this._map, a));
              }
              mouseover(a) {
                this._map.fire(new Ci(a.type, this._map, a));
              }
              mouseout(a) {
                this._map.fire(new Ci(a.type, this._map, a));
              }
              touchstart(a) {
                return this._firePreventable(new Cc(a.type, this._map, a));
              }
              touchmove(a) {
                this._map.fire(new Cc(a.type, this._map, a));
              }
              touchend(a) {
                this._map.fire(new Cc(a.type, this._map, a));
              }
              touchcancel(a) {
                this._map.fire(new Cc(a.type, this._map, a));
              }
              _firePreventable(a) {
                if ((this._map.fire(a), a.defaultPrevented)) return {};
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class Pu {
              constructor(a) {
                this._map = a;
              }
              reset() {
                (this._delayContextMenu = !1),
                  (this._contextMenuEvent = void 0);
              }
              mousemove(a) {
                this._map.fire(new Ci(a.type, this._map, a));
              }
              mousedown() {
                this._delayContextMenu = !0;
              }
              mouseup() {
                (this._delayContextMenu = !1),
                  this._contextMenuEvent &&
                    (this._map.fire(
                      new Ci("contextmenu", this._map, this._contextMenuEvent)
                    ),
                    delete this._contextMenuEvent);
              }
              contextmenu(a) {
                this._delayContextMenu
                  ? (this._contextMenuEvent = a)
                  : this._map.fire(new Ci(a.type, this._map, a)),
                  this._map.listens("contextmenu") && a.preventDefault();
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class jf {
              constructor(a, u) {
                (this._map = a),
                  (this._el = a.getCanvasContainer()),
                  (this._container = a.getContainer()),
                  (this._clickTolerance = u.clickTolerance || 1);
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active;
              }
              enable() {
                this.isEnabled() || (this._enabled = !0);
              }
              disable() {
                this.isEnabled() && (this._enabled = !1);
              }
              mousedown(a, u) {
                this.isEnabled() &&
                  a.shiftKey &&
                  0 === a.button &&
                  (oc(),
                  (this._startPos = this._lastPos = u),
                  (this._active = !0));
              }
              mousemoveWindow(a, u) {
                if (!this._active) return;
                const g = u,
                  v = this._startPos,
                  b = this._lastPos;
                if (
                  !v ||
                  !b ||
                  b.equals(g) ||
                  (!this._box && g.dist(v) < this._clickTolerance)
                )
                  return;
                (this._lastPos = g),
                  this._box ||
                    ((this._box = zt(
                      "div",
                      "mapboxgl-boxzoom",
                      this._container
                    )),
                    this._container.classList.add("mapboxgl-crosshair"),
                    this._fireEvent("boxzoomstart", a));
                const D = Math.min(v.x, g.x),
                  S = Math.max(v.x, g.x),
                  M = Math.min(v.y, g.y),
                  R = Math.max(v.y, g.y);
                this._map._requestDomTask(() => {
                  this._box &&
                    ((this._box.style.transform = `translate(${D}px,${M}px)`),
                    (this._box.style.width = S - D + "px"),
                    (this._box.style.height = R - M + "px"));
                });
              }
              mouseupWindow(a, u) {
                if (!this._active) return;
                const g = this._startPos,
                  v = u;
                if (g && 0 === a.button) {
                  if ((this.reset(), to(), g.x !== v.x || g.y !== v.y))
                    return (
                      this._map.fire(
                        new d.Event("boxzoomend", { originalEvent: a })
                      ),
                      {
                        cameraAnimation: (b) =>
                          b.fitScreenCoordinates(g, v, this._map.getBearing(), {
                            linear: !1,
                          }),
                      }
                    );
                  this._fireEvent("boxzoomcancel", a);
                }
              }
              keydown(a) {
                this._active &&
                  27 === a.keyCode &&
                  (this.reset(), this._fireEvent("boxzoomcancel", a));
              }
              blur() {
                this.reset();
              }
              reset() {
                (this._active = !1),
                  this._container.classList.remove("mapboxgl-crosshair"),
                  this._box && (this._box.remove(), (this._box = null)),
                  vl(),
                  delete this._startPos,
                  delete this._lastPos;
              }
              _fireEvent(a, u) {
                return this._map.fire(new d.Event(a, { originalEvent: u }));
              }
            }
            function ja(f, a) {
              const u = {};
              for (let g = 0; g < f.length; g++) u[f[g].identifier] = a[g];
              return u;
            }
            class ji {
              constructor(a) {
                this.reset(), (this.numTouches = a.numTouches);
              }
              reset() {
                (this.centroid = void 0),
                  (this.startTime = 0),
                  (this.touches = {}),
                  (this.aborted = !1);
              }
              touchstart(a, u, g) {
                (this.centroid || g.length > this.numTouches) &&
                  (this.aborted = !0),
                  this.aborted ||
                    (0 === this.startTime && (this.startTime = a.timeStamp),
                    g.length === this.numTouches &&
                      ((this.centroid = (function (v) {
                        const b = new d.Point(0, 0);
                        for (const D of v) b._add(D);
                        return b.div(v.length);
                      })(u)),
                      (this.touches = ja(g, u))));
              }
              touchmove(a, u, g) {
                if (this.aborted || !this.centroid) return;
                const v = ja(g, u);
                for (const b in this.touches) {
                  const D = v[b];
                  (!D || D.dist(this.touches[b]) > 30) && (this.aborted = !0);
                }
              }
              touchend(a, u, g) {
                if (
                  ((!this.centroid || a.timeStamp - this.startTime > 500) &&
                    (this.aborted = !0),
                  0 === g.length)
                ) {
                  const v = !this.aborted && this.centroid;
                  if ((this.reset(), v)) return v;
                }
              }
            }
            class Gh {
              constructor(a) {
                (this.singleTap = new ji(a)),
                  (this.numTaps = a.numTaps),
                  this.reset();
              }
              reset() {
                (this.lastTime = 1 / 0),
                  (this.lastTap = void 0),
                  (this.count = 0),
                  this.singleTap.reset();
              }
              touchstart(a, u, g) {
                this.singleTap.touchstart(a, u, g);
              }
              touchmove(a, u, g) {
                this.singleTap.touchmove(a, u, g);
              }
              touchend(a, u, g) {
                const v = this.singleTap.touchend(a, u, g);
                if (v) {
                  const b = a.timeStamp - this.lastTime < 500,
                    D = !this.lastTap || this.lastTap.dist(v) < 30;
                  if (
                    ((b && D) || this.reset(),
                    this.count++,
                    (this.lastTime = a.timeStamp),
                    (this.lastTap = v),
                    this.count === this.numTaps)
                  )
                    return this.reset(), v;
                }
              }
            }
            class qh {
              constructor() {
                (this._zoomIn = new Gh({ numTouches: 1, numTaps: 2 })),
                  (this._zoomOut = new Gh({ numTouches: 2, numTaps: 1 })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  this._zoomIn.reset(),
                  this._zoomOut.reset();
              }
              touchstart(a, u, g) {
                this._zoomIn.touchstart(a, u, g),
                  this._zoomOut.touchstart(a, u, g);
              }
              touchmove(a, u, g) {
                this._zoomIn.touchmove(a, u, g),
                  this._zoomOut.touchmove(a, u, g);
              }
              touchend(a, u, g) {
                const v = this._zoomIn.touchend(a, u, g),
                  b = this._zoomOut.touchend(a, u, g);
                return v
                  ? ((this._active = !0),
                    a.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (D) =>
                        D.easeTo(
                          {
                            duration: 300,
                            zoom: D.getZoom() + 1,
                            around: D.unproject(v),
                          },
                          { originalEvent: a }
                        ),
                    })
                  : b
                  ? ((this._active = !0),
                    a.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (D) =>
                        D.easeTo(
                          {
                            duration: 300,
                            zoom: D.getZoom() - 1,
                            around: D.unproject(b),
                          },
                          { originalEvent: a }
                        ),
                    })
                  : void 0;
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            const Ua = { 0: 1, 2: 2 };
            class Ui {
              constructor(a) {
                this.reset(), (this._clickTolerance = a.clickTolerance || 1);
              }
              blur() {
                this.reset();
              }
              reset() {
                (this._active = !1),
                  (this._moved = !1),
                  (this._lastPoint = void 0),
                  (this._eventButton = void 0);
              }
              _correctButton(a, u) {
                return !1;
              }
              _move(a, u) {
                return {};
              }
              mousedown(a, u) {
                if (this._lastPoint) return;
                const g = is(a);
                this._correctButton(a, g) &&
                  ((this._lastPoint = u), (this._eventButton = g));
              }
              mousemoveWindow(a, u) {
                const g = this._lastPoint;
                if (g)
                  if (
                    (a.preventDefault(),
                    null != this._eventButton &&
                      (function (v, b) {
                        const D = Ua[b];
                        return void 0 === v.buttons || (v.buttons & D) !== D;
                      })(a, this._eventButton))
                  )
                    this.reset();
                  else if (this._moved || !(u.dist(g) < this._clickTolerance))
                    return (
                      (this._moved = !0),
                      (this._lastPoint = u),
                      this._move(g, u)
                    );
              }
              mouseupWindow(a) {
                this._lastPoint &&
                  is(a) === this._eventButton &&
                  (this._moved && to(), this.reset());
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class Wh extends Ui {
              mousedown(a, u) {
                super.mousedown(a, u), this._lastPoint && (this._active = !0);
              }
              _correctButton(a, u) {
                return 0 === u && !a.ctrlKey;
              }
              _move(a, u) {
                return { around: u, panDelta: u.sub(a) };
              }
            }
            class Nl extends Ui {
              _correctButton(a, u) {
                return (0 === u && a.ctrlKey) || 2 === u;
              }
              _move(a, u) {
                const g = 0.8 * (u.x - a.x);
                if (g) return (this._active = !0), { bearingDelta: g };
              }
              contextmenu(a) {
                a.preventDefault();
              }
            }
            class Zh extends Ui {
              _correctButton(a, u) {
                return (0 === u && a.ctrlKey) || 2 === u;
              }
              _move(a, u) {
                const g = -0.5 * (u.y - a.y);
                if (g) return (this._active = !0), { pitchDelta: g };
              }
              contextmenu(a) {
                a.preventDefault();
              }
            }
            class Do {
              constructor(a, u) {
                (this._map = a),
                  (this._el = a.getCanvasContainer()),
                  (this._minTouches = 1),
                  (this._clickTolerance = u.clickTolerance || 1),
                  this.reset(),
                  d.bindAll(
                    ["_addTouchPanBlocker", "_showTouchPanBlockerAlert"],
                    this
                  );
              }
              reset() {
                (this._active = !1),
                  (this._touches = {}),
                  (this._sum = new d.Point(0, 0));
              }
              touchstart(a, u, g) {
                return this._calculateTransform(a, u, g);
              }
              touchmove(a, u, g) {
                if (this._active && !(g.length < this._minTouches)) {
                  if (this._map._cooperativeGestures && !this._map.isMoving()) {
                    if (1 === g.length && !d.isFullscreen())
                      return void this._showTouchPanBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility &&
                      ((this._alertContainer.style.visibility = "hidden"),
                      clearTimeout(this._alertTimer));
                  }
                  return (
                    a.cancelable && a.preventDefault(),
                    this._calculateTransform(a, u, g)
                  );
                }
              }
              touchend(a, u, g) {
                this._calculateTransform(a, u, g),
                  this._active && g.length < this._minTouches && this.reset();
              }
              touchcancel() {
                this.reset();
              }
              _calculateTransform(a, u, g) {
                g.length > 0 && (this._active = !0);
                const v = ja(g, u),
                  b = new d.Point(0, 0),
                  D = new d.Point(0, 0);
                let S = 0;
                for (const R in v) {
                  const k = v[R],
                    z = this._touches[R];
                  z && (b._add(k), D._add(k.sub(z)), S++, (v[R] = k));
                }
                if (((this._touches = v), S < this._minTouches || !D.mag()))
                  return;
                const M = D.div(S);
                return (
                  this._sum._add(M),
                  this._sum.mag() < this._clickTolerance
                    ? void 0
                    : { around: b.div(S), panDelta: M }
                );
              }
              enable() {
                (this._enabled = !0),
                  this._map._cooperativeGestures &&
                    (this._addTouchPanBlocker(),
                    this._el.classList.add(
                      "mapboxgl-touch-pan-blocker-override",
                      "mapboxgl-scrollable-page"
                    ));
              }
              disable() {
                (this._enabled = !1),
                  this._map._cooperativeGestures &&
                    (clearTimeout(this._alertTimer),
                    this._alertContainer.remove(),
                    this._el.classList.remove(
                      "mapboxgl-touch-pan-blocker-override",
                      "mapboxgl-scrollable-page"
                    )),
                  this.reset();
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active;
              }
              _addTouchPanBlocker() {
                this._map &&
                  !this._alertContainer &&
                  ((this._alertContainer = zt(
                    "div",
                    "mapboxgl-touch-pan-blocker",
                    this._map._container
                  )),
                  (this._alertContainer.textContent = this._map._getUIString(
                    "TouchPanBlocker.Message"
                  )),
                  (this._alertContainer.style.fontSize = `${Math.max(
                    10,
                    Math.min(24, Math.floor(0.05 * this._el.clientWidth))
                  )}px`));
              }
              _showTouchPanBlockerAlert() {
                (this._alertContainer.style.visibility = "visible"),
                  this._alertContainer.classList.add(
                    "mapboxgl-touch-pan-blocker-show"
                  ),
                  this._alertContainer.setAttribute("role", "alert"),
                  clearTimeout(this._alertTimer),
                  (this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove(
                      "mapboxgl-touch-pan-blocker-show"
                    ),
                      this._alertContainer.setAttribute("role", "null");
                  }, 500));
              }
            }
            class zl {
              constructor() {
                this.reset();
              }
              reset() {
                (this._active = !1), (this._firstTwoTouches = void 0);
              }
              _start(a) {}
              _move(a, u, g) {
                return {};
              }
              touchstart(a, u, g) {
                this._firstTwoTouches ||
                  g.length < 2 ||
                  ((this._firstTwoTouches = [g[0].identifier, g[1].identifier]),
                  this._start([u[0], u[1]]));
              }
              touchmove(a, u, g) {
                const v = this._firstTwoTouches;
                if (!v) return;
                a.preventDefault();
                const [b, D] = v,
                  S = $a(g, u, b),
                  M = $a(g, u, D);
                if (!S || !M) return;
                const R = this._aroundCenter ? null : S.add(M).div(2);
                return this._move([S, M], R, a);
              }
              touchend(a, u, g) {
                if (!this._firstTwoTouches) return;
                const [v, b] = this._firstTwoTouches,
                  D = $a(g, u, v),
                  S = $a(g, u, b);
                (D && S) || (this._active && to(), this.reset());
              }
              touchcancel() {
                this.reset();
              }
              enable(a) {
                (this._enabled = !0),
                  (this._aroundCenter = !!a && "center" === a.around);
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            function $a(f, a, u) {
              for (let g = 0; g < f.length; g++)
                if (f[g].identifier === u) return a[g];
            }
            function Bt(f, a) {
              return Math.log(f / a) / Math.LN2;
            }
            class Xh extends zl {
              reset() {
                super.reset(), (this._distance = 0), (this._startDistance = 0);
              }
              _start(a) {
                this._startDistance = this._distance = a[0].dist(a[1]);
              }
              _move(a, u) {
                const g = this._distance;
                if (
                  ((this._distance = a[0].dist(a[1])),
                  this._active ||
                    !(Math.abs(Bt(this._distance, this._startDistance)) < 0.1))
                )
                  return (
                    (this._active = !0),
                    { zoomDelta: Bt(this._distance, g), pinchAround: u }
                  );
              }
            }
            function gp(f, a) {
              return (180 * f.angleWith(a)) / Math.PI;
            }
            class _p extends zl {
              reset() {
                super.reset(),
                  (this._minDiameter = 0),
                  (this._startVector = void 0),
                  (this._vector = void 0);
              }
              _start(a) {
                (this._startVector = this._vector = a[0].sub(a[1])),
                  (this._minDiameter = a[0].dist(a[1]));
              }
              _move(a, u) {
                const g = this._vector;
                if (
                  ((this._vector = a[0].sub(a[1])),
                  g && (this._active || !this._isBelowThreshold(this._vector)))
                )
                  return (
                    (this._active = !0),
                    { bearingDelta: gp(this._vector, g), pinchAround: u }
                  );
              }
              _isBelowThreshold(a) {
                this._minDiameter = Math.min(this._minDiameter, a.mag());
                const u = (25 / (Math.PI * this._minDiameter)) * 360,
                  g = this._startVector;
                if (!g) return !1;
                const v = gp(a, g);
                return Math.abs(v) < u;
              }
            }
            function Qs(f) {
              return Math.abs(f.y) > Math.abs(f.x);
            }
            class yp extends zl {
              constructor(a) {
                super(), (this._map = a);
              }
              reset() {
                super.reset(),
                  (this._valid = void 0),
                  (this._firstMove = void 0),
                  (this._lastPoints = void 0);
              }
              _start(a) {
                (this._lastPoints = a),
                  Qs(a[0].sub(a[1])) && (this._valid = !1);
              }
              _move(a, u, g) {
                const v = this._lastPoints;
                if (!v) return;
                const b = a[0].sub(v[0]),
                  D = a[1].sub(v[1]);
                return (this._map._cooperativeGestures &&
                  !d.isFullscreen() &&
                  g.touches.length < 3) ||
                  ((this._valid = this.gestureBeginsVertically(
                    b,
                    D,
                    g.timeStamp
                  )),
                  !this._valid)
                  ? void 0
                  : ((this._lastPoints = a),
                    (this._active = !0),
                    { pitchDelta: ((b.y + D.y) / 2) * -0.5 });
              }
              gestureBeginsVertically(a, u, g) {
                if (void 0 !== this._valid) return this._valid;
                const v = a.mag() >= 2,
                  b = u.mag() >= 2;
                if (!v && !b) return;
                if (!v || !b)
                  return (
                    null == this._firstMove && (this._firstMove = g),
                    g - this._firstMove < 100 && void 0
                  );
                const D = a.y > 0 == u.y > 0;
                return Qs(a) && Qs(u) && D;
              }
            }
            const Kh = { panStep: 100, bearingStep: 15, pitchStep: 10 };
            class Uf {
              constructor() {
                const a = Kh;
                (this._panStep = a.panStep),
                  (this._bearingStep = a.bearingStep),
                  (this._pitchStep = a.pitchStep),
                  (this._rotationDisabled = !1);
              }
              blur() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              keydown(a) {
                if (a.altKey || a.ctrlKey || a.metaKey) return;
                let u = 0,
                  g = 0,
                  v = 0,
                  b = 0,
                  D = 0;
                switch (a.keyCode) {
                  case 61:
                  case 107:
                  case 171:
                  case 187:
                    u = 1;
                    break;
                  case 189:
                  case 109:
                  case 173:
                    u = -1;
                    break;
                  case 37:
                    a.shiftKey ? (g = -1) : (a.preventDefault(), (b = -1));
                    break;
                  case 39:
                    a.shiftKey ? (g = 1) : (a.preventDefault(), (b = 1));
                    break;
                  case 38:
                    a.shiftKey ? (v = 1) : (a.preventDefault(), (D = -1));
                    break;
                  case 40:
                    a.shiftKey ? (v = -1) : (a.preventDefault(), (D = 1));
                    break;
                  default:
                    return;
                }
                return (
                  this._rotationDisabled && ((g = 0), (v = 0)),
                  {
                    cameraAnimation: (S) => {
                      const M = S.getZoom();
                      S.easeTo(
                        {
                          duration: 300,
                          easeId: "keyboardHandler",
                          easing: vp,
                          zoom: u
                            ? Math.round(M) + u * (a.shiftKey ? 2 : 1)
                            : M,
                          bearing: S.getBearing() + g * this._bearingStep,
                          pitch: S.getPitch() + v * this._pitchStep,
                          offset: [-b * this._panStep, -D * this._panStep],
                          center: S.getCenter(),
                        },
                        { originalEvent: a }
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
              disableRotation() {
                this._rotationDisabled = !0;
              }
              enableRotation() {
                this._rotationDisabled = !1;
              }
            }
            function vp(f) {
              return f * (2 - f);
            }
            const Ze = 4.000244140625;
            class mn {
              constructor(a, u) {
                (this._map = a),
                  (this._el = a.getCanvasContainer()),
                  (this._handler = u),
                  (this._delta = 0),
                  (this._defaultZoomRate = 0.01),
                  (this._wheelZoomRate = 0.0022222222222222222),
                  d.bindAll(
                    [
                      "_onTimeout",
                      "_addScrollZoomBlocker",
                      "_showBlockerAlert",
                    ],
                    this
                  );
              }
              setZoomRate(a) {
                this._defaultZoomRate = a;
              }
              setWheelZoomRate(a) {
                this._wheelZoomRate = a;
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return this._active || void 0 !== this._finishTimeout;
              }
              isZooming() {
                return !!this._zooming;
              }
              enable(a) {
                this.isEnabled() ||
                  ((this._enabled = !0),
                  (this._aroundCenter = !!a && "center" === a.around),
                  this._map._cooperativeGestures &&
                    this._addScrollZoomBlocker());
              }
              disable() {
                this.isEnabled() &&
                  ((this._enabled = !1),
                  this._map._cooperativeGestures &&
                    (clearTimeout(this._alertTimer),
                    this._alertContainer.remove()));
              }
              wheel(a) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                  if (
                    !(
                      a.ctrlKey ||
                      a.metaKey ||
                      this.isZooming() ||
                      d.isFullscreen()
                    )
                  )
                    return void this._showBlockerAlert();
                  "hidden" !== this._alertContainer.style.visibility &&
                    ((this._alertContainer.style.visibility = "hidden"),
                    clearTimeout(this._alertTimer));
                }
                let u =
                  a.deltaMode === d.window.WheelEvent.DOM_DELTA_LINE
                    ? 40 * a.deltaY
                    : a.deltaY;
                const g = d.exported.now(),
                  v = g - (this._lastWheelEventTime || 0);
                (this._lastWheelEventTime = g),
                  0 !== u && u % Ze == 0
                    ? (this._type = "wheel")
                    : 0 !== u && Math.abs(u) < 4
                    ? (this._type = "trackpad")
                    : v > 400
                    ? ((this._type = null),
                      (this._lastValue = u),
                      (this._timeout = setTimeout(this._onTimeout, 40, a)))
                    : this._type ||
                      ((this._type =
                        Math.abs(v * u) < 200 ? "trackpad" : "wheel"),
                      this._timeout &&
                        (clearTimeout(this._timeout),
                        (this._timeout = null),
                        (u += this._lastValue))),
                  a.shiftKey && u && (u /= 4),
                  this._type &&
                    ((this._lastWheelEvent = a),
                    (this._delta -= u),
                    this._active || this._start(a)),
                  a.preventDefault();
              }
              _onTimeout(a) {
                (this._type = "wheel"),
                  (this._delta -= this._lastValue),
                  this._active || this._start(a);
              }
              _start(a) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null),
                  (this._active = !0),
                  this.isZooming() || (this._zooming = !0),
                  this._finishTimeout &&
                    (clearTimeout(this._finishTimeout),
                    delete this._finishTimeout);
                const u = Mr(this._el, a);
                (this._aroundPoint = this._aroundCenter
                  ? this._map.transform.centerPoint
                  : u),
                  (this._aroundCoord = this._map.transform.pointCoordinate3D(
                    this._aroundPoint
                  )),
                  (this._targetZoom = void 0),
                  this._frameId ||
                    ((this._frameId = !0), this._handler._triggerRenderFrame());
              }
              renderFrame() {
                if (
                  !this._frameId ||
                  ((this._frameId = null), !this.isActive())
                )
                  return;
                const a = this._map.transform;
                "wheel" === this._type &&
                  a.projection.wrap &&
                  (a._center.lng >= 180 || a._center.lng <= -180) &&
                  ((this._prevEase = null),
                  (this._easing = null),
                  (this._lastWheelEvent = null),
                  (this._lastWheelEventTime = 0));
                const u = () =>
                  a._terrainEnabled() && this._aroundCoord
                    ? a.computeZoomRelativeTo(this._aroundCoord)
                    : a.zoom;
                if (0 !== this._delta) {
                  const M =
                    "wheel" === this._type && Math.abs(this._delta) > Ze
                      ? this._wheelZoomRate
                      : this._defaultZoomRate;
                  let R = 2 / (1 + Math.exp(-Math.abs(this._delta * M)));
                  this._delta < 0 && 0 !== R && (R = 1 / R);
                  const k = u(),
                    z = Math.pow(2, k),
                    H =
                      "number" == typeof this._targetZoom
                        ? a.zoomScale(this._targetZoom)
                        : z;
                  (this._targetZoom = Math.min(
                    a.maxZoom,
                    Math.max(a.minZoom, a.scaleZoom(H * R))
                  )),
                    "wheel" === this._type &&
                      ((this._startZoom = k),
                      (this._easing = this._smoothOutEasing(200))),
                    (this._delta = 0);
                }
                const g =
                    "number" == typeof this._targetZoom
                      ? this._targetZoom
                      : u(),
                  v = this._startZoom,
                  b = this._easing;
                let D,
                  S = !1;
                if ("wheel" === this._type && v && b) {
                  const M = Math.min(
                      (d.exported.now() - this._lastWheelEventTime) / 200,
                      1
                    ),
                    R = b(M);
                  (D = d.number(v, g, R)),
                    M < 1 ? this._frameId || (this._frameId = !0) : (S = !0);
                } else (D = g), (S = !0);
                return (
                  (this._active = !0),
                  S &&
                    ((this._active = !1),
                    (this._finishTimeout = setTimeout(() => {
                      (this._zooming = !1),
                        this._handler._triggerRenderFrame(),
                        delete this._targetZoom,
                        delete this._finishTimeout;
                    }, 200))),
                  {
                    noInertia: !0,
                    needsRenderFrame: !S,
                    zoomDelta: D - u(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent,
                  }
                );
              }
              _smoothOutEasing(a) {
                let u = d.ease;
                if (this._prevEase) {
                  const g = this._prevEase,
                    v = (d.exported.now() - g.start) / g.duration,
                    b = g.easing(v + 0.01) - g.easing(v),
                    D = (0.27 / Math.sqrt(b * b + 1e-4)) * 0.01,
                    S = Math.sqrt(0.0729 - D * D);
                  u = d.bezier(D, S, 0.25, 1);
                }
                return (
                  (this._prevEase = {
                    start: d.exported.now(),
                    duration: a,
                    easing: u,
                  }),
                  u
                );
              }
              blur() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              _addScrollZoomBlocker() {
                this._map &&
                  !this._alertContainer &&
                  ((this._alertContainer = zt(
                    "div",
                    "mapboxgl-scroll-zoom-blocker",
                    this._map._container
                  )),
                  (this._alertContainer.textContent = /(Mac|iPad)/i.test(
                    d.window.navigator.userAgent
                  )
                    ? this._map._getUIString("ScrollZoomBlocker.CmdMessage")
                    : this._map._getUIString("ScrollZoomBlocker.CtrlMessage")),
                  (this._alertContainer.style.fontSize = `${Math.max(
                    10,
                    Math.min(24, Math.floor(0.05 * this._el.clientWidth))
                  )}px`));
              }
              _showBlockerAlert() {
                (this._alertContainer.style.visibility = "visible"),
                  this._alertContainer.classList.add(
                    "mapboxgl-scroll-zoom-blocker-show"
                  ),
                  this._alertContainer.setAttribute("role", "alert"),
                  clearTimeout(this._alertTimer),
                  (this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove(
                      "mapboxgl-scroll-zoom-blocker-show"
                    ),
                      this._alertContainer.setAttribute("role", "null");
                  }, 200));
              }
            }
            class Ha {
              constructor(a, u) {
                (this._clickZoom = a), (this._tapZoom = u);
              }
              enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
              }
              disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
              }
              isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
              }
              isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
              }
            }
            class yi {
              constructor() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              blur() {
                this.reset();
              }
              dblclick(a, u) {
                return (
                  a.preventDefault(),
                  {
                    cameraAnimation: (g) => {
                      g.easeTo(
                        {
                          duration: 300,
                          zoom: g.getZoom() + (a.shiftKey ? -1 : 1),
                          around: g.unproject(u),
                        },
                        { originalEvent: a }
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class ki {
              constructor() {
                (this._tap = new Gh({ numTouches: 1, numTaps: 1 })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  (this._swipePoint = void 0),
                  (this._swipeTouch = 0),
                  (this._tapTime = 0),
                  this._tap.reset();
              }
              touchstart(a, u, g) {
                this._swipePoint ||
                  (this._tapTime &&
                    a.timeStamp - this._tapTime > 500 &&
                    this.reset(),
                  this._tapTime
                    ? g.length > 0 &&
                      ((this._swipePoint = u[0]),
                      (this._swipeTouch = g[0].identifier))
                    : this._tap.touchstart(a, u, g));
              }
              touchmove(a, u, g) {
                if (this._tapTime) {
                  if (this._swipePoint) {
                    if (g[0].identifier !== this._swipeTouch) return;
                    const v = u[0],
                      b = v.y - this._swipePoint.y;
                    return (
                      (this._swipePoint = v),
                      a.preventDefault(),
                      (this._active = !0),
                      { zoomDelta: b / 128 }
                    );
                  }
                } else this._tap.touchmove(a, u, g);
              }
              touchend(a, u, g) {
                this._tapTime
                  ? this._swipePoint && 0 === g.length && this.reset()
                  : this._tap.touchend(a, u, g) &&
                    (this._tapTime = a.timeStamp);
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class Yh {
              constructor(a, u, g) {
                (this._el = a), (this._mousePan = u), (this._touchPan = g);
              }
              enable(a) {
                (this._inertiaOptions = a || {}),
                  this._mousePan.enable(),
                  this._touchPan.enable(),
                  this._el.classList.add("mapboxgl-touch-drag-pan");
              }
              disable() {
                this._mousePan.disable(),
                  this._touchPan.disable(),
                  this._el.classList.remove("mapboxgl-touch-drag-pan");
              }
              isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
              }
              isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
              }
            }
            class Sc {
              constructor(a, u, g) {
                (this._pitchWithRotate = a.pitchWithRotate),
                  (this._mouseRotate = u),
                  (this._mousePitch = g);
              }
              enable() {
                this._mouseRotate.enable(),
                  this._pitchWithRotate && this._mousePitch.enable();
              }
              disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
              }
              isEnabled() {
                return (
                  this._mouseRotate.isEnabled() &&
                  (!this._pitchWithRotate || this._mousePitch.isEnabled())
                );
              }
              isActive() {
                return (
                  this._mouseRotate.isActive() || this._mousePitch.isActive()
                );
              }
            }
            class Xo {
              constructor(a, u, g, v) {
                (this._el = a),
                  (this._touchZoom = u),
                  (this._touchRotate = g),
                  (this._tapDragZoom = v),
                  (this._rotationDisabled = !1),
                  (this._enabled = !0);
              }
              enable(a) {
                this._touchZoom.enable(a),
                  this._rotationDisabled || this._touchRotate.enable(a),
                  this._tapDragZoom.enable(),
                  this._el.classList.add("mapboxgl-touch-zoom-rotate");
              }
              disable() {
                this._touchZoom.disable(),
                  this._touchRotate.disable(),
                  this._tapDragZoom.disable(),
                  this._el.classList.remove("mapboxgl-touch-zoom-rotate");
              }
              isEnabled() {
                return (
                  this._touchZoom.isEnabled() &&
                  (this._rotationDisabled || this._touchRotate.isEnabled()) &&
                  this._tapDragZoom.isEnabled()
                );
              }
              isActive() {
                return (
                  this._touchZoom.isActive() ||
                  this._touchRotate.isActive() ||
                  this._tapDragZoom.isActive()
                );
              }
              disableRotation() {
                (this._rotationDisabled = !0), this._touchRotate.disable();
              }
              enableRotation() {
                (this._rotationDisabled = !1),
                  this._touchZoom.isEnabled() && this._touchRotate.enable();
              }
            }
            const Or = (f) => f.zoom || f.drag || f.pitch || f.rotate;
            class Lu extends d.Event {}
            class Ng {
              constructor() {
                (this.constants = [1, 1, 0.01]), (this.radius = 0);
              }
              setup(a, u) {
                const g = d.sub([], u, a);
                this.radius = d.length(
                  g[2] < 0 ? d.div([], g, this.constants) : [g[0], g[1], 0]
                );
              }
              projectRay(a) {
                d.div(a, a, this.constants),
                  d.normalize(a, a),
                  d.mul$1(a, a, this.constants);
                const u = d.scale$2([], a, this.radius);
                if (u[2] > 0) {
                  const g = d.scale$2([], [0, 0, 1], d.dot(u, [0, 0, 1])),
                    v = d.scale$2(
                      [],
                      d.normalize([], [u[0], u[1], 0]),
                      this.radius
                    ),
                    b = d.add(
                      [],
                      u,
                      d.scale$2([], d.sub([], d.add([], v, g), u), 2)
                    );
                  (u[0] = b[0]), (u[1] = b[1]);
                }
                return u;
              }
            }
            function Co(f) {
              return (
                (f.panDelta && f.panDelta.mag()) ||
                f.zoomDelta ||
                f.bearingDelta ||
                f.pitchDelta
              );
            }
            class ms {
              constructor(a, u) {
                (this._map = a),
                  (this._el = this._map.getCanvasContainer()),
                  (this._handlers = []),
                  (this._handlersById = {}),
                  (this._changes = []),
                  (this._inertia = new Xr(a)),
                  (this._bearingSnap = u.bearingSnap),
                  (this._previousActiveHandlers = {}),
                  (this._trackingEllipsoid = new Ng()),
                  (this._dragOrigin = null),
                  (this._eventsInProgress = {}),
                  this._addDefaultHandlers(u),
                  d.bindAll(["handleEvent", "handleWindowEvent"], this);
                const g = this._el;
                this._listeners = [
                  [g, "touchstart", { passive: !0 }],
                  [g, "touchmove", { passive: !1 }],
                  [g, "touchend", void 0],
                  [g, "touchcancel", void 0],
                  [g, "mousedown", void 0],
                  [g, "mousemove", void 0],
                  [g, "mouseup", void 0],
                  [d.window.document, "mousemove", { capture: !0 }],
                  [d.window.document, "mouseup", void 0],
                  [g, "mouseover", void 0],
                  [g, "mouseout", void 0],
                  [g, "dblclick", void 0],
                  [g, "click", void 0],
                  [g, "keydown", { capture: !1 }],
                  [g, "keyup", void 0],
                  [g, "wheel", { passive: !1 }],
                  [g, "contextmenu", void 0],
                  [d.window, "blur", void 0],
                ];
                for (const [v, b, D] of this._listeners)
                  v.addEventListener(
                    b,
                    v === d.window.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    D
                  );
              }
              destroy() {
                for (const [a, u, g] of this._listeners)
                  a.removeEventListener(
                    u,
                    a === d.window.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    g
                  );
              }
              _addDefaultHandlers(a) {
                const u = this._map,
                  g = u.getCanvasContainer();
                this._add("mapEvent", new oi(u, a));
                const v = (u.boxZoom = new jf(u, a));
                this._add("boxZoom", v);
                const b = new qh(),
                  D = new yi();
                (u.doubleClickZoom = new Ha(D, b)),
                  this._add("tapZoom", b),
                  this._add("clickZoom", D);
                const S = new ki();
                this._add("tapDragZoom", S);
                const M = (u.touchPitch = new yp(u));
                this._add("touchPitch", M);
                const R = new Nl(a),
                  k = new Zh(a);
                (u.dragRotate = new Sc(a, R, k)),
                  this._add("mouseRotate", R, ["mousePitch"]),
                  this._add("mousePitch", k, ["mouseRotate"]);
                const z = new Wh(a),
                  H = new Do(u, a);
                (u.dragPan = new Yh(g, z, H)),
                  this._add("mousePan", z),
                  this._add("touchPan", H, ["touchZoom", "touchRotate"]);
                const q = new _p(),
                  X = new Xh();
                (u.touchZoomRotate = new Xo(g, X, q, S)),
                  this._add("touchRotate", q, ["touchPan", "touchZoom"]),
                  this._add("touchZoom", X, ["touchPan", "touchRotate"]),
                  this._add("blockableMapEvent", new Pu(u));
                const Z = (u.scrollZoom = new mn(u, this));
                this._add("scrollZoom", Z, ["mousePan"]);
                const Y = (u.keyboard = new Uf());
                this._add("keyboard", Y);
                for (const B of [
                  "boxZoom",
                  "doubleClickZoom",
                  "tapDragZoom",
                  "touchPitch",
                  "dragRotate",
                  "dragPan",
                  "touchZoomRotate",
                  "scrollZoom",
                  "keyboard",
                ])
                  a.interactive && a[B] && u[B].enable(a[B]);
              }
              _add(a, u, g) {
                this._handlers.push({ handlerName: a, handler: u, allowed: g }),
                  (this._handlersById[a] = u);
              }
              stop(a) {
                if (!this._updatingCamera) {
                  for (const { handler: u } of this._handlers) u.reset();
                  this._inertia.clear(),
                    this._fireEvents({}, {}, a),
                    (this._changes = []);
                }
              }
              isActive() {
                for (const { handler: a } of this._handlers)
                  if (a.isActive()) return !0;
                return !1;
              }
              isZooming() {
                return (
                  !!this._eventsInProgress.zoom ||
                  this._map.scrollZoom.isZooming()
                );
              }
              isRotating() {
                return !!this._eventsInProgress.rotate;
              }
              isMoving() {
                return !!Or(this._eventsInProgress) || this.isZooming();
              }
              _isDragging() {
                return !!this._eventsInProgress.drag;
              }
              _blockedByActive(a, u, g) {
                for (const v in a)
                  if (v !== g && (!u || u.indexOf(v) < 0)) return !0;
                return !1;
              }
              handleWindowEvent(a) {
                this.handleEvent(a, `${a.type}Window`);
              }
              _getMapTouches(a) {
                const u = [];
                for (const g of a) this._el.contains(g.target) && u.push(g);
                return u;
              }
              handleEvent(a, u) {
                this._updatingCamera = !0;
                const g = "renderFrame" === a.type,
                  v = g ? void 0 : a,
                  b = { needsRenderFrame: !1 },
                  D = {},
                  S = {},
                  M = a.touches ? this._getMapTouches(a.touches) : void 0,
                  R = M ? Ca(this._el, M) : g ? void 0 : Mr(this._el, a);
                for (const { handlerName: H, handler: q, allowed: X } of this
                  ._handlers) {
                  if (!q.isEnabled()) continue;
                  let Z;
                  this._blockedByActive(S, X, H)
                    ? q.reset()
                    : q[u || a.type] &&
                      ((Z = q[u || a.type](a, R, M)),
                      this.mergeHandlerResult(b, D, Z, H, v),
                      Z && Z.needsRenderFrame && this._triggerRenderFrame()),
                    (Z || q.isActive()) && (S[H] = q);
                }
                const k = {};
                for (const H in this._previousActiveHandlers)
                  S[H] || (k[H] = v);
                (this._previousActiveHandlers = S),
                  (Object.keys(k).length || Co(b)) &&
                    (this._changes.push([b, D, k]), this._triggerRenderFrame()),
                  (Object.keys(S).length || Co(b)) && this._map._stop(!0),
                  (this._updatingCamera = !1);
                const { cameraAnimation: z } = b;
                z &&
                  (this._inertia.clear(),
                  this._fireEvents({}, {}, !0),
                  (this._changes = []),
                  z(this._map));
              }
              mergeHandlerResult(a, u, g, v, b) {
                if (!g) return;
                d.extend(a, g);
                const D = {
                  handlerName: v,
                  originalEvent: g.originalEvent || b,
                };
                void 0 !== g.zoomDelta && (u.zoom = D),
                  void 0 !== g.panDelta && (u.drag = D),
                  void 0 !== g.pitchDelta && (u.pitch = D),
                  void 0 !== g.bearingDelta && (u.rotate = D);
              }
              _applyChanges() {
                const a = {},
                  u = {},
                  g = {};
                for (const [v, b, D] of this._changes)
                  v.panDelta &&
                    (a.panDelta = (a.panDelta || new d.Point(0, 0))._add(
                      v.panDelta
                    )),
                    v.zoomDelta &&
                      (a.zoomDelta = (a.zoomDelta || 0) + v.zoomDelta),
                    v.bearingDelta &&
                      (a.bearingDelta = (a.bearingDelta || 0) + v.bearingDelta),
                    v.pitchDelta &&
                      (a.pitchDelta = (a.pitchDelta || 0) + v.pitchDelta),
                    void 0 !== v.around && (a.around = v.around),
                    void 0 !== v.aroundCoord && (a.aroundCoord = v.aroundCoord),
                    void 0 !== v.pinchAround && (a.pinchAround = v.pinchAround),
                    v.noInertia && (a.noInertia = v.noInertia),
                    d.extend(u, b),
                    d.extend(g, D);
                this._updateMapTransform(a, u, g), (this._changes = []);
              }
              _updateMapTransform(a, u, g) {
                const v = this._map,
                  b = v.transform,
                  D = (W) => [W.x, W.y, W.z];
                if (
                  ((W) => {
                    const ee = this._eventsInProgress.drag;
                    return ee && !this._handlersById[ee.handlerName].isActive();
                  })() &&
                  !Co(a)
                ) {
                  const W = b.zoom;
                  (b.cameraElevationReference = "sea"),
                    b.recenterOnTerrain(),
                    (b.cameraElevationReference = "ground"),
                    W !== b.zoom && this._map._update(!0);
                }
                if ((b._isCameraConstrained && v._stop(!0), !Co(a)))
                  return void this._fireEvents(u, g, !0);
                let {
                  panDelta: S,
                  zoomDelta: M,
                  bearingDelta: R,
                  pitchDelta: k,
                  around: z,
                  aroundCoord: H,
                  pinchAround: q,
                } = a;
                b._isCameraConstrained &&
                  (M > 0 && (M = 0), (b._isCameraConstrained = !1)),
                  void 0 !== q && (z = q),
                  (M || ((W) => u[W] && !this._eventsInProgress[W])("drag")) &&
                    z &&
                    ((this._dragOrigin = D(b.pointCoordinate3D(z))),
                    this._trackingEllipsoid.setup(
                      b._camera.position,
                      this._dragOrigin
                    )),
                  (b.cameraElevationReference = "sea"),
                  v._stop(!0),
                  (z = z || v.transform.centerPoint),
                  R && (b.bearing += R),
                  k && (b.pitch += k),
                  b._updateCameraState();
                const X = [0, 0, 0];
                if (S)
                  if ("mercator" === b.projection.name) {
                    const W = this._trackingEllipsoid.projectRay(
                        b.screenPointToMercatorRay(z).dir
                      ),
                      ee = this._trackingEllipsoid.projectRay(
                        b.screenPointToMercatorRay(z.sub(S)).dir
                      );
                    (X[0] = ee[0] - W[0]), (X[1] = ee[1] - W[1]);
                  } else {
                    const W = b.pointCoordinate(z);
                    if ("globe" === b.projection.name) {
                      S = S.rotate(-b.angle);
                      const ee = b._pixelsPerMercatorPixel / b.worldSize;
                      (X[0] =
                        -S.x * d.mercatorScale(d.latFromMercatorY(W.y)) * ee),
                        (X[1] = -S.y * d.mercatorScale(b.center.lat) * ee);
                    } else {
                      const ee = b.pointCoordinate(z.sub(S));
                      W && ee && ((X[0] = ee.x - W.x), (X[1] = ee.y - W.y));
                    }
                  }
                const Z = b.zoom,
                  Y = [0, 0, 0];
                if (M) {
                  const W = D(H || b.pointCoordinate3D(z)),
                    ee = {
                      dir: d.normalize([], d.sub([], W, b._camera.position)),
                    };
                  if (ee.dir[2] < 0) {
                    const te = b.zoomDeltaToMovement(W, M);
                    d.scale$2(Y, ee.dir, te);
                  }
                }
                const B = d.add(X, X, Y);
                b._translateCameraConstrained(B),
                  M && Math.abs(b.zoom - Z) > 1e-4 && b.recenterOnTerrain(),
                  (b.cameraElevationReference = "ground"),
                  this._map._update(),
                  a.noInertia || this._inertia.record(a),
                  this._fireEvents(u, g, !0);
              }
              _fireEvents(a, u, g) {
                const v = Or(this._eventsInProgress),
                  b = Or(a),
                  D = {};
                for (const k in a) {
                  const { originalEvent: z } = a[k];
                  this._eventsInProgress[k] || (D[`${k}start`] = z),
                    (this._eventsInProgress[k] = a[k]);
                }
                !v && b && this._fireEvent("movestart", b.originalEvent);
                for (const k in D) this._fireEvent(k, D[k]);
                b && this._fireEvent("move", b.originalEvent);
                for (const k in a) {
                  const { originalEvent: z } = a[k];
                  this._fireEvent(k, z);
                }
                const S = {};
                let M;
                for (const k in this._eventsInProgress) {
                  const { handlerName: z, originalEvent: H } =
                    this._eventsInProgress[k];
                  this._handlersById[z].isActive() ||
                    (delete this._eventsInProgress[k],
                    (M = u[z] || H),
                    (S[`${k}end`] = M));
                }
                for (const k in S) this._fireEvent(k, S[k]);
                const R = Or(this._eventsInProgress);
                if (g && (v || b) && !R) {
                  this._updatingCamera = !0;
                  const k = this._inertia._onMoveEnd(
                      this._map.dragPan._inertiaOptions
                    ),
                    z = (H) =>
                      0 !== H &&
                      -this._bearingSnap < H &&
                      H < this._bearingSnap;
                  k
                    ? (z(k.bearing || this._map.getBearing()) &&
                        (k.bearing = 0),
                      this._map.easeTo(k, { originalEvent: M }))
                    : (this._map.fire(
                        new d.Event("moveend", { originalEvent: M })
                      ),
                      z(this._map.getBearing()) && this._map.resetNorth()),
                    (this._updatingCamera = !1);
                }
              }
              _fireEvent(a, u) {
                this._map.fire(new d.Event(a, u ? { originalEvent: u } : {}));
              }
              _requestFrame() {
                return (
                  this._map.triggerRepaint(),
                  this._map._renderTaskQueue.add((a) => {
                    (this._frameId = void 0),
                      this.handleEvent(new Lu("renderFrame", { timeStamp: a })),
                      this._applyChanges();
                  })
                );
              }
              _triggerRenderFrame() {
                void 0 === this._frameId &&
                  (this._frameId = this._requestFrame());
              }
            }
            const Js =
              "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
            class $i extends d.Evented {
              constructor(a, u) {
                super(),
                  (this._moving = !1),
                  (this._zooming = !1),
                  (this.transform = a),
                  (this._bearingSnap = u.bearingSnap),
                  (this._respectPrefersReducedMotion =
                    !1 !== u.respectPrefersReducedMotion),
                  d.bindAll(["_renderFrameCallback"], this);
              }
              getCenter() {
                return new d.LngLat(
                  this.transform.center.lng,
                  this.transform.center.lat
                );
              }
              setCenter(a, u) {
                return this.jumpTo({ center: a }, u);
              }
              panBy(a, u, g) {
                return (
                  (a = d.Point.convert(a).mult(-1)),
                  this.panTo(
                    this.transform.center,
                    d.extend({ offset: a }, u),
                    g
                  )
                );
              }
              panTo(a, u, g) {
                return this.easeTo(d.extend({ center: a }, u), g);
              }
              getZoom() {
                return this.transform.zoom;
              }
              setZoom(a, u) {
                return this.jumpTo({ zoom: a }, u), this;
              }
              zoomTo(a, u, g) {
                return this.easeTo(d.extend({ zoom: a }, u), g);
              }
              zoomIn(a, u) {
                return this.zoomTo(this.getZoom() + 1, a, u), this;
              }
              zoomOut(a, u) {
                return this.zoomTo(this.getZoom() - 1, a, u), this;
              }
              getBearing() {
                return this.transform.bearing;
              }
              setBearing(a, u) {
                return this.jumpTo({ bearing: a }, u), this;
              }
              getPadding() {
                return this.transform.padding;
              }
              setPadding(a, u) {
                return this.jumpTo({ padding: a }, u), this;
              }
              rotateTo(a, u, g) {
                return this.easeTo(d.extend({ bearing: a }, u), g);
              }
              resetNorth(a, u) {
                return (
                  this.rotateTo(0, d.extend({ duration: 1e3 }, a), u), this
                );
              }
              resetNorthPitch(a, u) {
                return (
                  this.easeTo(
                    d.extend({ bearing: 0, pitch: 0, duration: 1e3 }, a),
                    u
                  ),
                  this
                );
              }
              snapToNorth(a, u) {
                return Math.abs(this.getBearing()) < this._bearingSnap
                  ? this.resetNorth(a, u)
                  : this;
              }
              getPitch() {
                return this.transform.pitch;
              }
              setPitch(a, u) {
                return this.jumpTo({ pitch: a }, u), this;
              }
              cameraForBounds(a, u) {
                a = d.LngLatBounds.convert(a);
                const g = (u && u.bearing) || 0,
                  v = (u && u.pitch) || 0,
                  b = a.getNorthWest(),
                  D = a.getSouthEast();
                return this._cameraForBounds(this.transform, b, D, g, v, u);
              }
              _extendCameraOptions(a) {
                const u = { top: 0, bottom: 0, right: 0, left: 0 };
                if (
                  "number" ==
                  typeof (a = d.extend(
                    {
                      padding: u,
                      offset: [0, 0],
                      maxZoom: this.transform.maxZoom,
                    },
                    a
                  )).padding
                ) {
                  const g = a.padding;
                  a.padding = { top: g, bottom: g, right: g, left: g };
                }
                return (a.padding = d.extend(u, a.padding)), a;
              }
              _minimumAABBFrustumDistance(a, u) {
                const g = u.max[0] - u.min[0],
                  v = u.max[1] - u.min[1];
                return g / v > a.aspect
                  ? g / (2 * Math.tan(0.5 * a.fovX) * a.aspect)
                  : v / (2 * Math.tan(0.5 * a.fovY) * a.aspect);
              }
              _cameraForBoundsOnGlobe(a, u, g, v, b, D) {
                const S = a.clone(),
                  M = this._extendCameraOptions(D);
                (S.bearing = v), (S.pitch = b);
                const R = d.LngLat.convert(u),
                  k = d.LngLat.convert(g),
                  z = 0.5 * (R.lat + k.lat),
                  H = 0.5 * (R.lng + k.lng),
                  q = d.latLngToECEF(z, H),
                  X = d.normalize([], q),
                  Z = d.normalize([], d.cross([], X, [0, 1, 0])),
                  Y = d.cross([], Z, X),
                  B = [
                    Z[0],
                    Z[1],
                    Z[2],
                    0,
                    Y[0],
                    Y[1],
                    Y[2],
                    0,
                    X[0],
                    X[1],
                    X[2],
                    0,
                    0,
                    0,
                    0,
                    1,
                  ],
                  W = [
                    q,
                    d.latLngToECEF(R.lat, R.lng),
                    d.latLngToECEF(k.lat, R.lng),
                    d.latLngToECEF(k.lat, k.lng),
                    d.latLngToECEF(R.lat, k.lng),
                    d.latLngToECEF(z, R.lng),
                    d.latLngToECEF(z, k.lng),
                    d.latLngToECEF(R.lat, H),
                    d.latLngToECEF(k.lat, H),
                  ];
                let ee = d.Aabb.fromPoints(
                  W.map((Ne) => [d.dot(Z, Ne), d.dot(Y, Ne), d.dot(X, Ne)])
                );
                const te = d.transformMat4([], ee.center, B);
                0 === d.squaredLength(te) && d.set(te, 0, 0, 1),
                  d.normalize(te, te),
                  d.scale$2(te, te, d.GLOBE_RADIUS),
                  (S.center = d.ecefToLatLng(te));
                const he = S.getWorldToCameraMatrix(),
                  de = d.invert(new Float64Array(16), he);
                (ee = d.Aabb.applyTransform(ee, d.multiply([], he, B))),
                  d.transformMat4(te, te, he);
                const ue = 0.5 * (ee.max[2] - ee.min[2]),
                  _e = this._minimumAABBFrustumDistance(S, ee),
                  ge = d.scale$2([], [0, 0, 1], ue),
                  Te = d.add(ge, te, ge),
                  Ge = _e + (0 === S.pitch ? 0 : d.distance(te, Te)),
                  be = S.globeCenterInViewSpace,
                  Le = d.sub([], te, [be[0], be[1], be[2]]);
                d.normalize(Le, Le), d.scale$2(Le, Le, Ge);
                const Se = d.add([], te, Le);
                d.transformMat4(Se, Se, de);
                const je = d.earthRadius / d.GLOBE_RADIUS,
                  we = d.length(Se),
                  ke = d.mercatorZfromAltitude(
                    Math.max(we * je - d.earthRadius, Number.EPSILON),
                    0
                  ),
                  He = Math.min(S.zoomFromMercatorZAdjusted(ke), M.maxZoom);
                return He >
                  0.5 *
                    (d.GLOBE_ZOOM_THRESHOLD_MIN + d.GLOBE_ZOOM_THRESHOLD_MAX)
                  ? (S.setProjection({ name: "mercator" }),
                    (S.zoom = He),
                    this._cameraForBounds(S, u, g, v, b, D))
                  : { center: S.center, zoom: He, bearing: v, pitch: b };
              }
              queryTerrainElevation(a, u) {
                const g = this.transform.elevation;
                return g
                  ? ((u = d.extend({}, { exaggerated: !0 }, u)),
                    g.getAtPoint(
                      d.MercatorCoordinate.fromLngLat(a),
                      null,
                      u.exaggerated
                    ))
                  : null;
              }
              _cameraForBounds(a, u, g, v, b, D) {
                if ("globe" === a.projection.name)
                  return this._cameraForBoundsOnGlobe(a, u, g, v, b, D);
                const S = a.clone(),
                  M = this._extendCameraOptions(D),
                  R = S.padding;
                (S.bearing = v), (S.pitch = b);
                const k = d.LngLat.convert(u),
                  z = d.LngLat.convert(g),
                  H = new d.LngLat(k.lng, z.lat),
                  q = new d.LngLat(z.lng, k.lat),
                  X = S.project(k),
                  Z = S.project(z),
                  Y = this.queryTerrainElevation(k),
                  B = this.queryTerrainElevation(z),
                  W = this.queryTerrainElevation(H),
                  ee = this.queryTerrainElevation(q),
                  te = [
                    [X.x, X.y, Math.min(Y || 0, B || 0, W || 0, ee || 0)],
                    [Z.x, Z.y, Math.max(Y || 0, B || 0, W || 0, ee || 0)],
                  ];
                let he = d.Aabb.fromPoints(te);
                const de = S.getWorldToCameraMatrix(),
                  ue = d.invert(new Float64Array(16), de);
                he = d.Aabb.applyTransform(he, de);
                const _e = d.sub([], he.max, he.min),
                  ge = R.left || 0,
                  Te = R.right || 0,
                  Ge = R.bottom || 0,
                  be = R.top || 0,
                  { left: Le, right: Se, top: je, bottom: we } = M.padding,
                  ke = 0.5 * (ge + Te),
                  He = 0.5 * (be + Ge),
                  Ne = Math.min(
                    S.scaleZoom(
                      S.scale *
                        Math.min(
                          (S.width - (ge + Te + Le + Se)) / _e[0],
                          (S.height - (Ge + be + we + je)) / _e[1]
                        )
                    ),
                    M.maxZoom
                  ),
                  Xe = S.scale / S.zoomScale(Ne);
                he = new d.Aabb(
                  [
                    he.min[0] - (Le + ke) * Xe,
                    he.min[1] - (we + He) * Xe,
                    he.min[2],
                  ],
                  [
                    he.max[0] + (Se + ke) * Xe,
                    he.max[1] + (je + He) * Xe,
                    he.max[2],
                  ]
                );
                const mt = 0.5 * _e[2],
                  It = this._minimumAABBFrustumDistance(S, he),
                  dt = [0, 0, 1, 0];
                d.transformMat4$1(dt, dt, de), d.normalize$2(dt, dt);
                const Dt = d.scale$2([], dt, It + mt),
                  Kt = d.add([], he.center, Dt),
                  Ht = (
                    "number" == typeof M.offset.x &&
                    "number" == typeof M.offset.y
                      ? new d.Point(M.offset.x, M.offset.y)
                      : d.Point.convert(M.offset)
                  ).rotate(-d.degToRad(v));
                (he.center[0] -= Ht.x * Xe),
                  (he.center[1] += Ht.y * Xe),
                  d.transformMat4(he.center, he.center, ue),
                  d.transformMat4(Kt, Kt, ue);
                const _t = [
                  he.center[0],
                  he.center[1],
                  Kt[2] * S.pixelsPerMeter,
                ];
                d.scale$2(_t, _t, 1 / S.worldSize);
                const en = d.lngFromMercatorX(_t[0]),
                  On = d.latFromMercatorY(_t[1]),
                  _n = Math.min(S._zoomFromMercatorZ(_t[2]), M.maxZoom),
                  Sn = new d.LngLat(en, On);
                return S.mercatorFromTransition &&
                  _n <
                    0.5 *
                      (d.GLOBE_ZOOM_THRESHOLD_MIN + d.GLOBE_ZOOM_THRESHOLD_MAX)
                  ? (S.setProjection({ name: "globe" }),
                    (S.zoom = _n),
                    this._cameraForBounds(S, u, g, v, b, D))
                  : { center: Sn, zoom: _n, bearing: v, pitch: b };
              }
              fitBounds(a, u, g) {
                const v = this.cameraForBounds(a, u);
                return this._fitInternal(v, u, g);
              }
              fitScreenCoordinates(a, u, g, v, b) {
                const D = d.Point.convert(a),
                  S = d.Point.convert(u),
                  M = new d.Point(Math.min(D.x, S.x), Math.min(D.y, S.y)),
                  R = new d.Point(Math.max(D.x, S.x), Math.max(D.y, S.y));
                if (
                  "mercator" === this.transform.projection.name &&
                  this.transform.anyCornerOffEdge(D, S)
                )
                  return this;
                const k = this.transform.pointLocation3D(M),
                  z = this.transform.pointLocation3D(R),
                  H = this.transform.pointLocation3D(new d.Point(M.x, R.y)),
                  q = this.transform.pointLocation3D(new d.Point(R.x, M.y)),
                  X = [
                    Math.min(k.lng, z.lng, H.lng, q.lng),
                    Math.min(k.lat, z.lat, H.lat, q.lat),
                  ],
                  Z = [
                    Math.max(k.lng, z.lng, H.lng, q.lng),
                    Math.max(k.lat, z.lat, H.lat, q.lat),
                  ],
                  Y = v && v.pitch ? v.pitch : this.getPitch(),
                  B = this._cameraForBounds(this.transform, X, Z, g, Y, v);
                return this._fitInternal(B, v, b);
              }
              _fitInternal(a, u, g) {
                return a
                  ? (delete (u = d.extend(a, u)).padding,
                    u.linear ? this.easeTo(u, g) : this.flyTo(u, g))
                  : this;
              }
              jumpTo(a, u) {
                this.stop();
                const g = a.preloadOnly
                  ? this.transform.clone()
                  : this.transform;
                let v = !1,
                  b = !1,
                  D = !1;
                return (
                  "zoom" in a &&
                    g.zoom !== +a.zoom &&
                    ((v = !0), (g.zoom = +a.zoom)),
                  void 0 !== a.center &&
                    (g.center = d.LngLat.convert(a.center)),
                  "bearing" in a &&
                    g.bearing !== +a.bearing &&
                    ((b = !0), (g.bearing = +a.bearing)),
                  "pitch" in a &&
                    g.pitch !== +a.pitch &&
                    ((D = !0), (g.pitch = +a.pitch)),
                  null == a.padding ||
                    g.isPaddingEqual(a.padding) ||
                    (g.padding = a.padding),
                  a.preloadOnly
                    ? (this._preloadTiles(g), this)
                    : (this.fire(new d.Event("movestart", u)).fire(
                        new d.Event("move", u)
                      ),
                      v &&
                        this.fire(new d.Event("zoomstart", u))
                          .fire(new d.Event("zoom", u))
                          .fire(new d.Event("zoomend", u)),
                      b &&
                        this.fire(new d.Event("rotatestart", u))
                          .fire(new d.Event("rotate", u))
                          .fire(new d.Event("rotateend", u)),
                      D &&
                        this.fire(new d.Event("pitchstart", u))
                          .fire(new d.Event("pitch", u))
                          .fire(new d.Event("pitchend", u)),
                      this.fire(new d.Event("moveend", u)))
                );
              }
              getFreeCameraOptions() {
                return (
                  this.transform.projection.supportsFreeCamera ||
                    d.warnOnce(Js),
                  this.transform.getFreeCameraOptions()
                );
              }
              setFreeCameraOptions(a, u) {
                const g = this.transform;
                if (!g.projection.supportsFreeCamera)
                  return d.warnOnce(Js), this;
                this.stop();
                const v = g.zoom,
                  b = g.pitch,
                  D = g.bearing;
                g.setFreeCameraOptions(a);
                const S = v !== g.zoom,
                  M = b !== g.pitch,
                  R = D !== g.bearing;
                return (
                  this.fire(new d.Event("movestart", u)).fire(
                    new d.Event("move", u)
                  ),
                  S &&
                    this.fire(new d.Event("zoomstart", u))
                      .fire(new d.Event("zoom", u))
                      .fire(new d.Event("zoomend", u)),
                  R &&
                    this.fire(new d.Event("rotatestart", u))
                      .fire(new d.Event("rotate", u))
                      .fire(new d.Event("rotateend", u)),
                  M &&
                    this.fire(new d.Event("pitchstart", u))
                      .fire(new d.Event("pitch", u))
                      .fire(new d.Event("pitchend", u)),
                  this.fire(new d.Event("moveend", u)),
                  this
                );
              }
              easeTo(a, u) {
                this._stop(!1, a.easeId),
                  (!1 ===
                    (a = d.extend(
                      { offset: [0, 0], duration: 500, easing: d.ease },
                      a
                    )).animate ||
                    this._prefersReducedMotion(a)) &&
                    (a.duration = 0);
                const g = this.transform,
                  v = this.getZoom(),
                  b = this.getBearing(),
                  D = this.getPitch(),
                  S = this.getPadding(),
                  M = "zoom" in a ? +a.zoom : v,
                  R = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b,
                  k = "pitch" in a ? +a.pitch : D,
                  z = "padding" in a ? a.padding : g.padding,
                  H = d.Point.convert(a.offset);
                let q, X, Z;
                if ("globe" === g.projection.name) {
                  const ge = d.MercatorCoordinate.fromLngLat(g.center),
                    Te = H.rotate(-g.angle);
                  (ge.x += Te.x / g.worldSize), (ge.y += Te.y / g.worldSize);
                  const Ge = ge.toLngLat(),
                    be = d.LngLat.convert(a.center || Ge);
                  this._normalizeCenter(be),
                    (q = g.centerPoint.add(Te)),
                    (X = new d.Point(ge.x, ge.y).mult(g.worldSize)),
                    (Z = new d.Point(
                      d.mercatorXfromLng(be.lng),
                      d.mercatorYfromLat(be.lat)
                    )
                      .mult(g.worldSize)
                      .sub(X));
                } else {
                  q = g.centerPoint.add(H);
                  const ge = g.pointLocation(q),
                    Te = d.LngLat.convert(a.center || ge);
                  this._normalizeCenter(Te),
                    (X = g.project(ge)),
                    (Z = g.project(Te).sub(X));
                }
                const Y = g.zoomScale(M - v);
                let B, W;
                a.around &&
                  ((B = d.LngLat.convert(a.around)), (W = g.locationPoint(B)));
                const ee = this._zooming || M !== v,
                  te = this._rotating || b !== R,
                  he = this._pitching || k !== D,
                  de = !g.isPaddingEqual(z),
                  ue = (ge) => (Te) => {
                    if (
                      (ee && (ge.zoom = d.number(v, M, Te)),
                      te && (ge.bearing = d.number(b, R, Te)),
                      he && (ge.pitch = d.number(D, k, Te)),
                      de &&
                        (ge.interpolatePadding(S, z, Te),
                        (q = ge.centerPoint.add(H))),
                      B)
                    )
                      ge.setLocationAtPoint(B, W);
                    else {
                      const Ge = ge.zoomScale(ge.zoom - v),
                        be = M > v ? Math.min(2, Y) : Math.max(0.5, Y),
                        Le = Math.pow(be, 1 - Te),
                        Se = ge.unproject(X.add(Z.mult(Te * Le)).mult(Ge));
                      ge.setLocationAtPoint(
                        ge.renderWorldCopies ? Se.wrap() : Se,
                        q
                      );
                    }
                    return a.preloadOnly || this._fireMoveEvents(u), ge;
                  };
                if (a.preloadOnly) {
                  const ge = this._emulate(ue, a.duration, g);
                  return this._preloadTiles(ge), this;
                }
                const _e = {
                  moving: this._moving,
                  zooming: this._zooming,
                  rotating: this._rotating,
                  pitching: this._pitching,
                };
                return (
                  (this._zooming = ee),
                  (this._rotating = te),
                  (this._pitching = he),
                  (this._padding = de),
                  (this._easeId = a.easeId),
                  this._prepareEase(u, a.noMoveStart, _e),
                  this._ease(
                    ue(g),
                    (ge) => {
                      g.recenterOnTerrain(), this._afterEase(u, ge);
                    },
                    a
                  ),
                  this
                );
              }
              _prepareEase(a, u, g = {}) {
                (this._moving = !0),
                  (this.transform.cameraElevationReference = "sea"),
                  u || g.moving || this.fire(new d.Event("movestart", a)),
                  this._zooming &&
                    !g.zooming &&
                    this.fire(new d.Event("zoomstart", a)),
                  this._rotating &&
                    !g.rotating &&
                    this.fire(new d.Event("rotatestart", a)),
                  this._pitching &&
                    !g.pitching &&
                    this.fire(new d.Event("pitchstart", a));
              }
              _fireMoveEvents(a) {
                this.fire(new d.Event("move", a)),
                  this._zooming && this.fire(new d.Event("zoom", a)),
                  this._rotating && this.fire(new d.Event("rotate", a)),
                  this._pitching && this.fire(new d.Event("pitch", a));
              }
              _afterEase(a, u) {
                if (this._easeId && u && this._easeId === u) return;
                (this._easeId = void 0),
                  (this.transform.cameraElevationReference = "ground");
                const g = this._zooming,
                  v = this._rotating,
                  b = this._pitching;
                (this._moving = !1),
                  (this._zooming = !1),
                  (this._rotating = !1),
                  (this._pitching = !1),
                  (this._padding = !1),
                  g && this.fire(new d.Event("zoomend", a)),
                  v && this.fire(new d.Event("rotateend", a)),
                  b && this.fire(new d.Event("pitchend", a)),
                  this.fire(new d.Event("moveend", a));
              }
              flyTo(a, u) {
                if (this._prefersReducedMotion(a)) {
                  const Ne = d.pick(a, [
                    "center",
                    "zoom",
                    "bearing",
                    "pitch",
                    "around",
                  ]);
                  return this.jumpTo(Ne, u);
                }
                this.stop(),
                  (a = d.extend(
                    { offset: [0, 0], speed: 1.2, curve: 1.42, easing: d.ease },
                    a
                  ));
                const g = this.transform,
                  v = this.getZoom(),
                  b = this.getBearing(),
                  D = this.getPitch(),
                  S = this.getPadding(),
                  M = "zoom" in a ? d.clamp(+a.zoom, g.minZoom, g.maxZoom) : v,
                  R = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b,
                  k = "pitch" in a ? +a.pitch : D,
                  z = "padding" in a ? a.padding : g.padding,
                  H = g.zoomScale(M - v),
                  q = d.Point.convert(a.offset);
                let X = g.centerPoint.add(q);
                const Z = g.pointLocation(X),
                  Y = d.LngLat.convert(a.center || Z);
                this._normalizeCenter(Y);
                const B = g.project(Z),
                  W = g.project(Y).sub(B);
                let ee = a.curve;
                const te = Math.max(g.width, g.height),
                  he = te / H,
                  de = W.mag();
                if ("minZoom" in a) {
                  const Ne = d.clamp(
                      Math.min(a.minZoom, v, M),
                      g.minZoom,
                      g.maxZoom
                    ),
                    Xe = te / g.zoomScale(Ne - v);
                  ee = Math.sqrt((Xe / de) * 2);
                }
                const ue = ee * ee;
                function _e(Ne) {
                  const Xe =
                    (he * he - te * te + (Ne ? -1 : 1) * ue * ue * de * de) /
                    (2 * (Ne ? he : te) * ue * de);
                  return Math.log(Math.sqrt(Xe * Xe + 1) - Xe);
                }
                function ge(Ne) {
                  return (Math.exp(Ne) - Math.exp(-Ne)) / 2;
                }
                function Te(Ne) {
                  return (Math.exp(Ne) + Math.exp(-Ne)) / 2;
                }
                const Ge = _e(0);
                let be = function (Ne) {
                    return Te(Ge) / Te(Ge + ee * Ne);
                  },
                  Le = function (Ne) {
                    return (
                      (te *
                        ((Te(Ge) * (ge((Xe = Ge + ee * Ne)) / Te(Xe)) -
                          ge(Ge)) /
                          ue)) /
                      de
                    );
                    var Xe;
                  },
                  Se = (_e(1) - Ge) / ee;
                if (Math.abs(de) < 1e-6 || !isFinite(Se)) {
                  if (Math.abs(te - he) < 1e-6) return this.easeTo(a, u);
                  const Ne = he < te ? -1 : 1;
                  (Se = Math.abs(Math.log(he / te)) / ee),
                    (Le = function () {
                      return 0;
                    }),
                    (be = function (Xe) {
                      return Math.exp(Ne * ee * Xe);
                    });
                }
                (a.duration =
                  "duration" in a
                    ? +a.duration
                    : (1e3 * Se) /
                      ("screenSpeed" in a ? +a.screenSpeed / ee : +a.speed)),
                  a.maxDuration &&
                    a.duration > a.maxDuration &&
                    (a.duration = 0);
                const je = b !== R,
                  we = k !== D,
                  ke = !g.isPaddingEqual(z),
                  He = (Ne) => (Xe) => {
                    const mt = Xe * Se,
                      It = 1 / be(mt);
                    (Ne.zoom = 1 === Xe ? M : v + Ne.scaleZoom(It)),
                      je && (Ne.bearing = d.number(b, R, Xe)),
                      we && (Ne.pitch = d.number(D, k, Xe)),
                      ke &&
                        (Ne.interpolatePadding(S, z, Xe),
                        (X = Ne.centerPoint.add(q)));
                    const dt =
                      1 === Xe
                        ? Y
                        : Ne.unproject(B.add(W.mult(Le(mt))).mult(It));
                    return (
                      Ne.setLocationAtPoint(
                        Ne.renderWorldCopies ? dt.wrap() : dt,
                        X
                      ),
                      Ne._updateCameraOnTerrain(),
                      a.preloadOnly || this._fireMoveEvents(u),
                      Ne
                    );
                  };
                if (a.preloadOnly) {
                  const Ne = this._emulate(He, a.duration, g);
                  return this._preloadTiles(Ne), this;
                }
                return (
                  (this._zooming = !0),
                  (this._rotating = je),
                  (this._pitching = we),
                  (this._padding = ke),
                  this._prepareEase(u, !1),
                  this._ease(He(g), () => this._afterEase(u), a),
                  this
                );
              }
              isEasing() {
                return !!this._easeFrameId;
              }
              stop() {
                return this._stop();
              }
              _stop(a, u) {
                if (
                  (this._easeFrameId &&
                    (this._cancelRenderFrame(this._easeFrameId),
                    (this._easeFrameId = void 0),
                    (this._onEaseFrame = void 0)),
                  this._onEaseEnd)
                ) {
                  const g = this._onEaseEnd;
                  (this._onEaseEnd = void 0), g.call(this, u);
                }
                if (!a) {
                  const g = this.handlers;
                  g && g.stop(!1);
                }
                return this;
              }
              _ease(a, u, g) {
                !1 === g.animate || 0 === g.duration
                  ? (a(1), u())
                  : ((this._easeStart = d.exported.now()),
                    (this._easeOptions = g),
                    (this._onEaseFrame = a),
                    (this._onEaseEnd = u),
                    (this._easeFrameId = this._requestRenderFrame(
                      this._renderFrameCallback
                    )));
              }
              _renderFrameCallback() {
                const a = Math.min(
                    (d.exported.now() - this._easeStart) /
                      this._easeOptions.duration,
                    1
                  ),
                  u = this._onEaseFrame;
                u && u(this._easeOptions.easing(a)),
                  a < 1
                    ? (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback
                      ))
                    : this.stop();
              }
              _normalizeBearing(a, u) {
                a = d.wrap(a, -180, 180);
                const g = Math.abs(a - u);
                return (
                  Math.abs(a - 360 - u) < g && (a -= 360),
                  Math.abs(a + 360 - u) < g && (a += 360),
                  a
                );
              }
              _normalizeCenter(a) {
                const u = this.transform;
                if (!u.renderWorldCopies || u.maxBounds) return;
                const g = a.lng - u.center.lng;
                a.lng += g > 180 ? -360 : g < -180 ? 360 : 0;
              }
              _prefersReducedMotion(a) {
                return (
                  this._respectPrefersReducedMotion &&
                  d.exported.prefersReducedMotion &&
                  !(a && a.essential)
                );
              }
              _emulate(a, u, g) {
                const v = Math.ceil((15 * u) / 1e3),
                  b = [],
                  D = a(g.clone());
                for (let S = 0; S <= v; S++) {
                  const M = D(S / v);
                  b.push(M.clone());
                }
                return b;
              }
            }
            class lt {
              constructor(a = {}) {
                (this.options = a),
                  d.bindAll(
                    [
                      "_toggleAttribution",
                      "_updateEditLink",
                      "_updateData",
                      "_updateCompact",
                    ],
                    this
                  );
              }
              getDefaultPosition() {
                return "bottom-right";
              }
              onAdd(a) {
                const u = this.options && this.options.compact;
                return (
                  (this._map = a),
                  (this._container = zt(
                    "div",
                    "mapboxgl-ctrl mapboxgl-ctrl-attrib"
                  )),
                  (this._compactButton = zt(
                    "button",
                    "mapboxgl-ctrl-attrib-button",
                    this._container
                  )),
                  zt(
                    "span",
                    "mapboxgl-ctrl-icon",
                    this._compactButton
                  ).setAttribute("aria-hidden", "true"),
                  (this._compactButton.type = "button"),
                  this._compactButton.addEventListener(
                    "click",
                    this._toggleAttribution
                  ),
                  this._setElementTitle(
                    this._compactButton,
                    "ToggleAttribution"
                  ),
                  (this._innerContainer = zt(
                    "div",
                    "mapboxgl-ctrl-attrib-inner",
                    this._container
                  )),
                  this._innerContainer.setAttribute("role", "list"),
                  u && this._container.classList.add("mapboxgl-compact"),
                  this._updateAttributions(),
                  this._updateEditLink(),
                  this._map.on("styledata", this._updateData),
                  this._map.on("sourcedata", this._updateData),
                  this._map.on("moveend", this._updateEditLink),
                  void 0 === u &&
                    (this._map.on("resize", this._updateCompact),
                    this._updateCompact()),
                  this._container
                );
              }
              onRemove() {
                this._container.remove(),
                  this._map.off("styledata", this._updateData),
                  this._map.off("sourcedata", this._updateData),
                  this._map.off("moveend", this._updateEditLink),
                  this._map.off("resize", this._updateCompact),
                  (this._map = void 0),
                  (this._attribHTML = void 0);
              }
              _setElementTitle(a, u) {
                const g = this._map._getUIString(`AttributionControl.${u}`);
                a.setAttribute("aria-label", g),
                  a.removeAttribute("title"),
                  a.firstElementChild &&
                    a.firstElementChild.setAttribute("title", g);
              }
              _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show")
                  ? (this._container.classList.remove("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "false"))
                  : (this._container.classList.add("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "true"));
              }
              _updateEditLink() {
                let a = this._editLink;
                a ||
                  (a = this._editLink =
                    this._container.querySelector(".mapbox-improve-map"));
                const u = [
                  { key: "owner", value: this.styleOwner },
                  { key: "id", value: this.styleId },
                  {
                    key: "access_token",
                    value:
                      this._map._requestManager._customAccessToken ||
                      d.config.ACCESS_TOKEN,
                  },
                ];
                if (a) {
                  const g = u.reduce(
                    (v, b, D) => (
                      b.value &&
                        (v += `${b.key}=${b.value}${
                          D < u.length - 1 ? "&" : ""
                        }`),
                      v
                    ),
                    "?"
                  );
                  (a.href = `${d.config.FEEDBACK_URL}/${g}#${Ec(
                    this._map,
                    !0
                  )}`),
                    (a.rel = "noopener nofollow"),
                    this._setElementTitle(a, "MapFeedback");
                }
              }
              _updateData(a) {
                !a ||
                  ("metadata" !== a.sourceDataType &&
                    "visibility" !== a.sourceDataType &&
                    "style" !== a.dataType) ||
                  (this._updateAttributions(), this._updateEditLink());
              }
              _updateAttributions() {
                if (!this._map.style) return;
                let a = [];
                if (this._map.style.stylesheet) {
                  const v = this._map.style.stylesheet;
                  (this.styleOwner = v.owner), (this.styleId = v.id);
                }
                const u = this._map.style._sourceCaches;
                for (const v in u) {
                  const b = u[v];
                  if (b.used) {
                    const D = b.getSource();
                    D.attribution &&
                      a.indexOf(D.attribution) < 0 &&
                      a.push(D.attribution);
                  }
                }
                a.sort((v, b) => v.length - b.length),
                  (a = a.filter((v, b) => {
                    for (let D = b + 1; D < a.length; D++)
                      if (a[D].indexOf(v) >= 0) return !1;
                    return !0;
                  })),
                  this.options.customAttribution &&
                    (Array.isArray(this.options.customAttribution)
                      ? (a = [...this.options.customAttribution, ...a])
                      : a.unshift(this.options.customAttribution));
                const g = a.join(" | ");
                g !== this._attribHTML &&
                  ((this._attribHTML = g),
                  a.length
                    ? ((this._innerContainer.innerHTML = g),
                      this._container.classList.remove("mapboxgl-attrib-empty"))
                    : this._container.classList.add("mapboxgl-attrib-empty"),
                  (this._editLink = null));
              }
              _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640
                  ? this._container.classList.add("mapboxgl-compact")
                  : this._container.classList.remove(
                      "mapboxgl-compact",
                      "mapboxgl-compact-show"
                    );
              }
            }
            class ku {
              constructor() {
                d.bindAll(["_updateLogo", "_updateCompact"], this);
              }
              onAdd(a) {
                (this._map = a), (this._container = zt("div", "mapboxgl-ctrl"));
                const u = zt("a", "mapboxgl-ctrl-logo");
                return (
                  (u.target = "_blank"),
                  (u.rel = "noopener nofollow"),
                  (u.href = "https://www.mapbox.com/"),
                  u.setAttribute(
                    "aria-label",
                    this._map._getUIString("LogoControl.Title")
                  ),
                  u.setAttribute("rel", "noopener nofollow"),
                  this._container.appendChild(u),
                  (this._container.style.display = "none"),
                  this._map.on("sourcedata", this._updateLogo),
                  this._updateLogo(),
                  this._map.on("resize", this._updateCompact),
                  this._updateCompact(),
                  this._container
                );
              }
              onRemove() {
                this._container.remove(),
                  this._map.off("sourcedata", this._updateLogo),
                  this._map.off("resize", this._updateCompact);
              }
              getDefaultPosition() {
                return "bottom-left";
              }
              _updateLogo(a) {
                (a && "metadata" !== a.sourceDataType) ||
                  (this._container.style.display = this._logoRequired()
                    ? "block"
                    : "none");
              }
              _logoRequired() {
                if (!this._map.style) return !0;
                const a = this._map.style._sourceCaches;
                if (0 === Object.entries(a).length) return !0;
                for (const u in a) {
                  const g = a[u].getSource();
                  if (g.hasOwnProperty("mapbox_logo") && !g.mapbox_logo)
                    return !1;
                }
                return !0;
              }
              _updateCompact() {
                const a = this._container.children;
                if (a.length) {
                  const u = a[0];
                  this._map.getCanvasContainer().offsetWidth < 250
                    ? u.classList.add("mapboxgl-compact")
                    : u.classList.remove("mapboxgl-compact");
                }
              }
            }
            class ea {
              constructor() {
                (this._queue = []),
                  (this._id = 0),
                  (this._cleared = !1),
                  (this._currentlyRunning = !1);
              }
              add(a) {
                const u = ++this._id;
                return (
                  this._queue.push({ callback: a, id: u, cancelled: !1 }), u
                );
              }
              remove(a) {
                const u = this._currentlyRunning,
                  g = u ? this._queue.concat(u) : this._queue;
                for (const v of g)
                  if (v.id === a) return void (v.cancelled = !0);
              }
              run(a = 0) {
                const u = (this._currentlyRunning = this._queue);
                this._queue = [];
                for (const g of u)
                  if (!g.cancelled && (g.callback(a), this._cleared)) break;
                (this._cleared = !1), (this._currentlyRunning = !1);
              }
              clear() {
                this._currentlyRunning && (this._cleared = !0),
                  (this._queue = []);
              }
            }
            function Fr(f, a, u) {
              if (((f = new d.LngLat(f.lng, f.lat)), a)) {
                const g = new d.LngLat(f.lng - 360, f.lat),
                  v = new d.LngLat(f.lng + 360, f.lat),
                  b = 360 * Math.ceil(Math.abs(f.lng - u.center.lng) / 360),
                  D = u.locationPoint(f).distSqr(a),
                  S = a.x < 0 || a.y < 0 || a.x > u.width || a.y > u.height;
                u.locationPoint(g).distSqr(a) < D &&
                (S || Math.abs(g.lng - u.center.lng) < b)
                  ? (f = g)
                  : u.locationPoint(v).distSqr(a) < D &&
                    (S || Math.abs(v.lng - u.center.lng) < b) &&
                    (f = v);
              }
              for (; Math.abs(f.lng - u.center.lng) > 180; ) {
                const g = u.locationPoint(f);
                if (g.x >= 0 && g.y >= 0 && g.x <= u.width && g.y <= u.height)
                  break;
                f.lng > u.center.lng ? (f.lng -= 360) : (f.lng += 360);
              }
              return f;
            }
            const Ga = {
              center: "translate(-50%,-50%)",
              top: "translate(-50%,0)",
              "top-left": "translate(0,0)",
              "top-right": "translate(-100%,0)",
              bottom: "translate(-50%,-100%)",
              "bottom-left": "translate(0,-100%)",
              "bottom-right": "translate(-100%,-100%)",
              left: "translate(0,-50%)",
              right: "translate(-100%,-50%)",
            };
            class at extends d.Evented {
              constructor(a, u) {
                if (
                  (super(),
                  (a instanceof d.window.HTMLElement || u) &&
                    (a = d.extend({ element: a }, u)),
                  d.bindAll(
                    [
                      "_update",
                      "_onMove",
                      "_onUp",
                      "_addDragHandler",
                      "_onMapClick",
                      "_onKeyPress",
                      "_clearFadeTimer",
                    ],
                    this
                  ),
                  (this._anchor = (a && a.anchor) || "center"),
                  (this._color = (a && a.color) || "#3FB1CE"),
                  (this._scale = (a && a.scale) || 1),
                  (this._draggable = (a && a.draggable) || !1),
                  (this._clickTolerance = (a && a.clickTolerance) || 0),
                  (this._isDragging = !1),
                  (this._state = "inactive"),
                  (this._rotation = (a && a.rotation) || 0),
                  (this._rotationAlignment =
                    (a && a.rotationAlignment) || "auto"),
                  (this._pitchAlignment =
                    (a && a.pitchAlignment && a.pitchAlignment) || "auto"),
                  (this._updateMoving = () => this._update(!0)),
                  (this._occludedOpacity = (a && a.occludedOpacity) || 0.2),
                  a && a.element)
                )
                  (this._element = a.element),
                    (this._offset = d.Point.convert((a && a.offset) || [0, 0]));
                else {
                  (this._defaultMarker = !0), (this._element = zt("div"));
                  const v = 41,
                    b = 27,
                    D = Mi(
                      "svg",
                      {
                        display: "block",
                        height: v * this._scale + "px",
                        width: b * this._scale + "px",
                        viewBox: `0 0 ${b} ${v}`,
                      },
                      this._element
                    ),
                    S = Mi(
                      "radialGradient",
                      { id: "shadowGradient" },
                      Mi("defs", {}, D)
                    );
                  Mi("stop", { offset: "10%", "stop-opacity": 0.4 }, S),
                    Mi("stop", { offset: "100%", "stop-opacity": 0.05 }, S),
                    Mi(
                      "ellipse",
                      {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)",
                      },
                      D
                    ),
                    Mi(
                      "path",
                      {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z",
                      },
                      D
                    ),
                    Mi(
                      "path",
                      {
                        opacity: 0.25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z",
                      },
                      D
                    ),
                    Mi(
                      "circle",
                      { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 },
                      D
                    ),
                    (this._offset = d.Point.convert(
                      (a && a.offset) || [0, -14]
                    ));
                }
                this._element.hasAttribute("aria-label") ||
                  this._element.setAttribute("aria-label", "Map marker"),
                  this._element.classList.add("mapboxgl-marker"),
                  this._element.addEventListener("dragstart", (v) => {
                    v.preventDefault();
                  }),
                  this._element.addEventListener("mousedown", (v) => {
                    v.preventDefault();
                  });
                const g = this._element.classList;
                for (const v in Ga) g.remove(`mapboxgl-marker-anchor-${v}`);
                g.add(`mapboxgl-marker-anchor-${this._anchor}`),
                  (this._popup = null);
              }
              addTo(a) {
                return (
                  a === this._map ||
                    (this.remove(),
                    (this._map = a),
                    a.getCanvasContainer().appendChild(this._element),
                    a.on("move", this._updateMoving),
                    a.on("moveend", this._update),
                    a.on("remove", this._clearFadeTimer),
                    a._addMarker(this),
                    this.setDraggable(this._draggable),
                    this._update(),
                    a.on("click", this._onMapClick)),
                  this
                );
              }
              remove() {
                const a = this._map;
                return (
                  a &&
                    (a.off("click", this._onMapClick),
                    a.off("move", this._updateMoving),
                    a.off("moveend", this._update),
                    a.off("mousedown", this._addDragHandler),
                    a.off("touchstart", this._addDragHandler),
                    a.off("mouseup", this._onUp),
                    a.off("touchend", this._onUp),
                    a.off("mousemove", this._onMove),
                    a.off("touchmove", this._onMove),
                    a.off("remove", this._clearFadeTimer),
                    a._removeMarker(this),
                    (this._map = void 0)),
                  this._clearFadeTimer(),
                  this._element.remove(),
                  this._popup && this._popup.remove(),
                  this
                );
              }
              getLngLat() {
                return this._lngLat;
              }
              setLngLat(a) {
                return (
                  (this._lngLat = d.LngLat.convert(a)),
                  (this._pos = null),
                  this._popup && this._popup.setLngLat(this._lngLat),
                  this._update(!0),
                  this
                );
              }
              getElement() {
                return this._element;
              }
              setPopup(a) {
                if (
                  (this._popup &&
                    (this._popup.remove(),
                    (this._popup = null),
                    this._element.removeAttribute("role"),
                    this._element.removeEventListener(
                      "keypress",
                      this._onKeyPress
                    ),
                    this._originalTabIndex ||
                      this._element.removeAttribute("tabindex")),
                  a)
                ) {
                  if (!("offset" in a.options)) {
                    const v = Math.sqrt(Math.pow(13.5, 2) / 2);
                    a.options.offset = this._defaultMarker
                      ? {
                          top: [0, 0],
                          "top-left": [0, 0],
                          "top-right": [0, 0],
                          bottom: [0, -38.1],
                          "bottom-left": [v, -1 * (24.6 + v)],
                          "bottom-right": [-v, -1 * (24.6 + v)],
                          left: [13.5, -24.6],
                          right: [-13.5, -24.6],
                        }
                      : this._offset;
                  }
                  (this._popup = a),
                    (a._marker = this),
                    this._lngLat && this._popup.setLngLat(this._lngLat),
                    this._element.setAttribute("role", "button"),
                    (this._originalTabIndex =
                      this._element.getAttribute("tabindex")),
                    this._originalTabIndex ||
                      this._element.setAttribute("tabindex", "0"),
                    this._element.addEventListener(
                      "keypress",
                      this._onKeyPress
                    ),
                    this._element.setAttribute("aria-expanded", "false");
                }
                return this;
              }
              _onKeyPress(a) {
                const u = a.code,
                  g = a.charCode || a.keyCode;
                ("Space" !== u && "Enter" !== u && 32 !== g && 13 !== g) ||
                  this.togglePopup();
              }
              _onMapClick(a) {
                const u = a.originalEvent.target,
                  g = this._element;
                this._popup && (u === g || g.contains(u)) && this.togglePopup();
              }
              getPopup() {
                return this._popup;
              }
              togglePopup() {
                const a = this._popup;
                return a
                  ? (a.isOpen()
                      ? (a.remove(),
                        this._element.setAttribute("aria-expanded", "false"))
                      : this._map &&
                        (a.addTo(this._map),
                        this._element.setAttribute("aria-expanded", "true")),
                    this)
                  : this;
              }
              _behindTerrain() {
                const a = this._map,
                  u = this._pos;
                if (!a || !u) return !1;
                const g = a.unproject(u),
                  v = a.getFreeCameraOptions();
                if (!v.position) return !1;
                const b = v.position.toLngLat();
                return b.distanceTo(g) < 0.9 * b.distanceTo(this._lngLat);
              }
              _evaluateOpacity() {
                const a = this._map;
                if (!a) return;
                const u = this._pos;
                if (
                  !u ||
                  u.x < 0 ||
                  u.x > a.transform.width ||
                  u.y < 0 ||
                  u.y > a.transform.height
                )
                  return void this._clearFadeTimer();
                const g = a.unproject(u);
                let v;
                a._showingGlobe() &&
                d.isLngLatBehindGlobe(a.transform, this._lngLat)
                  ? (v = 0)
                  : ((v = 1 - a._queryFogOpacity(g)),
                    a.transform._terrainEnabled() &&
                      a.getTerrain() &&
                      this._behindTerrain() &&
                      (v *= this._occludedOpacity)),
                  (this._element.style.opacity = `${v}`),
                  (this._element.style.pointerEvents = v > 0 ? "auto" : "none"),
                  this._popup && this._popup._setOpacity(v),
                  (this._fadeTimer = null);
              }
              _clearFadeTimer() {
                this._fadeTimer &&
                  (clearTimeout(this._fadeTimer), (this._fadeTimer = null));
              }
              _updateDOM() {
                const a = this._pos;
                if (!a || !this._map) return;
                const u = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${
                  a.x
                }px,${a.y}px)\n            ${
                  Ga[this._anchor]
                }\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${
                  u.x
                }px,${u.y}px)\n        `;
              }
              _calculateXYTransform() {
                const a = this._pos,
                  u = this._map,
                  g = this.getPitchAlignment();
                if (!u || !a || "map" !== g) return "";
                if (!u._showingGlobe()) {
                  const M = u.getPitch();
                  return M ? `rotateX(${M}deg)` : "";
                }
                const v = d.radToDeg(
                    d.globeTiltAtLngLat(u.transform, this._lngLat)
                  ),
                  b = a.sub(d.globeCenterToScreenPoint(u.transform)),
                  D = Math.abs(b.x) + Math.abs(b.y);
                if (0 === D) return "";
                const S = v / D;
                return `rotateX(${-b.y * S}deg) rotateY(${b.x * S}deg)`;
              }
              _calculateZTransform() {
                const a = this._pos,
                  u = this._map;
                if (!u || !a) return "";
                let g = 0;
                const v = this.getRotationAlignment();
                if ("map" === v)
                  if (u._showingGlobe()) {
                    const b = u.project(
                        new d.LngLat(this._lngLat.lng, this._lngLat.lat + 0.001)
                      ),
                      D = u
                        .project(
                          new d.LngLat(
                            this._lngLat.lng,
                            this._lngLat.lat - 0.001
                          )
                        )
                        .sub(b);
                    g = d.radToDeg(Math.atan2(D.y, D.x)) - 90;
                  } else g = -u.getBearing();
                else if ("horizon" === v) {
                  const b = d.smoothstep(4, 6, u.getZoom()),
                    D = d.globeCenterToScreenPoint(u.transform);
                  D.y += b * u.transform.height;
                  const S = a.sub(D),
                    M = d.radToDeg(Math.atan2(S.y, S.x));
                  g = (M > 90 ? M - 270 : M + 90) * (1 - b);
                }
                return (g += this._rotation), g ? `rotateZ(${g}deg)` : "";
              }
              _update(a) {
                d.window.cancelAnimationFrame(this._updateFrameId);
                const u = this._map;
                u &&
                  (u.transform.renderWorldCopies &&
                    (this._lngLat = Fr(this._lngLat, this._pos, u.transform)),
                  (this._pos = u.project(this._lngLat)),
                  !0 === a
                    ? (this._updateFrameId = d.window.requestAnimationFrame(
                        () => {
                          this._element &&
                            this._pos &&
                            this._anchor &&
                            ((this._pos = this._pos.round()),
                            this._updateDOM());
                        }
                      ))
                    : (this._pos = this._pos.round()),
                  u._requestDomTask(() => {
                    this._map &&
                      (this._element &&
                        this._pos &&
                        this._anchor &&
                        this._updateDOM(),
                      (u._showingGlobe() || u.getTerrain() || u.getFog()) &&
                        !this._fadeTimer &&
                        (this._fadeTimer = setTimeout(
                          this._evaluateOpacity.bind(this),
                          60
                        )));
                  }));
              }
              getOffset() {
                return this._offset;
              }
              setOffset(a) {
                return (
                  (this._offset = d.Point.convert(a)), this._update(), this
                );
              }
              _onMove(a) {
                const u = this._map;
                if (!u) return;
                const g = this._pointerdownPos,
                  v = this._positionDelta;
                if (g && v) {
                  if (!this._isDragging) {
                    const b = this._clickTolerance || u._clickTolerance;
                    if (a.point.dist(g) < b) return;
                    this._isDragging = !0;
                  }
                  (this._pos = a.point.sub(v)),
                    (this._lngLat = u.unproject(this._pos)),
                    this.setLngLat(this._lngLat),
                    (this._element.style.pointerEvents = "none"),
                    "pending" === this._state &&
                      ((this._state = "active"),
                      this.fire(new d.Event("dragstart"))),
                    this.fire(new d.Event("drag"));
                }
              }
              _onUp() {
                (this._element.style.pointerEvents = "auto"),
                  (this._positionDelta = null),
                  (this._pointerdownPos = null),
                  (this._isDragging = !1);
                const a = this._map;
                a &&
                  (a.off("mousemove", this._onMove),
                  a.off("touchmove", this._onMove)),
                  "active" === this._state && this.fire(new d.Event("dragend")),
                  (this._state = "inactive");
              }
              _addDragHandler(a) {
                const u = this._map,
                  g = this._pos;
                u &&
                  g &&
                  this._element.contains(a.originalEvent.target) &&
                  (a.preventDefault(),
                  (this._positionDelta = a.point.sub(g)),
                  (this._pointerdownPos = a.point),
                  (this._state = "pending"),
                  u.on("mousemove", this._onMove),
                  u.on("touchmove", this._onMove),
                  u.once("mouseup", this._onUp),
                  u.once("touchend", this._onUp));
              }
              setDraggable(a) {
                this._draggable = !!a;
                const u = this._map;
                return (
                  u &&
                    (a
                      ? (u.on("mousedown", this._addDragHandler),
                        u.on("touchstart", this._addDragHandler))
                      : (u.off("mousedown", this._addDragHandler),
                        u.off("touchstart", this._addDragHandler))),
                  this
                );
              }
              isDraggable() {
                return this._draggable;
              }
              setRotation(a) {
                return (this._rotation = a || 0), this._update(), this;
              }
              getRotation() {
                return this._rotation;
              }
              setRotationAlignment(a) {
                return (
                  (this._rotationAlignment = a || "auto"), this._update(), this
                );
              }
              getRotationAlignment() {
                return "auto" === this._rotationAlignment ||
                  ("horizon" === this._rotationAlignment &&
                    this._map &&
                    !this._map._showingGlobe())
                  ? "viewport"
                  : this._rotationAlignment;
              }
              setPitchAlignment(a) {
                return (
                  (this._pitchAlignment = a || "auto"), this._update(), this
                );
              }
              getPitchAlignment() {
                return "auto" === this._pitchAlignment
                  ? this.getRotationAlignment()
                  : this._pitchAlignment;
              }
              setOccludedOpacity(a) {
                return (this._occludedOpacity = a || 0.2), this._update(), this;
              }
              getOccludedOpacity() {
                return this._occludedOpacity;
              }
            }
            const Qh = {
                closeButton: !0,
                closeOnClick: !0,
                focusAfterOpen: !0,
                className: "",
                maxWidth: "240px",
              },
              $f = [
                "a[href]",
                "[tabindex]:not([tabindex='-1'])",
                "[contenteditable]:not([contenteditable='false'])",
                "button:not([disabled])",
                "input:not([disabled])",
                "select:not([disabled])",
                "textarea:not([disabled])",
              ].join(", ");
            function Ru(f = new d.Point(0, 0), a = "bottom") {
              if ("number" == typeof f) {
                const u = Math.round(Math.sqrt(0.5 * Math.pow(f, 2)));
                switch (a) {
                  case "top":
                    return new d.Point(0, f);
                  case "top-left":
                    return new d.Point(u, u);
                  case "top-right":
                    return new d.Point(-u, u);
                  case "bottom":
                    return new d.Point(0, -f);
                  case "bottom-left":
                    return new d.Point(u, -u);
                  case "bottom-right":
                    return new d.Point(-u, -u);
                  case "left":
                    return new d.Point(f, 0);
                  case "right":
                    return new d.Point(-f, 0);
                }
                return new d.Point(0, 0);
              }
              return f instanceof d.Point || Array.isArray(f)
                ? d.Point.convert(f)
                : d.Point.convert(f[a] || [0, 0]);
            }
            class Ic {
              constructor(a) {
                this.jumpTo(a);
              }
              getValue(a) {
                if (a <= this._startTime) return this._start;
                if (a >= this._endTime) return this._end;
                const u = d.easeCubicInOut(
                  (a - this._startTime) / (this._endTime - this._startTime)
                );
                return this._start * (1 - u) + this._end * u;
              }
              isEasing(a) {
                return a >= this._startTime && a <= this._endTime;
              }
              jumpTo(a) {
                (this._startTime = -1 / 0),
                  (this._endTime = -1 / 0),
                  (this._start = a),
                  (this._end = a);
              }
              easeTo(a, u, g) {
                (this._start = this.getValue(u)),
                  (this._end = a),
                  (this._startTime = u),
                  (this._endTime = u + g);
              }
            }
            const Jh = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "AttributionControl.MapFeedback": "Map feedback",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable":
                  "Location not available",
                "LogoControl.Title": "Mapbox logo",
                "Map.Title": "Map",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScrollZoomBlocker.CtrlMessage":
                  "Use ctrl + scroll to zoom the map",
                "ScrollZoomBlocker.CmdMessage":
                  "Use \u2318 + scroll to zoom the map",
                "TouchPanBlocker.Message": "Use two fingers to move the map",
              },
              Ou = {
                center: [0, 0],
                zoom: 0,
                bearing: 0,
                pitch: 0,
                minZoom: -2,
                maxZoom: 22,
                minPitch: 0,
                maxPitch: 85,
                interactive: !0,
                scrollZoom: !0,
                boxZoom: !0,
                dragRotate: !0,
                dragPan: !0,
                keyboard: !0,
                doubleClickZoom: !0,
                touchZoomRotate: !0,
                touchPitch: !0,
                cooperativeGestures: !1,
                performanceMetricsCollection: !0,
                bearingSnap: 7,
                clickTolerance: 3,
                pitchWithRotate: !0,
                hash: !1,
                attributionControl: !0,
                failIfMajorPerformanceCaveat: !1,
                preserveDrawingBuffer: !1,
                trackResize: !0,
                optimizeForTerrain: !0,
                renderWorldCopies: !0,
                refreshExpiredTiles: !0,
                minTileCacheSize: null,
                maxTileCacheSize: null,
                localIdeographFontFamily: "sans-serif",
                localFontFamily: null,
                transformRequest: null,
                accessToken: null,
                fadeDuration: 300,
                respectPrefersReducedMotion: !0,
                crossSourceCollisions: !0,
              },
              Hf = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
            class xp {
              constructor(a, u, g = !1) {
                (this._clickTolerance = 10),
                  (this.element = u),
                  (this.mouseRotate = new Nl({
                    clickTolerance: a.dragRotate._mouseRotate._clickTolerance,
                  })),
                  (this.map = a),
                  g &&
                    (this.mousePitch = new Zh({
                      clickTolerance: a.dragRotate._mousePitch._clickTolerance,
                    })),
                  d.bindAll(
                    [
                      "mousedown",
                      "mousemove",
                      "mouseup",
                      "touchstart",
                      "touchmove",
                      "touchend",
                      "reset",
                    ],
                    this
                  ),
                  u.addEventListener("mousedown", this.mousedown),
                  u.addEventListener("touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  u.addEventListener("touchmove", this.touchmove),
                  u.addEventListener("touchend", this.touchend),
                  u.addEventListener("touchcancel", this.reset);
              }
              down(a, u) {
                this.mouseRotate.mousedown(a, u),
                  this.mousePitch && this.mousePitch.mousedown(a, u),
                  oc();
              }
              move(a, u) {
                const g = this.map,
                  v = this.mouseRotate.mousemoveWindow(a, u),
                  b = v && v.bearingDelta;
                if ((b && g.setBearing(g.getBearing() + b), this.mousePitch)) {
                  const D = this.mousePitch.mousemoveWindow(a, u),
                    S = D && D.pitchDelta;
                  S && g.setPitch(g.getPitch() + S);
                }
              }
              off() {
                const a = this.element;
                a.removeEventListener("mousedown", this.mousedown),
                  a.removeEventListener("touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  a.removeEventListener("touchmove", this.touchmove),
                  a.removeEventListener("touchend", this.touchend),
                  a.removeEventListener("touchcancel", this.reset),
                  this.offTemp();
              }
              offTemp() {
                vl(),
                  d.window.removeEventListener("mousemove", this.mousemove),
                  d.window.removeEventListener("mouseup", this.mouseup);
              }
              mousedown(a) {
                this.down(
                  d.extend({}, a, {
                    ctrlKey: !0,
                    preventDefault: () => a.preventDefault(),
                  }),
                  Mr(this.element, a)
                ),
                  d.window.addEventListener("mousemove", this.mousemove),
                  d.window.addEventListener("mouseup", this.mouseup);
              }
              mousemove(a) {
                this.move(a, Mr(this.element, a));
              }
              mouseup(a) {
                this.mouseRotate.mouseupWindow(a),
                  this.mousePitch && this.mousePitch.mouseupWindow(a),
                  this.offTemp();
              }
              touchstart(a) {
                1 !== a.targetTouches.length
                  ? this.reset()
                  : ((this._startPos = this._lastPos =
                      Ca(this.element, a.targetTouches)[0]),
                    this.down(
                      {
                        type: "mousedown",
                        button: 0,
                        ctrlKey: !0,
                        preventDefault: () => a.preventDefault(),
                      },
                      this._startPos
                    ));
              }
              touchmove(a) {
                1 !== a.targetTouches.length
                  ? this.reset()
                  : ((this._lastPos = Ca(this.element, a.targetTouches)[0]),
                    this.move(
                      { preventDefault: () => a.preventDefault() },
                      this._lastPos
                    ));
              }
              touchend(a) {
                0 === a.targetTouches.length &&
                  this._startPos &&
                  this._lastPos &&
                  this._startPos.dist(this._lastPos) < this._clickTolerance &&
                  this.element.click(),
                  this.reset();
              }
              reset() {
                this.mouseRotate.reset(),
                  this.mousePitch && this.mousePitch.reset(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp();
              }
            }
            const Mc = {
                positionOptions: {
                  enableHighAccuracy: !1,
                  maximumAge: 0,
                  timeout: 6e3,
                },
                fitBoundsOptions: { maxZoom: 15 },
                trackUserLocation: !1,
                showAccuracyCircle: !0,
                showUserLocation: !0,
                showUserHeading: !1,
              },
              Fu = { maxWidth: 100, unit: "metric" },
              Nu = {
                kilometer: "km",
                meter: "m",
                mile: "mi",
                foot: "ft",
                "nautical-mile": "nm",
              },
              qa = {
                version: d.version,
                supported: Oo,
                setRTLTextPlugin: d.setRTLTextPlugin,
                getRTLTextPluginStatus: d.getRTLTextPluginStatus,
                Map: class extends $i {
                  constructor(f) {
                    if (
                      (d.LivePerformanceUtils.mark(d.PerformanceMarkers.create),
                      null != (f = d.extend({}, Ou, f)).minZoom &&
                        null != f.maxZoom &&
                        f.minZoom > f.maxZoom)
                    )
                      throw new Error(
                        "maxZoom must be greater than or equal to minZoom"
                      );
                    if (
                      null != f.minPitch &&
                      null != f.maxPitch &&
                      f.minPitch > f.maxPitch
                    )
                      throw new Error(
                        "maxPitch must be greater than or equal to minPitch"
                      );
                    if (null != f.minPitch && f.minPitch < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0"
                      );
                    if (null != f.maxPitch && f.maxPitch > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85"
                      );
                    if (
                      (f.antialias &&
                        d.isSafariWithAntialiasingBug(d.window) &&
                        ((f.antialias = !1),
                        d.warnOnce(
                          "Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609"
                        )),
                      super(
                        new Zo(
                          f.minZoom,
                          f.maxZoom,
                          f.minPitch,
                          f.maxPitch,
                          f.renderWorldCopies
                        ),
                        f
                      ),
                      (this._interactive = f.interactive),
                      (this._minTileCacheSize = f.minTileCacheSize),
                      (this._maxTileCacheSize = f.maxTileCacheSize),
                      (this._failIfMajorPerformanceCaveat =
                        f.failIfMajorPerformanceCaveat),
                      (this._preserveDrawingBuffer = f.preserveDrawingBuffer),
                      (this._antialias = f.antialias),
                      (this._useWebGL2 = f.useWebGL2),
                      (this._trackResize = f.trackResize),
                      (this._bearingSnap = f.bearingSnap),
                      (this._refreshExpiredTiles = f.refreshExpiredTiles),
                      (this._fadeDuration = f.fadeDuration),
                      (this._isInitialLoad = !0),
                      (this._crossSourceCollisions = f.crossSourceCollisions),
                      (this._collectResourceTiming = f.collectResourceTiming),
                      (this._optimizeForTerrain = f.optimizeForTerrain),
                      (this._language = this._parseLanguage(f.language)),
                      (this._worldview = f.worldview),
                      (this._renderTaskQueue = new ea()),
                      (this._domRenderTaskQueue = new ea()),
                      (this._controls = []),
                      (this._markers = []),
                      (this._popups = []),
                      (this._mapId = d.uniqueId()),
                      (this._locale = d.extend({}, Jh, f.locale)),
                      (this._clickTolerance = f.clickTolerance),
                      (this._cooperativeGestures = f.cooperativeGestures),
                      (this._performanceMetricsCollection =
                        f.performanceMetricsCollection),
                      (this._containerWidth = 0),
                      (this._containerHeight = 0),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      (this._averageElevationExaggeration = 0),
                      (this._averageElevation = new Ic(0)),
                      (this._interactionRange = [1 / 0, -1 / 0]),
                      (this._visibilityHidden = 0),
                      (this._useExplicitProjection = !1),
                      (this._requestManager = new d.RequestManager(
                        f.transformRequest,
                        f.accessToken,
                        f.testMode
                      )),
                      (this._silenceAuthErrors = !!f.testMode),
                      "string" == typeof f.container)
                    ) {
                      if (
                        ((this._container = d.window.document.getElementById(
                          f.container
                        )),
                        !this._container)
                      )
                        throw new Error(
                          `Container '${f.container}' not found.`
                        );
                    } else {
                      if (!(f.container instanceof d.window.HTMLElement))
                        throw new Error(
                          "Invalid type: 'container' must be a String or HTMLElement."
                        );
                      this._container = f.container;
                    }
                    if (
                      (this._container.childNodes.length > 0 &&
                        d.warnOnce(
                          "The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."
                        ),
                      f.maxBounds && this.setMaxBounds(f.maxBounds),
                      d.bindAll(
                        [
                          "_onWindowOnline",
                          "_onWindowResize",
                          "_onVisibilityChange",
                          "_onMapScroll",
                          "_contextLost",
                          "_contextRestored",
                        ],
                        this
                      ),
                      this._setupContainer(),
                      this._setupPainter(),
                      void 0 === this.painter)
                    )
                      throw new Error("Failed to initialize WebGL.");
                    this.on("move", () => this._update(!1)),
                      this.on("moveend", () => this._update(!1)),
                      this.on("zoom", () => this._update(!0)),
                      void 0 !== d.window &&
                        (d.window.addEventListener(
                          "online",
                          this._onWindowOnline,
                          !1
                        ),
                        d.window.addEventListener(
                          "resize",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.addEventListener(
                          "orientationchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.addEventListener(
                          "webkitfullscreenchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.addEventListener(
                          "visibilitychange",
                          this._onVisibilityChange,
                          !1
                        )),
                      (this.handlers = new ms(this, f)),
                      (this._localFontFamily = f.localFontFamily),
                      (this._localIdeographFontFamily =
                        f.localIdeographFontFamily),
                      f.style &&
                        this.setStyle(f.style, {
                          localFontFamily: this._localFontFamily,
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                        }),
                      f.projection && this.setProjection(f.projection),
                      (this._hash =
                        f.hash &&
                        new $h(
                          ("string" == typeof f.hash && f.hash) || void 0
                        ).addTo(this)),
                      (this._hash && this._hash._onHashChange()) ||
                        (this.jumpTo({
                          center: f.center,
                          zoom: f.zoom,
                          bearing: f.bearing,
                          pitch: f.pitch,
                        }),
                        f.bounds &&
                          (this.resize(),
                          this.fitBounds(
                            f.bounds,
                            d.extend({}, f.fitBoundsOptions, { duration: 0 })
                          ))),
                      this.resize(),
                      f.attributionControl &&
                        this.addControl(
                          new lt({ customAttribution: f.customAttribution })
                        ),
                      (this._logoControl = new ku()),
                      this.addControl(this._logoControl, f.logoPosition),
                      this.on("style.load", () => {
                        this.transform.unmodified &&
                          this.jumpTo(this.style.stylesheet);
                      }),
                      this.on("data", (a) => {
                        this._update("style" === a.dataType),
                          this.fire(new d.Event(`${a.dataType}data`, a));
                      }),
                      this.on("dataloading", (a) => {
                        this.fire(new d.Event(`${a.dataType}dataloading`, a));
                      });
                  }
                  _getMapId() {
                    return this._mapId;
                  }
                  addControl(f, a) {
                    if (
                      (void 0 === a &&
                        (a = f.getDefaultPosition
                          ? f.getDefaultPosition()
                          : "top-right"),
                      !f || !f.onAdd)
                    )
                      return this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."
                          )
                        )
                      );
                    const u = f.onAdd(this);
                    this._controls.push(f);
                    const g = this._controlPositions[a];
                    return (
                      -1 !== a.indexOf("bottom")
                        ? g.insertBefore(u, g.firstChild)
                        : g.appendChild(u),
                      this
                    );
                  }
                  removeControl(f) {
                    if (!f || !f.onRemove)
                      return this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."
                          )
                        )
                      );
                    const a = this._controls.indexOf(f);
                    return (
                      a > -1 && this._controls.splice(a, 1),
                      f.onRemove(this),
                      this
                    );
                  }
                  hasControl(f) {
                    return this._controls.indexOf(f) > -1;
                  }
                  getContainer() {
                    return this._container;
                  }
                  getCanvasContainer() {
                    return this._canvasContainer;
                  }
                  getCanvas() {
                    return this._canvas;
                  }
                  resize(f) {
                    if (
                      (this._updateContainerDimensions(),
                      this._containerWidth === this.transform.width &&
                        this._containerHeight === this.transform.height)
                    )
                      return this;
                    this._resizeCanvas(
                      this._containerWidth,
                      this._containerHeight
                    ),
                      this.transform.resize(
                        this._containerWidth,
                        this._containerHeight
                      ),
                      this.painter.resize(
                        Math.ceil(this._containerWidth),
                        Math.ceil(this._containerHeight)
                      );
                    const a = !this._moving;
                    return (
                      a &&
                        this.fire(new d.Event("movestart", f)).fire(
                          new d.Event("move", f)
                        ),
                      this.fire(new d.Event("resize", f)),
                      a && this.fire(new d.Event("moveend", f)),
                      this
                    );
                  }
                  getBounds() {
                    return this.transform.getBounds();
                  }
                  getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                  }
                  setMaxBounds(f) {
                    return (
                      this.transform.setMaxBounds(d.LngLatBounds.convert(f)),
                      this._update()
                    );
                  }
                  setMinZoom(f) {
                    if ((f = f ?? -2) >= -2 && f <= this.transform.maxZoom)
                      return (
                        (this.transform.minZoom = f),
                        this._update(),
                        this.getZoom() < f
                          ? this.setZoom(f)
                          : this.fire(new d.Event("zoomstart"))
                              .fire(new d.Event("zoom"))
                              .fire(new d.Event("zoomend")),
                        this
                      );
                    throw new Error(
                      "minZoom must be between -2 and the current maxZoom, inclusive"
                    );
                  }
                  getMinZoom() {
                    return this.transform.minZoom;
                  }
                  setMaxZoom(f) {
                    if ((f = f ?? 22) >= this.transform.minZoom)
                      return (
                        (this.transform.maxZoom = f),
                        this._update(),
                        this.getZoom() > f
                          ? this.setZoom(f)
                          : this.fire(new d.Event("zoomstart"))
                              .fire(new d.Event("zoom"))
                              .fire(new d.Event("zoomend")),
                        this
                      );
                    throw new Error(
                      "maxZoom must be greater than the current minZoom"
                    );
                  }
                  getMaxZoom() {
                    return this.transform.maxZoom;
                  }
                  setMinPitch(f) {
                    if ((f = f ?? 0) < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0"
                      );
                    if (f >= 0 && f <= this.transform.maxPitch)
                      return (
                        (this.transform.minPitch = f),
                        this._update(),
                        this.getPitch() < f
                          ? this.setPitch(f)
                          : this.fire(new d.Event("pitchstart"))
                              .fire(new d.Event("pitch"))
                              .fire(new d.Event("pitchend")),
                        this
                      );
                    throw new Error(
                      "minPitch must be between 0 and the current maxPitch, inclusive"
                    );
                  }
                  getMinPitch() {
                    return this.transform.minPitch;
                  }
                  setMaxPitch(f) {
                    if ((f = f ?? 85) > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85"
                      );
                    if (f >= this.transform.minPitch)
                      return (
                        (this.transform.maxPitch = f),
                        this._update(),
                        this.getPitch() > f
                          ? this.setPitch(f)
                          : this.fire(new d.Event("pitchstart"))
                              .fire(new d.Event("pitch"))
                              .fire(new d.Event("pitchend")),
                        this
                      );
                    throw new Error(
                      "maxPitch must be greater than or equal to minPitch"
                    );
                  }
                  getMaxPitch() {
                    return this.transform.maxPitch;
                  }
                  getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                  }
                  setRenderWorldCopies(f) {
                    return (
                      (this.transform.renderWorldCopies = f),
                      this.transform.renderWorldCopies ||
                        this._forceMarkerAndPopupUpdate(!0),
                      this._update()
                    );
                  }
                  getLanguage() {
                    return this._language;
                  }
                  _parseLanguage(f) {
                    return "auto" === f
                      ? d.window.navigator.language
                      : Array.isArray(f)
                      ? 0 === f.length
                        ? void 0
                        : f.map((a) =>
                            "auto" === a ? d.window.navigator.language : a
                          )
                      : f;
                  }
                  setLanguage(f) {
                    const a = this._parseLanguage(f);
                    if (!this.style || a === this._language) return this;
                    (this._language = a), this.style._reloadSources();
                    for (const u of this._controls)
                      u._setLanguage && u._setLanguage(this._language);
                    return this;
                  }
                  getWorldview() {
                    return this._worldview;
                  }
                  setWorldview(f) {
                    return this.style && f !== this._worldview
                      ? ((this._worldview = f),
                        this.style._reloadSources(),
                        this)
                      : this;
                  }
                  getProjection() {
                    return this.transform.mercatorFromTransition
                      ? { name: "globe", center: [0, 0] }
                      : this.transform.getProjection();
                  }
                  _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                  }
                  setProjection(f) {
                    return (
                      this._lazyInitEmptyStyle(),
                      f
                        ? "string" == typeof f && (f = { name: f })
                        : (f = null),
                      (this._useExplicitProjection = !!f),
                      this._prioritizeAndUpdateProjection(
                        f,
                        this.style.stylesheet
                          ? this.style.stylesheet.projection
                          : null
                      )
                    );
                  }
                  _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const f = this.transform,
                      a = f.projection.name;
                    let u;
                    "globe" === a && f.zoom >= d.GLOBE_ZOOM_THRESHOLD_MAX
                      ? (f.setMercatorFromTransition(), (u = !0))
                      : "mercator" === a &&
                        f.zoom < d.GLOBE_ZOOM_THRESHOLD_MAX &&
                        (f.setProjection({ name: "globe" }), (u = !0)),
                      u &&
                        (this.style.applyProjectionUpdate(),
                        this.style._forceSymbolLayerUpdate());
                  }
                  _prioritizeAndUpdateProjection(f, a) {
                    return this._updateProjection(
                      f || a || { name: "mercator" }
                    );
                  }
                  _updateProjection(f) {
                    let a;
                    if (
                      ((a =
                        "globe" === f.name &&
                        this.transform.zoom >= d.GLOBE_ZOOM_THRESHOLD_MAX
                          ? this.transform.setMercatorFromTransition()
                          : this.transform.setProjection(f)),
                      this.style.applyProjectionUpdate(),
                      a)
                    ) {
                      this.painter.clearBackgroundTiles();
                      for (const u in this.style._sourceCaches)
                        this.style._sourceCaches[u].clearTiles();
                      this._update(!0), this._forceMarkerAndPopupUpdate(!0);
                    }
                    return this;
                  }
                  project(f) {
                    return this.transform.locationPoint3D(d.LngLat.convert(f));
                  }
                  unproject(f) {
                    return this.transform.pointLocation3D(d.Point.convert(f));
                  }
                  isMoving() {
                    return (
                      this._moving ||
                      (this.handlers && this.handlers.isMoving()) ||
                      !1
                    );
                  }
                  isZooming() {
                    return (
                      this._zooming ||
                      (this.handlers && this.handlers.isZooming()) ||
                      !1
                    );
                  }
                  isRotating() {
                    return (
                      this._rotating ||
                      (this.handlers && this.handlers.isRotating()) ||
                      !1
                    );
                  }
                  _isDragging() {
                    return (this.handlers && this.handlers._isDragging()) || !1;
                  }
                  _createDelegatedListener(f, a, u) {
                    if ("mouseenter" === f || "mouseover" === f) {
                      let g = !1;
                      const v = (D) => {
                          const S = a.filter((R) => this.getLayer(R)),
                            M = S.length
                              ? this.queryRenderedFeatures(D.point, {
                                  layers: S,
                                })
                              : [];
                          M.length
                            ? g ||
                              ((g = !0),
                              u.call(
                                this,
                                new Ci(f, this, D.originalEvent, {
                                  features: M,
                                })
                              ))
                            : (g = !1);
                        },
                        b = () => {
                          g = !1;
                        };
                      return {
                        layers: new Set(a),
                        listener: u,
                        delegates: { mousemove: v, mouseout: b },
                      };
                    }
                    if ("mouseleave" === f || "mouseout" === f) {
                      let g = !1;
                      const v = (D) => {
                          const S = a.filter((M) => this.getLayer(M));
                          (S.length
                            ? this.queryRenderedFeatures(D.point, { layers: S })
                            : []
                          ).length
                            ? (g = !0)
                            : g &&
                              ((g = !1),
                              u.call(this, new Ci(f, this, D.originalEvent)));
                        },
                        b = (D) => {
                          g &&
                            ((g = !1),
                            u.call(this, new Ci(f, this, D.originalEvent)));
                        };
                      return {
                        layers: new Set(a),
                        listener: u,
                        delegates: { mousemove: v, mouseout: b },
                      };
                    }
                    {
                      const g = (v) => {
                        const b = a.filter((S) => this.getLayer(S)),
                          D = b.length
                            ? this.queryRenderedFeatures(v.point, { layers: b })
                            : [];
                        D.length &&
                          ((v.features = D),
                          u.call(this, v),
                          delete v.features);
                      };
                      return {
                        layers: new Set(a),
                        listener: u,
                        delegates: { [f]: g },
                      };
                    }
                  }
                  on(f, a, u) {
                    if (void 0 === u) return super.on(f, a);
                    Array.isArray(a) || (a = [a]);
                    const g = this._createDelegatedListener(f, a, u);
                    (this._delegatedListeners = this._delegatedListeners || {}),
                      (this._delegatedListeners[f] =
                        this._delegatedListeners[f] || []),
                      this._delegatedListeners[f].push(g);
                    for (const v in g.delegates) this.on(v, g.delegates[v]);
                    return this;
                  }
                  once(f, a, u) {
                    if (void 0 === u) return super.once(f, a);
                    Array.isArray(a) || (a = [a]);
                    const g = this._createDelegatedListener(f, a, u);
                    for (const v in g.delegates) this.once(v, g.delegates[v]);
                    return this;
                  }
                  off(f, a, u) {
                    if (void 0 === u) return super.off(f, a);
                    a = new Set(Array.isArray(a) ? a : [a]);
                    const g = (b, D) => {
                        if (b.size !== D.size) return !1;
                        for (const S of b) if (!D.has(S)) return !1;
                        return !0;
                      },
                      v = this._delegatedListeners
                        ? this._delegatedListeners[f]
                        : void 0;
                    return (
                      v &&
                        ((b) => {
                          for (let D = 0; D < b.length; D++) {
                            const S = b[D];
                            if (S.listener === u && g(S.layers, a)) {
                              for (const M in S.delegates)
                                this.off(M, S.delegates[M]);
                              return b.splice(D, 1), this;
                            }
                          }
                        })(v),
                      this
                    );
                  }
                  queryRenderedFeatures(f, a) {
                    return this.style
                      ? (void 0 !== a ||
                          void 0 === f ||
                          f instanceof d.Point ||
                          Array.isArray(f) ||
                          ((a = f), (f = void 0)),
                        this.style.queryRenderedFeatures(
                          (f = f || [
                            [0, 0],
                            [this.transform.width, this.transform.height],
                          ]),
                          (a = a || {}),
                          this.transform
                        ))
                      : [];
                  }
                  querySourceFeatures(f, a) {
                    return this.style.querySourceFeatures(f, a);
                  }
                  isPointOnSurface(f) {
                    const { name: a } = this.transform.projection;
                    return (
                      "globe" !== a &&
                        "mercator" !== a &&
                        d.warnOnce(
                          `${a} projection does not support isPointOnSurface, this API may behave unexpectedly.`
                        ),
                      this.transform.isPointOnSurface(d.Point.convert(f))
                    );
                  }
                  setStyle(f, a) {
                    return !1 !==
                      (a = d.extend(
                        {},
                        {
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                          localFontFamily: this._localFontFamily,
                        },
                        a
                      )).diff &&
                      a.localIdeographFontFamily ===
                        this._localIdeographFontFamily &&
                      a.localFontFamily === this._localFontFamily &&
                      this.style &&
                      f
                      ? (this._diffStyle(f, a), this)
                      : ((this._localIdeographFontFamily =
                          a.localIdeographFontFamily),
                        (this._localFontFamily = a.localFontFamily),
                        this._updateStyle(f, a));
                  }
                  _getUIString(f) {
                    const a = this._locale[f];
                    if (null == a) throw new Error(`Missing UI string '${f}'`);
                    return a;
                  }
                  _updateStyle(f, a) {
                    return (
                      this.style &&
                        (this.style.setEventedParent(null),
                        this.style._remove(),
                        (this.style = void 0)),
                      f &&
                        ((this.style = new vo(this, a || {})),
                        this.style.setEventedParent(this, {
                          style: this.style,
                        }),
                        "string" == typeof f
                          ? this.style.loadURL(f)
                          : this.style.loadJSON(f)),
                      this._updateTerrain(),
                      this
                    );
                  }
                  _lazyInitEmptyStyle() {
                    this.style ||
                      ((this.style = new vo(this, {})),
                      this.style.setEventedParent(this, { style: this.style }),
                      this.style.loadEmpty());
                  }
                  _diffStyle(f, a) {
                    if ("string" == typeof f) {
                      const u = this._requestManager.normalizeStyleURL(f),
                        g = this._requestManager.transformRequest(
                          u,
                          d.ResourceType.Style
                        );
                      d.getJSON(g, (v, b) => {
                        v
                          ? this.fire(new d.ErrorEvent(v))
                          : b && this._updateDiff(b, a);
                      });
                    } else "object" == typeof f && this._updateDiff(f, a);
                  }
                  _updateDiff(f, a) {
                    try {
                      this.style.setState(f) && this._update(!0);
                    } catch (u) {
                      d.warnOnce(
                        `Unable to perform style diff: ${
                          u.message || u.error || u
                        }.  Rebuilding the style from scratch.`
                      ),
                        this._updateStyle(f, a);
                    }
                  }
                  getStyle() {
                    if (this.style) return this.style.serialize();
                  }
                  isStyleLoaded() {
                    return this.style
                      ? this.style.loaded()
                      : (d.warnOnce("There is no style added to the map."), !1);
                  }
                  addSource(f, a) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.addSource(f, a),
                      this._update(!0)
                    );
                  }
                  isSourceLoaded(f) {
                    return !!this.style && this.style._isSourceCacheLoaded(f);
                  }
                  areTilesLoaded() {
                    const f = this.style && this.style._sourceCaches;
                    for (const a in f) {
                      const u = f[a]._tiles;
                      for (const g in u) {
                        const v = u[g];
                        if ("loaded" !== v.state && "errored" !== v.state)
                          return !1;
                      }
                    }
                    return !0;
                  }
                  addSourceType(f, a, u) {
                    this._lazyInitEmptyStyle(),
                      this.style.addSourceType(f, a, u);
                  }
                  removeSource(f) {
                    return (
                      this.style.removeSource(f),
                      this._updateTerrain(),
                      this._update(!0)
                    );
                  }
                  getSource(f) {
                    return this.style.getSource(f);
                  }
                  addImage(
                    f,
                    a,
                    {
                      pixelRatio: u = 1,
                      sdf: g = !1,
                      stretchX: v,
                      stretchY: b,
                      content: D,
                    } = {}
                  ) {
                    if (
                      (this._lazyInitEmptyStyle(),
                      a instanceof d.window.HTMLImageElement ||
                        (d.window.ImageBitmap &&
                          a instanceof d.window.ImageBitmap))
                    ) {
                      const {
                        width: S,
                        height: M,
                        data: R,
                      } = d.exported.getImageData(a);
                      this.style.addImage(f, {
                        data: new d.RGBAImage({ width: S, height: M }, R),
                        pixelRatio: u,
                        stretchX: v,
                        stretchY: b,
                        content: D,
                        sdf: g,
                        version: 0,
                      });
                    } else if (void 0 === a.width || void 0 === a.height)
                      this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                          )
                        )
                      );
                    else {
                      const { width: S, height: M } = a,
                        R = a;
                      this.style.addImage(f, {
                        data: new d.RGBAImage(
                          { width: S, height: M },
                          new Uint8Array(R.data)
                        ),
                        pixelRatio: u,
                        stretchX: v,
                        stretchY: b,
                        content: D,
                        sdf: g,
                        version: 0,
                        userImage: R,
                      }),
                        R.onAdd && R.onAdd(this, f);
                    }
                  }
                  updateImage(f, a) {
                    const u = this.style.getImage(f);
                    if (!u)
                      return void this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."
                          )
                        )
                      );
                    const g =
                        a instanceof d.window.HTMLImageElement ||
                        (d.window.ImageBitmap &&
                          a instanceof d.window.ImageBitmap)
                          ? d.exported.getImageData(a)
                          : a,
                      { width: v, height: b } = g;
                    void 0 !== v && void 0 !== b
                      ? v === u.data.width && b === u.data.height
                        ? (u.data.replace(
                            g.data,
                            !(
                              a instanceof d.window.HTMLImageElement ||
                              (d.window.ImageBitmap &&
                                a instanceof d.window.ImageBitmap)
                            )
                          ),
                          this.style.updateImage(f, u))
                        : this.fire(
                            new d.ErrorEvent(
                              new Error(
                                `The width and height of the updated image (${v}, ${b})\n                must be that same as the previous version of the image\n                (${u.data.width}, ${u.data.height})`
                              )
                            )
                          )
                      : this.fire(
                          new d.ErrorEvent(
                            new Error(
                              "Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                            )
                          )
                        );
                  }
                  hasImage(f) {
                    return f
                      ? !!this.style.getImage(f)
                      : (this.fire(
                          new d.ErrorEvent(
                            new Error("Missing required image id")
                          )
                        ),
                        !1);
                  }
                  removeImage(f) {
                    this.style.removeImage(f);
                  }
                  loadImage(f, a) {
                    d.getImage(
                      this._requestManager.transformRequest(
                        f,
                        d.ResourceType.Image
                      ),
                      (u, g) => {
                        a(
                          u,
                          g instanceof d.window.HTMLImageElement
                            ? d.exported.getImageData(g)
                            : g
                        );
                      }
                    );
                  }
                  listImages() {
                    return this.style.listImages();
                  }
                  addLayer(f, a) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.addLayer(f, a),
                      this._update(!0)
                    );
                  }
                  moveLayer(f, a) {
                    return this.style.moveLayer(f, a), this._update(!0);
                  }
                  removeLayer(f) {
                    return this.style.removeLayer(f), this._update(!0);
                  }
                  getLayer(f) {
                    return this.style.getLayer(f);
                  }
                  setLayerZoomRange(f, a, u) {
                    return (
                      this.style.setLayerZoomRange(f, a, u), this._update(!0)
                    );
                  }
                  setFilter(f, a, u = {}) {
                    return this.style.setFilter(f, a, u), this._update(!0);
                  }
                  getFilter(f) {
                    return this.style.getFilter(f);
                  }
                  setPaintProperty(f, a, u, g = {}) {
                    return (
                      this.style.setPaintProperty(f, a, u, g), this._update(!0)
                    );
                  }
                  getPaintProperty(f, a) {
                    return this.style.getPaintProperty(f, a);
                  }
                  setLayoutProperty(f, a, u, g = {}) {
                    return (
                      this.style.setLayoutProperty(f, a, u, g), this._update(!0)
                    );
                  }
                  getLayoutProperty(f, a) {
                    return this.style.getLayoutProperty(f, a);
                  }
                  setLight(f, a = {}) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setLight(f, a),
                      this._update(!0)
                    );
                  }
                  getLight() {
                    return this.style.getLight();
                  }
                  setTerrain(f) {
                    return (
                      this._lazyInitEmptyStyle(),
                      !f && this.transform.projection.requiresDraping
                        ? this.style.setTerrainForDraping()
                        : this.style.setTerrain(f),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      this._update(!0)
                    );
                  }
                  getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                  }
                  setFog(f) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setFog(f),
                      this._update(!0)
                    );
                  }
                  getFog() {
                    return this.style ? this.style.getFog() : null;
                  }
                  _queryFogOpacity(f) {
                    return this.style && this.style.fog
                      ? this.style.fog.getOpacityAtLatLng(
                          d.LngLat.convert(f),
                          this.transform
                        )
                      : 0;
                  }
                  setFeatureState(f, a) {
                    return this.style.setFeatureState(f, a), this._update();
                  }
                  removeFeatureState(f, a) {
                    return this.style.removeFeatureState(f, a), this._update();
                  }
                  getFeatureState(f) {
                    return this.style.getFeatureState(f);
                  }
                  _updateContainerDimensions() {
                    if (!this._container) return;
                    const f =
                        this._container.getBoundingClientRect().width || 400,
                      a = this._container.getBoundingClientRect().height || 300;
                    let u,
                      g,
                      v,
                      b = this._container;
                    for (; b && (!g || !v); ) {
                      const D = d.window.getComputedStyle(b).transform;
                      D &&
                        "none" !== D &&
                        ((u = D.match(/matrix.*\((.+)\)/)[1].split(", ")),
                        u[0] && "0" !== u[0] && "1" !== u[0] && (g = u[0]),
                        u[3] && "0" !== u[3] && "1" !== u[3] && (v = u[3])),
                        (b = b.parentElement);
                    }
                    (this._containerWidth = g ? Math.abs(f / g) : f),
                      (this._containerHeight = v ? Math.abs(a / v) : a);
                  }
                  _detectMissingCSS() {
                    "rgb(250, 128, 114)" !==
                      d.window
                        .getComputedStyle(this._missingCSSCanary)
                        .getPropertyValue("background-color") &&
                      d.warnOnce(
                        "This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/."
                      );
                  }
                  _setupContainer() {
                    const f = this._container;
                    f.classList.add("mapboxgl-map"),
                      ((this._missingCSSCanary = zt(
                        "div",
                        "mapboxgl-canary",
                        f
                      )).style.visibility = "hidden"),
                      this._detectMissingCSS();
                    const a = (this._canvasContainer = zt(
                      "div",
                      "mapboxgl-canvas-container",
                      f
                    ));
                    this._interactive &&
                      a.classList.add("mapboxgl-interactive"),
                      (this._canvas = zt("canvas", "mapboxgl-canvas", a)),
                      this._canvas.addEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1
                      ),
                      this._canvas.addEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1
                      ),
                      this._canvas.setAttribute("tabindex", "0"),
                      this._canvas.setAttribute(
                        "aria-label",
                        this._getUIString("Map.Title")
                      ),
                      this._canvas.setAttribute("role", "region"),
                      this._updateContainerDimensions(),
                      this._resizeCanvas(
                        this._containerWidth,
                        this._containerHeight
                      );
                    const u = (this._controlContainer = zt(
                        "div",
                        "mapboxgl-control-container",
                        f
                      )),
                      g = (this._controlPositions = {});
                    [
                      "top-left",
                      "top-right",
                      "bottom-left",
                      "bottom-right",
                    ].forEach((v) => {
                      g[v] = zt("div", `mapboxgl-ctrl-${v}`, u);
                    }),
                      this._container.addEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1
                      );
                  }
                  _resizeCanvas(f, a) {
                    const u = d.exported.devicePixelRatio || 1;
                    (this._canvas.width = u * Math.ceil(f)),
                      (this._canvas.height = u * Math.ceil(a)),
                      (this._canvas.style.width = `${f}px`),
                      (this._canvas.style.height = `${a}px`);
                  }
                  _addMarker(f) {
                    this._markers.push(f);
                  }
                  _removeMarker(f) {
                    const a = this._markers.indexOf(f);
                    -1 !== a && this._markers.splice(a, 1);
                  }
                  _addPopup(f) {
                    this._popups.push(f);
                  }
                  _removePopup(f) {
                    const a = this._popups.indexOf(f);
                    -1 !== a && this._popups.splice(a, 1);
                  }
                  _setupPainter() {
                    const f = d.extend({}, Oo.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat:
                          this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1,
                      }),
                      a =
                        this._useWebGL2 && this._canvas.getContext("webgl2", f),
                      u =
                        a ||
                        this._canvas.getContext("webgl", f) ||
                        this._canvas.getContext("experimental-webgl", f);
                    u
                      ? (this._useWebGL2 &&
                          !a &&
                          d.warnOnce(
                            "Failed to create WebGL 2 context. Using WebGL 1."
                          ),
                        d.storeAuthState(u, !0),
                        (this.painter = new bc(u, this.transform, !!a)),
                        this.on("data", (g) => {
                          "source" === g.dataType &&
                            this.painter.setTileLoadedFlag(!0);
                        }),
                        d.exported$1.testSupport(u))
                      : this.fire(
                          new d.ErrorEvent(
                            new Error("Failed to initialize WebGL")
                          )
                        );
                  }
                  _contextLost(f) {
                    f.preventDefault(),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this.fire(
                        new d.Event("webglcontextlost", { originalEvent: f })
                      );
                  }
                  _contextRestored(f) {
                    this._setupPainter(),
                      this.resize(),
                      this._update(),
                      this.fire(
                        new d.Event("webglcontextrestored", {
                          originalEvent: f,
                        })
                      );
                  }
                  _onMapScroll(f) {
                    if (f.target === this._container)
                      return (
                        (this._container.scrollTop = 0),
                        (this._container.scrollLeft = 0),
                        !1
                      );
                  }
                  loaded() {
                    return (
                      !this._styleDirty &&
                      !this._sourcesDirty &&
                      !!this.style &&
                      this.style.loaded()
                    );
                  }
                  _update(f) {
                    return this.style
                      ? ((this._styleDirty = this._styleDirty || f),
                        (this._sourcesDirty = !0),
                        this.triggerRepaint(),
                        this)
                      : this;
                  }
                  _requestRenderFrame(f) {
                    return this._update(), this._renderTaskQueue.add(f);
                  }
                  _cancelRenderFrame(f) {
                    this._renderTaskQueue.remove(f);
                  }
                  _requestDomTask(f) {
                    !this.loaded() || (this.loaded() && !this.isMoving())
                      ? f()
                      : this._domRenderTaskQueue.add(f);
                  }
                  _render(f) {
                    let a;
                    const u = this.painter.context.extTimerQuery,
                      g = d.exported.now();
                    if (
                      (this.listens("gpu-timing-frame") &&
                        ((a = u.createQueryEXT()),
                        u.beginQueryEXT(u.TIME_ELAPSED_EXT, a)),
                      this.painter.context.setDirty(),
                      this.painter.setBaseState(),
                      (this.isMoving() ||
                        this.isRotating() ||
                        this.isZooming()) &&
                        ((this._interactionRange[0] = Math.min(
                          this._interactionRange[0],
                          d.window.performance.now()
                        )),
                        (this._interactionRange[1] = Math.max(
                          this._interactionRange[1],
                          d.window.performance.now()
                        ))),
                      this._renderTaskQueue.run(f),
                      this._domRenderTaskQueue.run(f),
                      this._removed)
                    )
                      return;
                    this._updateProjectionTransition();
                    const v = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                      this._styleDirty = !1;
                      const S = this.transform.zoom,
                        M = this.transform.pitch,
                        R = d.exported.now(),
                        k = new d.EvaluationParameters(S, {
                          now: R,
                          fadeDuration: v,
                          pitch: M,
                          transition: this.style.getTransition(),
                        });
                      this.style.update(k);
                    }
                    this.style &&
                      this.style.fog &&
                      this.style.fog.hasTransition() &&
                      ((this.style._markersNeedUpdate = !0),
                      (this._sourcesDirty = !0));
                    let b = !1;
                    if (
                      (this.style && this._sourcesDirty
                        ? ((this._sourcesDirty = !1),
                          this.painter._updateFog(this.style),
                          this._updateTerrain(),
                          (b = this._updateAverageElevation(g)),
                          this.style._updateSources(this.transform),
                          this._forceMarkerAndPopupUpdate())
                        : (b = this._updateAverageElevation(g)),
                      (this._placementDirty =
                        this.style &&
                        this.style._updatePlacement(
                          this.painter.transform,
                          this.showCollisionBoxes,
                          v,
                          this._crossSourceCollisions
                        )),
                      this.style &&
                        this.painter.render(this.style, {
                          showTileBoundaries: this.showTileBoundaries,
                          showTerrainWireframe: this.showTerrainWireframe,
                          showOverdrawInspector: this._showOverdrawInspector,
                          showQueryGeometry: !!this._showQueryGeometry,
                          showTileAABBs: this.showTileAABBs,
                          rotating: this.isRotating(),
                          zooming: this.isZooming(),
                          moving: this.isMoving(),
                          fadeDuration: v,
                          isInitialLoad: this._isInitialLoad,
                          showPadding: this.showPadding,
                          gpuTiming: !!this.listens("gpu-timing-layer"),
                          gpuTimingDeferredRender: !!this.listens(
                            "gpu-timing-deferred-render"
                          ),
                          speedIndexTiming: this.speedIndexTiming,
                        }),
                      this.fire(new d.Event("render")),
                      this.loaded() &&
                        !this._loaded &&
                        ((this._loaded = !0), this.fire(new d.Event("load"))),
                      this.style &&
                        this.style.hasTransitions() &&
                        (this._styleDirty = !0),
                      this.style &&
                        !this._placementDirty &&
                        this.style._releaseSymbolFadeTiles(),
                      a)
                    ) {
                      const S = d.exported.now() - g;
                      u.endQueryEXT(u.TIME_ELAPSED_EXT, a),
                        setTimeout(() => {
                          const M =
                            u.getQueryObjectEXT(a, u.QUERY_RESULT_EXT) / 1e6;
                          u.deleteQueryEXT(a),
                            this.fire(
                              new d.Event("gpu-timing-frame", {
                                cpuTime: S,
                                gpuTime: M,
                              })
                            ),
                            d.window.performance.mark("frame-gpu", {
                              startTime: g,
                              detail: { gpuTime: M },
                            });
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                      const S = this.painter.collectGpuTimers();
                      setTimeout(() => {
                        const M = this.painter.queryGpuTimers(S);
                        this.fire(
                          new d.Event("gpu-timing-layer", { layerTimes: M })
                        );
                      }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                      const S = this.painter.collectDeferredRenderGpuQueries();
                      setTimeout(() => {
                        const M = this.painter.queryGpuTimeDeferredRender(S);
                        this.fire(
                          new d.Event("gpu-timing-deferred-render", {
                            gpuTime: M,
                          })
                        );
                      }, 50);
                    }
                    const D =
                      this._sourcesDirty ||
                      this._styleDirty ||
                      this._placementDirty ||
                      b;
                    if (D || this._repaint) this.triggerRepaint();
                    else {
                      const S = !this.isMoving() && this.loaded();
                      if ((S && (b = this._updateAverageElevation(g, !0)), b))
                        this.triggerRepaint();
                      else if (
                        (this._triggerFrame(!1),
                        S &&
                          (this.fire(new d.Event("idle")),
                          (this._isInitialLoad = !1),
                          this.speedIndexTiming))
                      ) {
                        const M = this._calculateSpeedIndex();
                        this.fire(
                          new d.Event("speedindexcompleted", { speedIndex: M })
                        ),
                          (this.speedIndexTiming = !1);
                      }
                    }
                    !this._loaded ||
                      this._fullyLoaded ||
                      D ||
                      ((this._fullyLoaded = !0),
                      d.LivePerformanceUtils.mark(
                        d.PerformanceMarkers.fullLoad
                      ),
                      this._performanceMetricsCollection &&
                        d.postPerformanceEvent(
                          this._requestManager._customAccessToken,
                          {
                            width: this.painter.width,
                            height: this.painter.height,
                            interactionRange: this._interactionRange,
                            visibilityHidden: this._visibilityHidden,
                            terrainEnabled: !!this.painter.style.getTerrain(),
                            fogEnabled: !!this.painter.style.getFog(),
                            projection: this.getProjection().name,
                            zoom: this.transform.zoom,
                            renderer: this.painter.context.renderer,
                            vendor: this.painter.context.vendor,
                          }
                        ),
                      this._authenticate());
                  }
                  _forceMarkerAndPopupUpdate(f) {
                    for (const a of this._markers)
                      f &&
                        !this.getRenderWorldCopies() &&
                        (a._lngLat = a._lngLat.wrap()),
                        a._update();
                    for (const a of this._popups)
                      !f ||
                        this.getRenderWorldCopies() ||
                        a._trackPointer ||
                        (a._lngLat = a._lngLat.wrap()),
                        a._update();
                  }
                  _updateAverageElevation(f, a = !1) {
                    const u = (g) => (
                      (this.transform.averageElevation = g),
                      this._update(!1),
                      !0
                    );
                    if (!this.painter.averageElevationNeedsEasing())
                      return 0 !== this.transform.averageElevation && u(0);
                    if (
                      (a || f - this._averageElevationLastSampledAt > 500) &&
                      !this._averageElevation.isEasing(f)
                    ) {
                      const g = this.transform.averageElevation;
                      let v = this.transform.sampleAverageElevation(),
                        b = !1;
                      this.transform.elevation &&
                        ((b =
                          this.transform.elevation.exaggeration() !==
                          this._averageElevationExaggeration),
                        (this._averageElevationExaggeration =
                          this.transform.elevation.exaggeration())),
                        isNaN(v)
                          ? (v = 0)
                          : (this._averageElevationLastSampledAt = f);
                      const D = Math.abs(g - v);
                      if (D > 1) {
                        if (this._isInitialLoad || b)
                          return this._averageElevation.jumpTo(v), u(v);
                        this._averageElevation.easeTo(v, f, 300);
                      } else if (D > 1e-4)
                        return this._averageElevation.jumpTo(v), u(v);
                    }
                    return (
                      !!this._averageElevation.isEasing(f) &&
                      u(this._averageElevation.getValue(f))
                    );
                  }
                  _authenticate() {
                    d.getMapSessionAPI(
                      this._getMapId(),
                      this._requestManager._skuToken,
                      this._requestManager._customAccessToken,
                      (f) => {
                        if (
                          f &&
                          (f.message === d.AUTH_ERR_MSG || 401 === f.status)
                        ) {
                          const a = this.painter.context.gl;
                          d.storeAuthState(a, !1),
                            this._logoControl instanceof ku &&
                              this._logoControl._updateLogo(),
                            a &&
                              a.clear(
                                a.DEPTH_BUFFER_BIT |
                                  a.COLOR_BUFFER_BIT |
                                  a.STENCIL_BUFFER_BIT
                              ),
                            this._silenceAuthErrors ||
                              this.fire(
                                new d.ErrorEvent(
                                  new Error(
                                    "A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/"
                                  )
                                )
                              );
                        }
                      }
                    ),
                      d.postMapLoadEvent(
                        this._getMapId(),
                        this._requestManager._skuToken,
                        this._requestManager._customAccessToken,
                        () => {}
                      );
                  }
                  _updateTerrain() {
                    const f = this._isDragging();
                    this.painter.updateTerrain(this.style, f);
                  }
                  _calculateSpeedIndex() {
                    const f = this.painter.canvasCopy(),
                      a = this.painter.getCanvasCopiesAndTimestamps();
                    a.timeStamps.push(performance.now());
                    const u = this.painter.context.gl,
                      g = u.createFramebuffer();
                    function v(b) {
                      u.framebufferTexture2D(
                        u.FRAMEBUFFER,
                        u.COLOR_ATTACHMENT0,
                        u.TEXTURE_2D,
                        b,
                        0
                      );
                      const D = new Uint8Array(
                        u.drawingBufferWidth * u.drawingBufferHeight * 4
                      );
                      return (
                        u.readPixels(
                          0,
                          0,
                          u.drawingBufferWidth,
                          u.drawingBufferHeight,
                          u.RGBA,
                          u.UNSIGNED_BYTE,
                          D
                        ),
                        D
                      );
                    }
                    return (
                      u.bindFramebuffer(u.FRAMEBUFFER, g),
                      this._canvasPixelComparison(
                        v(f),
                        a.canvasCopies.map(v),
                        a.timeStamps
                      )
                    );
                  }
                  _canvasPixelComparison(f, a, u) {
                    let g = u[1] - u[0];
                    const v = f.length / 4;
                    for (let b = 0; b < a.length; b++) {
                      const D = a[b];
                      let S = 0;
                      for (let M = 0; M < D.length; M += 4)
                        D[M] === f[M] &&
                          D[M + 1] === f[M + 1] &&
                          D[M + 2] === f[M + 2] &&
                          D[M + 3] === f[M + 3] &&
                          (S += 1);
                      g += (u[b + 2] - u[b + 1]) * (1 - S / v);
                    }
                    return g;
                  }
                  remove() {
                    this._hash && this._hash.remove();
                    for (const a of this._controls) a.onRemove(this);
                    (this._controls = []),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this._renderTaskQueue.clear(),
                      this._domRenderTaskQueue.clear(),
                      this.style && this.style.destroy(),
                      this.painter.destroy(),
                      this.handlers && this.handlers.destroy(),
                      (this.handlers = void 0),
                      this.setStyle(null),
                      void 0 !== d.window &&
                        (d.window.removeEventListener(
                          "resize",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.removeEventListener(
                          "orientationchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.removeEventListener(
                          "webkitfullscreenchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.removeEventListener(
                          "online",
                          this._onWindowOnline,
                          !1
                        ),
                        d.window.removeEventListener(
                          "visibilitychange",
                          this._onVisibilityChange,
                          !1
                        ));
                    const f =
                      this.painter.context.gl.getExtension(
                        "WEBGL_lose_context"
                      );
                    f && f.loseContext(),
                      this._canvas.removeEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1
                      ),
                      this._canvas.removeEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1
                      ),
                      this._canvasContainer.remove(),
                      this._controlContainer.remove(),
                      this._missingCSSCanary.remove(),
                      (this._canvas = void 0),
                      (this._canvasContainer = void 0),
                      (this._controlContainer = void 0),
                      (this._missingCSSCanary = void 0),
                      this._container.classList.remove("mapboxgl-map"),
                      this._container.removeEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1
                      ),
                      d.removeAuthState(this.painter.context.gl),
                      (this._removed = !0),
                      this.fire(new d.Event("remove"));
                  }
                  triggerRepaint() {
                    this._triggerFrame(!0);
                  }
                  _triggerFrame(f) {
                    (this._renderNextFrame = this._renderNextFrame || f),
                      this.style &&
                        !this._frame &&
                        (this._frame = d.exported.frame((a) => {
                          const u = !!this._renderNextFrame;
                          (this._frame = null),
                            (this._renderNextFrame = null),
                            u && this._render(a);
                        }));
                  }
                  _preloadTiles(f) {
                    const a = this.style
                      ? Object.values(this.style._sourceCaches)
                      : [];
                    return (
                      d.asyncAll(
                        a,
                        (u, g) => u._preloadTiles(f, g),
                        () => {
                          this.triggerRepaint();
                        }
                      ),
                      this
                    );
                  }
                  _onWindowOnline() {
                    this._update();
                  }
                  _onWindowResize(f) {
                    this._trackResize &&
                      this.resize({ originalEvent: f })._update();
                  }
                  _onVisibilityChange() {
                    "hidden" === d.window.document.visibilityState &&
                      this._visibilityHidden++;
                  }
                  get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                  }
                  set showTileBoundaries(f) {
                    this._showTileBoundaries !== f &&
                      ((this._showTileBoundaries = f), this._update());
                  }
                  get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                  }
                  set showTerrainWireframe(f) {
                    this._showTerrainWireframe !== f &&
                      ((this._showTerrainWireframe = f), this._update());
                  }
                  get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                  }
                  set speedIndexTiming(f) {
                    this._speedIndexTiming !== f &&
                      ((this._speedIndexTiming = f), this._update());
                  }
                  get showPadding() {
                    return !!this._showPadding;
                  }
                  set showPadding(f) {
                    this._showPadding !== f &&
                      ((this._showPadding = f), this._update());
                  }
                  get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                  }
                  set showCollisionBoxes(f) {
                    this._showCollisionBoxes !== f &&
                      ((this._showCollisionBoxes = f),
                      f
                        ? this.style._generateCollisionBoxes()
                        : this._update());
                  }
                  get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                  }
                  set showOverdrawInspector(f) {
                    this._showOverdrawInspector !== f &&
                      ((this._showOverdrawInspector = f), this._update());
                  }
                  get repaint() {
                    return !!this._repaint;
                  }
                  set repaint(f) {
                    this._repaint !== f &&
                      ((this._repaint = f), this.triggerRepaint());
                  }
                  get vertices() {
                    return !!this._vertices;
                  }
                  set vertices(f) {
                    (this._vertices = f), this._update();
                  }
                  get showTileAABBs() {
                    return !!this._showTileAABBs;
                  }
                  set showTileAABBs(f) {
                    this._showTileAABBs !== f &&
                      ((this._showTileAABBs = f), f && this._update());
                  }
                  _setCacheLimits(f, a) {
                    d.setCacheLimits(f, a);
                  }
                  get version() {
                    return d.version;
                  }
                },
                NavigationControl: class {
                  constructor(f) {
                    (this.options = d.extend({}, Hf, f)),
                      (this._container = zt(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group"
                      )),
                      this._container.addEventListener("contextmenu", (a) =>
                        a.preventDefault()
                      ),
                      this.options.showZoom &&
                        (d.bindAll(
                          ["_setButtonTitle", "_updateZoomButtons"],
                          this
                        ),
                        (this._zoomInButton = this._createButton(
                          "mapboxgl-ctrl-zoom-in",
                          (a) => {
                            this._map &&
                              this._map.zoomIn({}, { originalEvent: a });
                          }
                        )),
                        zt(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomInButton
                        ).setAttribute("aria-hidden", "true"),
                        (this._zoomOutButton = this._createButton(
                          "mapboxgl-ctrl-zoom-out",
                          (a) => {
                            this._map &&
                              this._map.zoomOut({}, { originalEvent: a });
                          }
                        )),
                        zt(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomOutButton
                        ).setAttribute("aria-hidden", "true")),
                      this.options.showCompass &&
                        (d.bindAll(["_rotateCompassArrow"], this),
                        (this._compass = this._createButton(
                          "mapboxgl-ctrl-compass",
                          (a) => {
                            const u = this._map;
                            u &&
                              (this.options.visualizePitch
                                ? u.resetNorthPitch({}, { originalEvent: a })
                                : u.resetNorth({}, { originalEvent: a }));
                          }
                        )),
                        (this._compassIcon = zt(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._compass
                        )),
                        this._compassIcon.setAttribute("aria-hidden", "true"));
                  }
                  _updateZoomButtons() {
                    const f = this._map;
                    if (!f) return;
                    const a = f.getZoom(),
                      u = a === f.getMaxZoom(),
                      g = a === f.getMinZoom();
                    (this._zoomInButton.disabled = u),
                      (this._zoomOutButton.disabled = g),
                      this._zoomInButton.setAttribute(
                        "aria-disabled",
                        u.toString()
                      ),
                      this._zoomOutButton.setAttribute(
                        "aria-disabled",
                        g.toString()
                      );
                  }
                  _rotateCompassArrow() {
                    const f = this._map;
                    if (!f) return;
                    const a = this.options.visualizePitch
                      ? `scale(${
                          1 /
                          Math.pow(
                            Math.cos(f.transform.pitch * (Math.PI / 180)),
                            0.5
                          )
                        }) rotateX(${f.transform.pitch}deg) rotateZ(${
                          f.transform.angle * (180 / Math.PI)
                        }deg)`
                      : `rotate(${f.transform.angle * (180 / Math.PI)}deg)`;
                    f._requestDomTask(() => {
                      this._compassIcon &&
                        (this._compassIcon.style.transform = a);
                    });
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      this.options.showZoom &&
                        (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        f.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                      this.options.showCompass &&
                        (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch &&
                          f.on("pitch", this._rotateCompassArrow),
                        f.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        (this._handler = new xp(
                          f,
                          this._compass,
                          this.options.visualizePitch
                        ))),
                      this._container
                    );
                  }
                  onRemove() {
                    const f = this._map;
                    f &&
                      (this._container.remove(),
                      this.options.showZoom &&
                        f.off("zoom", this._updateZoomButtons),
                      this.options.showCompass &&
                        (this.options.visualizePitch &&
                          f.off("pitch", this._rotateCompassArrow),
                        f.off("rotate", this._rotateCompassArrow),
                        this._handler && this._handler.off(),
                        (this._handler = void 0)),
                      (this._map = void 0));
                  }
                  _createButton(f, a) {
                    const u = zt("button", f, this._container);
                    return (
                      (u.type = "button"), u.addEventListener("click", a), u
                    );
                  }
                  _setButtonTitle(f, a) {
                    if (!this._map) return;
                    const u = this._map._getUIString(`NavigationControl.${a}`);
                    f.setAttribute("aria-label", u),
                      f.firstElementChild &&
                        f.firstElementChild.setAttribute("title", u);
                  }
                },
                GeolocateControl: class extends d.Evented {
                  constructor(f) {
                    super(),
                      (this.options = d.extend(
                        { geolocation: d.window.navigator.geolocation },
                        Mc,
                        f
                      )),
                      d.bindAll(
                        [
                          "_onSuccess",
                          "_onError",
                          "_onZoom",
                          "_finish",
                          "_setupUI",
                          "_updateCamera",
                          "_updateMarker",
                          "_updateMarkerRotation",
                          "_onDeviceOrientation",
                        ],
                        this
                      ),
                      (this._updateMarkerRotationThrottled = Ba(
                        this._updateMarkerRotation,
                        20
                      )),
                      (this._numberOfWatches = 0);
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      (this._container = zt(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group"
                      )),
                      this._checkGeolocationSupport(this._setupUI),
                      this._container
                    );
                  }
                  onRemove() {
                    void 0 !== this._geolocationWatchID &&
                      (this.options.geolocation.clearWatch(
                        this._geolocationWatchID
                      ),
                      (this._geolocationWatchID = void 0)),
                      this.options.showUserLocation &&
                        this._userLocationDotMarker &&
                        this._userLocationDotMarker.remove(),
                      this.options.showAccuracyCircle &&
                        this._accuracyCircleMarker &&
                        this._accuracyCircleMarker.remove(),
                      this._container.remove(),
                      this._map.off("zoom", this._onZoom),
                      (this._map = void 0),
                      (this._numberOfWatches = 0),
                      (this._noTimeout = !1);
                  }
                  _checkGeolocationSupport(f) {
                    const a = (u = !!this.options.geolocation) => {
                      (this._supportsGeolocation = u), f(u);
                    };
                    void 0 !== this._supportsGeolocation
                      ? f(this._supportsGeolocation)
                      : void 0 !== d.window.navigator.permissions
                      ? d.window.navigator.permissions
                          .query({ name: "geolocation" })
                          .then((u) => a("denied" !== u.state))
                          .catch(() => a())
                      : a();
                  }
                  _isOutOfMapMaxBounds(f) {
                    const a = this._map.getMaxBounds(),
                      u = f.coords;
                    return (
                      !!a &&
                      (u.longitude < a.getWest() ||
                        u.longitude > a.getEast() ||
                        u.latitude < a.getSouth() ||
                        u.latitude > a.getNorth())
                    );
                  }
                  _setErrorState() {
                    switch (this._watchState) {
                      case "WAITING_ACTIVE":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error"
                          );
                        break;
                      case "ACTIVE_LOCK":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          );
                        break;
                      case "BACKGROUND":
                        (this._watchState = "BACKGROUND_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background-error"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          );
                    }
                  }
                  _onSuccess(f) {
                    if (this._map) {
                      if (this._isOutOfMapMaxBounds(f))
                        return (
                          this._setErrorState(),
                          this.fire(new d.Event("outofmaxbounds", f)),
                          this._updateMarker(),
                          void this._finish()
                        );
                      if (this.options.trackUserLocation)
                        switch (
                          ((this._lastKnownPosition = f), this._watchState)
                        ) {
                          case "WAITING_ACTIVE":
                          case "ACTIVE_LOCK":
                          case "ACTIVE_ERROR":
                            (this._watchState = "ACTIVE_LOCK"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting"
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active-error"
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-active"
                              );
                            break;
                          case "BACKGROUND":
                          case "BACKGROUND_ERROR":
                            (this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting"
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-background-error"
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background"
                              );
                        }
                      this.options.showUserLocation &&
                        "OFF" !== this._watchState &&
                        this._updateMarker(f),
                        (this.options.trackUserLocation &&
                          "ACTIVE_LOCK" !== this._watchState) ||
                          this._updateCamera(f),
                        this.options.showUserLocation &&
                          this._dotElement.classList.remove(
                            "mapboxgl-user-location-dot-stale"
                          ),
                        this.fire(new d.Event("geolocate", f)),
                        this._finish();
                    }
                  }
                  _updateCamera(f) {
                    const a = new d.LngLat(
                        f.coords.longitude,
                        f.coords.latitude
                      ),
                      u = f.coords.accuracy,
                      g = this._map.getBearing(),
                      v = d.extend(
                        { bearing: g },
                        this.options.fitBoundsOptions
                      );
                    this._map.fitBounds(a.toBounds(u), v, {
                      geolocateSource: !0,
                    });
                  }
                  _updateMarker(f) {
                    if (f) {
                      const a = new d.LngLat(
                        f.coords.longitude,
                        f.coords.latitude
                      );
                      this._accuracyCircleMarker.setLngLat(a).addTo(this._map),
                        this._userLocationDotMarker
                          .setLngLat(a)
                          .addTo(this._map),
                        (this._accuracy = f.coords.accuracy),
                        this.options.showUserLocation &&
                          this.options.showAccuracyCircle &&
                          this._updateCircleRadius();
                    } else
                      this._userLocationDotMarker.remove(),
                        this._accuracyCircleMarker.remove();
                  }
                  _updateCircleRadius() {
                    const f = this._map.transform,
                      a =
                        d.mercatorZfromAltitude(1, f._center.lat) * f.worldSize,
                      u = Math.ceil(2 * this._accuracy * a);
                    (this._circleElement.style.width = `${u}px`),
                      (this._circleElement.style.height = `${u}px`);
                  }
                  _onZoom() {
                    this.options.showUserLocation &&
                      this.options.showAccuracyCircle &&
                      this._updateCircleRadius();
                  }
                  _updateMarkerRotation() {
                    this._userLocationDotMarker &&
                    "number" == typeof this._heading
                      ? (this._userLocationDotMarker.setRotation(this._heading),
                        this._dotElement.classList.add(
                          "mapboxgl-user-location-show-heading"
                        ))
                      : (this._dotElement.classList.remove(
                          "mapboxgl-user-location-show-heading"
                        ),
                        this._userLocationDotMarker.setRotation(0));
                  }
                  _onError(f) {
                    if (this._map) {
                      if (this.options.trackUserLocation)
                        if (1 === f.code) {
                          (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error"
                            ),
                            (this._geolocateButton.disabled = !0);
                          const a = this._map._getUIString(
                            "GeolocateControl.LocationNotAvailable"
                          );
                          this._geolocateButton.setAttribute("aria-label", a),
                            this._geolocateButton.firstElementChild &&
                              this._geolocateButton.firstElementChild.setAttribute(
                                "title",
                                a
                              ),
                            void 0 !== this._geolocationWatchID &&
                              this._clearWatch();
                        } else {
                          if (3 === f.code && this._noTimeout) return;
                          this._setErrorState();
                        }
                      "OFF" !== this._watchState &&
                        this.options.showUserLocation &&
                        this._dotElement.classList.add(
                          "mapboxgl-user-location-dot-stale"
                        ),
                        this.fire(new d.Event("error", f)),
                        this._finish();
                    }
                  }
                  _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId),
                      (this._timeoutId = void 0);
                  }
                  _setupUI(f) {
                    if (void 0 !== this._map) {
                      if (
                        (this._container.addEventListener("contextmenu", (a) =>
                          a.preventDefault()
                        ),
                        (this._geolocateButton = zt(
                          "button",
                          "mapboxgl-ctrl-geolocate",
                          this._container
                        )),
                        zt(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._geolocateButton
                        ).setAttribute("aria-hidden", "true"),
                        (this._geolocateButton.type = "button"),
                        !1 === f)
                      ) {
                        d.warnOnce(
                          "Geolocation support is not available so the GeolocateControl will be disabled."
                        );
                        const a = this._map._getUIString(
                          "GeolocateControl.LocationNotAvailable"
                        );
                        (this._geolocateButton.disabled = !0),
                          this._geolocateButton.setAttribute("aria-label", a),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              a
                            );
                      } else {
                        const a = this._map._getUIString(
                          "GeolocateControl.FindMyLocation"
                        );
                        this._geolocateButton.setAttribute("aria-label", a),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              a
                            );
                      }
                      this.options.trackUserLocation &&
                        (this._geolocateButton.setAttribute(
                          "aria-pressed",
                          "false"
                        ),
                        (this._watchState = "OFF")),
                        this.options.showUserLocation &&
                          ((this._dotElement = zt(
                            "div",
                            "mapboxgl-user-location"
                          )),
                          this._dotElement.appendChild(
                            zt("div", "mapboxgl-user-location-dot")
                          ),
                          this._dotElement.appendChild(
                            zt("div", "mapboxgl-user-location-heading")
                          ),
                          (this._userLocationDotMarker = new at({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map",
                          })),
                          (this._circleElement = zt(
                            "div",
                            "mapboxgl-user-location-accuracy-circle"
                          )),
                          (this._accuracyCircleMarker = new at({
                            element: this._circleElement,
                            pitchAlignment: "map",
                          })),
                          this.options.trackUserLocation &&
                            (this._watchState = "OFF"),
                          this._map.on("zoom", this._onZoom)),
                        this._geolocateButton.addEventListener(
                          "click",
                          this.trigger.bind(this)
                        ),
                        (this._setup = !0),
                        this.options.trackUserLocation &&
                          this._map.on("movestart", (a) => {
                            a.geolocateSource ||
                              "ACTIVE_LOCK" !== this._watchState ||
                              (a.originalEvent &&
                                "resize" === a.originalEvent.type) ||
                              ((this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background"
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active"
                              ),
                              this.fire(new d.Event("trackuserlocationend")));
                          });
                    }
                  }
                  _onDeviceOrientation(f) {
                    this._userLocationDotMarker &&
                      (f.webkitCompassHeading
                        ? (this._heading = f.webkitCompassHeading)
                        : !0 === f.absolute && (this._heading = -1 * f.alpha),
                      this._updateMarkerRotationThrottled());
                  }
                  trigger() {
                    if (!this._setup)
                      return (
                        d.warnOnce(
                          "Geolocate control triggered before added to a map"
                        ),
                        !1
                      );
                    if (this.options.trackUserLocation) {
                      switch (this._watchState) {
                        case "OFF":
                          (this._watchState = "WAITING_ACTIVE"),
                            this.fire(new d.Event("trackuserlocationstart"));
                          break;
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                        case "BACKGROUND_ERROR":
                          this._numberOfWatches--,
                            (this._noTimeout = !1),
                            (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error"
                            ),
                            this.fire(new d.Event("trackuserlocationend"));
                          break;
                        case "BACKGROUND":
                          (this._watchState = "ACTIVE_LOCK"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background"
                            ),
                            this._lastKnownPosition &&
                              this._updateCamera(this._lastKnownPosition),
                            this.fire(new d.Event("trackuserlocationstart"));
                      }
                      switch (this._watchState) {
                        case "WAITING_ACTIVE":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active"
                            );
                          break;
                        case "ACTIVE_LOCK":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active"
                          );
                          break;
                        case "ACTIVE_ERROR":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active-error"
                            );
                          break;
                        case "BACKGROUND":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background"
                          );
                          break;
                        case "BACKGROUND_ERROR":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-background-error"
                            );
                      }
                      if (
                        "OFF" === this._watchState &&
                        void 0 !== this._geolocationWatchID
                      )
                        this._clearWatch();
                      else if (void 0 === this._geolocationWatchID) {
                        let f;
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting"
                        ),
                          this._geolocateButton.setAttribute(
                            "aria-pressed",
                            "true"
                          ),
                          this._numberOfWatches++,
                          this._numberOfWatches > 1
                            ? ((f = { maximumAge: 6e5, timeout: 0 }),
                              (this._noTimeout = !0))
                            : ((f = this.options.positionOptions),
                              (this._noTimeout = !1)),
                          (this._geolocationWatchID =
                            this.options.geolocation.watchPosition(
                              this._onSuccess,
                              this._onError,
                              f
                            )),
                          this.options.showUserHeading &&
                            this._addDeviceOrientationListener();
                      }
                    } else
                      this.options.geolocation.getCurrentPosition(
                        this._onSuccess,
                        this._onError,
                        this.options.positionOptions
                      ),
                        (this._timeoutId = setTimeout(this._finish, 1e4));
                    return !0;
                  }
                  _addDeviceOrientationListener() {
                    const f = () => {
                      d.window.addEventListener(
                        "ondeviceorientationabsolute" in d.window
                          ? "deviceorientationabsolute"
                          : "deviceorientation",
                        this._onDeviceOrientation
                      );
                    };
                    void 0 !== d.window.DeviceMotionEvent &&
                    "function" ==
                      typeof d.window.DeviceMotionEvent.requestPermission
                      ? DeviceOrientationEvent.requestPermission()
                          .then((a) => {
                            "granted" === a && f();
                          })
                          .catch(console.error)
                      : f();
                  }
                  _clearWatch() {
                    this.options.geolocation.clearWatch(
                      this._geolocationWatchID
                    ),
                      d.window.removeEventListener(
                        "deviceorientation",
                        this._onDeviceOrientation
                      ),
                      d.window.removeEventListener(
                        "deviceorientationabsolute",
                        this._onDeviceOrientation
                      ),
                      (this._geolocationWatchID = void 0),
                      this._geolocateButton.classList.remove(
                        "mapboxgl-ctrl-geolocate-waiting"
                      ),
                      this._geolocateButton.setAttribute(
                        "aria-pressed",
                        "false"
                      ),
                      this.options.showUserLocation && this._updateMarker(null);
                  }
                },
                AttributionControl: lt,
                ScaleControl: class {
                  constructor(f) {
                    (this.options = d.extend({}, Fu, f)),
                      (this._isNumberFormatSupported = (function () {
                        try {
                          return (
                            new Intl.NumberFormat("en", {
                              style: "unit",
                              unitDisplay: "short",
                              unit: "meter",
                            }),
                            !0
                          );
                        } catch {
                          return !1;
                        }
                      })()),
                      d.bindAll(["_update", "_setScale", "setUnit"], this);
                  }
                  getDefaultPosition() {
                    return "bottom-left";
                  }
                  _update() {
                    const f = this.options.maxWidth || 100,
                      a = this._map,
                      u = a._containerHeight / 2,
                      g = a._containerWidth / 2 - f / 2,
                      v = a.unproject([g, u]),
                      b = a.unproject([g + f, u]),
                      D = v.distanceTo(b);
                    if ("imperial" === this.options.unit) {
                      const S = 3.2808 * D;
                      S > 5280
                        ? this._setScale(f, S / 5280, "mile")
                        : this._setScale(f, S, "foot");
                    } else
                      "nautical" === this.options.unit
                        ? this._setScale(f, D / 1852, "nautical-mile")
                        : D >= 1e3
                        ? this._setScale(f, D / 1e3, "kilometer")
                        : this._setScale(f, D, "meter");
                  }
                  _setScale(f, a, u) {
                    this._map._requestDomTask(() => {
                      const g = (function (b) {
                          const D = Math.pow(10, `${Math.floor(b)}`.length - 1);
                          let S = b / D;
                          return (
                            (S =
                              S >= 10
                                ? 10
                                : S >= 5
                                ? 5
                                : S >= 3
                                ? 3
                                : S >= 2
                                ? 2
                                : S >= 1
                                ? 1
                                : (function (M) {
                                    const R = Math.pow(
                                      10,
                                      Math.ceil(-Math.log(M) / Math.LN10)
                                    );
                                    return Math.round(M * R) / R;
                                  })(S)),
                            D * S
                          );
                        })(a),
                        v = g / a;
                      (this._container.innerHTML =
                        this._isNumberFormatSupported && "nautical-mile" !== u
                          ? new Intl.NumberFormat(this._language, {
                              style: "unit",
                              unitDisplay: "short",
                              unit: u,
                            }).format(g)
                          : `${g}&nbsp;${Nu[u]}`),
                        (this._container.style.width = f * v + "px");
                    });
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      (this._language = f.getLanguage()),
                      (this._container = zt(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-scale",
                        f.getContainer()
                      )),
                      (this._container.dir = "auto"),
                      this._map.on("move", this._update),
                      this._update(),
                      this._container
                    );
                  }
                  onRemove() {
                    this._container.remove(),
                      this._map.off("move", this._update),
                      (this._map = void 0);
                  }
                  _setLanguage(f) {
                    (this._language = f), this._update();
                  }
                  setUnit(f) {
                    (this.options.unit = f), this._update();
                  }
                },
                FullscreenControl: class {
                  constructor(f) {
                    (this._fullscreen = !1),
                      f &&
                        f.container &&
                        (f.container instanceof d.window.HTMLElement
                          ? (this._container = f.container)
                          : d.warnOnce(
                              "Full screen control 'container' must be a DOM element."
                            )),
                      d.bindAll(["_onClickFullscreen", "_changeIcon"], this),
                      "onfullscreenchange" in d.window.document
                        ? (this._fullscreenchange = "fullscreenchange")
                        : "onwebkitfullscreenchange" in d.window.document &&
                          (this._fullscreenchange = "webkitfullscreenchange");
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      this._container ||
                        (this._container = this._map.getContainer()),
                      (this._controlContainer = zt(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group"
                      )),
                      this._checkFullscreenSupport()
                        ? this._setupUI()
                        : ((this._controlContainer.style.display = "none"),
                          d.warnOnce(
                            "This device does not support fullscreen mode."
                          )),
                      this._controlContainer
                    );
                  }
                  onRemove() {
                    this._controlContainer.remove(),
                      (this._map = null),
                      d.window.document.removeEventListener(
                        this._fullscreenchange,
                        this._changeIcon
                      );
                  }
                  _checkFullscreenSupport() {
                    return !(
                      !d.window.document.fullscreenEnabled &&
                      !d.window.document.webkitFullscreenEnabled
                    );
                  }
                  _setupUI() {
                    const f = (this._fullscreenButton = zt(
                      "button",
                      "mapboxgl-ctrl-fullscreen",
                      this._controlContainer
                    ));
                    zt("span", "mapboxgl-ctrl-icon", f).setAttribute(
                      "aria-hidden",
                      "true"
                    ),
                      (f.type = "button"),
                      this._updateTitle(),
                      this._fullscreenButton.addEventListener(
                        "click",
                        this._onClickFullscreen
                      ),
                      d.window.document.addEventListener(
                        this._fullscreenchange,
                        this._changeIcon
                      );
                  }
                  _updateTitle() {
                    const f = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", f),
                      this._fullscreenButton.firstElementChild &&
                        this._fullscreenButton.firstElementChild.setAttribute(
                          "title",
                          f
                        );
                  }
                  _getTitle() {
                    return this._map._getUIString(
                      this._isFullscreen()
                        ? "FullscreenControl.Exit"
                        : "FullscreenControl.Enter"
                    );
                  }
                  _isFullscreen() {
                    return this._fullscreen;
                  }
                  _changeIcon() {
                    ((d.window.document.fullscreenElement ||
                      d.window.document.webkitFullscreenElement) ===
                      this._container) !==
                      this._fullscreen &&
                      ((this._fullscreen = !this._fullscreen),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-shrink"
                      ),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-fullscreen"
                      ),
                      this._updateTitle());
                  }
                  _onClickFullscreen() {
                    this._isFullscreen()
                      ? d.window.document.exitFullscreen
                        ? d.window.document.exitFullscreen()
                        : d.window.document.webkitCancelFullScreen &&
                          d.window.document.webkitCancelFullScreen()
                      : this._container.requestFullscreen
                      ? this._container.requestFullscreen()
                      : this._container.webkitRequestFullscreen &&
                        this._container.webkitRequestFullscreen();
                  }
                },
                Popup: class extends d.Evented {
                  constructor(f) {
                    super(),
                      (this.options = d.extend(Object.create(Qh), f)),
                      d.bindAll(
                        ["_update", "_onClose", "remove", "_onMouseEvent"],
                        this
                      ),
                      (this._classList = new Set(
                        f && f.className ? f.className.trim().split(/\s+/) : []
                      ));
                  }
                  addTo(f) {
                    return (
                      this._map && this.remove(),
                      (this._map = f),
                      this.options.closeOnClick &&
                        f.on("preclick", this._onClose),
                      this.options.closeOnMove && f.on("move", this._onClose),
                      f.on("remove", this.remove),
                      this._update(),
                      f._addPopup(this),
                      this._focusFirstElement(),
                      this._trackPointer
                        ? (f.on("mousemove", this._onMouseEvent),
                          f.on("mouseup", this._onMouseEvent),
                          f._canvasContainer.classList.add(
                            "mapboxgl-track-pointer"
                          ))
                        : f.on("move", this._update),
                      this.fire(new d.Event("open")),
                      this
                    );
                  }
                  isOpen() {
                    return !!this._map;
                  }
                  remove() {
                    this._content && this._content.remove(),
                      this._container &&
                        (this._container.remove(), (this._container = void 0));
                    const f = this._map;
                    return (
                      f &&
                        (f.off("move", this._update),
                        f.off("move", this._onClose),
                        f.off("preclick", this._onClose),
                        f.off("click", this._onClose),
                        f.off("remove", this.remove),
                        f.off("mousemove", this._onMouseEvent),
                        f.off("mouseup", this._onMouseEvent),
                        f.off("drag", this._onMouseEvent),
                        f._canvasContainer &&
                          f._canvasContainer.classList.remove(
                            "mapboxgl-track-pointer"
                          ),
                        f._removePopup(this),
                        (this._map = void 0)),
                      this.fire(new d.Event("close")),
                      this
                    );
                  }
                  getLngLat() {
                    return this._lngLat;
                  }
                  setLngLat(f) {
                    (this._lngLat = d.LngLat.convert(f)),
                      (this._pos = null),
                      (this._trackPointer = !1),
                      this._update();
                    const a = this._map;
                    return (
                      a &&
                        (a.on("move", this._update),
                        a.off("mousemove", this._onMouseEvent),
                        a._canvasContainer.classList.remove(
                          "mapboxgl-track-pointer"
                        )),
                      this
                    );
                  }
                  trackPointer() {
                    (this._trackPointer = !0),
                      (this._pos = null),
                      this._update();
                    const f = this._map;
                    return (
                      f &&
                        (f.off("move", this._update),
                        f.on("mousemove", this._onMouseEvent),
                        f.on("drag", this._onMouseEvent),
                        f._canvasContainer.classList.add(
                          "mapboxgl-track-pointer"
                        )),
                      this
                    );
                  }
                  getElement() {
                    return this._container;
                  }
                  setText(f) {
                    return this.setDOMContent(
                      d.window.document.createTextNode(f)
                    );
                  }
                  setHTML(f) {
                    const a = d.window.document.createDocumentFragment(),
                      u = d.window.document.createElement("body");
                    let g;
                    for (u.innerHTML = f; (g = u.firstChild), g; )
                      a.appendChild(g);
                    return this.setDOMContent(a);
                  }
                  getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                  }
                  setMaxWidth(f) {
                    return (this.options.maxWidth = f), this._update(), this;
                  }
                  setDOMContent(f) {
                    let a = this._content;
                    if (a)
                      for (; a.hasChildNodes(); )
                        a.firstChild && a.removeChild(a.firstChild);
                    else
                      a = this._content = zt(
                        "div",
                        "mapboxgl-popup-content",
                        this._container || void 0
                      );
                    if ((a.appendChild(f), this.options.closeButton)) {
                      const u = (this._closeButton = zt(
                        "button",
                        "mapboxgl-popup-close-button",
                        a
                      ));
                      (u.type = "button"),
                        u.setAttribute("aria-label", "Close popup"),
                        u.setAttribute("aria-hidden", "true"),
                        (u.innerHTML = "&#215;"),
                        u.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                  }
                  addClassName(f) {
                    return (
                      this._classList.add(f), this._updateClassList(), this
                    );
                  }
                  removeClassName(f) {
                    return (
                      this._classList.delete(f), this._updateClassList(), this
                    );
                  }
                  setOffset(f) {
                    return (this.options.offset = f), this._update(), this;
                  }
                  toggleClassName(f) {
                    let a;
                    return (
                      this._classList.delete(f)
                        ? (a = !1)
                        : (this._classList.add(f), (a = !0)),
                      this._updateClassList(),
                      a
                    );
                  }
                  _onMouseEvent(f) {
                    this._update(f.point);
                  }
                  _getAnchor(f) {
                    if (this.options.anchor) return this.options.anchor;
                    const a = this._map,
                      u = this._container,
                      g = this._pos;
                    if (!a || !u || !g) return "bottom";
                    const v = u.offsetWidth,
                      b = u.offsetHeight,
                      D = g.x < v / 2,
                      S = g.x > a.transform.width - v / 2;
                    if (g.y + f < b)
                      return D ? "top-left" : S ? "top-right" : "top";
                    if (g.y > a.transform.height - b) {
                      if (D) return "bottom-left";
                      if (S) return "bottom-right";
                    }
                    return D ? "left" : S ? "right" : "bottom";
                  }
                  _updateClassList() {
                    const f = this._container;
                    if (!f) return;
                    const a = [...this._classList];
                    a.push("mapboxgl-popup"),
                      this._anchor &&
                        a.push(`mapboxgl-popup-anchor-${this._anchor}`),
                      this._trackPointer &&
                        a.push("mapboxgl-popup-track-pointer"),
                      (f.className = a.join(" "));
                  }
                  _update(f) {
                    const a = this._map,
                      u = this._content;
                    if (!a || (!this._lngLat && !this._trackPointer) || !u)
                      return;
                    let g = this._container;
                    if (
                      (g ||
                        ((g = this._container =
                          zt("div", "mapboxgl-popup", a.getContainer())),
                        (this._tip = zt("div", "mapboxgl-popup-tip", g)),
                        g.appendChild(u)),
                      this.options.maxWidth &&
                        g.style.maxWidth !== this.options.maxWidth &&
                        (g.style.maxWidth = this.options.maxWidth),
                      a.transform.renderWorldCopies &&
                        !this._trackPointer &&
                        (this._lngLat = Fr(
                          this._lngLat,
                          this._pos,
                          a.transform
                        )),
                      !this._trackPointer || f)
                    ) {
                      const v = (this._pos =
                          this._trackPointer && f
                            ? f
                            : a.project(this._lngLat)),
                        b = Ru(this.options.offset),
                        D = (this._anchor = this._getAnchor(b.y)),
                        S = Ru(this.options.offset, D),
                        M = v.add(S).round();
                      a._requestDomTask(() => {
                        this._container &&
                          D &&
                          (this._container.style.transform = `${Ga[D]} translate(${M.x}px,${M.y}px)`);
                      });
                    }
                    if (!this._marker && a._showingGlobe()) {
                      const v = d.isLngLatBehindGlobe(a.transform, this._lngLat)
                        ? 0
                        : 1;
                      this._setOpacity(v);
                    }
                    this._updateClassList();
                  }
                  _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container)
                      return;
                    const f = this._container.querySelector($f);
                    f && f.focus();
                  }
                  _onClose() {
                    this.remove();
                  }
                  _setOpacity(f) {
                    this._container && (this._container.style.opacity = `${f}`),
                      this._content &&
                        (this._content.style.pointerEvents = f
                          ? "auto"
                          : "none");
                  }
                },
                Marker: at,
                Style: vo,
                LngLat: d.LngLat,
                LngLatBounds: d.LngLatBounds,
                Point: d.Point,
                MercatorCoordinate: d.MercatorCoordinate,
                FreeCameraOptions: Bf,
                Evented: d.Evented,
                config: d.config,
                prewarm: function () {
                  ka().acquire(zo);
                },
                clearPrewarmedResources: function () {
                  const f = gr;
                  f &&
                    (f.isPreloaded() && 1 === f.numActive()
                      ? (f.release(zo), (gr = null))
                      : console.warn(
                          "Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"
                        ));
                },
                get accessToken() {
                  return d.config.ACCESS_TOKEN;
                },
                set accessToken(f) {
                  d.config.ACCESS_TOKEN = f;
                },
                get baseApiUrl() {
                  return d.config.API_URL;
                },
                set baseApiUrl(f) {
                  d.config.API_URL = f;
                },
                get workerCount() {
                  return Xn.workerCount;
                },
                set workerCount(f) {
                  Xn.workerCount = f;
                },
                get maxParallelImageRequests() {
                  return d.config.MAX_PARALLEL_IMAGE_REQUESTS;
                },
                set maxParallelImageRequests(f) {
                  d.config.MAX_PARALLEL_IMAGE_REQUESTS = f;
                },
                clearStorage(f) {
                  d.clearTileCache(f);
                },
                workerUrl: "",
                workerClass: null,
                setNow: d.exported.setNow,
                restoreNow: d.exported.restoreNow,
              };
            return qa;
          }),
          di
        );
      })();
    },
  },
  (Af) => {
    Af((Af.s = 93));
  },
]);
