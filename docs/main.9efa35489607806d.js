(self.webpackChunkostoo = self.webpackChunkostoo || []).push([
  [179],
  {
    196: (Af, ou, su) => {
      "use strict";
      function li(n) {
        return "function" == typeof n;
      }
      function rp(n) {
        const t = n((s) => {
          Error.call(s), (s.stack = new Error().stack);
        });
        return (
          (t.prototype = Object.create(Error.prototype)),
          (t.prototype.constructor = t),
          t
        );
      }
      const Pf = rp(
        (n) =>
          function (t) {
            n(this),
              (this.message = t
                ? `${t.length} errors occurred during unsubscription:\n${t
                    .map((s, c) => `${c + 1}) ${s.toString()}`)
                    .join("\n  ")}`
                : ""),
              (this.name = "UnsubscriptionError"),
              (this.errors = t);
          }
      );
      function d(n, e) {
        if (n) {
          const t = n.indexOf(e);
          0 <= t && n.splice(t, 1);
        }
      }
      class Be {
        constructor(e) {
          (this.initialTeardown = e),
            (this.closed = !1),
            (this._parentage = null),
            (this._finalizers = null);
        }
        unsubscribe() {
          let e;
          if (!this.closed) {
            this.closed = !0;
            const { _parentage: t } = this;
            if (t)
              if (((this._parentage = null), Array.isArray(t)))
                for (const p of t) p.remove(this);
              else t.remove(this);
            const { initialTeardown: s } = this;
            if (li(s))
              try {
                s();
              } catch (p) {
                e = p instanceof Pf ? p.errors : [p];
              }
            const { _finalizers: c } = this;
            if (c) {
              this._finalizers = null;
              for (const p of c)
                try {
                  zt(p);
                } catch (y) {
                  (e = e ?? []),
                    y instanceof Pf ? (e = [...e, ...y.errors]) : e.push(y);
                }
            }
            if (e) throw new Pf(e);
          }
        }
        add(e) {
          var t;
          if (e && e !== this)
            if (this.closed) zt(e);
            else {
              if (e instanceof Be) {
                if (e.closed || e._hasParent(this)) return;
                e._addParent(this);
              }
              (this._finalizers =
                null !== (t = this._finalizers) && void 0 !== t ? t : []).push(
                e
              );
            }
        }
        _hasParent(e) {
          const { _parentage: t } = this;
          return t === e || (Array.isArray(t) && t.includes(e));
        }
        _addParent(e) {
          const { _parentage: t } = this;
          this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
        }
        _removeParent(e) {
          const { _parentage: t } = this;
          t === e ? (this._parentage = null) : Array.isArray(t) && d(t, e);
        }
        remove(e) {
          const { _finalizers: t } = this;
          t && d(t, e), e instanceof Be && e._removeParent(this);
        }
      }
      Be.EMPTY = (() => {
        const n = new Be();
        return (n.closed = !0), n;
      })();
      const Oo = Be.EMPTY;
      function Jr(n) {
        return (
          n instanceof Be ||
          (n && "closed" in n && li(n.remove) && li(n.add) && li(n.unsubscribe))
        );
      }
      function zt(n) {
        li(n) ? n() : n.unsubscribe();
      }
      const Ot = {
          onUnhandledError: null,
          onStoppedNotification: null,
          Promise: void 0,
          useDeprecatedSynchronousErrorHandling: !1,
          useDeprecatedNextContext: !1,
        },
        Ii = {
          setTimeout(n, e, ...t) {
            const { delegate: s } = Ii;
            return s?.setTimeout
              ? s.setTimeout(n, e, ...t)
              : setTimeout(n, e, ...t);
          },
          clearTimeout(n) {
            const { delegate: e } = Ii;
            return (e?.clearTimeout || clearTimeout)(n);
          },
          delegate: void 0,
        };
      function pr(n) {
        Ii.setTimeout(() => {
          const { onUnhandledError: e } = Ot;
          if (!e) throw n;
          e(n);
        });
      }
      function Fo() {}
      const ns = Vr("C", void 0, void 0);
      function Vr(n, e, t) {
        return { kind: n, value: e, error: t };
      }
      let eo = null;
      function Ir(n) {
        if (Ot.useDeprecatedSynchronousErrorHandling) {
          const e = !eo;
          if ((e && (eo = { errorThrown: !1, error: null }), n(), e)) {
            const { errorThrown: t, error: s } = eo;
            if (((eo = null), t)) throw s;
          }
        } else n();
      }
      class is extends Be {
        constructor(e) {
          super(),
            (this.isStopped = !1),
            e
              ? ((this.destination = e), Jr(e) && e.add(this))
              : (this.destination = au);
        }
        static create(e, t, s) {
          return new Ia(e, t, s);
        }
        next(e) {
          this.isStopped
            ? sc(
                (function vl(n) {
                  return Vr("N", n, void 0);
                })(e),
                this
              )
            : this._next(e);
        }
        error(e) {
          this.isStopped
            ? sc(
                (function oc(n) {
                  return Vr("E", void 0, n);
                })(e),
                this
              )
            : ((this.isStopped = !0), this._error(e));
        }
        complete() {
          this.isStopped
            ? sc(ns, this)
            : ((this.isStopped = !0), this._complete());
        }
        unsubscribe() {
          this.closed ||
            ((this.isStopped = !0),
            super.unsubscribe(),
            (this.destination = null));
        }
        _next(e) {
          this.destination.next(e);
        }
        _error(e) {
          try {
            this.destination.error(e);
          } finally {
            this.unsubscribe();
          }
        }
        _complete() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }
      }
      const mo = Function.prototype.bind;
      function et(n, e) {
        return mo.call(n, e);
      }
      class Dh {
        constructor(e) {
          this.partialObserver = e;
        }
        next(e) {
          const { partialObserver: t } = this;
          if (t.next)
            try {
              t.next(e);
            } catch (s) {
              Xt(s);
            }
        }
        error(e) {
          const { partialObserver: t } = this;
          if (t.error)
            try {
              t.error(e);
            } catch (s) {
              Xt(s);
            }
          else Xt(e);
        }
        complete() {
          const { partialObserver: e } = this;
          if (e.complete)
            try {
              e.complete();
            } catch (t) {
              Xt(t);
            }
        }
      }
      class Ia extends is {
        constructor(e, t, s) {
          let c;
          if ((super(), li(e) || !e))
            c = {
              next: e ?? void 0,
              error: t ?? void 0,
              complete: s ?? void 0,
            };
          else {
            let p;
            this && Ot.useDeprecatedNextContext
              ? ((p = Object.create(e)),
                (p.unsubscribe = () => this.unsubscribe()),
                (c = {
                  next: e.next && et(e.next, p),
                  error: e.error && et(e.error, p),
                  complete: e.complete && et(e.complete, p),
                }))
              : (c = e);
          }
          this.destination = new Dh(c);
        }
      }
      function Xt(n) {
        Ot.useDeprecatedSynchronousErrorHandling
          ? (function Sa(n) {
              Ot.useDeprecatedSynchronousErrorHandling &&
                eo &&
                ((eo.errorThrown = !0), (eo.error = n));
            })(n)
          : pr(n);
      }
      function sc(n, e) {
        const { onStoppedNotification: t } = Ot;
        t && Ii.setTimeout(() => t(n, e));
      }
      const au = {
          closed: !0,
          next: Fo,
          error: function Oi(n) {
            throw n;
          },
          complete: Fo,
        },
        Ca =
          ("function" == typeof Symbol && Symbol.observable) || "@@observable";
      function ac(n) {
        return n;
      }
      let bn = (() => {
        class n {
          constructor(t) {
            t && (this._subscribe = t);
          }
          lift(t) {
            const s = new n();
            return (s.source = this), (s.operator = t), s;
          }
          subscribe(t, s, c) {
            const p = (function ci(n) {
              return (
                (n && n instanceof is) ||
                ((function Rs(n) {
                  return n && li(n.next) && li(n.error) && li(n.complete);
                })(n) &&
                  Jr(n))
              );
            })(t)
              ? t
              : new Ia(t, s, c);
            return (
              Ir(() => {
                const { operator: y, source: w } = this;
                p.add(
                  y
                    ? y.call(p, w)
                    : w
                    ? this._subscribe(p)
                    : this._trySubscribe(p)
                );
              }),
              p
            );
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t);
            } catch (s) {
              t.error(s);
            }
          }
          forEach(t, s) {
            return new (s = Ci(s))((c, p) => {
              const y = new Ia({
                next: (w) => {
                  try {
                    t(w);
                  } catch (S) {
                    p(S), y.unsubscribe();
                  }
                },
                error: p,
                complete: c,
              });
              this.subscribe(y);
            });
          }
          _subscribe(t) {
            var s;
            return null === (s = this.source) || void 0 === s
              ? void 0
              : s.subscribe(t);
          }
          [Ca]() {
            return this;
          }
          pipe(...t) {
            return (function Ma(n) {
              return 0 === n.length
                ? ac
                : 1 === n.length
                ? n[0]
                : function (t) {
                    return n.reduce((s, c) => c(s), t);
                  };
            })(t)(this);
          }
          toPromise(t) {
            return new (t = Ci(t))((s, c) => {
              let p;
              this.subscribe(
                (y) => (p = y),
                (y) => c(y),
                () => s(p)
              );
            });
          }
        }
        return (n.create = (e) => new n(e)), n;
      })();
      function Ci(n) {
        var e;
        return null !== (e = n ?? Ot.Promise) && void 0 !== e ? e : Promise;
      }
      const Os = rp(
        (n) =>
          function () {
            n(this),
              (this.name = "ObjectUnsubscribedError"),
              (this.message = "object unsubscribed");
          }
      );
      let rs = (() => {
        class n extends bn {
          constructor() {
            super(),
              (this.closed = !1),
              (this.currentObservers = null),
              (this.observers = []),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null);
          }
          lift(t) {
            const s = new os(this, this);
            return (s.operator = t), s;
          }
          _throwIfClosed() {
            if (this.closed) throw new Os();
          }
          next(t) {
            Ir(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.currentObservers ||
                  (this.currentObservers = Array.from(this.observers));
                for (const s of this.currentObservers) s.next(t);
              }
            });
          }
          error(t) {
            Ir(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                (this.hasError = this.isStopped = !0), (this.thrownError = t);
                const { observers: s } = this;
                for (; s.length; ) s.shift().error(t);
              }
            });
          }
          complete() {
            Ir(() => {
              if ((this._throwIfClosed(), !this.isStopped)) {
                this.isStopped = !0;
                const { observers: t } = this;
                for (; t.length; ) t.shift().complete();
              }
            });
          }
          unsubscribe() {
            (this.isStopped = this.closed = !0),
              (this.observers = this.currentObservers = null);
          }
          get observed() {
            var t;
            return (
              (null === (t = this.observers) || void 0 === t
                ? void 0
                : t.length) > 0
            );
          }
          _trySubscribe(t) {
            return this._throwIfClosed(), super._trySubscribe(t);
          }
          _subscribe(t) {
            return (
              this._throwIfClosed(),
              this._checkFinalizedStatuses(t),
              this._innerSubscribe(t)
            );
          }
          _innerSubscribe(t) {
            const { hasError: s, isStopped: c, observers: p } = this;
            return s || c
              ? Oo
              : ((this.currentObservers = null),
                p.push(t),
                new Be(() => {
                  (this.currentObservers = null), d(p, t);
                }));
          }
          _checkFinalizedStatuses(t) {
            const { hasError: s, thrownError: c, isStopped: p } = this;
            s ? t.error(c) : p && t.complete();
          }
          asObservable() {
            const t = new bn();
            return (t.source = this), t;
          }
        }
        return (n.create = (e, t) => new os(e, t)), n;
      })();
      class os extends rs {
        constructor(e, t) {
          super(), (this.destination = e), (this.source = t);
        }
        next(e) {
          var t, s;
          null ===
            (s =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.next) ||
            void 0 === s ||
            s.call(t, e);
        }
        error(e) {
          var t, s;
          null ===
            (s =
              null === (t = this.destination) || void 0 === t
                ? void 0
                : t.error) ||
            void 0 === s ||
            s.call(t, e);
        }
        complete() {
          var e, t;
          null ===
            (t =
              null === (e = this.destination) || void 0 === e
                ? void 0
                : e.complete) ||
            void 0 === t ||
            t.call(e);
        }
        _subscribe(e) {
          var t, s;
          return null !==
            (s =
              null === (t = this.source) || void 0 === t
                ? void 0
                : t.subscribe(e)) && void 0 !== s
            ? s
            : Oo;
        }
      }
      function Fs(n) {
        return (e) => {
          if (
            (function ss(n) {
              return li(n?.lift);
            })(e)
          )
            return e.lift(function (t) {
              try {
                return n(t, this);
              } catch (s) {
                this.error(s);
              }
            });
          throw new TypeError("Unable to lift unknown Observable type");
        };
      }
      function No(n, e, t, s, c) {
        return new xl(n, e, t, s, c);
      }
      class xl extends is {
        constructor(e, t, s, c, p, y) {
          super(e),
            (this.onFinalize = p),
            (this.shouldUnsubscribe = y),
            (this._next = t
              ? function (w) {
                  try {
                    t(w);
                  } catch (S) {
                    e.error(S);
                  }
                }
              : super._next),
            (this._error = c
              ? function (w) {
                  try {
                    c(w);
                  } catch (S) {
                    e.error(S);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._error),
            (this._complete = s
              ? function () {
                  try {
                    s();
                  } catch (w) {
                    e.error(w);
                  } finally {
                    this.unsubscribe();
                  }
                }
              : super._complete);
        }
        unsubscribe() {
          var e;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            const { closed: t } = this;
            super.unsubscribe(),
              !t &&
                (null === (e = this.onFinalize) ||
                  void 0 === e ||
                  e.call(this));
          }
        }
      }
      function io(n) {
        return this instanceof io ? ((this.v = n), this) : new io(n);
      }
      function Bs(n, e, t) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var c,
          s = t.apply(n, e || []),
          p = [];
        return (
          (c = {}),
          y("next"),
          y("throw"),
          y("return"),
          (c[Symbol.asyncIterator] = function () {
            return this;
          }),
          c
        );
        function y(Q) {
          s[Q] &&
            (c[Q] = function (ie) {
              return new Promise(function (pe, Ee) {
                p.push([Q, ie, pe, Ee]) > 1 || w(Q, ie);
              });
            });
        }
        function w(Q, ie) {
          try {
            !(function S(Q) {
              Q.value instanceof io
                ? Promise.resolve(Q.value.v).then(P, N)
                : j(p[0][2], Q);
            })(s[Q](ie));
          } catch (pe) {
            j(p[0][3], pe);
          }
        }
        function P(Q) {
          w("next", Q);
        }
        function N(Q) {
          w("throw", Q);
        }
        function j(Q, ie) {
          Q(ie), p.shift(), p.length && w(p[0][0], p[0][1]);
        }
      }
      function js(n) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t,
          e = n[Symbol.asyncIterator];
        return e
          ? e.call(n)
          : ((n = (function Cr(n) {
              var e = "function" == typeof Symbol && Symbol.iterator,
                t = e && n[e],
                s = 0;
              if (t) return t.call(n);
              if (n && "number" == typeof n.length)
                return {
                  next: function () {
                    return (
                      n && s >= n.length && (n = void 0),
                      { value: n && n[s++], done: !n }
                    );
                  },
                };
              throw new TypeError(
                e
                  ? "Object is not iterable."
                  : "Symbol.iterator is not defined."
              );
            })(n)),
            (t = {}),
            s("next"),
            s("throw"),
            s("return"),
            (t[Symbol.asyncIterator] = function () {
              return this;
            }),
            t);
        function s(p) {
          t[p] =
            n[p] &&
            function (y) {
              return new Promise(function (w, S) {
                !(function c(p, y, w, S) {
                  Promise.resolve(S).then(function (P) {
                    p({ value: P, done: w });
                  }, y);
                })(w, S, (y = n[p](y)).done, y.value);
              });
            };
        }
      }
      const me = (n) =>
        n && "number" == typeof n.length && "function" != typeof n;
      function ve(n) {
        return li(n?.then);
      }
      function ye(n) {
        return li(n[Ca]);
      }
      function fe(n) {
        return Symbol.asyncIterator && li(n?.[Symbol.asyncIterator]);
      }
      function Se(n) {
        return new TypeError(
          `You provided ${
            null !== n && "object" == typeof n ? "an invalid object" : `'${n}'`
          } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`
        );
      }
      const Qe = (function Ye() {
        return "function" == typeof Symbol && Symbol.iterator
          ? Symbol.iterator
          : "@@iterator";
      })();
      function We(n) {
        return li(n?.[Qe]);
      }
      function Pt(n) {
        return Bs(this, arguments, function* () {
          const t = n.getReader();
          try {
            for (;;) {
              const { value: s, done: c } = yield io(t.read());
              if (c) return yield io(void 0);
              yield yield io(s);
            }
          } finally {
            t.releaseLock();
          }
        });
      }
      function Bt(n) {
        return li(n?.getReader);
      }
      function Et(n) {
        if (n instanceof bn) return n;
        if (null != n) {
          if (ye(n))
            return (function Gt(n) {
              return new bn((e) => {
                const t = n[Ca]();
                if (li(t.subscribe)) return t.subscribe(e);
                throw new TypeError(
                  "Provided object does not correctly implement Symbol.observable"
                );
              });
            })(n);
          if (me(n))
            return (function tn(n) {
              return new bn((e) => {
                for (let t = 0; t < n.length && !e.closed; t++) e.next(n[t]);
                e.complete();
              });
            })(n);
          if (ve(n))
            return (function Gn(n) {
              return new bn((e) => {
                n.then(
                  (t) => {
                    e.closed || (e.next(t), e.complete());
                  },
                  (t) => e.error(t)
                ).then(null, pr);
              });
            })(n);
          if (fe(n)) return Xi(n);
          if (We(n))
            return (function ui(n) {
              return new bn((e) => {
                for (const t of n) if ((e.next(t), e.closed)) return;
                e.complete();
              });
            })(n);
          if (Bt(n))
            return (function wi(n) {
              return Xi(Pt(n));
            })(n);
        }
        throw Se(n);
      }
      function Xi(n) {
        return new bn((e) => {
          (function zo(n, e) {
            var t, s, c, p;
            return (function as(n, e, t, s) {
              return new (t || (t = Promise))(function (p, y) {
                function w(N) {
                  try {
                    P(s.next(N));
                  } catch (j) {
                    y(j);
                  }
                }
                function S(N) {
                  try {
                    P(s.throw(N));
                  } catch (j) {
                    y(j);
                  }
                }
                function P(N) {
                  N.done
                    ? p(N.value)
                    : (function c(p) {
                        return p instanceof t
                          ? p
                          : new t(function (y) {
                              y(p);
                            });
                      })(N.value).then(w, S);
                }
                P((s = s.apply(n, e || [])).next());
              });
            })(this, void 0, void 0, function* () {
              try {
                for (t = js(n); !(s = yield t.next()).done; )
                  if ((e.next(s.value), e.closed)) return;
              } catch (y) {
                c = { error: y };
              } finally {
                try {
                  s && !s.done && (p = t.return) && (yield p.call(t));
                } finally {
                  if (c) throw c.error;
                }
              }
              e.complete();
            });
          })(n, e).catch((t) => e.error(t));
        });
      }
      function qn(n, e, t, s = 0, c = !1) {
        const p = e.schedule(function () {
          t(), c ? n.add(this.schedule(null, s)) : this.unsubscribe();
        }, s);
        if ((n.add(p), !c)) return p;
      }
      function ka(n, e, t = 1 / 0) {
        return li(e)
          ? ka(
              (s, c) =>
                (function en(n, e) {
                  return Fs((t, s) => {
                    let c = 0;
                    t.subscribe(
                      No(s, (p) => {
                        s.next(n.call(e, p, c++));
                      })
                    );
                  });
                })((p, y) => e(s, p, c, y))(Et(n(s, c))),
              t
            )
          : ("number" == typeof e && (t = e),
            Fs((s, c) =>
              (function fr(n, e, t, s, c, p, y, w) {
                const S = [];
                let P = 0,
                  N = 0,
                  j = !1;
                const Q = () => {
                    j && !S.length && !P && e.complete();
                  },
                  ie = (Ee) => (P < s ? pe(Ee) : S.push(Ee)),
                  pe = (Ee) => {
                    p && e.next(Ee), P++;
                    let Oe = !1;
                    Et(t(Ee, N++)).subscribe(
                      No(
                        e,
                        (Ue) => {
                          c?.(Ue), p ? ie(Ue) : e.next(Ue);
                        },
                        () => {
                          Oe = !0;
                        },
                        void 0,
                        () => {
                          if (Oe)
                            try {
                              for (P--; S.length && P < s; ) {
                                const Ue = S.shift();
                                y ? qn(e, y, () => pe(Ue)) : pe(Ue);
                              }
                              Q();
                            } catch (Ue) {
                              e.error(Ue);
                            }
                        }
                      )
                    );
                  };
                return (
                  n.subscribe(
                    No(e, ie, () => {
                      (j = !0), Q();
                    })
                  ),
                  () => {
                    w?.();
                  }
                );
              })(s, c, n, t)
            ));
      }
      const Sh = new bn((n) => n.complete());
      function dc(n) {
        return n[n.length - 1];
      }
      function du(n, e = 0) {
        return Fs((t, s) => {
          t.subscribe(
            No(
              s,
              (c) => qn(s, n, () => s.next(c), e),
              () => qn(s, n, () => s.complete(), e),
              (c) => qn(s, n, () => s.error(c), e)
            )
          );
        });
      }
      function pu(n, e = 0) {
        return Fs((t, s) => {
          s.add(n.schedule(() => t.subscribe(s), e));
        });
      }
      function Vo(n, e) {
        if (!n) throw new Error("Iterable cannot be null");
        return new bn((t) => {
          qn(t, e, () => {
            const s = n[Symbol.asyncIterator]();
            qn(
              t,
              e,
              () => {
                s.next().then((c) => {
                  c.done ? t.complete() : t.next(c.value);
                });
              },
              0,
              !0
            );
          });
        });
      }
      function jo(...n) {
        const e = (function Bo(n) {
            return (function hc(n) {
              return n && li(n.schedule);
            })(dc(n))
              ? n.pop()
              : void 0;
          })(n),
          t = (function cs(n, e) {
            return "number" == typeof dc(n) ? n.pop() : e;
          })(n, 1 / 0),
          s = n;
        return s.length
          ? 1 === s.length
            ? Et(s[0])
            : (function Lf(n = 1 / 0) {
                return ka(ac, n);
              })(t)(
                (function op(n, e) {
                  return e
                    ? (function Fi(n, e) {
                        if (null != n) {
                          if (ye(n))
                            return (function Ra(n, e) {
                              return Et(n).pipe(pu(e), du(e));
                            })(n, e);
                          if (me(n))
                            return (function pc(n, e) {
                              return new bn((t) => {
                                let s = 0;
                                return e.schedule(function () {
                                  s === n.length
                                    ? t.complete()
                                    : (t.next(n[s++]),
                                      t.closed || this.schedule());
                                });
                              });
                            })(n, e);
                          if (ve(n))
                            return (function us(n, e) {
                              return Et(n).pipe(pu(e), du(e));
                            })(n, e);
                          if (fe(n)) return Vo(n, e);
                          if (We(n))
                            return (function Ae(n, e) {
                              return new bn((t) => {
                                let s;
                                return (
                                  qn(t, e, () => {
                                    (s = n[Qe]()),
                                      qn(
                                        t,
                                        e,
                                        () => {
                                          let c, p;
                                          try {
                                            ({ value: c, done: p } = s.next());
                                          } catch (y) {
                                            return void t.error(y);
                                          }
                                          p ? t.complete() : t.next(c);
                                        },
                                        0,
                                        !0
                                      );
                                  }),
                                  () => li(s?.return) && s.return()
                                );
                              });
                            })(n, e);
                          if (Bt(n))
                            return (function hi(n, e) {
                              return Vo(Pt(n), e);
                            })(n, e);
                        }
                        throw Se(n);
                      })(n, e)
                    : Et(n);
                })(s, e)
              )
          : Sh;
      }
      function fu(n, e, ...t) {
        if (!0 === e) return void n();
        if (!1 === e) return;
        const s = new Ia({
          next: () => {
            s.unsubscribe(), n();
          },
        });
        return e(...t).subscribe(s);
      }
      function wn(n) {
        for (let e in n) if (n[e] === wn) return e;
        throw Error("Could not find renamed property on target object.");
      }
      function _t(n) {
        if ("string" == typeof n) return n;
        if (Array.isArray(n)) return "[" + n.map(_t).join(", ") + "]";
        if (null == n) return "" + n;
        if (n.overriddenName) return `${n.overriddenName}`;
        if (n.name) return `${n.name}`;
        const e = n.toString();
        if (null == e) return "" + e;
        const t = e.indexOf("\n");
        return -1 === t ? e : e.substring(0, t);
      }
      function Vt(n, e) {
        return null == n || "" === n
          ? null === e
            ? ""
            : e
          : null == e || "" === e
          ? n
          : n + " " + e;
      }
      const Ur = wn({ __forward_ref__: wn });
      function Mr(n) {
        return (
          (n.__forward_ref__ = Mr),
          (n.toString = function () {
            return _t(this());
          }),
          n
        );
      }
      function tt(n) {
        return (function mr(n) {
          return (
            "function" == typeof n &&
            n.hasOwnProperty(Ur) &&
            n.__forward_ref__ === Mr
          );
        })(n)
          ? n()
          : n;
      }
      class rt extends Error {
        constructor(e, t) {
          super(
            (function gr(n, e) {
              return `NG0${Math.abs(n)}${e ? ": " + e.trim() : ""}`;
            })(e, t)
          ),
            (this.code = e);
        }
      }
      function pt(n) {
        return "string" == typeof n ? n : null == n ? "" : String(n);
      }
      function Dl(n, e) {
        throw new rt(-201, !1);
      }
      function un(n, e) {
        null == n &&
          (function pn(n, e, t, s) {
            throw new Error(
              `ASSERTION ERROR: ${n}` +
                (null == s ? "" : ` [Expected=> ${t} ${s} ${e} <=Actual]`)
            );
          })(e, n, null, "!=");
      }
      function Sn(n) {
        return {
          token: n.token,
          providedIn: n.providedIn || null,
          factory: n.factory,
          value: void 0,
        };
      }
      function Jn(n) {
        return { providers: n.providers || [], imports: n.imports || [] };
      }
      function _o(n) {
        return hp(n, Cl) || hp(n, Uo);
      }
      function hp(n, e) {
        return n.hasOwnProperty(e) ? n[e] : null;
      }
      function yo(n) {
        return n && (n.hasOwnProperty(ds) || n.hasOwnProperty(gc))
          ? n[ds]
          : null;
      }
      const Cl = wn({ ɵprov: wn }),
        ds = wn({ ɵinj: wn }),
        Uo = wn({ ngInjectableDef: wn }),
        gc = wn({ ngInjectorDef: wn });
      var Tt = (() => (
        ((Tt = Tt || {})[(Tt.Default = 0)] = "Default"),
        (Tt[(Tt.Host = 1)] = "Host"),
        (Tt[(Tt.Self = 2)] = "Self"),
        (Tt[(Tt.SkipSelf = 4)] = "SkipSelf"),
        (Tt[(Tt.Optional = 8)] = "Optional"),
        Tt
      ))();
      let Ml;
      function rr(n) {
        const e = Ml;
        return (Ml = n), e;
      }
      function kh(n, e, t) {
        const s = _o(n);
        return s && "root" == s.providedIn
          ? void 0 === s.value
            ? (s.value = s.factory())
            : s.value
          : t & Tt.Optional
          ? null
          : void 0 !== e
          ? e
          : void Dl(_t(n));
      }
      function $o(n) {
        return { toString: n }.toString();
      }
      var Hr = (() => (
          ((Hr = Hr || {})[(Hr.OnPush = 0)] = "OnPush"),
          (Hr[(Hr.Default = 1)] = "Default"),
          Hr
        ))(),
        vo = (() => {
          return (
            ((n = vo || (vo = {}))[(n.Emulated = 0)] = "Emulated"),
            (n[(n.None = 2)] = "None"),
            (n[(n.ShadowDom = 3)] = "ShadowDom"),
            vo
          );
          var n;
        })();
      const jn = (() =>
          (typeof globalThis < "u" && globalThis) ||
          (typeof global < "u" && global) ||
          (typeof window < "u" && window) ||
          (typeof self < "u" &&
            typeof WorkerGlobalScope < "u" &&
            self instanceof WorkerGlobalScope &&
            self))(),
        Oa = {},
        vn = [],
        ps = wn({ ɵcmp: wn }),
        Pl = wn({ ɵdir: wn }),
        Us = wn({ ɵpipe: wn }),
        Ho = wn({ ɵmod: wn }),
        _r = wn({ ɵfac: wn }),
        $s = wn({ __NG_ELEMENT_ID__: wn });
      let pp = 0;
      function xo(n) {
        return $o(() => {
          const t = !0 === n.standalone,
            s = {},
            c = {
              type: n.type,
              providersResolver: null,
              decls: n.decls,
              vars: n.vars,
              factory: null,
              template: n.template || null,
              consts: n.consts || null,
              ngContentSelectors: n.ngContentSelectors,
              hostBindings: n.hostBindings || null,
              hostVars: n.hostVars || 0,
              hostAttrs: n.hostAttrs || null,
              contentQueries: n.contentQueries || null,
              declaredInputs: s,
              inputs: null,
              outputs: null,
              exportAs: n.exportAs || null,
              onPush: n.changeDetection === Hr.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              standalone: t,
              dependencies: (t && n.dependencies) || null,
              getStandaloneInjector: null,
              selectors: n.selectors || vn,
              viewQuery: n.viewQuery || null,
              features: n.features || null,
              data: n.data || {},
              encapsulation: n.encapsulation || vo.Emulated,
              id: "c" + pp++,
              styles: n.styles || vn,
              _: null,
              setInput: null,
              schemas: n.schemas || null,
              tView: null,
            },
            p = n.dependencies,
            y = n.features;
          return (
            (c.inputs = rn(n.inputs, s)),
            (c.outputs = rn(n.outputs)),
            y && y.forEach((w) => w(c)),
            (c.directiveDefs = p
              ? () => ("function" == typeof p ? p() : p).map(vu).filter(yc)
              : null),
            (c.pipeDefs = p
              ? () => ("function" == typeof p ? p() : p).map(pi).filter(yc)
              : null),
            c
          );
        });
      }
      function vu(n) {
        return In(n) || sr(n);
      }
      function yc(n) {
        return null !== n;
      }
      function or(n) {
        return $o(() => ({
          type: n.type,
          bootstrap: n.bootstrap || vn,
          declarations: n.declarations || vn,
          imports: n.imports || vn,
          exports: n.exports || vn,
          transitiveCompileScopes: null,
          schemas: n.schemas || null,
          id: n.id || null,
        }));
      }
      function rn(n, e) {
        if (null == n) return Oa;
        const t = {};
        for (const s in n)
          if (n.hasOwnProperty(s)) {
            let c = n[s],
              p = c;
            Array.isArray(c) && ((p = c[1]), (c = c[0])),
              (t[c] = s),
              e && (e[c] = p);
          }
        return t;
      }
      const Mi = xo;
      function In(n) {
        return n[ps] || null;
      }
      function sr(n) {
        return n[Pl] || null;
      }
      function pi(n) {
        return n[Us] || null;
      }
      function xr(n) {
        return Array.isArray(n) && "object" == typeof n[1];
      }
      function ar(n) {
        return Array.isArray(n) && !0 === n[1];
      }
      function zh(n) {
        return 0 != (8 & n.flags);
      }
      function wu(n) {
        return 2 == (2 & n.flags);
      }
      function Eu(n) {
        return 1 == (1 & n.flags);
      }
      function wo(n) {
        return null !== n.template;
      }
      function Rf(n) {
        return 0 != (256 & n[2]);
      }
      function Ys(n, e) {
        return n.hasOwnProperty(_r) ? n[_r] : null;
      }
      class Iu {
        constructor(e, t, s) {
          (this.previousValue = e),
            (this.currentValue = t),
            (this.firstChange = s);
        }
        isFirstChange() {
          return this.firstChange;
        }
      }
      function Zo() {
        return Ba;
      }
      function Ba(n) {
        return n.type.prototype.ngOnChanges && (n.setInput = Ec), $h;
      }
      function $h() {
        const n = Tc(this),
          e = n?.current;
        if (e) {
          const t = n.previous;
          if (t === Oa) n.previous = e;
          else for (let s in e) t[s] = e[s];
          (n.current = null), this.ngOnChanges(e);
        }
      }
      function Ec(n, e, t, s) {
        const c =
            Tc(n) ||
            (function Cu(n, e) {
              return (n[Fl] = e);
            })(n, { previous: Oa, current: null }),
          p = c.current || (c.current = {}),
          y = c.previous,
          w = this.declaredInputs[t],
          S = y[w];
        (p[w] = new Iu(S && S.currentValue, e, y === Oa)), (n[s] = e);
      }
      Zo.ngInherit = !0;
      const Fl = "__ngSimpleChanges__";
      function Tc(n) {
        return n[Fl] || null;
      }
      function ti(n) {
        for (; Array.isArray(n); ) n = n[0];
        return n;
      }
      function ja(n, e) {
        return ti(e[n]);
      }
      function zi(n, e) {
        return ti(e[n.index]);
      }
      function qh(n, e) {
        return n.data[e];
      }
      function Bi(n, e) {
        const t = e[n];
        return xr(t) ? t : t[0];
      }
      function Nl(n) {
        return 64 == (64 & n[2]);
      }
      function Do(n, e) {
        return null == e ? null : n[e];
      }
      function zl(n) {
        n[18] = 0;
      }
      function $a(n, e) {
        n[5] += e;
        let t = n,
          s = n[3];
        for (
          ;
          null !== s && ((1 === e && 1 === t[5]) || (-1 === e && 0 === t[5]));

        )
          (s[5] += e), (t = s), (s = s[3]);
      }
      const Ft = { lFrame: Ou(null), bindingsEnabled: !0 };
      function Kh() {
        return Ft.bindingsEnabled;
      }
      function Ze() {
        return Ft.lFrame.lView;
      }
      function dn() {
        return Ft.lFrame.tView;
      }
      function Ha(n) {
        return (Ft.lFrame.contextLView = n), n[8];
      }
      function fi(n) {
        return (Ft.lFrame.contextLView = null), n;
      }
      function Pi() {
        let n = Yh();
        for (; null !== n && 64 === n.type; ) n = n.parent;
        return n;
      }
      function Yh() {
        return Ft.lFrame.currentTNode;
      }
      function Xo(n, e) {
        const t = Ft.lFrame;
        (t.currentTNode = n), (t.isParent = e);
      }
      function kr() {
        return Ft.lFrame.isParent;
      }
      function Au() {
        Ft.lFrame.isParent = !1;
      }
      function Vi() {
        const n = Ft.lFrame;
        let e = n.bindingRootIndex;
        return (
          -1 === e && (e = n.bindingRootIndex = n.tView.bindingStartIndex), e
        );
      }
      function ea() {
        return Ft.lFrame.bindingIndex++;
      }
      function Qh(n, e) {
        const t = Ft.lFrame;
        (t.bindingIndex = t.bindingRootIndex = n), Lu(e);
      }
      function Lu(n) {
        Ft.lFrame.currentDirectiveIndex = n;
      }
      function Jh() {
        return Ft.lFrame.currentQueryIndex;
      }
      function ku(n) {
        Ft.lFrame.currentQueryIndex = n;
      }
      function Hf(n) {
        const e = n[1];
        return 2 === e.type ? e.declTNode : 1 === e.type ? n[6] : null;
      }
      function vp(n, e, t) {
        if (t & Tt.SkipSelf) {
          let c = e,
            p = n;
          for (
            ;
            !((c = c.parent),
            null !== c ||
              t & Tt.Host ||
              ((c = Hf(p)), null === c || ((p = p[15]), 10 & c.type)));

          );
          if (null === c) return !1;
          (e = c), (n = p);
        }
        const s = (Ft.lFrame = Ru());
        return (s.currentTNode = e), (s.lView = n), !0;
      }
      function Mc(n) {
        const e = Ru(),
          t = n[1];
        (Ft.lFrame = e),
          (e.currentTNode = t.firstChild),
          (e.lView = n),
          (e.tView = t),
          (e.contextLView = n),
          (e.bindingIndex = t.bindingStartIndex),
          (e.inI18n = !1);
      }
      function Ru() {
        const n = Ft.lFrame,
          e = null === n ? null : n.child;
        return null === e ? Ou(n) : e;
      }
      function Ou(n) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: n,
          child: null,
          inI18n: !1,
        };
        return null !== n && (n.child = e), e;
      }
      function qa() {
        const n = Ft.lFrame;
        return (
          (Ft.lFrame = n.parent), (n.currentTNode = null), (n.lView = null), n
        );
      }
      const f = qa;
      function a() {
        const n = qa();
        (n.isParent = !0),
          (n.tView = null),
          (n.selectedIndex = -1),
          (n.contextLView = null),
          (n.elementDepthCount = 0),
          (n.currentDirectiveIndex = -1),
          (n.currentNamespace = null),
          (n.bindingRootIndex = -1),
          (n.bindingIndex = -1),
          (n.currentQueryIndex = 0);
      }
      function v() {
        return Ft.lFrame.selectedIndex;
      }
      function b(n) {
        Ft.lFrame.selectedIndex = n;
      }
      function D() {
        const n = Ft.lFrame;
        return qh(n.tView, n.selectedIndex);
      }
      function q(n, e) {
        for (let t = e.directiveStart, s = e.directiveEnd; t < s; t++) {
          const p = n.data[t].type.prototype,
            {
              ngAfterContentInit: y,
              ngAfterContentChecked: w,
              ngAfterViewInit: S,
              ngAfterViewChecked: P,
              ngOnDestroy: N,
            } = p;
          y && (n.contentHooks || (n.contentHooks = [])).push(-t, y),
            w &&
              ((n.contentHooks || (n.contentHooks = [])).push(t, w),
              (n.contentCheckHooks || (n.contentCheckHooks = [])).push(t, w)),
            S && (n.viewHooks || (n.viewHooks = [])).push(-t, S),
            P &&
              ((n.viewHooks || (n.viewHooks = [])).push(t, P),
              (n.viewCheckHooks || (n.viewCheckHooks = [])).push(t, P)),
            null != N && (n.destroyHooks || (n.destroyHooks = [])).push(t, N);
        }
      }
      function X(n, e, t) {
        B(n, e, 3, t);
      }
      function Z(n, e, t, s) {
        (3 & n[2]) === t && B(n, e, t, s);
      }
      function Y(n, e) {
        let t = n[2];
        (3 & t) === e && ((t &= 2047), (t += 1), (n[2] = t));
      }
      function B(n, e, t, s) {
        const p = s ?? -1,
          y = e.length - 1;
        let w = 0;
        for (let S = void 0 !== s ? 65535 & n[18] : 0; S < y; S++)
          if ("number" == typeof e[S + 1]) {
            if (((w = e[S]), null != s && w >= s)) break;
          } else
            e[S] < 0 && (n[18] += 65536),
              (w < p || -1 == p) &&
                (W(n, t, e, S), (n[18] = (4294901760 & n[18]) + S + 2)),
              S++;
      }
      function W(n, e, t, s) {
        const c = t[s] < 0,
          p = t[s + 1],
          w = n[c ? -t[s] : t[s]];
        if (c) {
          if (n[2] >> 11 < n[18] >> 16 && (3 & n[2]) === e) {
            n[2] += 2048;
            try {
              p.call(w);
            } finally {
            }
          }
        } else
          try {
            p.call(w);
          } finally {
          }
      }
      class te {
        constructor(e, t, s) {
          (this.factory = e),
            (this.resolving = !1),
            (this.canSeeViewProviders = t),
            (this.injectImpl = s);
        }
      }
      function Le(n, e, t) {
        let s = 0;
        for (; s < t.length; ) {
          const c = t[s];
          if ("number" == typeof c) {
            if (0 !== c) break;
            s++;
            const p = t[s++],
              y = t[s++],
              w = t[s++];
            n.setAttribute(e, y, w, p);
          } else {
            const p = c,
              y = t[++s];
            je(p) ? n.setProperty(e, p, y) : n.setAttribute(e, p, y), s++;
          }
        }
        return s;
      }
      function Ie(n) {
        return 3 === n || 4 === n || 6 === n;
      }
      function je(n) {
        return 64 === n.charCodeAt(0);
      }
      function we(n, e) {
        if (null !== e && 0 !== e.length)
          if (null === n || 0 === n.length) n = e.slice();
          else {
            let t = -1;
            for (let s = 0; s < e.length; s++) {
              const c = e[s];
              "number" == typeof c
                ? (t = c)
                : 0 === t ||
                  ke(n, t, c, null, -1 === t || 2 === t ? e[++s] : null);
            }
          }
        return n;
      }
      function ke(n, e, t, s, c) {
        let p = 0,
          y = n.length;
        if (-1 === e) y = -1;
        else
          for (; p < n.length; ) {
            const w = n[p++];
            if ("number" == typeof w) {
              if (w === e) {
                y = -1;
                break;
              }
              if (w > e) {
                y = p - 1;
                break;
              }
            }
          }
        for (; p < n.length; ) {
          const w = n[p];
          if ("number" == typeof w) break;
          if (w === t) {
            if (null === s) return void (null !== c && (n[p + 1] = c));
            if (s === n[p + 1]) return void (n[p + 2] = c);
          }
          p++, null !== s && p++, null !== c && p++;
        }
        -1 !== y && (n.splice(y, 0, e), (p = y + 1)),
          n.splice(p++, 0, t),
          null !== s && n.splice(p++, 0, s),
          null !== c && n.splice(p++, 0, c);
      }
      function He(n) {
        return -1 !== n;
      }
      function Ne(n) {
        return 32767 & n;
      }
      function dt(n, e) {
        let t = (function Xe(n) {
            return n >> 16;
          })(n),
          s = e;
        for (; t > 0; ) (s = s[15]), t--;
        return s;
      }
      let Dt = !0;
      function ct(n) {
        const e = Dt;
        return (Dt = n), e;
      }
      let ft = 0;
      const Yt = {};
      function fn(n, e) {
        const t = ji(n, e);
        if (-1 !== t) return t;
        const s = e[1];
        s.firstCreatePass &&
          ((n.injectorIndex = e.length),
          Tn(s.data, n),
          Tn(e, null),
          Tn(s.blueprint, null));
        const c = mi(n, e),
          p = n.injectorIndex;
        if (He(c)) {
          const y = Ne(c),
            w = dt(c, e),
            S = w[1].data;
          for (let P = 0; P < 8; P++) e[p + P] = w[y + P] | S[y + P];
        }
        return (e[p + 8] = c), p;
      }
      function Tn(n, e) {
        n.push(0, 0, 0, 0, 0, 0, 0, 0, e);
      }
      function ji(n, e) {
        return -1 === n.injectorIndex ||
          (n.parent && n.parent.injectorIndex === n.injectorIndex) ||
          null === e[n.injectorIndex + 8]
          ? -1
          : n.injectorIndex;
      }
      function mi(n, e) {
        if (n.parent && -1 !== n.parent.injectorIndex)
          return n.parent.injectorIndex;
        let t = 0,
          s = null,
          c = e;
        for (; null !== c; ) {
          if (((s = Nu(c)), null === s)) return -1;
          if ((t++, (c = c[15]), -1 !== s.injectorIndex))
            return s.injectorIndex | (t << 16);
        }
        return -1;
      }
      function br(n, e, t) {
        !(function kn(n, e, t) {
          let s;
          "string" == typeof t
            ? (s = t.charCodeAt(0) || 0)
            : t.hasOwnProperty($s) && (s = t[$s]),
            null == s && (s = t[$s] = ft++);
          const c = 255 & s;
          e.data[n + (c >> 5)] |= 1 << c;
        })(n, e, t);
      }
      function Un(n, e, t) {
        if (t & Tt.Optional || void 0 !== n) return n;
        Dl();
      }
      function Cn(n, e, t, s) {
        if (
          (t & Tt.Optional && void 0 === s && (s = null),
          0 == (t & (Tt.Self | Tt.Host)))
        ) {
          const c = n[9],
            p = rr(void 0);
          try {
            return c ? c.get(e, s, t & Tt.Optional) : kh(e, s, t & Tt.Optional);
          } finally {
            rr(p);
          }
        }
        return Un(s, 0, t);
      }
      function ln(n, e, t, s = Tt.Default, c) {
        if (null !== n) {
          if (1024 & e[2]) {
            const y = (function Ac(n, e, t, s, c) {
              let p = n,
                y = e;
              for (
                ;
                null !== p && null !== y && 1024 & y[2] && !(256 & y[2]);

              ) {
                const w = ni(p, y, t, s | Tt.Self, Yt);
                if (w !== Yt) return w;
                let S = p.parent;
                if (!S) {
                  const P = y[21];
                  if (P) {
                    const N = P.get(t, Yt, s);
                    if (N !== Yt) return N;
                  }
                  (S = Nu(y)), (y = y[15]);
                }
                p = S;
              }
              return c;
            })(n, e, t, s, Yt);
            if (y !== Yt) return y;
          }
          const p = ni(n, e, t, s, Yt);
          if (p !== Yt) return p;
        }
        return Cn(e, t, s, c);
      }
      function ni(n, e, t, s, c) {
        const p = (function Fu(n) {
          if ("string" == typeof n) return n.charCodeAt(0) || 0;
          const e = n.hasOwnProperty($s) ? n[$s] : void 0;
          return "number" == typeof e ? (e >= 0 ? 255 & e : na) : e;
        })(t);
        if ("function" == typeof p) {
          if (!vp(e, n, s)) return s & Tt.Host ? Un(c, 0, s) : Cn(e, t, s, c);
          try {
            const y = p(s);
            if (null != y || s & Tt.Optional) return y;
            Dl();
          } finally {
            f();
          }
        } else if ("number" == typeof p) {
          let y = null,
            w = ji(n, e),
            S = -1,
            P = s & Tt.Host ? e[16][6] : null;
          for (
            (-1 === w || s & Tt.SkipSelf) &&
            ((S = -1 === w ? mi(n, e) : e[w + 8]),
            -1 !== S && Bl(s, !1)
              ? ((y = e[1]), (w = Ne(S)), (e = dt(S, e)))
              : (w = -1));
            -1 !== w;

          ) {
            const N = e[1];
            if (ta(p, w, N.data)) {
              const j = wr(w, e, t, y, s, P);
              if (j !== Yt) return j;
            }
            (S = e[w + 8]),
              -1 !== S && Bl(s, e[1].data[w + 8] === P) && ta(p, w, e)
                ? ((y = N), (w = Ne(S)), (e = dt(S, e)))
                : (w = -1);
          }
        }
        return c;
      }
      function wr(n, e, t, s, c, p) {
        const y = e[1],
          w = y.data[n + 8],
          N = Rn(
            w,
            y,
            t,
            null == s ? wu(w) && Dt : s != y && 0 != (3 & w.type),
            c & Tt.Host && p === w
          );
        return null !== N ? Ui(e, y, N, w) : Yt;
      }
      function Rn(n, e, t, s, c) {
        const p = n.providerIndexes,
          y = e.data,
          w = 1048575 & p,
          S = n.directiveStart,
          N = p >> 20,
          Q = c ? w + N : n.directiveEnd;
        for (let ie = s ? w : w + N; ie < Q; ie++) {
          const pe = y[ie];
          if ((ie < S && t === pe) || (ie >= S && pe.type === t)) return ie;
        }
        if (c) {
          const ie = y[S];
          if (ie && wo(ie) && ie.type === t) return S;
        }
        return null;
      }
      function Ui(n, e, t, s) {
        let c = n[t];
        const p = e.data;
        if (
          (function he(n) {
            return n instanceof te;
          })(c)
        ) {
          const y = c;
          y.resolving &&
            (function hs(n, e) {
              const t = e ? `. Dependency path: ${e.join(" > ")} > ${n}` : "";
              throw new rt(
                -200,
                `Circular dependency in DI detected for ${n}${t}`
              );
            })(
              (function En(n) {
                return "function" == typeof n
                  ? n.name || n.toString()
                  : "object" == typeof n &&
                    null != n &&
                    "function" == typeof n.type
                  ? n.type.name || n.type.toString()
                  : pt(n);
              })(p[t])
            );
          const w = ct(y.canSeeViewProviders);
          y.resolving = !0;
          const S = y.injectImpl ? rr(y.injectImpl) : null;
          vp(n, s, Tt.Default);
          try {
            (c = n[t] = y.factory(void 0, p, n, s)),
              e.firstCreatePass &&
                t >= s.directiveStart &&
                (function H(n, e, t) {
                  const {
                    ngOnChanges: s,
                    ngOnInit: c,
                    ngDoCheck: p,
                  } = e.type.prototype;
                  if (s) {
                    const y = Ba(e);
                    (t.preOrderHooks || (t.preOrderHooks = [])).push(n, y),
                      (
                        t.preOrderCheckHooks || (t.preOrderCheckHooks = [])
                      ).push(n, y);
                  }
                  c &&
                    (t.preOrderHooks || (t.preOrderHooks = [])).push(0 - n, c),
                    p &&
                      ((t.preOrderHooks || (t.preOrderHooks = [])).push(n, p),
                      (
                        t.preOrderCheckHooks || (t.preOrderCheckHooks = [])
                      ).push(n, p));
                })(t, p[t], e);
          } finally {
            null !== S && rr(S), ct(w), (y.resolving = !1), f();
          }
        }
        return c;
      }
      function ta(n, e, t) {
        return !!(t[e + (n >> 5)] & (1 << n));
      }
      function Bl(n, e) {
        return !(n & Tt.Self || (n & Tt.Host && e));
      }
      class Or {
        constructor(e, t) {
          (this._tNode = e), (this._lView = t);
        }
        get(e, t, s) {
          return ln(this._tNode, this._lView, e, s, t);
        }
      }
      function na() {
        return new Or(Pi(), Ze());
      }
      function Nu(n) {
        const e = n[1],
          t = e.type;
        return 2 === t ? e.declTNode : 1 === t ? n[6] : null;
      }
      const zu = "__parameters__";
      function Ul(n, e, t) {
        return $o(() => {
          const s = (function bp(n) {
            return function (...t) {
              if (n) {
                const s = n(...t);
                for (const c in s) this[c] = s[c];
              }
            };
          })(e);
          function c(...p) {
            if (this instanceof c) return s.apply(this, p), this;
            const y = new c(...p);
            return (w.annotation = y), w;
            function w(S, P, N) {
              const j = S.hasOwnProperty(zu)
                ? S[zu]
                : Object.defineProperty(S, zu, { value: [] })[zu];
              for (; j.length <= N; ) j.push(null);
              return (j[N] = j[N] || []).push(y), S;
            }
          }
          return (
            t && (c.prototype = Object.create(t.prototype)),
            (c.prototype.ngMetadataName = n),
            (c.annotationCls = c),
            c
          );
        });
      }
      class nn {
        constructor(e, t) {
          (this._desc = e),
            (this.ngMetadataName = "InjectionToken"),
            (this.ɵprov = void 0),
            "number" == typeof t
              ? (this.__NG_ELEMENT_ID__ = t)
              : void 0 !== t &&
                (this.ɵprov = Sn({
                  token: this,
                  providedIn: t.providedIn || "root",
                  factory: t.factory,
                }));
        }
        get multi() {
          return this;
        }
        toString() {
          return `InjectionToken ${this._desc}`;
        }
      }
      function Io(n, e) {
        void 0 === e && (e = n);
        for (let t = 0; t < n.length; t++) {
          let s = n[t];
          Array.isArray(s)
            ? (e === n && (e = n.slice(0, t)), Io(s, e))
            : e !== n && e.push(s);
        }
        return e;
      }
      function Xa(n, e) {
        n.forEach((t) => (Array.isArray(t) ? Xa(t, e) : e(t)));
      }
      function qf(n, e, t) {
        e >= n.length ? n.push(t) : n.splice(e, 0, t);
      }
      function td(n, e) {
        return e >= n.length - 1 ? n.pop() : n.splice(e, 1)[0];
      }
      function Zr(n, e) {
        const t = [];
        for (let s = 0; s < n; s++) t.push(e);
        return t;
      }
      function Xn(n, e, t) {
        let s = kc(n, e);
        return (
          s >= 0
            ? (n[1 | s] = t)
            : ((s = ~s),
              (function gi(n, e, t, s) {
                let c = n.length;
                if (c == e) n.push(t, s);
                else if (1 === c) n.push(s, n[0]), (n[0] = t);
                else {
                  for (c--, n.push(n[c - 1], n[c]); c > e; )
                    (n[c] = n[c - 2]), c--;
                  (n[e] = t), (n[e + 1] = s);
                }
              })(n, s, e, t)),
          s
        );
      }
      function Ep(n, e) {
        const t = kc(n, e);
        if (t >= 0) return n[1 | t];
      }
      function kc(n, e) {
        return (function Tp(n, e, t) {
          let s = 0,
            c = n.length >> t;
          for (; c !== s; ) {
            const p = s + ((c - s) >> 1),
              y = n[p << t];
            if (e === y) return p << t;
            y > e ? (c = p) : (s = p + 1);
          }
          return ~(c << t);
        })(n, e, 1);
      }
      const Bu = {},
        Fc = "__NG_DI_FLAG__",
        Ka = "ngTempTokenPath",
        Zf = /\n/gm,
        Vu = "__source";
      let Qa;
      function lr(n) {
        const e = Qa;
        return (Qa = n), e;
      }
      function rd(n, e = Tt.Default) {
        if (void 0 === Qa) throw new rt(-203, !1);
        return null === Qa
          ? kh(n, void 0, e)
          : Qa.get(n, e & Tt.Optional ? null : void 0, e);
      }
      function St(n, e = Tt.Default) {
        return (
          (function Al() {
            return Ml;
          })() || rd
        )(tt(n), e);
      }
      function Kn(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) {
          const s = tt(n[t]);
          if (Array.isArray(s)) {
            if (0 === s.length) throw new rt(900, !1);
            let c,
              p = Tt.Default;
            for (let y = 0; y < s.length; y++) {
              const w = s[y],
                S = od(w);
              "number" == typeof S
                ? -1 === S
                  ? (c = w.token)
                  : (p |= S)
                : (c = w);
            }
            e.push(St(c, p));
          } else e.push(St(s));
        }
        return e;
      }
      function ju(n, e) {
        return (n[Fc] = e), (n.prototype[Fc] = e), n;
      }
      function od(n) {
        return n[Fc];
      }
      const sd = ju(Ul("Optional"), 8),
        aa = ju(Ul("SkipSelf"), 4);
      var Yi = (() => (
        ((Yi = Yi || {})[(Yi.Important = 1)] = "Important"),
        (Yi[(Yi.DashCase = 2)] = "DashCase"),
        Yi
      ))();
      const rm = new Map();
      let pd = 0;
      const $i = "__ngContext__";
      function Er(n, e) {
        xr(e)
          ? ((n[$i] = e[20]),
            (function Hl(n) {
              rm.set(n[20], n);
            })(e))
          : (n[$i] = e);
      }
      function Wu(n, e) {
        return undefined(n, e);
      }
      function fd(n) {
        const e = n[3];
        return ar(e) ? e[3] : e;
      }
      function md(n) {
        return Rp(n[13]);
      }
      function dm(n) {
        return Rp(n[4]);
      }
      function Rp(n) {
        for (; null !== n && !ar(n); ) n = n[4];
        return n;
      }
      function zc(n, e, t, s, c) {
        if (null != s) {
          let p,
            y = !1;
          ar(s) ? (p = s) : xr(s) && ((y = !0), (s = s[0]));
          const w = ti(s);
          0 === n && null !== t
            ? null == c
              ? Kr(e, t, w)
              : Xr(e, t, w, c || null, !0)
            : 1 === n && null !== t
            ? Xr(e, t, w, c || null, !0)
            : 2 === n
            ? (function vm(n, e, t) {
                const s = zp(n, e);
                s &&
                  (function gm(n, e, t, s) {
                    n.removeChild(e, t, s);
                  })(n, s, e, t);
              })(e, w, y)
            : 3 === n && e.destroyNode(w),
            null != p &&
              (function Xu(n, e, t, s, c) {
                const p = t[7];
                p !== ti(t) && zc(e, n, s, p, c);
                for (let w = 10; w < t.length; w++) {
                  const S = t[w];
                  _d(S[1], S, n, e, s, p);
                }
              })(e, n, p, t, c);
        }
      }
      function Gl(n, e, t) {
        return n.createElement(e, t);
      }
      function s_(n, e) {
        const t = n[9],
          s = t.indexOf(e),
          c = e[3];
        512 & e[2] && ((e[2] &= -513), $a(c, -1)), t.splice(s, 1);
      }
      function Fp(n, e) {
        if (n.length <= 10) return;
        const t = 10 + e,
          s = n[t];
        if (s) {
          const c = s[17];
          null !== c && c !== n && s_(c, s), e > 0 && (n[t - 1][4] = s[4]);
          const p = td(n, 10 + e);
          !(function Op(n, e) {
            _d(n, e, e[11], 2, null, null), (e[0] = null), (e[6] = null);
          })(s[1], s);
          const y = p[19];
          null !== y && y.detachView(p[1]),
            (s[3] = null),
            (s[4] = null),
            (s[2] &= -65);
        }
        return s;
      }
      function a_(n, e) {
        if (!(128 & e[2])) {
          const t = e[11];
          t.destroyNode && _d(n, e, t, 3, null, null),
            (function Cv(n) {
              let e = n[13];
              if (!e) return fm(n[1], n);
              for (; e; ) {
                let t = null;
                if (xr(e)) t = e[13];
                else {
                  const s = e[10];
                  s && (t = s);
                }
                if (!t) {
                  for (; e && !e[4] && e !== n; )
                    xr(e) && fm(e[1], e), (e = e[3]);
                  null === e && (e = n), xr(e) && fm(e[1], e), (t = e && e[4]);
                }
                e = t;
              }
            })(e);
        }
      }
      function fm(n, e) {
        if (!(128 & e[2])) {
          (e[2] &= -65),
            (e[2] |= 128),
            (function c_(n, e) {
              let t;
              if (null != n && null != (t = n.destroyHooks))
                for (let s = 0; s < t.length; s += 2) {
                  const c = e[t[s]];
                  if (!(c instanceof te)) {
                    const p = t[s + 1];
                    if (Array.isArray(p))
                      for (let y = 0; y < p.length; y += 2) {
                        const w = c[p[y]],
                          S = p[y + 1];
                        try {
                          S.call(w);
                        } finally {
                        }
                      }
                    else
                      try {
                        p.call(c);
                      } finally {
                      }
                  }
                }
            })(n, e),
            (function l_(n, e) {
              const t = n.cleanup,
                s = e[7];
              let c = -1;
              if (null !== t)
                for (let p = 0; p < t.length - 1; p += 2)
                  if ("string" == typeof t[p]) {
                    const y = t[p + 1],
                      w = "function" == typeof y ? y(e) : ti(e[y]),
                      S = s[(c = t[p + 2])],
                      P = t[p + 3];
                    "boolean" == typeof P
                      ? w.removeEventListener(t[p], S, P)
                      : P >= 0
                      ? s[(c = P)]()
                      : s[(c = -P)].unsubscribe(),
                      (p += 2);
                  } else {
                    const y = s[(c = t[p + 1])];
                    t[p].call(y);
                  }
              if (null !== s) {
                for (let p = c + 1; p < s.length; p++) (0, s[p])();
                e[7] = null;
              }
            })(n, e),
            1 === e[1].type && e[11].destroy();
          const t = e[17];
          if (null !== t && ar(e[3])) {
            t !== e[3] && s_(t, e);
            const s = e[19];
            null !== s && s.detachView(n);
          }
          !(function om(n) {
            rm.delete(n[20]);
          })(e);
        }
      }
      function mm(n, e, t) {
        return (function Np(n, e, t) {
          let s = e;
          for (; null !== s && 40 & s.type; ) s = (e = s).parent;
          if (null === s) return t[0];
          if (2 & s.flags) {
            const c = n.data[s.directiveStart].encapsulation;
            if (c === vo.None || c === vo.Emulated) return null;
          }
          return zi(s, t);
        })(n, e.parent, t);
      }
      function Xr(n, e, t, s, c) {
        n.insertBefore(e, t, s, c);
      }
      function Kr(n, e, t) {
        n.appendChild(e, t);
      }
      function u_(n, e, t, s, c) {
        null !== s ? Xr(n, e, t, s, c) : Kr(n, e, t);
      }
      function zp(n, e) {
        return n.parentNode(e);
      }
      function Bp(n, e, t) {
        return _m(n, e, t);
      }
      let bd,
        _m = function gd(n, e, t) {
          return 40 & n.type ? zi(n, t) : null;
        };
      function Vp(n, e, t, s) {
        const c = mm(n, s, e),
          p = e[11],
          w = Bp(s.parent || e[6], s, e);
        if (null != c)
          if (Array.isArray(t))
            for (let S = 0; S < t.length; S++) u_(p, c, t[S], w, !1);
          else u_(p, c, t, w, !1);
      }
      function jp(n, e) {
        if (null !== e) {
          const t = e.type;
          if (3 & t) return zi(e, n);
          if (4 & t) return ym(-1, n[e.index]);
          if (8 & t) {
            const s = e.child;
            if (null !== s) return jp(n, s);
            {
              const c = n[e.index];
              return ar(c) ? ym(-1, c) : ti(c);
            }
          }
          if (32 & t) return Wu(e, n)() || ti(n[e.index]);
          {
            const s = h_(n, e);
            return null !== s
              ? Array.isArray(s)
                ? s[0]
                : jp(fd(n[16]), s)
              : jp(n, e.next);
          }
        }
        return null;
      }
      function h_(n, e) {
        return null !== e ? n[16][6].projection[e.projection] : null;
      }
      function ym(n, e) {
        const t = 10 + n + 1;
        if (t < e.length) {
          const s = e[t],
            c = s[1].firstChild;
          if (null !== c) return jp(s, c);
        }
        return e[7];
      }
      function xm(n, e, t, s, c, p, y) {
        for (; null != t; ) {
          const w = s[t.index],
            S = t.type;
          if (
            (y && 0 === e && (w && Er(ti(w), s), (t.flags |= 4)),
            64 != (64 & t.flags))
          )
            if (8 & S) xm(n, e, t.child, s, c, p, !1), zc(e, n, c, w, p);
            else if (32 & S) {
              const P = Wu(t, s);
              let N;
              for (; (N = P()); ) zc(e, n, c, N, p);
              zc(e, n, c, w, p);
            } else 16 & S ? d_(n, e, s, t, c, p) : zc(e, n, c, w, p);
          t = y ? t.projectionNext : t.next;
        }
      }
      function _d(n, e, t, s, c, p) {
        xm(t, s, n.firstChild, e, c, p, !1);
      }
      function d_(n, e, t, s, c, p) {
        const y = t[16],
          S = y[6].projection[s.projection];
        if (Array.isArray(S))
          for (let P = 0; P < S.length; P++) zc(e, n, c, S[P], p);
        else xm(n, e, S, y[3], c, p, !0);
      }
      function ri(n, e, t) {
        n.setAttribute(e, "style", t);
      }
      function Ku(n, e, t) {
        "" === t
          ? n.removeAttribute(e, "class")
          : n.setAttribute(e, "class", t);
      }
      const C_ = new nn("ENVIRONMENT_INITIALIZER"),
        Ad = new nn("INJECTOR", -1),
        M_ = new nn("INJECTOR_DEF_TYPES");
      class Mm {
        get(e, t = Bu) {
          if (t === Bu) {
            const s = new Error(`NullInjectorError: No provider for ${_t(e)}!`);
            throw ((s.name = "NullInjectorError"), s);
          }
          return t;
        }
      }
      function A_(...n) {
        return { ɵproviders: Am(0, n) };
      }
      function Am(n, ...e) {
        const t = [],
          s = new Set();
        let c;
        return (
          Xa(e, (p) => {
            const y = p;
            Pm(y, t, [], s) && (c || (c = []), c.push(y));
          }),
          void 0 !== c && P_(c, t),
          t
        );
      }
      function P_(n, e) {
        for (let t = 0; t < n.length; t++) {
          const { providers: c } = n[t];
          Xa(c, (p) => {
            e.push(p);
          });
        }
      }
      function Pm(n, e, t, s) {
        if (!(n = tt(n))) return !1;
        let c = null,
          p = yo(n);
        const y = !p && In(n);
        if (p || y) {
          if (y && !y.standalone) return !1;
          c = n;
        } else {
          const S = n.ngModule;
          if (((p = yo(S)), !p)) return !1;
          c = S;
        }
        const w = s.has(c);
        if (y) {
          if (w) return !1;
          if ((s.add(c), y.dependencies)) {
            const S =
              "function" == typeof y.dependencies
                ? y.dependencies()
                : y.dependencies;
            for (const P of S) Pm(P, e, t, s);
          }
        } else {
          if (!p) return !1;
          {
            if (null != p.imports && !w) {
              let P;
              s.add(c);
              try {
                Xa(p.imports, (N) => {
                  Pm(N, e, t, s) && (P || (P = []), P.push(N));
                });
              } finally {
              }
              void 0 !== P && P_(P, e);
            }
            if (!w) {
              const P = Ys(c) || (() => new c());
              e.push(
                { provide: c, useFactory: P, deps: vn },
                { provide: M_, useValue: c, multi: !0 },
                { provide: C_, useValue: () => St(c), multi: !0 }
              );
            }
            const S = p.providers;
            null == S ||
              w ||
              Xa(S, (N) => {
                e.push(N);
              });
          }
        }
        return c !== n && void 0 !== n.providers;
      }
      const $v = wn({ provide: String, useValue: wn });
      function Lm(n) {
        return null !== n && "object" == typeof n && $v in n;
      }
      function Qn(n) {
        return "function" == typeof n;
      }
      const Pd = new nn("Set Injector scope."),
        jc = {},
        eh = {};
      let Rm;
      function Yp() {
        return void 0 === Rm && (Rm = new Mm()), Rm;
      }
      class da {}
      class k_ extends da {
        constructor(e, t, s, c) {
          super(),
            (this.parent = t),
            (this.source = s),
            (this.scopes = c),
            (this.records = new Map()),
            (this._ngOnDestroyHooks = new Set()),
            (this._onDestroyHooks = []),
            (this._destroyed = !1),
            Wl(e, (y) => this.processProvider(y)),
            this.records.set(Ad, mn(void 0, this)),
            c.has("environment") && this.records.set(da, mn(void 0, this));
          const p = this.records.get(Pd);
          null != p && "string" == typeof p.value && this.scopes.add(p.value),
            (this.injectorDefTypes = new Set(this.get(M_.multi, vn, Tt.Self)));
        }
        get destroyed() {
          return this._destroyed;
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0);
          try {
            for (const e of this._ngOnDestroyHooks) e.ngOnDestroy();
            for (const e of this._onDestroyHooks) e();
          } finally {
            this.records.clear(),
              this._ngOnDestroyHooks.clear(),
              this.injectorDefTypes.clear(),
              (this._onDestroyHooks.length = 0);
          }
        }
        onDestroy(e) {
          this._onDestroyHooks.push(e);
        }
        runInContext(e) {
          this.assertNotDestroyed();
          const t = lr(this),
            s = rr(void 0);
          try {
            return e();
          } finally {
            lr(t), rr(s);
          }
        }
        get(e, t = Bu, s = Tt.Default) {
          this.assertNotDestroyed();
          const c = lr(this),
            p = rr(void 0);
          try {
            if (!(s & Tt.SkipSelf)) {
              let w = this.records.get(e);
              if (void 0 === w) {
                const S =
                  (function N_(n) {
                    return (
                      "function" == typeof n ||
                      ("object" == typeof n && n instanceof nn)
                    );
                  })(e) && _o(e);
                (w = S && this.injectableDefInScope(S) ? mn(Om(e), jc) : null),
                  this.records.set(e, w);
              }
              if (null != w) return this.hydrate(e, w);
            }
            return (s & Tt.Self ? Yp() : this.parent).get(
              e,
              (t = s & Tt.Optional && t === Bu ? null : t)
            );
          } catch (y) {
            if ("NullInjectorError" === y.name) {
              if (((y[Ka] = y[Ka] || []).unshift(_t(e)), c)) throw y;
              return (function _s(n, e, t, s) {
                const c = n[Ka];
                throw (
                  (e[Vu] && c.unshift(e[Vu]),
                  (n.message = (function yv(n, e, t, s = null) {
                    n =
                      n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1)
                        ? n.slice(2)
                        : n;
                    let c = _t(e);
                    if (Array.isArray(e)) c = e.map(_t).join(" -> ");
                    else if ("object" == typeof e) {
                      let p = [];
                      for (let y in e)
                        if (e.hasOwnProperty(y)) {
                          let w = e[y];
                          p.push(
                            y +
                              ":" +
                              ("string" == typeof w ? JSON.stringify(w) : _t(w))
                          );
                        }
                      c = `{${p.join(", ")}}`;
                    }
                    return `${t}${s ? "(" + s + ")" : ""}[${c}]: ${n.replace(
                      Zf,
                      "\n  "
                    )}`;
                  })("\n" + n.message, c, t, s)),
                  (n.ngTokenPath = c),
                  (n[Ka] = null),
                  n)
                );
              })(y, e, "R3InjectorError", this.source);
            }
            throw y;
          } finally {
            rr(p), lr(c);
          }
        }
        resolveInjectorInitializers() {
          const e = lr(this),
            t = rr(void 0);
          try {
            const s = this.get(C_.multi, vn, Tt.Self);
            for (const c of s) c();
          } finally {
            lr(e), rr(t);
          }
        }
        toString() {
          const e = [],
            t = this.records;
          for (const s of t.keys()) e.push(_t(s));
          return `R3Injector[${e.join(", ")}]`;
        }
        assertNotDestroyed() {
          if (this._destroyed) throw new rt(205, !1);
        }
        processProvider(e) {
          let t = Qn((e = tt(e))) ? e : tt(e && e.provide);
          const s = (function O_(n) {
            return Lm(n)
              ? mn(void 0, n.useValue)
              : mn(
                  (function Fm(n, e, t) {
                    let s;
                    if (Qn(n)) {
                      const c = tt(n);
                      return Ys(c) || Om(c);
                    }
                    if (Lm(n)) s = () => tt(n.useValue);
                    else if (
                      (function L_(n) {
                        return !(!n || !n.useFactory);
                      })(n)
                    )
                      s = () => n.useFactory(...Kn(n.deps || []));
                    else if (
                      (function km(n) {
                        return !(!n || !n.useExisting);
                      })(n)
                    )
                      s = () => St(tt(n.useExisting));
                    else {
                      const c = tt(n && (n.useClass || n.provide));
                      if (
                        !(function Nm(n) {
                          return !!n.deps;
                        })(n)
                      )
                        return Ys(c) || Om(c);
                      s = () => new c(...Kn(n.deps));
                    }
                    return s;
                  })(n),
                  jc
                );
          })(e);
          if (Qn(e) || !0 !== e.multi) this.records.get(t);
          else {
            let c = this.records.get(t);
            c ||
              ((c = mn(void 0, jc, !0)),
              (c.factory = () => Kn(c.multi)),
              this.records.set(t, c)),
              (t = e),
              c.multi.push(e);
          }
          this.records.set(t, s);
        }
        hydrate(e, t) {
          return (
            t.value === jc && ((t.value = eh), (t.value = t.factory())),
            "object" == typeof t.value &&
              t.value &&
              (function F_(n) {
                return (
                  null !== n &&
                  "object" == typeof n &&
                  "function" == typeof n.ngOnDestroy
                );
              })(t.value) &&
              this._ngOnDestroyHooks.add(t.value),
            t.value
          );
        }
        injectableDefInScope(e) {
          if (!e.providedIn) return !1;
          const t = tt(e.providedIn);
          return "string" == typeof t
            ? "any" === t || this.scopes.has(t)
            : this.injectorDefTypes.has(t);
        }
      }
      function Om(n) {
        const e = _o(n),
          t = null !== e ? e.factory : Ys(n);
        if (null !== t) return t;
        if (n instanceof nn) throw new rt(204, !1);
        if (n instanceof Function)
          return (function R_(n) {
            const e = n.length;
            if (e > 0) throw (Zr(e, "?"), new rt(204, !1));
            const t = (function Lh(n) {
              const e = n && (n[Cl] || n[Uo]);
              if (e) {
                const t = (function Il(n) {
                  if (n.hasOwnProperty("name")) return n.name;
                  const e = ("" + n).match(/^function\s*([^\s(]+)/);
                  return null === e ? "" : e[1];
                })(n);
                return (
                  console.warn(
                    `DEPRECATED: DI is instantiating a token "${t}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${t}" class.`
                  ),
                  e
                );
              }
              return null;
            })(n);
            return null !== t ? () => t.factory(n) : () => new n();
          })(n);
        throw new rt(204, !1);
      }
      function mn(n, e, t = !1) {
        return { factory: n, value: e, multi: t ? [] : void 0 };
      }
      function ol(n) {
        return !!n.ɵproviders;
      }
      function Wl(n, e) {
        for (const t of n)
          Array.isArray(t) ? Wl(t, e) : ol(t) ? Wl(t.ɵproviders, e) : e(t);
      }
      class B_ {}
      class Gv {
        resolveComponentFactory(e) {
          throw (function Hv(n) {
            const e = Error(
              `No component factory found for ${_t(
                n
              )}. Did you add it to @NgModule.entryComponents?`
            );
            return (e.ngComponent = n), e;
          })(e);
        }
      }
      let Qp = (() => {
        class n {}
        return (n.NULL = new Gv()), n;
      })();
      function qv() {
        return th(Pi(), Ze());
      }
      function th(n, e) {
        return new sl(zi(n, e));
      }
      let sl = (() => {
        class n {
          constructor(t) {
            this.nativeElement = t;
          }
        }
        return (n.__NG_ELEMENT_ID__ = qv), n;
      })();
      function Jp(n) {
        return n instanceof sl ? n.nativeElement : n;
      }
      class nh {}
      let kd = (() => {
          class n {}
          return (
            (n.__NG_ELEMENT_ID__ = () =>
              (function zm() {
                const n = Ze(),
                  t = Bi(Pi().index, n);
                return (xr(t) ? t : n)[11];
              })()),
            n
          );
        })(),
        Wv = (() => {
          class n {}
          return (
            (n.ɵprov = Sn({
              token: n,
              providedIn: "root",
              factory: () => null,
            })),
            n
          );
        })();
      class Bm {
        constructor(e) {
          (this.full = e),
            (this.major = e.split(".")[0]),
            (this.minor = e.split(".")[1]),
            (this.patch = e.split(".").slice(2).join("."));
        }
      }
      const Zv = new Bm("14.3.0"),
        ef = {};
      function Od(n) {
        return n.ngOriginalError;
      }
      class Uc {
        constructor() {
          this._console = console;
        }
        handleError(e) {
          const t = this._findOriginalError(e);
          this._console.error("ERROR", e),
            t && this._console.error("ORIGINAL ERROR", t);
        }
        _findOriginalError(e) {
          let t = e && Od(e);
          for (; t && Od(t); ) t = Od(t);
          return t || null;
        }
      }
      function Um(n, e, t) {
        let s = n.length;
        for (;;) {
          const c = n.indexOf(e, t);
          if (-1 === c) return c;
          if (0 === c || n.charCodeAt(c - 1) <= 32) {
            const p = e.length;
            if (c + p === s || n.charCodeAt(c + p) <= 32) return c;
          }
          t = c + 1;
        }
      }
      const $m = "ng-template";
      function H_(n, e, t) {
        let s = 0;
        for (; s < n.length; ) {
          let c = n[s++];
          if (t && "class" === c) {
            if (((c = n[s]), -1 !== Um(c.toLowerCase(), e, 0))) return !0;
          } else if (1 === c) {
            for (; s < n.length && "string" == typeof (c = n[s++]); )
              if (c.toLowerCase() === e) return !0;
            return !1;
          }
        }
        return !1;
      }
      function Hm(n) {
        return 4 === n.type && n.value !== $m;
      }
      function G_(n, e, t) {
        return e === (4 !== n.type || t ? n.value : $m);
      }
      function Qv(n, e, t) {
        let s = 4;
        const c = n.attrs || [],
          p = (function W_(n) {
            for (let e = 0; e < n.length; e++) if (Ie(n[e])) return e;
            return n.length;
          })(c);
        let y = !1;
        for (let w = 0; w < e.length; w++) {
          const S = e[w];
          if ("number" != typeof S) {
            if (!y)
              if (4 & s) {
                if (
                  ((s = 2 | (1 & s)),
                  ("" !== S && !G_(n, S, t)) || ("" === S && 1 === e.length))
                ) {
                  if (vs(s)) return !1;
                  y = !0;
                }
              } else {
                const P = 8 & s ? S : e[++w];
                if (8 & s && null !== n.attrs) {
                  if (!H_(n.attrs, P, t)) {
                    if (vs(s)) return !1;
                    y = !0;
                  }
                  continue;
                }
                const j = q_(8 & s ? "class" : S, c, Hm(n), t);
                if (-1 === j) {
                  if (vs(s)) return !1;
                  y = !0;
                  continue;
                }
                if ("" !== P) {
                  let Q;
                  Q = j > p ? "" : c[j + 1].toLowerCase();
                  const ie = 8 & s ? Q : null;
                  if ((ie && -1 !== Um(ie, P, 0)) || (2 & s && P !== Q)) {
                    if (vs(s)) return !1;
                    y = !0;
                  }
                }
              }
          } else {
            if (!y && !vs(s) && !vs(S)) return !1;
            if (y && vs(S)) continue;
            (y = !1), (s = S | (1 & s));
          }
        }
        return vs(s) || y;
      }
      function vs(n) {
        return 0 == (1 & n);
      }
      function q_(n, e, t, s) {
        if (null === e) return -1;
        let c = 0;
        if (s || !t) {
          let p = !1;
          for (; c < e.length; ) {
            const y = e[c];
            if (y === n) return c;
            if (3 === y || 6 === y) p = !0;
            else {
              if (1 === y || 2 === y) {
                let w = e[++c];
                for (; "string" == typeof w; ) w = e[++c];
                continue;
              }
              if (4 === y) break;
              if (0 === y) {
                c += 4;
                continue;
              }
            }
            c += p ? 1 : 2;
          }
          return -1;
        }
        return (function Z_(n, e) {
          let t = n.indexOf(4);
          if (t > -1)
            for (t++; t < n.length; ) {
              const s = n[t];
              if ("number" == typeof s) return -1;
              if (s === e) return t;
              t++;
            }
          return -1;
        })(e, n);
      }
      function Gm(n, e, t = !1) {
        for (let s = 0; s < e.length; s++) if (Qv(n, e[s], t)) return !0;
        return !1;
      }
      function xs(n, e) {
        e: for (let t = 0; t < e.length; t++) {
          const s = e[t];
          if (n.length === s.length) {
            for (let c = 0; c < n.length; c++) if (n[c] !== s[c]) continue e;
            return !0;
          }
        }
        return !1;
      }
      function nf(n, e) {
        return n ? ":not(" + e.trim() + ")" : e;
      }
      function rh(n) {
        let e = n[0],
          t = 1,
          s = 2,
          c = "",
          p = !1;
        for (; t < n.length; ) {
          let y = n[t];
          if ("string" == typeof y)
            if (2 & s) {
              const w = n[++t];
              c += "[" + y + (w.length > 0 ? '="' + w + '"' : "") + "]";
            } else 8 & s ? (c += "." + y) : 4 & s && (c += " " + y);
          else
            "" !== c && !vs(y) && ((e += nf(p, c)), (c = "")),
              (s = y),
              (p = p || !vs(s));
          t++;
        }
        return "" !== c && (e += nf(p, c)), e;
      }
      const Ut = {};
      function Hi(n) {
        zd(dn(), Ze(), v() + n, !1);
      }
      function zd(n, e, t, s) {
        if (!s)
          if (3 == (3 & e[2])) {
            const p = n.preOrderCheckHooks;
            null !== p && X(e, p, t);
          } else {
            const p = n.preOrderHooks;
            null !== p && Z(e, p, 0, t);
          }
        b(t);
      }
      function J_(n, e = null, t = null, s) {
        const c = qm(n, e, t, s);
        return c.resolveInjectorInitializers(), c;
      }
      function qm(n, e = null, t = null, s, c = new Set()) {
        const p = [t || vn, A_(n)];
        return (
          (s = s || ("object" == typeof n ? void 0 : _t(n))),
          new k_(p, e || Yp(), s || null, c)
        );
      }
      let Hc = (() => {
        class n {
          static create(t, s) {
            if (Array.isArray(t)) return J_({ name: "" }, s, t, "");
            {
              const c = t.name ?? "";
              return J_({ name: c }, t.parent, t.providers, c);
            }
          }
        }
        return (
          (n.THROW_IF_NOT_FOUND = Bu),
          (n.NULL = new Mm()),
          (n.ɵprov = Sn({
            token: n,
            providedIn: "any",
            factory: () => St(Ad),
          })),
          (n.__NG_ELEMENT_ID__ = -1),
          n
        );
      })();
      function Lt(n, e = Tt.Default) {
        const t = Ze();
        return null === t ? St(n, e) : ln(Pi(), t, tt(n), e);
      }
      function Wc(n, e) {
        return (n << 17) | (e << 2);
      }
      function ao(n) {
        return (n >> 17) & 32767;
      }
      function Hd(n) {
        return 2 | n;
      }
      function bs(n) {
        return (131068 & n) >> 2;
      }
      function fa(n, e) {
        return (-131069 & n) | (e << 2);
      }
      function Gd(n) {
        return 1 | n;
      }
      function hf(n, e) {
        const t = n.contentQueries;
        if (null !== t)
          for (let s = 0; s < t.length; s += 2) {
            const c = t[s],
              p = t[s + 1];
            if (-1 !== p) {
              const y = n.data[p];
              ku(c), y.contentQueries(2, e[p], p);
            }
          }
      }
      function Xd(n, e, t, s, c, p, y, w, S, P, N) {
        const j = e.blueprint.slice();
        return (
          (j[0] = c),
          (j[2] = 76 | s),
          (null !== N || (n && 1024 & n[2])) && (j[2] |= 1024),
          zl(j),
          (j[3] = j[15] = n),
          (j[8] = t),
          (j[10] = y || (n && n[10])),
          (j[11] = w || (n && n[11])),
          (j[12] = S || (n && n[12]) || null),
          (j[9] = P || (n && n[9]) || null),
          (j[6] = p),
          (j[20] = (function Jg() {
            return pd++;
          })()),
          (j[21] = N),
          (j[16] = 2 == e.type ? n[16] : j),
          j
        );
      }
      function Kc(n, e, t, s, c) {
        let p = n.data[e];
        if (null === p)
          (p = (function Yc(n, e, t, s, c) {
            const p = Yh(),
              y = kr(),
              S = (n.data[e] = (function lg(n, e, t, s, c, p) {
                return {
                  type: t,
                  index: s,
                  insertBeforeIndex: null,
                  injectorIndex: e ? e.injectorIndex : -1,
                  directiveStart: -1,
                  directiveEnd: -1,
                  directiveStylingLast: -1,
                  propertyBindings: null,
                  flags: 0,
                  providerIndexes: 0,
                  value: c,
                  attrs: p,
                  mergedAttrs: null,
                  localNames: null,
                  initialInputs: void 0,
                  inputs: null,
                  outputs: null,
                  tViews: null,
                  next: null,
                  projectionNext: null,
                  child: null,
                  parent: e,
                  projection: null,
                  styles: null,
                  stylesWithoutHost: null,
                  residualStyles: void 0,
                  classes: null,
                  classesWithoutHost: null,
                  residualClasses: void 0,
                  classBindings: 0,
                  styleBindings: 0,
                };
              })(0, y ? p : p && p.parent, t, e, s, c));
            return (
              null === n.firstChild && (n.firstChild = S),
              null !== p &&
                (y
                  ? null == p.child && null !== S.parent && (p.child = S)
                  : null === p.next && (p.next = S)),
              S
            );
          })(n, e, t, s, c)),
            (function Ga() {
              return Ft.lFrame.inI18n;
            })() && (p.flags |= 64);
        else if (64 & p.type) {
          (p.type = t), (p.value = s), (p.attrs = c);
          const y = (function Ic() {
            const n = Ft.lFrame,
              e = n.currentTNode;
            return n.isParent ? e : e.parent;
          })();
          p.injectorIndex = null === y ? -1 : y.injectorIndex;
        }
        return Xo(p, !0), p;
      }
      function cl(n, e, t, s) {
        if (0 === t) return -1;
        const c = e.length;
        for (let p = 0; p < t; p++)
          e.push(s), n.blueprint.push(s), n.data.push(null);
        return c;
      }
      function df(n, e, t) {
        Mc(e);
        try {
          const s = n.viewQuery;
          null !== s && Je(1, s, t);
          const c = n.template;
          null !== c && cy(n, e, c, 1, t),
            n.firstCreatePass && (n.firstCreatePass = !1),
            n.staticContentQueries && hf(n, e),
            n.staticViewQueries && Je(2, n.viewQuery, t);
          const p = n.components;
          null !== p &&
            (function Xc(n, e) {
              for (let t = 0; t < e.length; t++) Ce(n, e[t]);
            })(e, p);
        } catch (s) {
          throw (
            (n.firstCreatePass &&
              ((n.incompleteFirstPass = !0), (n.firstCreatePass = !1)),
            s)
          );
        } finally {
          (e[2] &= -5), a();
        }
      }
      function Kd(n, e, t, s) {
        const c = e[2];
        if (128 != (128 & c)) {
          Mc(e);
          try {
            zl(e),
              (function Pu(n) {
                return (Ft.lFrame.bindingIndex = n);
              })(n.bindingStartIndex),
              null !== t && cy(n, e, t, 2, s);
            const y = 3 == (3 & c);
            if (y) {
              const P = n.preOrderCheckHooks;
              null !== P && X(e, P, null);
            } else {
              const P = n.preOrderHooks;
              null !== P && Z(e, P, 0, null), Y(e, 0);
            }
            if (
              ((function xe(n) {
                for (let e = md(n); null !== e; e = dm(e)) {
                  if (!e[2]) continue;
                  const t = e[9];
                  for (let s = 0; s < t.length; s++) {
                    const c = t[s],
                      p = c[3];
                    0 == (512 & c[2]) && $a(p, 1), (c[2] |= 512);
                  }
                }
              })(e),
              (function De(n) {
                for (let e = md(n); null !== e; e = dm(e))
                  for (let t = 10; t < e.length; t++) {
                    const s = e[t],
                      c = s[1];
                    Nl(s) && Kd(c, s, c.template, s[8]);
                  }
              })(e),
              null !== n.contentQueries && hf(n, e),
              y)
            ) {
              const P = n.contentCheckHooks;
              null !== P && X(e, P);
            } else {
              const P = n.contentHooks;
              null !== P && Z(e, P, 1), Y(e, 1);
            }
            !(function sg(n, e) {
              const t = n.hostBindingOpCodes;
              if (null !== t)
                try {
                  for (let s = 0; s < t.length; s++) {
                    const c = t[s];
                    if (c < 0) b(~c);
                    else {
                      const p = c,
                        y = t[++s],
                        w = t[++s];
                      Qh(y, p), w(2, e[p]);
                    }
                  }
                } finally {
                  b(-1);
                }
            })(n, e);
            const w = n.components;
            null !== w &&
              (function Ts(n, e) {
                for (let t = 0; t < e.length; t++) Pe(n, e[t]);
              })(e, w);
            const S = n.viewQuery;
            if ((null !== S && Je(2, S, s), y)) {
              const P = n.viewCheckHooks;
              null !== P && X(e, P);
            } else {
              const P = n.viewHooks;
              null !== P && Z(e, P, 2), Y(e, 2);
            }
            !0 === n.firstUpdatePass && (n.firstUpdatePass = !1),
              (e[2] &= -41),
              512 & e[2] && ((e[2] &= -513), $a(e[3], -1));
          } finally {
            a();
          }
        }
      }
      function cy(n, e, t, s, c) {
        const p = v(),
          y = 2 & s;
        try {
          b(-1), y && e.length > 22 && zd(n, e, 22, !1), t(s, c);
        } finally {
          b(p);
        }
      }
      function ag(n, e, t) {
        if (zh(e)) {
          const c = e.directiveEnd;
          for (let p = e.directiveStart; p < c; p++) {
            const y = n.data[p];
            y.contentQueries && y.contentQueries(1, t[p], p);
          }
        }
      }
      function pf(n, e, t) {
        !Kh() ||
          ((function x(n, e, t, s) {
            const c = t.directiveStart,
              p = t.directiveEnd;
            n.firstCreatePass || fn(t, e), Er(s, e);
            const y = t.initialInputs;
            for (let w = c; w < p; w++) {
              const S = n.data[w],
                P = wo(S);
              P && G(e, t, S);
              const N = Ui(e, n, w, t);
              Er(N, e),
                null !== y && J(0, w - c, N, S, 0, y),
                P && (Bi(t.index, e)[8] = N);
            }
          })(n, e, t, zi(t, e)),
          128 == (128 & t.flags) &&
            (function E(n, e, t) {
              const s = t.directiveStart,
                c = t.directiveEnd,
                p = t.index,
                y = (function $f() {
                  return Ft.lFrame.currentDirectiveIndex;
                })();
              try {
                b(p);
                for (let w = s; w < c; w++) {
                  const S = n.data[w],
                    P = e[w];
                  Lu(w),
                    (null !== S.hostBindings ||
                      0 !== S.hostVars ||
                      null !== S.hostAttrs) &&
                      T(S, P);
                }
              } finally {
                b(-1), Lu(y);
              }
            })(n, e, t));
      }
      function ff(n, e, t = zi) {
        const s = e.localNames;
        if (null !== s) {
          let c = e.index + 1;
          for (let p = 0; p < s.length; p += 2) {
            const y = s[p + 1],
              w = -1 === y ? t(e, n) : n[y];
            n[c++] = w;
          }
        }
      }
      function uy(n) {
        const e = n.tView;
        return null === e || e.incompleteFirstPass
          ? (n.tView = Yd(
              1,
              null,
              n.template,
              n.decls,
              n.vars,
              n.directiveDefs,
              n.pipeDefs,
              n.viewQuery,
              n.schemas,
              n.consts
            ))
          : e;
      }
      function Yd(n, e, t, s, c, p, y, w, S, P) {
        const N = 22 + s,
          j = N + c,
          Q = (function hy(n, e) {
            const t = [];
            for (let s = 0; s < e; s++) t.push(s < n ? null : Ut);
            return t;
          })(N, j),
          ie = "function" == typeof P ? P() : P;
        return (Q[1] = {
          type: n,
          blueprint: Q,
          template: t,
          queries: null,
          viewQuery: w,
          declTNode: e,
          data: Q.slice().fill(null, N),
          bindingStartIndex: N,
          expandoStartIndex: j,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: "function" == typeof p ? p() : p,
          pipeRegistry: "function" == typeof y ? y() : y,
          firstChild: null,
          schemas: S,
          consts: ie,
          incompleteFirstPass: !1,
        });
      }
      function mf(n, e, t, s) {
        const c = nt(e);
        null === t
          ? c.push(s)
          : (c.push(t), n.firstCreatePass && Mt(n).push(s, c.length - 1));
      }
      function cg(n, e, t) {
        for (let s in n)
          if (n.hasOwnProperty(s)) {
            const c = n[s];
            (t = null === t ? {} : t).hasOwnProperty(s)
              ? t[s].push(e, c)
              : (t[s] = [e, c]);
          }
        return t;
      }
      function dh(n, e) {
        const s = e.directiveEnd,
          c = n.data,
          p = e.attrs,
          y = [];
        let w = null,
          S = null;
        for (let P = e.directiveStart; P < s; P++) {
          const N = c[P],
            j = N.inputs,
            Q = null === p || Hm(e) ? null : re(j, p);
          y.push(Q), (w = cg(j, P, w)), (S = cg(N.outputs, P, S));
        }
        null !== w &&
          (w.hasOwnProperty("class") && (e.flags |= 16),
          w.hasOwnProperty("style") && (e.flags |= 32)),
          (e.initialInputs = y),
          (e.inputs = w),
          (e.outputs = S);
      }
      function r(n, e) {
        const t = Bi(e, n);
        16 & t[2] || (t[2] |= 32);
      }
      function h(n, e, t, s) {
        let c = !1;
        if (Kh()) {
          const p = (function C(n, e, t) {
              const s = n.directiveRegistry;
              let c = null;
              if (s)
                for (let p = 0; p < s.length; p++) {
                  const y = s[p];
                  Gm(t, y.selectors, !1) &&
                    (c || (c = []),
                    br(fn(t, e), n, y.type),
                    wo(y) ? (A(n, t), c.unshift(y)) : c.push(y));
                }
              return c;
            })(n, e, t),
            y = null === s ? null : { "": -1 };
          if (null !== p) {
            (c = !0), F(t, n.data.length, p.length);
            for (let N = 0; N < p.length; N++) {
              const j = p[N];
              j.providersResolver && j.providersResolver(j);
            }
            let w = !1,
              S = !1,
              P = cl(n, e, p.length, null);
            for (let N = 0; N < p.length; N++) {
              const j = p[N];
              (t.mergedAttrs = we(t.mergedAttrs, j.hostAttrs)),
                V(n, t, e, P, j),
                O(P, j, y),
                null !== j.contentQueries && (t.flags |= 8),
                (null !== j.hostBindings ||
                  null !== j.hostAttrs ||
                  0 !== j.hostVars) &&
                  (t.flags |= 128);
              const Q = j.type.prototype;
              !w &&
                (Q.ngOnChanges || Q.ngOnInit || Q.ngDoCheck) &&
                ((n.preOrderHooks || (n.preOrderHooks = [])).push(t.index),
                (w = !0)),
                !S &&
                  (Q.ngOnChanges || Q.ngDoCheck) &&
                  ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(
                    t.index
                  ),
                  (S = !0)),
                P++;
            }
            dh(n, t);
          }
          y &&
            (function L(n, e, t) {
              if (e) {
                const s = (n.localNames = []);
                for (let c = 0; c < e.length; c += 2) {
                  const p = t[e[c + 1]];
                  if (null == p) throw new rt(-301, !1);
                  s.push(e[c], p);
                }
              }
            })(t, s, y);
        }
        return (t.mergedAttrs = we(t.mergedAttrs, t.attrs)), c;
      }
      function m(n, e, t, s, c, p) {
        const y = p.hostBindings;
        if (y) {
          let w = n.hostBindingOpCodes;
          null === w && (w = n.hostBindingOpCodes = []);
          const S = ~e.index;
          (function _(n) {
            let e = n.length;
            for (; e > 0; ) {
              const t = n[--e];
              if ("number" == typeof t && t < 0) return t;
            }
            return 0;
          })(w) != S && w.push(S),
            w.push(s, c, y);
        }
      }
      function T(n, e) {
        null !== n.hostBindings && n.hostBindings(1, e);
      }
      function A(n, e) {
        (e.flags |= 2), (n.components || (n.components = [])).push(e.index);
      }
      function O(n, e, t) {
        if (t) {
          if (e.exportAs)
            for (let s = 0; s < e.exportAs.length; s++) t[e.exportAs[s]] = n;
          wo(e) && (t[""] = n);
        }
      }
      function F(n, e, t) {
        (n.flags |= 1),
          (n.directiveStart = e),
          (n.directiveEnd = e + t),
          (n.providerIndexes = e);
      }
      function V(n, e, t, s, c) {
        n.data[s] = c;
        const p = c.factory || (c.factory = Ys(c.type)),
          y = new te(p, wo(c), Lt);
        (n.blueprint[s] = y),
          (t[s] = y),
          m(n, e, 0, s, cl(n, t, c.hostVars, Ut), c);
      }
      function G(n, e, t) {
        const s = zi(e, n),
          c = uy(t),
          p = n[10],
          y = Re(
            n,
            Xd(
              n,
              c,
              null,
              t.onPush ? 32 : 16,
              s,
              e,
              p,
              p.createRenderer(s, t),
              null,
              null,
              null
            )
          );
        n[e.index] = y;
      }
      function K(n, e, t, s, c, p) {
        const y = zi(n, e);
        !(function oe(n, e, t, s, c, p, y) {
          if (null == p) n.removeAttribute(e, c, t);
          else {
            const w = null == y ? pt(p) : y(p, s || "", c);
            n.setAttribute(e, c, w, t);
          }
        })(e[11], y, p, n.value, t, s, c);
      }
      function J(n, e, t, s, c, p) {
        const y = p[e];
        if (null !== y) {
          const w = s.setInput;
          for (let S = 0; S < y.length; ) {
            const P = y[S++],
              N = y[S++],
              j = y[S++];
            null !== w ? s.setInput(t, j, P, N) : (t[N] = j);
          }
        }
      }
      function re(n, e) {
        let t = null,
          s = 0;
        for (; s < e.length; ) {
          const c = e[s];
          if (0 !== c)
            if (5 !== c) {
              if ("number" == typeof c) break;
              n.hasOwnProperty(c) &&
                (null === t && (t = []), t.push(c, n[c], e[s + 1])),
                (s += 2);
            } else s += 2;
          else s += 4;
        }
        return t;
      }
      function ae(n, e, t, s) {
        return new Array(n, !0, !1, e, null, 0, s, t, null, null);
      }
      function Pe(n, e) {
        const t = Bi(e, n);
        if (Nl(t)) {
          const s = t[1];
          48 & t[2] ? Kd(s, t, s.template, t[8]) : t[5] > 0 && $e(t);
        }
      }
      function $e(n) {
        for (let s = md(n); null !== s; s = dm(s))
          for (let c = 10; c < s.length; c++) {
            const p = s[c];
            if (Nl(p))
              if (512 & p[2]) {
                const y = p[1];
                Kd(y, p, y.template, p[8]);
              } else p[5] > 0 && $e(p);
          }
        const t = n[1].components;
        if (null !== t)
          for (let s = 0; s < t.length; s++) {
            const c = Bi(t[s], n);
            Nl(c) && c[5] > 0 && $e(c);
          }
      }
      function Ce(n, e) {
        const t = Bi(e, n),
          s = t[1];
        (function Fe(n, e) {
          for (let t = e.length; t < n.blueprint.length; t++)
            e.push(n.blueprint[t]);
        })(s, t),
          df(s, t, t[8]);
      }
      function Re(n, e) {
        return n[13] ? (n[14][4] = e) : (n[13] = e), (n[14] = e), e;
      }
      function Ve(n) {
        for (; n; ) {
          n[2] |= 32;
          const e = fd(n);
          if (Rf(n) && !e) return n;
          n = e;
        }
        return null;
      }
      function qe(n, e, t, s = !0) {
        const c = e[10];
        c.begin && c.begin();
        try {
          Kd(n, e, n.template, t);
        } catch (y) {
          throw (s && yt(e, y), y);
        } finally {
          c.end && c.end();
        }
      }
      function Je(n, e, t) {
        ku(0), e(n, t);
      }
      function nt(n) {
        return n[7] || (n[7] = []);
      }
      function Mt(n) {
        return n.cleanup || (n.cleanup = []);
      }
      function yt(n, e) {
        const t = n[9],
          s = t ? t.get(Uc, null) : null;
        s && s.handleError(e);
      }
      function Ct(n, e, t, s, c) {
        for (let p = 0; p < t.length; ) {
          const y = t[p++],
            w = t[p++],
            S = e[y],
            P = n.data[y];
          null !== P.setInput ? P.setInput(S, c, s, w) : (S[w] = c);
        }
      }
      function It(n, e, t) {
        let s = t ? n.styles : null,
          c = t ? n.classes : null,
          p = 0;
        if (null !== e)
          for (let y = 0; y < e.length; y++) {
            const w = e[y];
            "number" == typeof w
              ? (p = w)
              : 1 == p
              ? (c = Vt(c, w))
              : 2 == p && (s = Vt(s, w + ": " + e[++y] + ";"));
          }
        t ? (n.styles = s) : (n.stylesWithoutHost = s),
          t ? (n.classes = c) : (n.classesWithoutHost = c);
      }
      function xt(n, e, t, s, c = !1) {
        for (; null !== t; ) {
          const p = e[t.index];
          if ((null !== p && s.push(ti(p)), ar(p)))
            for (let w = 10; w < p.length; w++) {
              const S = p[w],
                P = S[1].firstChild;
              null !== P && xt(S[1], S, P, s);
            }
          const y = t.type;
          if (8 & y) xt(n, e, t.child, s);
          else if (32 & y) {
            const w = Wu(t, e);
            let S;
            for (; (S = w()); ) s.push(S);
          } else if (16 & y) {
            const w = h_(e, t);
            if (Array.isArray(w)) s.push(...w);
            else {
              const S = fd(e[16]);
              xt(S[1], S, w, s, !0);
            }
          }
          t = c ? t.projectionNext : t.next;
        }
        return s;
      }
      class Dn {
        constructor(e, t) {
          (this._lView = e),
            (this._cdRefInjectingView = t),
            (this._appRef = null),
            (this._attachedToViewContainer = !1);
        }
        get rootNodes() {
          const e = this._lView,
            t = e[1];
          return xt(t, e, t.firstChild, []);
        }
        get context() {
          return this._lView[8];
        }
        set context(e) {
          this._lView[8] = e;
        }
        get destroyed() {
          return 128 == (128 & this._lView[2]);
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this);
          else if (this._attachedToViewContainer) {
            const e = this._lView[3];
            if (ar(e)) {
              const t = e[8],
                s = t ? t.indexOf(this) : -1;
              s > -1 && (Fp(e, s), td(t, s));
            }
            this._attachedToViewContainer = !1;
          }
          a_(this._lView[1], this._lView);
        }
        onDestroy(e) {
          mf(this._lView[1], this._lView, null, e);
        }
        markForCheck() {
          Ve(this._cdRefInjectingView || this._lView);
        }
        detach() {
          this._lView[2] &= -65;
        }
        reattach() {
          this._lView[2] |= 64;
        }
        detectChanges() {
          qe(this._lView[1], this._lView, this.context);
        }
        checkNoChanges() {}
        attachToViewContainerRef() {
          if (this._appRef) throw new rt(902, !1);
          this._attachedToViewContainer = !0;
        }
        detachFromAppRef() {
          (this._appRef = null),
            (function r_(n, e) {
              _d(n, e, e[11], 2, null, null);
            })(this._lView[1], this._lView);
        }
        attachToAppRef(e) {
          if (this._attachedToViewContainer) throw new rt(902, !1);
          this._appRef = e;
        }
      }
      class Rt extends Dn {
        constructor(e) {
          super(e), (this._view = e);
        }
        detectChanges() {
          const e = this._view;
          qe(e[1], e, e[8], !1);
        }
        checkNoChanges() {}
        get context() {
          return null;
        }
      }
      class At extends Qp {
        constructor(e) {
          super(), (this.ngModule = e);
        }
        resolveComponentFactory(e) {
          const t = In(e);
          return new gn(t, this.ngModule);
        }
      }
      function An(n) {
        const e = [];
        for (let t in n)
          n.hasOwnProperty(t) && e.push({ propName: n[t], templateName: t });
        return e;
      }
      class Nn {
        constructor(e, t) {
          (this.injector = e), (this.parentInjector = t);
        }
        get(e, t, s) {
          const c = this.injector.get(e, ef, s);
          return c !== ef || t === ef ? c : this.parentInjector.get(e, t, s);
        }
      }
      class gn extends B_ {
        constructor(e, t) {
          super(),
            (this.componentDef = e),
            (this.ngModule = t),
            (this.componentType = e.type),
            (this.selector = (function oh(n) {
              return n.map(rh).join(",");
            })(e.selectors)),
            (this.ngContentSelectors = e.ngContentSelectors
              ? e.ngContentSelectors
              : []),
            (this.isBoundToModule = !!t);
        }
        get inputs() {
          return An(this.componentDef.inputs);
        }
        get outputs() {
          return An(this.componentDef.outputs);
        }
        create(e, t, s, c) {
          let p = (c = c || this.ngModule) instanceof da ? c : c?.injector;
          p &&
            null !== this.componentDef.getStandaloneInjector &&
            (p = this.componentDef.getStandaloneInjector(p) || p);
          const y = p ? new Nn(e, p) : e,
            w = y.get(nh, null);
          if (null === w) throw new rt(407, !1);
          const S = y.get(Wv, null),
            P = w.createRenderer(null, this.componentDef),
            N = this.componentDef.selectors[0][0] || "div",
            j = s
              ? (function dy(n, e, t) {
                  return n.selectRootElement(e, t === vo.ShadowDom);
                })(P, s, this.componentDef.encapsulation)
              : Gl(
                  P,
                  N,
                  (function Fn(n) {
                    const e = n.toLowerCase();
                    return "svg" === e ? "svg" : "math" === e ? "math" : null;
                  })(N)
                ),
            Q = this.componentDef.onPush ? 288 : 272,
            ie = Yd(0, null, null, 1, 0, null, null, null, null, null),
            pe = Xd(null, ie, null, Q, null, null, w, P, S, y, null);
          let Ee, Oe;
          Mc(pe);
          try {
            const Ue = (function Di(n, e, t, s, c, p) {
              const y = t[1];
              t[22] = n;
              const S = Kc(y, 22, 2, "#host", null),
                P = (S.mergedAttrs = e.hostAttrs);
              null !== P &&
                (It(S, P, !0),
                null !== n &&
                  (Le(c, n, P),
                  null !== S.classes && Ku(c, n, S.classes),
                  null !== S.styles && ri(c, n, S.styles)));
              const N = s.createRenderer(n, e),
                j = Xd(
                  t,
                  uy(e),
                  null,
                  e.onPush ? 32 : 16,
                  t[22],
                  S,
                  s,
                  N,
                  p || null,
                  null,
                  null
                );
              return (
                y.firstCreatePass &&
                  (br(fn(S, t), y, e.type), A(y, S), F(S, t.length, 1)),
                Re(t, j),
                (t[22] = j)
              );
            })(j, this.componentDef, pe, w, P);
            if (j)
              if (s) Le(P, j, ["ng-version", Zv.full]);
              else {
                const { attrs: lt, classes: ze } = (function X_(n) {
                  const e = [],
                    t = [];
                  let s = 1,
                    c = 2;
                  for (; s < n.length; ) {
                    let p = n[s];
                    if ("string" == typeof p)
                      2 === c
                        ? "" !== p && e.push(p, n[++s])
                        : 8 === c && t.push(p);
                    else {
                      if (!vs(c)) break;
                      c = p;
                    }
                    s++;
                  }
                  return { attrs: e, classes: t };
                })(this.componentDef.selectors[0]);
                lt && Le(P, j, lt),
                  ze && ze.length > 0 && Ku(P, j, ze.join(" "));
              }
            if (((Oe = qh(ie, 22)), void 0 !== t)) {
              const lt = (Oe.projection = []);
              for (let ze = 0; ze < this.ngContentSelectors.length; ze++) {
                const gt = t[ze];
                lt.push(null != gt ? Array.from(gt) : null);
              }
            }
            (Ee = (function vi(n, e, t, s) {
              const c = t[1],
                p = (function l(n, e, t) {
                  const s = Pi();
                  n.firstCreatePass &&
                    (t.providersResolver && t.providersResolver(t),
                    V(n, s, e, cl(n, e, 1, null), t),
                    dh(n, s));
                  const c = Ui(e, n, s.directiveStart, s);
                  Er(c, e);
                  const p = zi(s, e);
                  return p && Er(p, e), c;
                })(c, t, e);
              if (((n[8] = t[8] = p), null !== s)) for (const w of s) w(p, e);
              if (e.contentQueries) {
                const w = Pi();
                e.contentQueries(1, p, w.directiveStart);
              }
              const y = Pi();
              return (
                !c.firstCreatePass ||
                  (null === e.hostBindings && null === e.hostAttrs) ||
                  (b(y.index),
                  m(t[1], y, 0, y.directiveStart, y.directiveEnd, e),
                  T(e, p)),
                p
              );
            })(Ue, this.componentDef, pe, [Yn])),
              df(ie, pe, null);
          } finally {
            a();
          }
          return new yi(this.componentType, Ee, th(Oe, pe), pe, Oe);
        }
      }
      class yi extends class z_ {} {
        constructor(e, t, s, c, p) {
          super(),
            (this.location = s),
            (this._rootLView = c),
            (this._tNode = p),
            (this.instance = t),
            (this.hostView = this.changeDetectorRef = new Rt(c)),
            (this.componentType = e);
        }
        setInput(e, t) {
          const s = this._tNode.inputs;
          let c;
          if (null !== s && (c = s[e])) {
            const p = this._rootLView;
            Ct(p[1], p, c, e, t), r(p, this._tNode.index);
          }
        }
        get injector() {
          return new Or(this._tNode, this._rootLView);
        }
        destroy() {
          this.hostView.destroy();
        }
        onDestroy(e) {
          this.hostView.onDestroy(e);
        }
      }
      function Yn() {
        const n = Pi();
        q(Ze()[1], n);
      }
      let ul = null;
      function Ss() {
        if (!ul) {
          const n = jn.Symbol;
          if (n && n.iterator) ul = n.iterator;
          else {
            const e = Object.getOwnPropertyNames(Map.prototype);
            for (let t = 0; t < e.length; ++t) {
              const s = e[t];
              "entries" !== s &&
                "size" !== s &&
                Map.prototype[s] === Map.prototype.entries &&
                (ul = s);
            }
          }
        }
        return ul;
      }
      function ph(n) {
        return (
          !!_f(n) && (Array.isArray(n) || (!(n instanceof Map) && Ss() in n))
        );
      }
      function _f(n) {
        return null !== n && ("function" == typeof n || "object" == typeof n);
      }
      function Jo(n, e, t) {
        return (n[e] = t);
      }
      function Tr(n, e, t) {
        return !Object.is(n[e], t) && ((n[e] = t), !0);
      }
      function Is(n, e, t, s) {
        const c = Ze();
        return Tr(c, ea(), e) && (dn(), K(D(), c, n, e, t, s)), Is;
      }
      function mh(n, e, t, s) {
        return Tr(n, ea(), t) ? e + pt(t) + s : Ut;
      }
      function Qr(n, e, t, s, c, p, y, w) {
        const S = Ze(),
          P = dn(),
          N = n + 22,
          j = P.firstCreatePass
            ? (function yD(n, e, t, s, c, p, y, w, S) {
                const P = e.consts,
                  N = Kc(e, n, 4, y || null, Do(P, w));
                h(e, t, N, Do(P, S)), q(e, N);
                const j = (N.tViews = Yd(
                  2,
                  N,
                  s,
                  c,
                  p,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  P
                ));
                return (
                  null !== e.queries &&
                    (e.queries.template(e, N),
                    (j.queries = e.queries.embeddedTView(N))),
                  N
                );
              })(N, P, S, e, t, s, c, p, y)
            : P.data[N];
        Xo(j, !1);
        const Q = S[11].createComment("");
        Vp(P, S, Q, j),
          Er(Q, S),
          Re(S, (S[N] = ae(Q, S, Q, j))),
          Eu(j) && pf(P, S, j),
          null != y && ff(S, j, w);
      }
      function bi(n, e, t) {
        const s = Ze();
        return (
          Tr(s, ea(), e) &&
            (function lo(n, e, t, s, c, p, y, w) {
              const S = zi(e, t);
              let N,
                P = e.inputs;
              !w && null != P && (N = P[s])
                ? (Ct(n, t, N, s, c), wu(e) && r(t, e.index))
                : 3 & e.type &&
                  ((s = (function ug(n) {
                    return "class" === n
                      ? "className"
                      : "for" === n
                      ? "htmlFor"
                      : "formaction" === n
                      ? "formAction"
                      : "innerHtml" === n
                      ? "innerHTML"
                      : "readonly" === n
                      ? "readOnly"
                      : "tabindex" === n
                      ? "tabIndex"
                      : n;
                  })(s)),
                  (c = null != y ? y(c, e.value || "", s) : c),
                  p.setProperty(S, s, c));
            })(dn(), D(), s, n, e, s[11], t, !1),
          bi
        );
      }
      function D0(n, e, t, s, c) {
        const y = c ? "class" : "style";
        Ct(n, t, e.inputs[y], y, s);
      }
      function on(n, e, t, s) {
        const c = Ze(),
          p = dn(),
          y = 22 + n,
          w = c[11],
          S = (c[y] = Gl(
            w,
            e,
            (function z() {
              return Ft.lFrame.currentNamespace;
            })()
          )),
          P = p.firstCreatePass
            ? (function bD(n, e, t, s, c, p, y) {
                const w = e.consts,
                  P = Kc(e, n, 2, c, Do(w, p));
                return (
                  h(e, t, P, Do(w, y)),
                  null !== P.attrs && It(P, P.attrs, !1),
                  null !== P.mergedAttrs && It(P, P.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, P),
                  P
                );
              })(y, p, c, 0, e, t, s)
            : p.data[y];
        Xo(P, !0);
        const N = P.mergedAttrs;
        null !== N && Le(w, S, N);
        const j = P.classes;
        null !== j && Ku(w, S, j);
        const Q = P.styles;
        return (
          null !== Q && ri(w, S, Q),
          64 != (64 & P.flags) && Vp(p, c, S, P),
          0 ===
            (function gp() {
              return Ft.lFrame.elementDepthCount;
            })() && Er(S, c),
          (function Qs() {
            Ft.lFrame.elementDepthCount++;
          })(),
          Eu(P) && (pf(p, c, P), ag(p, P, c)),
          null !== s && ff(c, P),
          on
        );
      }
      function Pn() {
        let n = Pi();
        kr() ? Au() : ((n = n.parent), Xo(n, !1));
        const e = n;
        !(function _p() {
          Ft.lFrame.elementDepthCount--;
        })();
        const t = dn();
        return (
          t.firstCreatePass && (q(t, n), zh(n) && t.queries.elementEnd(n)),
          null != e.classesWithoutHost &&
            (function ge(n) {
              return 0 != (16 & n.flags);
            })(e) &&
            D0(t, e, Ze(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function Te(n) {
              return 0 != (32 & n.flags);
            })(e) &&
            D0(t, e, Ze(), e.stylesWithoutHost, !1),
          Pn
        );
      }
      function Wi(n, e, t, s) {
        return on(n, e, t, s), Pn(), Wi;
      }
      function dg(n, e, t) {
        const s = Ze(),
          c = dn(),
          p = n + 22,
          y = c.firstCreatePass
            ? (function wD(n, e, t, s, c) {
                const p = e.consts,
                  y = Do(p, s),
                  w = Kc(e, n, 8, "ng-container", y);
                return (
                  null !== y && It(w, y, !0),
                  h(e, t, w, Do(p, c)),
                  null !== e.queries && e.queries.elementStart(e, w),
                  w
                );
              })(p, c, s, e, t)
            : c.data[p];
        Xo(y, !0);
        const w = (s[p] = s[11].createComment(""));
        return (
          Vp(c, s, w, y),
          Er(w, s),
          Eu(y) && (pf(c, s, y), ag(c, y, s)),
          null != t && ff(s, y),
          dg
        );
      }
      function pg() {
        let n = Pi();
        const e = dn();
        return (
          kr() ? Au() : ((n = n.parent), Xo(n, !1)),
          e.firstCreatePass && (q(e, n), zh(n) && e.queries.elementEnd(n)),
          pg
        );
      }
      function my(n, e, t) {
        return dg(n, e, t), pg(), my;
      }
      function fg() {
        return Ze();
      }
      function S0(n) {
        return !!n && "function" == typeof n.then;
      }
      const ED = function $b(n) {
        return !!n && "function" == typeof n.subscribe;
      };
      function gh(n, e, t, s) {
        const c = Ze(),
          p = dn(),
          y = Pi();
        return (
          (function Gb(n, e, t, s, c, p, y, w) {
            const S = Eu(s),
              N = n.firstCreatePass && Mt(n),
              j = e[8],
              Q = nt(e);
            let ie = !0;
            if (3 & s.type || w) {
              const Oe = zi(s, e),
                Ue = w ? w(Oe) : Oe,
                lt = Q.length,
                ze = w ? (an) => w(ti(an[s.index])) : s.index;
              let gt = null;
              if (
                (!w &&
                  S &&
                  (gt = (function TD(n, e, t, s) {
                    const c = n.cleanup;
                    if (null != c)
                      for (let p = 0; p < c.length - 1; p += 2) {
                        const y = c[p];
                        if (y === t && c[p + 1] === s) {
                          const w = e[7],
                            S = c[p + 2];
                          return w.length > S ? w[S] : null;
                        }
                        "string" == typeof y && (p += 2);
                      }
                    return null;
                  })(n, e, c, s.index)),
                null !== gt)
              )
                ((gt.__ngLastListenerFn__ || gt).__ngNextListenerFn__ = p),
                  (gt.__ngLastListenerFn__ = p),
                  (ie = !1);
              else {
                p = Wb(s, e, j, p, !1);
                const an = t.listen(Ue, c, p);
                Q.push(p, an), N && N.push(c, ze, lt, lt + 1);
              }
            } else p = Wb(s, e, j, p, !1);
            const pe = s.outputs;
            let Ee;
            if (ie && null !== pe && (Ee = pe[c])) {
              const Oe = Ee.length;
              if (Oe)
                for (let Ue = 0; Ue < Oe; Ue += 2) {
                  const Ln = e[Ee[Ue]][Ee[Ue + 1]].subscribe(p),
                    ki = Q.length;
                  Q.push(p, Ln), N && N.push(c, s.index, ki, -(ki + 1));
                }
            }
          })(p, c, c[11], y, n, e, 0, s),
          gh
        );
      }
      function qb(n, e, t, s) {
        try {
          return !1 !== t(s);
        } catch (c) {
          return yt(n, c), !1;
        }
      }
      function Wb(n, e, t, s, c) {
        return function p(y) {
          if (y === Function) return s;
          Ve(2 & n.flags ? Bi(n.index, e) : e);
          let S = qb(e, 0, s, y),
            P = p.__ngNextListenerFn__;
          for (; P; ) (S = qb(e, 0, P, y) && S), (P = P.__ngNextListenerFn__);
          return c && !1 === S && (y.preventDefault(), (y.returnValue = !1)), S;
        };
      }
      function ho(n = 1) {
        return (function u(n) {
          return (Ft.lFrame.contextLView = (function g(n, e) {
            for (; n > 0; ) (e = e[15]), n--;
            return e;
          })(n, Ft.lFrame.contextLView))[8];
        })(n);
      }
      function DD(n, e) {
        let t = null;
        const s = (function Nd(n) {
          const e = n.attrs;
          if (null != e) {
            const t = e.indexOf(5);
            if (0 == (1 & t)) return e[t + 1];
          }
          return null;
        })(n);
        for (let c = 0; c < e.length; c++) {
          const p = e[c];
          if ("*" !== p) {
            if (null === s ? Gm(n, p, !0) : xs(s, p)) return c;
          } else t = c;
        }
        return t;
      }
      function I0(n) {
        const e = Ze()[16][6];
        if (!e.projection) {
          const s = (e.projection = Zr(n ? n.length : 1, null)),
            c = s.slice();
          let p = e.child;
          for (; null !== p; ) {
            const y = n ? DD(p, n) : 0;
            null !== y &&
              (c[y] ? (c[y].projectionNext = p) : (s[y] = p), (c[y] = p)),
              (p = p.next);
          }
        }
      }
      function C0(n, e = 0, t) {
        const s = Ze(),
          c = dn(),
          p = Kc(c, 22 + n, 16, null, t || null);
        null === p.projection && (p.projection = e),
          Au(),
          64 != (64 & p.flags) &&
            (function bm(n, e, t) {
              d_(e[11], 0, e, t, mm(n, t, e), Bp(t.parent || e[6], t, e));
            })(c, s, p);
      }
      function r1(n, e, t, s, c) {
        const p = n[t + 1],
          y = null === e;
        let w = s ? ao(p) : bs(p),
          S = !1;
        for (; 0 !== w && (!1 === S || y); ) {
          const N = n[w + 1];
          CD(n[w], e) && ((S = !0), (n[w + 1] = s ? Gd(N) : Hd(N))),
            (w = s ? ao(N) : bs(N));
        }
        S && (n[t + 1] = s ? Hd(p) : Gd(p));
      }
      function CD(n, e) {
        return (
          null === n ||
          null == e ||
          (Array.isArray(n) ? n[1] : n) === e ||
          (!(!Array.isArray(n) || "string" != typeof e) && kc(n, e) >= 0)
        );
      }
      const Dr = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };
      function o1(n) {
        return n.substring(Dr.key, Dr.keyEnd);
      }
      function s1(n, e) {
        const t = Dr.textEnd;
        return t === e
          ? -1
          : ((e = Dr.keyEnd =
              (function LD(n, e, t) {
                for (; e < t && n.charCodeAt(e) > 32; ) e++;
                return e;
              })(n, (Dr.key = e), t)),
            vf(n, e, t));
      }
      function vf(n, e, t) {
        for (; e < t && n.charCodeAt(e) <= 32; ) e++;
        return e;
      }
      function A0(n) {
        dl(Xn, tc, n, !0);
      }
      function tc(n, e) {
        for (
          let t = (function AD(n) {
            return (
              (function l1(n) {
                (Dr.key = 0),
                  (Dr.keyEnd = 0),
                  (Dr.value = 0),
                  (Dr.valueEnd = 0),
                  (Dr.textEnd = n.length);
              })(n),
              s1(n, vf(n, 0, Dr.textEnd))
            );
          })(e);
          t >= 0;
          t = s1(e, t)
        )
          Xn(n, o1(e), !0);
      }
      function dl(n, e, t, s) {
        const c = dn(),
          p = (function Rr(n) {
            const e = Ft.lFrame,
              t = e.bindingIndex;
            return (e.bindingIndex = e.bindingIndex + n), t;
          })(2);
        c.firstUpdatePass &&
          (function f1(n, e, t, s) {
            const c = n.data;
            if (null === c[t + 1]) {
              const p = c[v()],
                y = p1(n, t);
              y1(p, s) && null === e && !y && (e = !1),
                (e = (function FD(n, e, t, s) {
                  const c = (function Cc(n) {
                    const e = Ft.lFrame.currentDirectiveIndex;
                    return -1 === e ? null : n[e];
                  })(n);
                  let p = s ? e.residualClasses : e.residualStyles;
                  if (null === c)
                    0 === (s ? e.classBindings : e.styleBindings) &&
                      ((t = mg((t = P0(null, n, e, t, s)), e.attrs, s)),
                      (p = null));
                  else {
                    const y = e.directiveStylingLast;
                    if (-1 === y || n[y] !== c)
                      if (((t = P0(c, n, e, t, s)), null === p)) {
                        let S = (function ND(n, e, t) {
                          const s = t ? e.classBindings : e.styleBindings;
                          if (0 !== bs(s)) return n[ao(s)];
                        })(n, e, s);
                        void 0 !== S &&
                          Array.isArray(S) &&
                          ((S = P0(null, n, e, S[1], s)),
                          (S = mg(S, e.attrs, s)),
                          (function zD(n, e, t, s) {
                            n[ao(t ? e.classBindings : e.styleBindings)] = s;
                          })(n, e, s, S));
                      } else
                        p = (function BD(n, e, t) {
                          let s;
                          const c = e.directiveEnd;
                          for (let p = 1 + e.directiveStylingLast; p < c; p++)
                            s = mg(s, n[p].hostAttrs, t);
                          return mg(s, e.attrs, t);
                        })(n, e, s);
                  }
                  return (
                    void 0 !== p &&
                      (s ? (e.residualClasses = p) : (e.residualStyles = p)),
                    t
                  );
                })(c, p, e, s)),
                (function SD(n, e, t, s, c, p) {
                  let y = p ? e.classBindings : e.styleBindings,
                    w = ao(y),
                    S = bs(y);
                  n[s] = t;
                  let N,
                    P = !1;
                  if (Array.isArray(t)) {
                    const j = t;
                    (N = j[1]), (null === N || kc(j, N) > 0) && (P = !0);
                  } else N = t;
                  if (c)
                    if (0 !== S) {
                      const Q = ao(n[w + 1]);
                      (n[s + 1] = Wc(Q, w)),
                        0 !== Q && (n[Q + 1] = fa(n[Q + 1], s)),
                        (n[w + 1] = (function h0(n, e) {
                          return (131071 & n) | (e << 17);
                        })(n[w + 1], s));
                    } else
                      (n[s + 1] = Wc(w, 0)),
                        0 !== w && (n[w + 1] = fa(n[w + 1], s)),
                        (w = s);
                  else
                    (n[s + 1] = Wc(S, 0)),
                      0 === w ? (w = s) : (n[S + 1] = fa(n[S + 1], s)),
                      (S = s);
                  P && (n[s + 1] = Hd(n[s + 1])),
                    r1(n, N, s, !0),
                    r1(n, N, s, !1),
                    (function ID(n, e, t, s, c) {
                      const p = c ? n.residualClasses : n.residualStyles;
                      null != p &&
                        "string" == typeof e &&
                        kc(p, e) >= 0 &&
                        (t[s + 1] = Gd(t[s + 1]));
                    })(e, N, n, s, p),
                    (y = Wc(w, S)),
                    p ? (e.classBindings = y) : (e.styleBindings = y);
                })(c, p, e, t, y, s);
            }
          })(c, null, p, s);
        const y = Ze();
        if (t !== Ut && Tr(y, p, t)) {
          const w = c.data[v()];
          if (y1(w, s) && !p1(c, p)) {
            let S = s ? w.classesWithoutHost : w.stylesWithoutHost;
            null !== S && (t = Vt(S, t || "")), D0(c, w, y, t, s);
          } else
            !(function jD(n, e, t, s, c, p, y, w) {
              c === Ut && (c = vn);
              let S = 0,
                P = 0,
                N = 0 < c.length ? c[0] : null,
                j = 0 < p.length ? p[0] : null;
              for (; null !== N || null !== j; ) {
                const Q = S < c.length ? c[S + 1] : void 0,
                  ie = P < p.length ? p[P + 1] : void 0;
                let Ee,
                  pe = null;
                N === j
                  ? ((S += 2), (P += 2), Q !== ie && ((pe = j), (Ee = ie)))
                  : null === j || (null !== N && N < j)
                  ? ((S += 2), (pe = N))
                  : ((P += 2), (pe = j), (Ee = ie)),
                  null !== pe && g1(n, e, t, s, pe, Ee, y, w),
                  (N = S < c.length ? c[S] : null),
                  (j = P < p.length ? p[P] : null);
              }
            })(
              c,
              w,
              y,
              y[11],
              y[p + 1],
              (y[p + 1] = (function VD(n, e, t) {
                if (null == t || "" === t) return vn;
                const s = [],
                  c = (function ql(n) {
                    return n instanceof
                      class m_ {
                        constructor(e) {
                          this.changingThisBreaksApplicationSecurity = e;
                        }
                        toString() {
                          return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
                        }
                      }
                      ? n.changingThisBreaksApplicationSecurity
                      : n;
                  })(t);
                if (Array.isArray(c))
                  for (let p = 0; p < c.length; p++) n(s, c[p], !0);
                else if ("object" == typeof c)
                  for (const p in c) c.hasOwnProperty(p) && n(s, p, c[p]);
                else "string" == typeof c && e(s, c);
                return s;
              })(n, e, t)),
              s,
              p
            );
        }
      }
      function p1(n, e) {
        return e >= n.expandoStartIndex;
      }
      function P0(n, e, t, s, c) {
        let p = null;
        const y = t.directiveEnd;
        let w = t.directiveStylingLast;
        for (
          -1 === w ? (w = t.directiveStart) : w++;
          w < y && ((p = e[w]), (s = mg(s, p.hostAttrs, c)), p !== n);

        )
          w++;
        return null !== n && (t.directiveStylingLast = w), s;
      }
      function mg(n, e, t) {
        const s = t ? 1 : 2;
        let c = -1;
        if (null !== e)
          for (let p = 0; p < e.length; p++) {
            const y = e[p];
            "number" == typeof y
              ? (c = y)
              : c === s &&
                (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]),
                Xn(n, y, !!t || e[++p]));
          }
        return void 0 === n ? null : n;
      }
      function g1(n, e, t, s, c, p, y, w) {
        if (!(3 & e.type)) return;
        const S = n.data,
          P = S[w + 1];
        gy(
          (function ry(n) {
            return 1 == (1 & n);
          })(P)
            ? _1(S, e, t, c, bs(P), y)
            : void 0
        ) ||
          (gy(p) ||
            ((function $d(n) {
              return 2 == (2 & n);
            })(P) &&
              (p = _1(S, null, t, c, w, y))),
          (function Pv(n, e, t, s, c) {
            if (e) c ? n.addClass(t, s) : n.removeClass(t, s);
            else {
              let p = -1 === s.indexOf("-") ? void 0 : Yi.DashCase;
              null == c
                ? n.removeStyle(t, s, p)
                : ("string" == typeof c &&
                    c.endsWith("!important") &&
                    ((c = c.slice(0, -10)), (p |= Yi.Important)),
                  n.setStyle(t, s, c, p));
            }
          })(s, y, ja(v(), t), c, p));
      }
      function _1(n, e, t, s, c, p) {
        const y = null === e;
        let w;
        for (; c > 0; ) {
          const S = n[c],
            P = Array.isArray(S),
            N = P ? S[1] : S,
            j = null === N;
          let Q = t[c + 1];
          Q === Ut && (Q = j ? vn : void 0);
          let ie = j ? Ep(Q, s) : N === s ? Q : void 0;
          if ((P && !gy(ie) && (ie = Ep(S, s)), gy(ie) && ((w = ie), y)))
            return w;
          const pe = n[c + 1];
          c = y ? ao(pe) : bs(pe);
        }
        if (null !== e) {
          let S = p ? e.residualClasses : e.residualStyles;
          null != S && (w = Ep(S, s));
        }
        return w;
      }
      function gy(n) {
        return void 0 !== n;
      }
      function y1(n, e) {
        return 0 != (n.flags & (e ? 16 : 32));
      }
      function Si(n, e = "") {
        const t = Ze(),
          s = dn(),
          c = n + 22,
          p = s.firstCreatePass ? Kc(s, c, 1, e, null) : s.data[c],
          y = (t[c] = (function nl(n, e) {
            return n.createText(e);
          })(t[11], e));
        Vp(s, t, y, p), Xo(p, !1);
      }
      function _y(n) {
        return L0("", n, ""), _y;
      }
      function L0(n, e, t) {
        const s = Ze(),
          c = mh(s, n, e, t);
        return (
          c !== Ut &&
            (function Zt(n, e, t) {
              const s = ja(e, n);
              !(function pm(n, e, t) {
                n.setValue(e, t);
              })(n[11], s, t);
            })(s, v(), c),
          L0
        );
      }
      const bf = "en-US";
      let j1 = bf;
      class wf {}
      class pw extends wf {
        constructor(e, t) {
          super(),
            (this._parent = t),
            (this._bootstrapComponents = []),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new At(this));
          const s = (function Gr(n, e) {
            const t = n[Ho] || null;
            if (!t && !0 === e)
              throw new Error(
                `Type ${_t(n)} does not have '\u0275mod' property.`
              );
            return t;
          })(e);
          (this._bootstrapComponents = (function pa(n) {
            return n instanceof Function ? n() : n;
          })(s.bootstrap)),
            (this._r3Injector = qm(
              e,
              t,
              [
                { provide: wf, useValue: this },
                { provide: Qp, useValue: this.componentFactoryResolver },
              ],
              _t(e),
              new Set(["environment"])
            )),
            this._r3Injector.resolveInjectorInitializers(),
            (this.instance = this._r3Injector.get(e));
        }
        get injector() {
          return this._r3Injector;
        }
        destroy() {
          const e = this._r3Injector;
          !e.destroyed && e.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null);
        }
        onDestroy(e) {
          this.destroyCbs.push(e);
        }
      }
      class B0 extends class aI {} {
        constructor(e) {
          super(), (this.moduleType = e);
        }
        create(e) {
          return new pw(this.moduleType, e);
        }
      }
      function bw(n, e, t, s) {
        return (function Ew(n, e, t, s, c, p) {
          const y = e + t;
          return Tr(n, y, c)
            ? Jo(n, y + 1, p ? s.call(p, c) : s(c))
            : bg(n, y + 1);
        })(Ze(), Vi(), n, e, t, s);
      }
      function ww(n, e, t, s, c) {
        return (function Tw(n, e, t, s, c, p, y) {
          const w = e + t;
          return (function Lo(n, e, t, s) {
            const c = Tr(n, e, t);
            return Tr(n, e + 1, s) || c;
          })(n, w, c, p)
            ? Jo(n, w + 2, y ? s.call(y, c, p) : s(c, p))
            : bg(n, w + 2);
        })(Ze(), Vi(), n, e, t, s, c);
      }
      function bg(n, e) {
        const t = n[e];
        return t === Ut ? void 0 : t;
      }
      function j0(n) {
        return (e) => {
          setTimeout(n, void 0, e);
        };
      }
      const xa = class OI extends rs {
        constructor(e = !1) {
          super(), (this.__isAsync = e);
        }
        emit(e) {
          super.next(e);
        }
        subscribe(e, t, s) {
          let c = e,
            p = t || (() => null),
            y = s;
          if (e && "object" == typeof e) {
            const S = e;
            (c = S.next?.bind(S)),
              (p = S.error?.bind(S)),
              (y = S.complete?.bind(S));
          }
          this.__isAsync && ((p = j0(p)), c && (c = j0(c)), y && (y = j0(y)));
          const w = super.subscribe({ next: c, error: p, complete: y });
          return e instanceof Be && e.add(w), w;
        }
      };
      function FI() {
        return this._results[Ss()]();
      }
      class U0 {
        constructor(e = !1) {
          (this._emitDistinctChangesOnly = e),
            (this.dirty = !0),
            (this._results = []),
            (this._changesDetected = !1),
            (this._changes = null),
            (this.length = 0),
            (this.first = void 0),
            (this.last = void 0);
          const t = Ss(),
            s = U0.prototype;
          s[t] || (s[t] = FI);
        }
        get changes() {
          return this._changes || (this._changes = new xa());
        }
        get(e) {
          return this._results[e];
        }
        map(e) {
          return this._results.map(e);
        }
        filter(e) {
          return this._results.filter(e);
        }
        find(e) {
          return this._results.find(e);
        }
        reduce(e, t) {
          return this._results.reduce(e, t);
        }
        forEach(e) {
          this._results.forEach(e);
        }
        some(e) {
          return this._results.some(e);
        }
        toArray() {
          return this._results.slice();
        }
        toString() {
          return this._results.toString();
        }
        reset(e, t) {
          const s = this;
          s.dirty = !1;
          const c = Io(e);
          (this._changesDetected = !(function gv(n, e, t) {
            if (n.length !== e.length) return !1;
            for (let s = 0; s < n.length; s++) {
              let c = n[s],
                p = e[s];
              if ((t && ((c = t(c)), (p = t(p))), p !== c)) return !1;
            }
            return !0;
          })(s._results, c, t)) &&
            ((s._results = c),
            (s.length = c.length),
            (s.last = c[this.length - 1]),
            (s.first = c[0]));
        }
        notifyOnChanges() {
          this._changes &&
            (this._changesDetected || !this._emitDistinctChangesOnly) &&
            this._changes.emit(this);
        }
        setDirty() {
          this.dirty = !0;
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe();
        }
      }
      let nc = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = BI), n;
      })();
      const NI = nc,
        zI = class extends NI {
          constructor(e, t, s) {
            super(),
              (this._declarationLView = e),
              (this._declarationTContainer = t),
              (this.elementRef = s);
          }
          createEmbeddedView(e, t) {
            const s = this._declarationTContainer.tViews,
              c = Xd(
                this._declarationLView,
                s,
                e,
                16,
                null,
                s.declTNode,
                null,
                null,
                null,
                null,
                t || null
              );
            c[17] = this._declarationLView[this._declarationTContainer.index];
            const y = this._declarationLView[19];
            return (
              null !== y && (c[19] = y.createEmbeddedView(s)),
              df(s, c, e),
              new Dn(c)
            );
          }
        };
      function BI() {
        return wy(Pi(), Ze());
      }
      function wy(n, e) {
        return 4 & n.type ? new zI(e, n, th(n, e)) : null;
      }
      let pl = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = VI), n;
      })();
      function VI() {
        return Aw(Pi(), Ze());
      }
      const jI = pl,
        Cw = class extends jI {
          constructor(e, t, s) {
            super(),
              (this._lContainer = e),
              (this._hostTNode = t),
              (this._hostLView = s);
          }
          get element() {
            return th(this._hostTNode, this._hostLView);
          }
          get injector() {
            return new Or(this._hostTNode, this._hostLView);
          }
          get parentInjector() {
            const e = mi(this._hostTNode, this._hostLView);
            if (He(e)) {
              const t = dt(e, this._hostLView),
                s = Ne(e);
              return new Or(t[1].data[s + 8], t);
            }
            return new Or(null, this._hostLView);
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1);
          }
          get(e) {
            const t = Mw(this._lContainer);
            return (null !== t && t[e]) || null;
          }
          get length() {
            return this._lContainer.length - 10;
          }
          createEmbeddedView(e, t, s) {
            let c, p;
            "number" == typeof s
              ? (c = s)
              : null != s && ((c = s.index), (p = s.injector));
            const y = e.createEmbeddedView(t || {}, p);
            return this.insert(y, c), y;
          }
          createComponent(e, t, s, c, p) {
            const y =
              e &&
              !(function gs(n) {
                return "function" == typeof n;
              })(e);
            let w;
            if (y) w = t;
            else {
              const j = t || {};
              (w = j.index),
                (s = j.injector),
                (c = j.projectableNodes),
                (p = j.environmentInjector || j.ngModuleRef);
            }
            const S = y ? e : new gn(In(e)),
              P = s || this.parentInjector;
            if (!p && null == S.ngModule) {
              const Q = (y ? P : this.parentInjector).get(da, null);
              Q && (p = Q);
            }
            const N = S.create(P, c, void 0, p);
            return this.insert(N.hostView, w), N;
          }
          insert(e, t) {
            const s = e._lView,
              c = s[1];
            if (
              (function Zh(n) {
                return ar(n[3]);
              })(s)
            ) {
              const N = this.indexOf(e);
              if (-1 !== N) this.detach(N);
              else {
                const j = s[3],
                  Q = new Cw(j, j[6], j[3]);
                Q.detach(Q.indexOf(e));
              }
            }
            const p = this._adjustIndex(t),
              y = this._lContainer;
            !(function Mv(n, e, t, s) {
              const c = 10 + s,
                p = t.length;
              s > 0 && (t[c - 1][4] = e),
                s < p - 10
                  ? ((e[4] = t[c]), qf(t, 10 + s, e))
                  : (t.push(e), (e[4] = null)),
                (e[3] = t);
              const y = e[17];
              null !== y &&
                t !== y &&
                (function o_(n, e) {
                  const t = n[9];
                  e[16] !== e[3][3][16] && (n[2] = !0),
                    null === t ? (n[9] = [e]) : t.push(e);
                })(y, e);
              const w = e[19];
              null !== w && w.insertView(n), (e[2] |= 64);
            })(c, s, y, p);
            const w = ym(p, y),
              S = s[11],
              P = zp(S, y[7]);
            return (
              null !== P &&
                (function i_(n, e, t, s, c, p) {
                  (s[0] = c), (s[6] = e), _d(n, s, t, 1, c, p);
                })(c, y[6], S, s, P, w),
              e.attachToViewContainerRef(),
              qf($0(y), p, e),
              e
            );
          }
          move(e, t) {
            return this.insert(e, t);
          }
          indexOf(e) {
            const t = Mw(this._lContainer);
            return null !== t ? t.indexOf(e) : -1;
          }
          remove(e) {
            const t = this._adjustIndex(e, -1),
              s = Fp(this._lContainer, t);
            s && (td($0(this._lContainer), t), a_(s[1], s));
          }
          detach(e) {
            const t = this._adjustIndex(e, -1),
              s = Fp(this._lContainer, t);
            return s && null != td($0(this._lContainer), t) ? new Dn(s) : null;
          }
          _adjustIndex(e, t = 0) {
            return e ?? this.length + t;
          }
        };
      function Mw(n) {
        return n[8];
      }
      function $0(n) {
        return n[8] || (n[8] = []);
      }
      function Aw(n, e) {
        let t;
        const s = e[n.index];
        if (ar(s)) t = s;
        else {
          let c;
          if (8 & n.type) c = ti(s);
          else {
            const p = e[11];
            c = p.createComment("");
            const y = zi(n, e);
            Xr(
              p,
              zp(p, y),
              c,
              (function Av(n, e) {
                return n.nextSibling(e);
              })(p, y),
              !1
            );
          }
          (e[n.index] = t = ae(s, e, c, n)), Re(e, t);
        }
        return new Cw(t, n, e);
      }
      class H0 {
        constructor(e) {
          (this.queryList = e), (this.matches = null);
        }
        clone() {
          return new H0(this.queryList);
        }
        setDirty() {
          this.queryList.setDirty();
        }
      }
      class G0 {
        constructor(e = []) {
          this.queries = e;
        }
        createEmbeddedView(e) {
          const t = e.queries;
          if (null !== t) {
            const s =
                null !== e.contentQueries ? e.contentQueries[0] : t.length,
              c = [];
            for (let p = 0; p < s; p++) {
              const y = t.getByIndex(p);
              c.push(this.queries[y.indexInDeclarationView].clone());
            }
            return new G0(c);
          }
          return null;
        }
        insertView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        detachView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        dirtyQueriesWithMatches(e) {
          for (let t = 0; t < this.queries.length; t++)
            null !== Ow(e, t).matches && this.queries[t].setDirty();
        }
      }
      class Pw {
        constructor(e, t, s = null) {
          (this.predicate = e), (this.flags = t), (this.read = s);
        }
      }
      class q0 {
        constructor(e = []) {
          this.queries = e;
        }
        elementStart(e, t) {
          for (let s = 0; s < this.queries.length; s++)
            this.queries[s].elementStart(e, t);
        }
        elementEnd(e) {
          for (let t = 0; t < this.queries.length; t++)
            this.queries[t].elementEnd(e);
        }
        embeddedTView(e) {
          let t = null;
          for (let s = 0; s < this.length; s++) {
            const c = null !== t ? t.length : 0,
              p = this.getByIndex(s).embeddedTView(e, c);
            p &&
              ((p.indexInDeclarationView = s),
              null !== t ? t.push(p) : (t = [p]));
          }
          return null !== t ? new q0(t) : null;
        }
        template(e, t) {
          for (let s = 0; s < this.queries.length; s++)
            this.queries[s].template(e, t);
        }
        getByIndex(e) {
          return this.queries[e];
        }
        get length() {
          return this.queries.length;
        }
        track(e) {
          this.queries.push(e);
        }
      }
      class W0 {
        constructor(e, t = -1) {
          (this.metadata = e),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = t);
        }
        elementStart(e, t) {
          this.isApplyingToNode(t) && this.matchTNode(e, t);
        }
        elementEnd(e) {
          this._declarationNodeIndex === e.index &&
            (this._appliesToNextNode = !1);
        }
        template(e, t) {
          this.elementStart(e, t);
        }
        embeddedTView(e, t) {
          return this.isApplyingToNode(e)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-e.index, t),
              new W0(this.metadata))
            : null;
        }
        isApplyingToNode(e) {
          if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
            const t = this._declarationNodeIndex;
            let s = e.parent;
            for (; null !== s && 8 & s.type && s.index !== t; ) s = s.parent;
            return t === (null !== s ? s.index : -1);
          }
          return this._appliesToNextNode;
        }
        matchTNode(e, t) {
          const s = this.metadata.predicate;
          if (Array.isArray(s))
            for (let c = 0; c < s.length; c++) {
              const p = s[c];
              this.matchTNodeWithReadOption(e, t, HI(t, p)),
                this.matchTNodeWithReadOption(e, t, Rn(t, e, p, !1, !1));
            }
          else
            s === nc
              ? 4 & t.type && this.matchTNodeWithReadOption(e, t, -1)
              : this.matchTNodeWithReadOption(e, t, Rn(t, e, s, !1, !1));
        }
        matchTNodeWithReadOption(e, t, s) {
          if (null !== s) {
            const c = this.metadata.read;
            if (null !== c)
              if (c === sl || c === pl || (c === nc && 4 & t.type))
                this.addMatch(t.index, -2);
              else {
                const p = Rn(t, e, c, !1, !1);
                null !== p && this.addMatch(t.index, p);
              }
            else this.addMatch(t.index, s);
          }
        }
        addMatch(e, t) {
          null === this.matches
            ? (this.matches = [e, t])
            : this.matches.push(e, t);
        }
      }
      function HI(n, e) {
        const t = n.localNames;
        if (null !== t)
          for (let s = 0; s < t.length; s += 2) if (t[s] === e) return t[s + 1];
        return null;
      }
      function qI(n, e, t, s) {
        return -1 === t
          ? (function GI(n, e) {
              return 11 & n.type ? th(n, e) : 4 & n.type ? wy(n, e) : null;
            })(e, n)
          : -2 === t
          ? (function WI(n, e, t) {
              return t === sl
                ? th(e, n)
                : t === nc
                ? wy(e, n)
                : t === pl
                ? Aw(e, n)
                : void 0;
            })(n, e, s)
          : Ui(n, n[1], t, e);
      }
      function Lw(n, e, t, s) {
        const c = e[19].queries[s];
        if (null === c.matches) {
          const p = n.data,
            y = t.matches,
            w = [];
          for (let S = 0; S < y.length; S += 2) {
            const P = y[S];
            w.push(P < 0 ? null : qI(e, p[P], y[S + 1], t.metadata.read));
          }
          c.matches = w;
        }
        return c.matches;
      }
      function Z0(n, e, t, s) {
        const c = n.queries.getByIndex(t),
          p = c.matches;
        if (null !== p) {
          const y = Lw(n, e, c, t);
          for (let w = 0; w < p.length; w += 2) {
            const S = p[w];
            if (S > 0) s.push(y[w / 2]);
            else {
              const P = p[w + 1],
                N = e[-S];
              for (let j = 10; j < N.length; j++) {
                const Q = N[j];
                Q[17] === Q[3] && Z0(Q[1], Q, P, s);
              }
              if (null !== N[9]) {
                const j = N[9];
                for (let Q = 0; Q < j.length; Q++) {
                  const ie = j[Q];
                  Z0(ie[1], ie, P, s);
                }
              }
            }
          }
        }
        return s;
      }
      function _h(n) {
        const e = Ze(),
          t = dn(),
          s = Jh();
        ku(s + 1);
        const c = Ow(t, s);
        if (
          n.dirty &&
          (function Wh(n) {
            return 4 == (4 & n[2]);
          })(e) ===
            (2 == (2 & c.metadata.flags))
        ) {
          if (null === c.matches) n.reset([]);
          else {
            const p = c.crossesNgTemplate ? Z0(t, e, s, []) : Lw(t, e, c, s);
            n.reset(p, Jp), n.notifyOnChanges();
          }
          return !0;
        }
        return !1;
      }
      function Ef(n, e, t) {
        const s = dn();
        s.firstCreatePass &&
          (Rw(s, new Pw(n, e, t), -1),
          2 == (2 & e) && (s.staticViewQueries = !0)),
          kw(s, Ze(), e);
      }
      function X0(n, e, t, s) {
        const c = dn();
        if (c.firstCreatePass) {
          const p = Pi();
          Rw(c, new Pw(e, t, s), p.index),
            (function XI(n, e) {
              const t = n.contentQueries || (n.contentQueries = []);
              e !== (t.length ? t[t.length - 1] : -1) &&
                t.push(n.queries.length - 1, e);
            })(c, n),
            2 == (2 & t) && (c.staticContentQueries = !0);
        }
        kw(c, Ze(), t);
      }
      function yh() {
        return (function ZI(n, e) {
          return n[19].queries[e].queryList;
        })(Ze(), Jh());
      }
      function kw(n, e, t) {
        const s = new U0(4 == (4 & t));
        mf(n, e, s, s.destroy),
          null === e[19] && (e[19] = new G0()),
          e[19].queries.push(new H0(s));
      }
      function Rw(n, e, t) {
        null === n.queries && (n.queries = new q0()),
          n.queries.track(new W0(e, t));
      }
      function Ow(n, e) {
        return n.queries.getByIndex(e);
      }
      function Ty(...n) {}
      const eE = new nn("Application Initializer");
      let Dy = (() => {
        class n {
          constructor(t) {
            (this.appInits = t),
              (this.resolve = Ty),
              (this.reject = Ty),
              (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((s, c) => {
                (this.resolve = s), (this.reject = c);
              }));
          }
          runInitializers() {
            if (this.initialized) return;
            const t = [],
              s = () => {
                (this.done = !0), this.resolve();
              };
            if (this.appInits)
              for (let c = 0; c < this.appInits.length; c++) {
                const p = this.appInits[c]();
                if (S0(p)) t.push(p);
                else if (ED(p)) {
                  const y = new Promise((w, S) => {
                    p.subscribe({ complete: w, error: S });
                  });
                  t.push(y);
                }
              }
            Promise.all(t)
              .then(() => {
                s();
              })
              .catch((c) => {
                this.reject(c);
              }),
              0 === t.length && s(),
              (this.initialized = !0);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(eE, 8));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const Tg = new nn("AppId", {
        providedIn: "root",
        factory: function tE() {
          return `${ex()}${ex()}${ex()}`;
        },
      });
      function ex() {
        return String.fromCharCode(97 + Math.floor(25 * Math.random()));
      }
      const nE = new nn("Platform Initializer"),
        iE = new nn("Platform ID", {
          providedIn: "platform",
          factory: () => "unknown",
        }),
        gC = new nn("appBootstrapListener"),
        rE = new nn("AnimationModuleType"),
        Jc = new nn("LocaleId", {
          providedIn: "root",
          factory: () =>
            (function Xf(n, e = Tt.Default) {
              return (
                "number" != typeof e &&
                  (e =
                    0 |
                    (e.optional && 8) |
                    (e.host && 1) |
                    (e.self && 2) |
                    (e.skipSelf && 4)),
                St(n, e)
              );
            })(Jc, Tt.Optional | Tt.SkipSelf) ||
            (function _C() {
              return (typeof $localize < "u" && $localize.locale) || bf;
            })(),
        }),
        wC = (() => Promise.resolve(0))();
      function tx(n) {
        typeof Zone > "u"
          ? wC.then(() => {
              n && n.apply(null, null);
            })
          : Zone.current.scheduleMicroTask("scheduleMicrotask", n);
      }
      class ur {
        constructor({
          enableLongStackTrace: e = !1,
          shouldCoalesceEventChangeDetection: t = !1,
          shouldCoalesceRunChangeDetection: s = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new xa(!1)),
            (this.onMicrotaskEmpty = new xa(!1)),
            (this.onStable = new xa(!1)),
            (this.onError = new xa(!1)),
            typeof Zone > "u")
          )
            throw new rt(908, !1);
          Zone.assertZonePatched();
          const c = this;
          if (
            ((c._nesting = 0),
            (c._outer = c._inner = Zone.current),
            Zone.AsyncStackTaggingZoneSpec)
          ) {
            const p = Zone.AsyncStackTaggingZoneSpec;
            c._inner = c._inner.fork(new p("Angular"));
          }
          Zone.TaskTrackingZoneSpec &&
            (c._inner = c._inner.fork(new Zone.TaskTrackingZoneSpec())),
            e &&
              Zone.longStackTraceZoneSpec &&
              (c._inner = c._inner.fork(Zone.longStackTraceZoneSpec)),
            (c.shouldCoalesceEventChangeDetection = !s && t),
            (c.shouldCoalesceRunChangeDetection = s),
            (c.lastRequestAnimationFrameId = -1),
            (c.nativeRequestAnimationFrame = (function EC() {
              let n = jn.requestAnimationFrame,
                e = jn.cancelAnimationFrame;
              if (typeof Zone < "u" && n && e) {
                const t = n[Zone.__symbol__("OriginalDelegate")];
                t && (n = t);
                const s = e[Zone.__symbol__("OriginalDelegate")];
                s && (e = s);
              }
              return {
                nativeRequestAnimationFrame: n,
                nativeCancelAnimationFrame: e,
              };
            })().nativeRequestAnimationFrame),
            (function SC(n) {
              const e = () => {
                !(function DC(n) {
                  n.isCheckStableRunning ||
                    -1 !== n.lastRequestAnimationFrameId ||
                    ((n.lastRequestAnimationFrameId =
                      n.nativeRequestAnimationFrame.call(jn, () => {
                        n.fakeTopEventTask ||
                          (n.fakeTopEventTask = Zone.root.scheduleEventTask(
                            "fakeTopEventTask",
                            () => {
                              (n.lastRequestAnimationFrameId = -1),
                                ix(n),
                                (n.isCheckStableRunning = !0),
                                nx(n),
                                (n.isCheckStableRunning = !1);
                            },
                            void 0,
                            () => {},
                            () => {}
                          )),
                          n.fakeTopEventTask.invoke();
                      })),
                    ix(n));
                })(n);
              };
              n._inner = n._inner.fork({
                name: "angular",
                properties: { isAngularZone: !0 },
                onInvokeTask: (t, s, c, p, y, w) => {
                  try {
                    return aE(n), t.invokeTask(c, p, y, w);
                  } finally {
                    ((n.shouldCoalesceEventChangeDetection &&
                      "eventTask" === p.type) ||
                      n.shouldCoalesceRunChangeDetection) &&
                      e(),
                      lE(n);
                  }
                },
                onInvoke: (t, s, c, p, y, w, S) => {
                  try {
                    return aE(n), t.invoke(c, p, y, w, S);
                  } finally {
                    n.shouldCoalesceRunChangeDetection && e(), lE(n);
                  }
                },
                onHasTask: (t, s, c, p) => {
                  t.hasTask(c, p),
                    s === c &&
                      ("microTask" == p.change
                        ? ((n._hasPendingMicrotasks = p.microTask),
                          ix(n),
                          nx(n))
                        : "macroTask" == p.change &&
                          (n.hasPendingMacrotasks = p.macroTask));
                },
                onHandleError: (t, s, c, p) => (
                  t.handleError(c, p),
                  n.runOutsideAngular(() => n.onError.emit(p)),
                  !1
                ),
              });
            })(c);
        }
        static isInAngularZone() {
          return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone");
        }
        static assertInAngularZone() {
          if (!ur.isInAngularZone()) throw new rt(909, !1);
        }
        static assertNotInAngularZone() {
          if (ur.isInAngularZone()) throw new rt(909, !1);
        }
        run(e, t, s) {
          return this._inner.run(e, t, s);
        }
        runTask(e, t, s, c) {
          const p = this._inner,
            y = p.scheduleEventTask("NgZoneEvent: " + c, e, TC, Ty, Ty);
          try {
            return p.runTask(y, t, s);
          } finally {
            p.cancelTask(y);
          }
        }
        runGuarded(e, t, s) {
          return this._inner.runGuarded(e, t, s);
        }
        runOutsideAngular(e) {
          return this._outer.run(e);
        }
      }
      const TC = {};
      function nx(n) {
        if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable)
          try {
            n._nesting++, n.onMicrotaskEmpty.emit(null);
          } finally {
            if ((n._nesting--, !n.hasPendingMicrotasks))
              try {
                n.runOutsideAngular(() => n.onStable.emit(null));
              } finally {
                n.isStable = !0;
              }
          }
      }
      function ix(n) {
        n.hasPendingMicrotasks = !!(
          n._hasPendingMicrotasks ||
          ((n.shouldCoalesceEventChangeDetection ||
            n.shouldCoalesceRunChangeDetection) &&
            -1 !== n.lastRequestAnimationFrameId)
        );
      }
      function aE(n) {
        n._nesting++,
          n.isStable && ((n.isStable = !1), n.onUnstable.emit(null));
      }
      function lE(n) {
        n._nesting--, nx(n);
      }
      class IC {
        constructor() {
          (this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new xa()),
            (this.onMicrotaskEmpty = new xa()),
            (this.onStable = new xa()),
            (this.onError = new xa());
        }
        run(e, t, s) {
          return e.apply(t, s);
        }
        runGuarded(e, t, s) {
          return e.apply(t, s);
        }
        runOutsideAngular(e) {
          return e();
        }
        runTask(e, t, s, c) {
          return e.apply(t, s);
        }
      }
      const cE = new nn(""),
        Sy = new nn("");
      let sx,
        rx = (() => {
          class n {
            constructor(t, s, c) {
              (this._ngZone = t),
                (this.registry = s),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                sx ||
                  ((function CC(n) {
                    sx = n;
                  })(c),
                  c.addToWindow(s)),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    typeof Zone > "u"
                      ? null
                      : Zone.current.get("TaskTrackingZone");
                });
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  (this._didWork = !0), (this._isZoneStable = !1);
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      ur.assertNotInAngularZone(),
                        tx(() => {
                          (this._isZoneStable = !0),
                            this._runCallbacksIfReady();
                        });
                    },
                  });
                });
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              );
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error("pending async requests below zero");
              return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              );
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                tx(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop();
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork);
                  }
                  this._didWork = !1;
                });
              else {
                let t = this.getPendingTasks();
                (this._callbacks = this._callbacks.filter(
                  (s) =>
                    !s.updateCb ||
                    !s.updateCb(t) ||
                    (clearTimeout(s.timeoutId), !1)
                )),
                  (this._didWork = !0);
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : [];
            }
            addCallback(t, s, c) {
              let p = -1;
              s &&
                s > 0 &&
                (p = setTimeout(() => {
                  (this._callbacks = this._callbacks.filter(
                    (y) => y.timeoutId !== p
                  )),
                    t(this._didWork, this.getPendingTasks());
                }, s)),
                this._callbacks.push({ doneCb: t, timeoutId: p, updateCb: c });
            }
            whenStable(t, s, c) {
              if (c && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'
                );
              this.addCallback(t, s, c), this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
              return this._pendingCount;
            }
            registerApplication(t) {
              this.registry.registerApplication(t, this);
            }
            unregisterApplication(t) {
              this.registry.unregisterApplication(t);
            }
            findProviders(t, s, c) {
              return [];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(St(ur), St(ox), St(Sy));
            }),
            (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        ox = (() => {
          class n {
            constructor() {
              this._applications = new Map();
            }
            registerApplication(t, s) {
              this._applications.set(t, s);
            }
            unregisterApplication(t) {
              this._applications.delete(t);
            }
            unregisterAllApplications() {
              this._applications.clear();
            }
            getTestability(t) {
              return this._applications.get(t) || null;
            }
            getAllTestabilities() {
              return Array.from(this._applications.values());
            }
            getAllRootElements() {
              return Array.from(this._applications.keys());
            }
            findTestabilityInTree(t, s = !0) {
              return sx?.findTestabilityInTree(this, t, s) ?? null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Sn({
              token: n,
              factory: n.ɵfac,
              providedIn: "platform",
            })),
            n
          );
        })(),
        vh = null;
      const uE = new nn("AllowMultipleToken"),
        ax = new nn("PlatformDestroyListeners");
      function dE(n, e, t = []) {
        const s = `Platform: ${e}`,
          c = new nn(s);
        return (p = []) => {
          let y = lx();
          if (!y || y.injector.get(uE, !1)) {
            const w = [...t, ...p, { provide: c, useValue: !0 }];
            n
              ? n(w)
              : (function PC(n) {
                  if (vh && !vh.get(uE, !1)) throw new rt(400, !1);
                  vh = n;
                  const e = n.get(fE);
                  (function hE(n) {
                    const e = n.get(nE, null);
                    e && e.forEach((t) => t());
                  })(n);
                })(
                  (function pE(n = [], e) {
                    return Hc.create({
                      name: e,
                      providers: [
                        { provide: Pd, useValue: "platform" },
                        { provide: ax, useValue: new Set([() => (vh = null)]) },
                        ...n,
                      ],
                    });
                  })(w, s)
                );
          }
          return (function kC(n) {
            const e = lx();
            if (!e) throw new rt(401, !1);
            return e;
          })();
        };
      }
      function lx() {
        return vh?.get(fE) ?? null;
      }
      let fE = (() => {
        class n {
          constructor(t) {
            (this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1);
          }
          bootstrapModuleFactory(t, s) {
            const c = (function gE(n, e) {
                let t;
                return (
                  (t =
                    "noop" === n
                      ? new IC()
                      : ("zone.js" === n ? void 0 : n) || new ur(e)),
                  t
                );
              })(
                s?.ngZone,
                (function mE(n) {
                  return {
                    enableLongStackTrace: !1,
                    shouldCoalesceEventChangeDetection:
                      !(!n || !n.ngZoneEventCoalescing) || !1,
                    shouldCoalesceRunChangeDetection:
                      !(!n || !n.ngZoneRunCoalescing) || !1,
                  };
                })(s)
              ),
              p = [{ provide: ur, useValue: c }];
            return c.run(() => {
              const y = Hc.create({
                  providers: p,
                  parent: this.injector,
                  name: t.moduleType.name,
                }),
                w = t.create(y),
                S = w.injector.get(Uc, null);
              if (!S) throw new rt(402, !1);
              return (
                c.runOutsideAngular(() => {
                  const P = c.onError.subscribe({
                    next: (N) => {
                      S.handleError(N);
                    },
                  });
                  w.onDestroy(() => {
                    Cy(this._modules, w), P.unsubscribe();
                  });
                }),
                (function _E(n, e, t) {
                  try {
                    const s = t();
                    return S0(s)
                      ? s.catch((c) => {
                          throw (
                            (e.runOutsideAngular(() => n.handleError(c)), c)
                          );
                        })
                      : s;
                  } catch (s) {
                    throw (e.runOutsideAngular(() => n.handleError(s)), s);
                  }
                })(S, c, () => {
                  const P = w.injector.get(Dy);
                  return (
                    P.runInitializers(),
                    P.donePromise.then(
                      () => (
                        (function U1(n) {
                          un(n, "Expected localeId to be defined"),
                            "string" == typeof n &&
                              (j1 = n.toLowerCase().replace(/_/g, "-"));
                        })(w.injector.get(Jc, bf) || bf),
                        this._moduleDoBootstrap(w),
                        w
                      )
                    )
                  );
                })
              );
            });
          }
          bootstrapModule(t, s = []) {
            const c = yE({}, s);
            return (function MC(n, e, t) {
              const s = new B0(t);
              return Promise.resolve(s);
            })(0, 0, t).then((p) => this.bootstrapModuleFactory(p, c));
          }
          _moduleDoBootstrap(t) {
            const s = t.injector.get(Iy);
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((c) => s.bootstrap(c));
            else {
              if (!t.instance.ngDoBootstrap) throw new rt(403, !1);
              t.instance.ngDoBootstrap(s);
            }
            this._modules.push(t);
          }
          onDestroy(t) {
            this._destroyListeners.push(t);
          }
          get injector() {
            return this._injector;
          }
          destroy() {
            if (this._destroyed) throw new rt(404, !1);
            this._modules.slice().forEach((s) => s.destroy()),
              this._destroyListeners.forEach((s) => s());
            const t = this._injector.get(ax, null);
            t && (t.forEach((s) => s()), t.clear()), (this._destroyed = !0);
          }
          get destroyed() {
            return this._destroyed;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(Hc));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac, providedIn: "platform" })),
          n
        );
      })();
      function yE(n, e) {
        return Array.isArray(e) ? e.reduce(yE, n) : { ...n, ...e };
      }
      let Iy = (() => {
        class n {
          constructor(t, s, c) {
            (this._zone = t),
              (this._injector = s),
              (this._exceptionHandler = c),
              (this._bootstrapListeners = []),
              (this._views = []),
              (this._runningTick = !1),
              (this._stable = !0),
              (this._destroyed = !1),
              (this._destroyListeners = []),
              (this.componentTypes = []),
              (this.components = []),
              (this._onMicrotaskEmptySubscription =
                this._zone.onMicrotaskEmpty.subscribe({
                  next: () => {
                    this._zone.run(() => {
                      this.tick();
                    });
                  },
                }));
            const p = new bn((w) => {
                (this._stable =
                  this._zone.isStable &&
                  !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks),
                  this._zone.runOutsideAngular(() => {
                    w.next(this._stable), w.complete();
                  });
              }),
              y = new bn((w) => {
                let S;
                this._zone.runOutsideAngular(() => {
                  S = this._zone.onStable.subscribe(() => {
                    ur.assertNotInAngularZone(),
                      tx(() => {
                        !this._stable &&
                          !this._zone.hasPendingMacrotasks &&
                          !this._zone.hasPendingMicrotasks &&
                          ((this._stable = !0), w.next(!0));
                      });
                  });
                });
                const P = this._zone.onUnstable.subscribe(() => {
                  ur.assertInAngularZone(),
                    this._stable &&
                      ((this._stable = !1),
                      this._zone.runOutsideAngular(() => {
                        w.next(!1);
                      }));
                });
                return () => {
                  S.unsubscribe(), P.unsubscribe();
                };
              });
            this.isStable = jo(
              p,
              y.pipe(
                (function Mh(n = {}) {
                  const {
                    connector: e = () => new rs(),
                    resetOnError: t = !0,
                    resetOnComplete: s = !0,
                    resetOnRefCountZero: c = !0,
                  } = n;
                  return (p) => {
                    let y,
                      w,
                      S,
                      P = 0,
                      N = !1,
                      j = !1;
                    const Q = () => {
                        w?.unsubscribe(), (w = void 0);
                      },
                      ie = () => {
                        Q(), (y = S = void 0), (N = j = !1);
                      },
                      pe = () => {
                        const Ee = y;
                        ie(), Ee?.unsubscribe();
                      };
                    return Fs((Ee, Oe) => {
                      P++, !j && !N && Q();
                      const Ue = (S = S ?? e());
                      Oe.add(() => {
                        P--, 0 === P && !j && !N && (w = fu(pe, c));
                      }),
                        Ue.subscribe(Oe),
                        !y &&
                          P > 0 &&
                          ((y = new Ia({
                            next: (lt) => Ue.next(lt),
                            error: (lt) => {
                              (j = !0), Q(), (w = fu(ie, t, lt)), Ue.error(lt);
                            },
                            complete: () => {
                              (N = !0), Q(), (w = fu(ie, s)), Ue.complete();
                            },
                          })),
                          Et(Ee).subscribe(y));
                    })(p);
                  };
                })()
              )
            );
          }
          get destroyed() {
            return this._destroyed;
          }
          get injector() {
            return this._injector;
          }
          bootstrap(t, s) {
            const c = t instanceof B_;
            if (!this._injector.get(Dy).done)
              throw (
                (!c &&
                  (function Fa(n) {
                    const e = In(n) || sr(n) || pi(n);
                    return null !== e && e.standalone;
                  })(t),
                new rt(405, false))
              );
            let y;
            (y = c ? t : this._injector.get(Qp).resolveComponentFactory(t)),
              this.componentTypes.push(y.componentType);
            const w = (function AC(n) {
                return n.isBoundToModule;
              })(y)
                ? void 0
                : this._injector.get(wf),
              P = y.create(Hc.NULL, [], s || y.selector, w),
              N = P.location.nativeElement,
              j = P.injector.get(cE, null);
            return (
              j?.registerApplication(N),
              P.onDestroy(() => {
                this.detachView(P.hostView),
                  Cy(this.components, P),
                  j?.unregisterApplication(N);
              }),
              this._loadComponent(P),
              P
            );
          }
          tick() {
            if (this._runningTick) throw new rt(101, !1);
            try {
              this._runningTick = !0;
              for (let t of this._views) t.detectChanges();
            } catch (t) {
              this._zone.runOutsideAngular(() =>
                this._exceptionHandler.handleError(t)
              );
            } finally {
              this._runningTick = !1;
            }
          }
          attachView(t) {
            const s = t;
            this._views.push(s), s.attachToAppRef(this);
          }
          detachView(t) {
            const s = t;
            Cy(this._views, s), s.detachFromAppRef();
          }
          _loadComponent(t) {
            this.attachView(t.hostView),
              this.tick(),
              this.components.push(t),
              this._injector
                .get(gC, [])
                .concat(this._bootstrapListeners)
                .forEach((c) => c(t));
          }
          ngOnDestroy() {
            if (!this._destroyed)
              try {
                this._destroyListeners.forEach((t) => t()),
                  this._views.slice().forEach((t) => t.destroy()),
                  this._onMicrotaskEmptySubscription.unsubscribe();
              } finally {
                (this._destroyed = !0),
                  (this._views = []),
                  (this._bootstrapListeners = []),
                  (this._destroyListeners = []);
              }
          }
          onDestroy(t) {
            return (
              this._destroyListeners.push(t),
              () => Cy(this._destroyListeners, t)
            );
          }
          destroy() {
            if (this._destroyed) throw new rt(406, !1);
            const t = this._injector;
            t.destroy && !t.destroyed && t.destroy();
          }
          get viewCount() {
            return this._views.length;
          }
          warnIfDestroyed() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(ur), St(da), St(Uc));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function Cy(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      let xE = !0,
        cx = (() => {
          class n {}
          return (n.__NG_ELEMENT_ID__ = FC), n;
        })();
      function FC(n) {
        return (function NC(n, e, t) {
          if (wu(n) && !t) {
            const s = Bi(n.index, e);
            return new Dn(s, s);
          }
          return 47 & n.type ? new Dn(e[16], e) : null;
        })(Pi(), Ze(), 16 == (16 & n));
      }
      class DE {
        constructor() {}
        supports(e) {
          return ph(e);
        }
        create(e) {
          return new $C(e);
        }
      }
      const UC = (n, e) => e;
      class $C {
        constructor(e) {
          (this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = e || UC);
        }
        forEachItem(e) {
          let t;
          for (t = this._itHead; null !== t; t = t._next) e(t);
        }
        forEachOperation(e) {
          let t = this._itHead,
            s = this._removalsHead,
            c = 0,
            p = null;
          for (; t || s; ) {
            const y = !s || (t && t.currentIndex < IE(s, c, p)) ? t : s,
              w = IE(y, c, p),
              S = y.currentIndex;
            if (y === s) c--, (s = s._nextRemoved);
            else if (((t = t._next), null == y.previousIndex)) c++;
            else {
              p || (p = []);
              const P = w - c,
                N = S - c;
              if (P != N) {
                for (let Q = 0; Q < P; Q++) {
                  const ie = Q < p.length ? p[Q] : (p[Q] = 0),
                    pe = ie + Q;
                  N <= pe && pe < P && (p[Q] = ie + 1);
                }
                p[y.previousIndex] = N - P;
              }
            }
            w !== S && e(y, w, S);
          }
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousItHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachMovedItem(e) {
          let t;
          for (t = this._movesHead; null !== t; t = t._nextMoved) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        forEachIdentityChange(e) {
          let t;
          for (
            t = this._identityChangesHead;
            null !== t;
            t = t._nextIdentityChange
          )
            e(t);
        }
        diff(e) {
          if ((null == e && (e = []), !ph(e))) throw new rt(900, !1);
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let c,
            p,
            y,
            t = this._itHead,
            s = !1;
          if (Array.isArray(e)) {
            this.length = e.length;
            for (let w = 0; w < this.length; w++)
              (p = e[w]),
                (y = this._trackByFn(w, p)),
                null !== t && Object.is(t.trackById, y)
                  ? (s && (t = this._verifyReinsertion(t, p, y, w)),
                    Object.is(t.item, p) || this._addIdentityChange(t, p))
                  : ((t = this._mismatch(t, p, y, w)), (s = !0)),
                (t = t._next);
          } else
            (c = 0),
              (function fy(n, e) {
                if (Array.isArray(n))
                  for (let t = 0; t < n.length; t++) e(n[t]);
                else {
                  const t = n[Ss()]();
                  let s;
                  for (; !(s = t.next()).done; ) e(s.value);
                }
              })(e, (w) => {
                (y = this._trackByFn(c, w)),
                  null !== t && Object.is(t.trackById, y)
                    ? (s && (t = this._verifyReinsertion(t, w, y, c)),
                      Object.is(t.item, w) || this._addIdentityChange(t, w))
                    : ((t = this._mismatch(t, w, y, c)), (s = !0)),
                  (t = t._next),
                  c++;
              }),
              (this.length = c);
          return this._truncate(t), (this.collection = e), this.isDirty;
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              e = this._previousItHead = this._itHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._additionsHead; null !== e; e = e._nextAdded)
              e.previousIndex = e.currentIndex;
            for (
              this._additionsHead = this._additionsTail = null,
                e = this._movesHead;
              null !== e;
              e = e._nextMoved
            )
              e.previousIndex = e.currentIndex;
            (this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null);
          }
        }
        _mismatch(e, t, s, c) {
          let p;
          return (
            null === e ? (p = this._itTail) : ((p = e._prev), this._remove(e)),
            null !==
            (e =
              null === this._unlinkedRecords
                ? null
                : this._unlinkedRecords.get(s, null))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._reinsertAfter(e, p, c))
              : null !==
                (e =
                  null === this._linkedRecords
                    ? null
                    : this._linkedRecords.get(s, c))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._moveAfter(e, p, c))
              : (e = this._addAfter(new HC(t, s), p, c)),
            e
          );
        }
        _verifyReinsertion(e, t, s, c) {
          let p =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(s, null);
          return (
            null !== p
              ? (e = this._reinsertAfter(p, e._prev, c))
              : e.currentIndex != c &&
                ((e.currentIndex = c), this._addToMoves(e, c)),
            e
          );
        }
        _truncate(e) {
          for (; null !== e; ) {
            const t = e._next;
            this._addToRemovals(this._unlink(e)), (e = t);
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null);
        }
        _reinsertAfter(e, t, s) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(e);
          const c = e._prevRemoved,
            p = e._nextRemoved;
          return (
            null === c ? (this._removalsHead = p) : (c._nextRemoved = p),
            null === p ? (this._removalsTail = c) : (p._prevRemoved = c),
            this._insertAfter(e, t, s),
            this._addToMoves(e, s),
            e
          );
        }
        _moveAfter(e, t, s) {
          return (
            this._unlink(e),
            this._insertAfter(e, t, s),
            this._addToMoves(e, s),
            e
          );
        }
        _addAfter(e, t, s) {
          return (
            this._insertAfter(e, t, s),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = e)
                : (this._additionsTail._nextAdded = e)),
            e
          );
        }
        _insertAfter(e, t, s) {
          const c = null === t ? this._itHead : t._next;
          return (
            (e._next = c),
            (e._prev = t),
            null === c ? (this._itTail = e) : (c._prev = e),
            null === t ? (this._itHead = e) : (t._next = e),
            null === this._linkedRecords && (this._linkedRecords = new SE()),
            this._linkedRecords.put(e),
            (e.currentIndex = s),
            e
          );
        }
        _remove(e) {
          return this._addToRemovals(this._unlink(e));
        }
        _unlink(e) {
          null !== this._linkedRecords && this._linkedRecords.remove(e);
          const t = e._prev,
            s = e._next;
          return (
            null === t ? (this._itHead = s) : (t._next = s),
            null === s ? (this._itTail = t) : (s._prev = t),
            e
          );
        }
        _addToMoves(e, t) {
          return (
            e.previousIndex === t ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = e)
                  : (this._movesTail._nextMoved = e)),
            e
          );
        }
        _addToRemovals(e) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new SE()),
            this._unlinkedRecords.put(e),
            (e.currentIndex = null),
            (e._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = e),
                (e._prevRemoved = null))
              : ((e._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = e)),
            e
          );
        }
        _addIdentityChange(e, t) {
          return (
            (e.item = t),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = e)
                : (this._identityChangesTail._nextIdentityChange = e)),
            e
          );
        }
      }
      class HC {
        constructor(e, t) {
          (this.item = e),
            (this.trackById = t),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null);
        }
      }
      class GC {
        constructor() {
          (this._head = null), (this._tail = null);
        }
        add(e) {
          null === this._head
            ? ((this._head = this._tail = e),
              (e._nextDup = null),
              (e._prevDup = null))
            : ((this._tail._nextDup = e),
              (e._prevDup = this._tail),
              (e._nextDup = null),
              (this._tail = e));
        }
        get(e, t) {
          let s;
          for (s = this._head; null !== s; s = s._nextDup)
            if (
              (null === t || t <= s.currentIndex) &&
              Object.is(s.trackById, e)
            )
              return s;
          return null;
        }
        remove(e) {
          const t = e._prevDup,
            s = e._nextDup;
          return (
            null === t ? (this._head = s) : (t._nextDup = s),
            null === s ? (this._tail = t) : (s._prevDup = t),
            null === this._head
          );
        }
      }
      class SE {
        constructor() {
          this.map = new Map();
        }
        put(e) {
          const t = e.trackById;
          let s = this.map.get(t);
          s || ((s = new GC()), this.map.set(t, s)), s.add(e);
        }
        get(e, t) {
          const c = this.map.get(e);
          return c ? c.get(e, t) : null;
        }
        remove(e) {
          const t = e.trackById;
          return this.map.get(t).remove(e) && this.map.delete(t), e;
        }
        get isEmpty() {
          return 0 === this.map.size;
        }
        clear() {
          this.map.clear();
        }
      }
      function IE(n, e, t) {
        const s = n.previousIndex;
        if (null === s) return s;
        let c = 0;
        return t && s < t.length && (c = t[s]), s + e + c;
      }
      class CE {
        constructor() {}
        supports(e) {
          return e instanceof Map || _f(e);
        }
        create() {
          return new qC();
        }
      }
      class qC {
        constructor() {
          (this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null);
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          );
        }
        forEachItem(e) {
          let t;
          for (t = this._mapHead; null !== t; t = t._next) e(t);
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousMapHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachChangedItem(e) {
          let t;
          for (t = this._changesHead; null !== t; t = t._nextChanged) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        diff(e) {
          if (e) {
            if (!(e instanceof Map || _f(e))) throw new rt(900, !1);
          } else e = new Map();
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let t = this._mapHead;
          if (
            ((this._appendAfter = null),
            this._forEach(e, (s, c) => {
              if (t && t.key === c)
                this._maybeAddToChanges(t, s),
                  (this._appendAfter = t),
                  (t = t._next);
              else {
                const p = this._getOrCreateRecordForKey(c, s);
                t = this._insertBeforeOrAppend(t, p);
              }
            }),
            t)
          ) {
            t._prev && (t._prev._next = null), (this._removalsHead = t);
            for (let s = t; null !== s; s = s._nextRemoved)
              s === this._mapHead && (this._mapHead = null),
                this._records.delete(s.key),
                (s._nextRemoved = s._next),
                (s.previousValue = s.currentValue),
                (s.currentValue = null),
                (s._prev = null),
                (s._next = null);
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          );
        }
        _insertBeforeOrAppend(e, t) {
          if (e) {
            const s = e._prev;
            return (
              (t._next = e),
              (t._prev = s),
              (e._prev = t),
              s && (s._next = t),
              e === this._mapHead && (this._mapHead = t),
              (this._appendAfter = e),
              e
            );
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = t), (t._prev = this._appendAfter))
              : (this._mapHead = t),
            (this._appendAfter = t),
            null
          );
        }
        _getOrCreateRecordForKey(e, t) {
          if (this._records.has(e)) {
            const c = this._records.get(e);
            this._maybeAddToChanges(c, t);
            const p = c._prev,
              y = c._next;
            return (
              p && (p._next = y),
              y && (y._prev = p),
              (c._next = null),
              (c._prev = null),
              c
            );
          }
          const s = new WC(e);
          return (
            this._records.set(e, s),
            (s.currentValue = t),
            this._addToAdditions(s),
            s
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              this._previousMapHead = this._mapHead, e = this._previousMapHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._changesHead; null !== e; e = e._nextChanged)
              e.previousValue = e.currentValue;
            for (e = this._additionsHead; null != e; e = e._nextAdded)
              e.previousValue = e.currentValue;
            (this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null);
          }
        }
        _maybeAddToChanges(e, t) {
          Object.is(t, e.currentValue) ||
            ((e.previousValue = e.currentValue),
            (e.currentValue = t),
            this._addToChanges(e));
        }
        _addToAdditions(e) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = e)
            : ((this._additionsTail._nextAdded = e), (this._additionsTail = e));
        }
        _addToChanges(e) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = e)
            : ((this._changesTail._nextChanged = e), (this._changesTail = e));
        }
        _forEach(e, t) {
          e instanceof Map
            ? e.forEach(t)
            : Object.keys(e).forEach((s) => t(e[s], s));
        }
      }
      class WC {
        constructor(e) {
          (this.key = e),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null);
        }
      }
      function ME() {
        return new Py([new DE()]);
      }
      let Py = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, s) {
            if (null != s) {
              const c = s.factories.slice();
              t = t.concat(c);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (s) => n.create(t, s || ME()),
              deps: [[n, new aa(), new sd()]],
            };
          }
          find(t) {
            const s = this.factories.find((c) => c.supports(t));
            if (null != s) return s;
            throw new rt(901, !1);
          }
        }
        return (n.ɵprov = Sn({ token: n, providedIn: "root", factory: ME })), n;
      })();
      function AE() {
        return new Dg([new CE()]);
      }
      let Dg = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, s) {
            if (s) {
              const c = s.factories.slice();
              t = t.concat(c);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (s) => n.create(t, s || AE()),
              deps: [[n, new aa(), new sd()]],
            };
          }
          find(t) {
            const s = this.factories.find((c) => c.supports(t));
            if (s) return s;
            throw new rt(901, !1);
          }
        }
        return (n.ɵprov = Sn({ token: n, providedIn: "root", factory: AE })), n;
      })();
      const KC = dE(null, "core", []);
      let YC = (() => {
          class n {
            constructor(t) {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(St(Iy));
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({})),
            n
          );
        })(),
        Ly = null;
      function Sg() {
        return Ly;
      }
      const ml = new nn("DocumentToken");
      let Ex = (() => {
        class n {
          constructor(t, s, c, p) {
            (this._iterableDiffers = t),
              (this._keyValueDiffers = s),
              (this._ngEl = c),
              (this._renderer = p),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._initialClasses = []),
              (this._rawClass = null);
          }
          set klass(t) {
            this._removeClasses(this._initialClasses),
              (this._initialClasses =
                "string" == typeof t ? t.split(/\s+/) : []),
              this._applyClasses(this._initialClasses),
              this._applyClasses(this._rawClass);
          }
          set ngClass(t) {
            this._removeClasses(this._rawClass),
              this._applyClasses(this._initialClasses),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._rawClass = "string" == typeof t ? t.split(/\s+/) : t),
              this._rawClass &&
                (ph(this._rawClass)
                  ? (this._iterableDiffer = this._iterableDiffers
                      .find(this._rawClass)
                      .create())
                  : (this._keyValueDiffer = this._keyValueDiffers
                      .find(this._rawClass)
                      .create()));
          }
          ngDoCheck() {
            if (this._iterableDiffer) {
              const t = this._iterableDiffer.diff(this._rawClass);
              t && this._applyIterableChanges(t);
            } else if (this._keyValueDiffer) {
              const t = this._keyValueDiffer.diff(this._rawClass);
              t && this._applyKeyValueChanges(t);
            }
          }
          _applyKeyValueChanges(t) {
            t.forEachAddedItem((s) => this._toggleClass(s.key, s.currentValue)),
              t.forEachChangedItem((s) =>
                this._toggleClass(s.key, s.currentValue)
              ),
              t.forEachRemovedItem((s) => {
                s.previousValue && this._toggleClass(s.key, !1);
              });
          }
          _applyIterableChanges(t) {
            t.forEachAddedItem((s) => {
              if ("string" != typeof s.item)
                throw new Error(
                  `NgClass can only toggle CSS classes expressed as strings, got ${_t(
                    s.item
                  )}`
                );
              this._toggleClass(s.item, !0);
            }),
              t.forEachRemovedItem((s) => this._toggleClass(s.item, !1));
          }
          _applyClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((s) => this._toggleClass(s, !0))
                : Object.keys(t).forEach((s) => this._toggleClass(s, !!t[s])));
          }
          _removeClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((s) => this._toggleClass(s, !1))
                : Object.keys(t).forEach((s) => this._toggleClass(s, !1)));
          }
          _toggleClass(t, s) {
            (t = t.trim()) &&
              t.split(/\s+/g).forEach((c) => {
                s
                  ? this._renderer.addClass(this._ngEl.nativeElement, c)
                  : this._renderer.removeClass(this._ngEl.nativeElement, c);
              });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Lt(Py), Lt(Dg), Lt(sl), Lt(kd));
          }),
          (n.ɵdir = Mi({
            type: n,
            selectors: [["", "ngClass", ""]],
            inputs: { klass: ["class", "klass"], ngClass: "ngClass" },
            standalone: !0,
          })),
          n
        );
      })();
      class jM {
        constructor(e, t, s, c) {
          (this.$implicit = e),
            (this.ngForOf = t),
            (this.index = s),
            (this.count = c);
        }
        get first() {
          return 0 === this.index;
        }
        get last() {
          return this.index === this.count - 1;
        }
        get even() {
          return this.index % 2 == 0;
        }
        get odd() {
          return !this.even;
        }
      }
      let Tx = (() => {
        class n {
          constructor(t, s, c) {
            (this._viewContainer = t),
              (this._template = s),
              (this._differs = c),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null);
          }
          set ngForOf(t) {
            (this._ngForOf = t), (this._ngForOfDirty = !0);
          }
          set ngForTrackBy(t) {
            this._trackByFn = t;
          }
          get ngForTrackBy() {
            return this._trackByFn;
          }
          set ngForTemplate(t) {
            t && (this._template = t);
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1;
              const t = this._ngForOf;
              !this._differ &&
                t &&
                (this._differ = this._differs
                  .find(t)
                  .create(this.ngForTrackBy));
            }
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf);
              t && this._applyChanges(t);
            }
          }
          _applyChanges(t) {
            const s = this._viewContainer;
            t.forEachOperation((c, p, y) => {
              if (null == c.previousIndex)
                s.createEmbeddedView(
                  this._template,
                  new jM(c.item, this._ngForOf, -1, -1),
                  null === y ? void 0 : y
                );
              else if (null == y) s.remove(null === p ? void 0 : p);
              else if (null !== p) {
                const w = s.get(p);
                s.move(w, y), UE(w, c);
              }
            });
            for (let c = 0, p = s.length; c < p; c++) {
              const w = s.get(c).context;
              (w.index = c), (w.count = p), (w.ngForOf = this._ngForOf);
            }
            t.forEachIdentityChange((c) => {
              UE(s.get(c.currentIndex), c);
            });
          }
          static ngTemplateContextGuard(t, s) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Lt(pl), Lt(nc), Lt(Py));
          }),
          (n.ɵdir = Mi({
            type: n,
            selectors: [["", "ngFor", "", "ngForOf", ""]],
            inputs: {
              ngForOf: "ngForOf",
              ngForTrackBy: "ngForTrackBy",
              ngForTemplate: "ngForTemplate",
            },
            standalone: !0,
          })),
          n
        );
      })();
      function UE(n, e) {
        n.context.$implicit = e.item;
      }
      let Uy = (() => {
        class n {
          constructor(t, s) {
            (this._viewContainer = t),
              (this._context = new $M()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = s);
          }
          set ngIf(t) {
            (this._context.$implicit = this._context.ngIf = t),
              this._updateView();
          }
          set ngIfThen(t) {
            $E("ngIfThen", t),
              (this._thenTemplateRef = t),
              (this._thenViewRef = null),
              this._updateView();
          }
          set ngIfElse(t) {
            $E("ngIfElse", t),
              (this._elseTemplateRef = t),
              (this._elseViewRef = null),
              this._updateView();
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )));
          }
          static ngTemplateContextGuard(t, s) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(Lt(pl), Lt(nc));
          }),
          (n.ɵdir = Mi({
            type: n,
            selectors: [["", "ngIf", ""]],
            inputs: {
              ngIf: "ngIf",
              ngIfThen: "ngIfThen",
              ngIfElse: "ngIfElse",
            },
            standalone: !0,
          })),
          n
        );
      })();
      class $M {
        constructor() {
          (this.$implicit = null), (this.ngIf = null);
        }
      }
      function $E(n, e) {
        if (e && !e.createEmbeddedView)
          throw new Error(
            `${n} must be a TemplateRef, but received '${_t(e)}'.`
          );
      }
      let GE = (() => {
          class n {
            constructor(t, s, c) {
              (this._ngEl = t),
                (this._differs = s),
                (this._renderer = c),
                (this._ngStyle = null),
                (this._differ = null);
            }
            set ngStyle(t) {
              (this._ngStyle = t),
                !this._differ &&
                  t &&
                  (this._differ = this._differs.find(t).create());
            }
            ngDoCheck() {
              if (this._differ) {
                const t = this._differ.diff(this._ngStyle);
                t && this._applyChanges(t);
              }
            }
            _setStyle(t, s) {
              const [c, p] = t.split("."),
                y = -1 === c.indexOf("-") ? void 0 : Yi.DashCase;
              null != s
                ? this._renderer.setStyle(
                    this._ngEl.nativeElement,
                    c,
                    p ? `${s}${p}` : s,
                    y
                  )
                : this._renderer.removeStyle(this._ngEl.nativeElement, c, y);
            }
            _applyChanges(t) {
              t.forEachRemovedItem((s) => this._setStyle(s.key, null)),
                t.forEachAddedItem((s) =>
                  this._setStyle(s.key, s.currentValue)
                ),
                t.forEachChangedItem((s) =>
                  this._setStyle(s.key, s.currentValue)
                );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Lt(sl), Lt(Dg), Lt(kd));
            }),
            (n.ɵdir = Mi({
              type: n,
              selectors: [["", "ngStyle", ""]],
              inputs: { ngStyle: "ngStyle" },
              standalone: !0,
            })),
            n
          );
        })(),
        Ix = (() => {
          class n {
            constructor(t) {
              (this._viewContainerRef = t),
                (this._viewRef = null),
                (this.ngTemplateOutletContext = null),
                (this.ngTemplateOutlet = null),
                (this.ngTemplateOutletInjector = null);
            }
            ngOnChanges(t) {
              if (t.ngTemplateOutlet || t.ngTemplateOutletInjector) {
                const s = this._viewContainerRef;
                if (
                  (this._viewRef && s.remove(s.indexOf(this._viewRef)),
                  this.ngTemplateOutlet)
                ) {
                  const {
                    ngTemplateOutlet: c,
                    ngTemplateOutletContext: p,
                    ngTemplateOutletInjector: y,
                  } = this;
                  this._viewRef = s.createEmbeddedView(
                    c,
                    p,
                    y ? { injector: y } : void 0
                  );
                } else this._viewRef = null;
              } else
                this._viewRef &&
                  t.ngTemplateOutletContext &&
                  this.ngTemplateOutletContext &&
                  (this._viewRef.context = this.ngTemplateOutletContext);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Lt(pl));
            }),
            (n.ɵdir = Mi({
              type: n,
              selectors: [["", "ngTemplateOutlet", ""]],
              inputs: {
                ngTemplateOutletContext: "ngTemplateOutletContext",
                ngTemplateOutlet: "ngTemplateOutlet",
                ngTemplateOutletInjector: "ngTemplateOutletInjector",
              },
              standalone: !0,
              features: [Zo],
            })),
            n
          );
        })(),
        xh = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({})),
            n
          );
        })();
      class Lx extends class GA extends class eM {} {
        constructor() {
          super(...arguments), (this.supportsDOMEvents = !0);
        }
      } {
        static makeCurrent() {
          !(function JC(n) {
            Ly || (Ly = n);
          })(new Lx());
        }
        onAndCancel(e, t, s) {
          return (
            e.addEventListener(t, s, !1),
            () => {
              e.removeEventListener(t, s, !1);
            }
          );
        }
        dispatchEvent(e, t) {
          e.dispatchEvent(t);
        }
        remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
        createElement(e, t) {
          return (t = t || this.getDefaultDocument()).createElement(e);
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument("fakeTitle");
        }
        getDefaultDocument() {
          return document;
        }
        isElementNode(e) {
          return e.nodeType === Node.ELEMENT_NODE;
        }
        isShadowRoot(e) {
          return e instanceof DocumentFragment;
        }
        getGlobalEventTarget(e, t) {
          return "window" === t
            ? window
            : "document" === t
            ? e
            : "body" === t
            ? e.body
            : null;
        }
        getBaseHref(e) {
          const t = (function qA() {
            return (
              (Ag = Ag || document.querySelector("base")),
              Ag ? Ag.getAttribute("href") : null
            );
          })();
          return null == t
            ? null
            : (function WA(n) {
                (Gy = Gy || document.createElement("a")),
                  Gy.setAttribute("href", n);
                const e = Gy.pathname;
                return "/" === e.charAt(0) ? e : `/${e}`;
              })(t);
        }
        resetBaseElement() {
          Ag = null;
        }
        getUserAgent() {
          return window.navigator.userAgent;
        }
        getCookie(e) {
          return (function BM(n, e) {
            e = encodeURIComponent(e);
            for (const t of n.split(";")) {
              const s = t.indexOf("="),
                [c, p] = -1 == s ? [t, ""] : [t.slice(0, s), t.slice(s + 1)];
              if (c.trim() === e) return decodeURIComponent(p);
            }
            return null;
          })(document.cookie, e);
        }
      }
      let Gy,
        Ag = null;
      const JE = new nn("TRANSITION_ID"),
        XA = [
          {
            provide: eE,
            useFactory: function ZA(n, e, t) {
              return () => {
                t.get(Dy).donePromise.then(() => {
                  const s = Sg(),
                    c = e.querySelectorAll(`style[ng-transition="${n}"]`);
                  for (let p = 0; p < c.length; p++) s.remove(c[p]);
                });
              };
            },
            deps: [JE, ml, Hc],
            multi: !0,
          },
        ];
      let YA = (() => {
        class n {
          build() {
            return new XMLHttpRequest();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const qy = new nn("EventManagerPlugins");
      let Wy = (() => {
        class n {
          constructor(t, s) {
            (this._zone = s),
              (this._eventNameToPlugin = new Map()),
              t.forEach((c) => (c.manager = this)),
              (this._plugins = t.slice().reverse());
          }
          addEventListener(t, s, c) {
            return this._findPluginFor(s).addEventListener(t, s, c);
          }
          addGlobalEventListener(t, s, c) {
            return this._findPluginFor(s).addGlobalEventListener(t, s, c);
          }
          getZone() {
            return this._zone;
          }
          _findPluginFor(t) {
            const s = this._eventNameToPlugin.get(t);
            if (s) return s;
            const c = this._plugins;
            for (let p = 0; p < c.length; p++) {
              const y = c[p];
              if (y.supports(t)) return this._eventNameToPlugin.set(t, y), y;
            }
            throw new Error(`No event manager plugin found for event ${t}`);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(qy), St(ur));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class eT {
        constructor(e) {
          this._doc = e;
        }
        addGlobalEventListener(e, t, s) {
          const c = Sg().getGlobalEventTarget(this._doc, e);
          if (!c)
            throw new Error(`Unsupported event target ${c} for event ${t}`);
          return this.addEventListener(c, t, s);
        }
      }
      let tT = (() => {
          class n {
            constructor() {
              this._stylesSet = new Set();
            }
            addStyles(t) {
              const s = new Set();
              t.forEach((c) => {
                this._stylesSet.has(c) || (this._stylesSet.add(c), s.add(c));
              }),
                this.onStylesAdded(s);
            }
            onStylesAdded(t) {}
            getAllStyles() {
              return Array.from(this._stylesSet);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Pg = (() => {
          class n extends tT {
            constructor(t) {
              super(),
                (this._doc = t),
                (this._hostNodes = new Map()),
                this._hostNodes.set(t.head, []);
            }
            _addStylesToHost(t, s, c) {
              t.forEach((p) => {
                const y = this._doc.createElement("style");
                (y.textContent = p), c.push(s.appendChild(y));
              });
            }
            addHost(t) {
              const s = [];
              this._addStylesToHost(this._stylesSet, t, s),
                this._hostNodes.set(t, s);
            }
            removeHost(t) {
              const s = this._hostNodes.get(t);
              s && s.forEach(nT), this._hostNodes.delete(t);
            }
            onStylesAdded(t) {
              this._hostNodes.forEach((s, c) => {
                this._addStylesToHost(t, c, s);
              });
            }
            ngOnDestroy() {
              this._hostNodes.forEach((t) => t.forEach(nT));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(St(ml));
            }),
            (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
            n
          );
        })();
      function nT(n) {
        Sg().remove(n);
      }
      const kx = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: "http://www.w3.org/1999/xhtml",
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
          math: "http://www.w3.org/1998/MathML/",
        },
        Rx = /%COMP%/g;
      function Zy(n, e, t) {
        for (let s = 0; s < e.length; s++) {
          let c = e[s];
          Array.isArray(c) ? Zy(n, c, t) : ((c = c.replace(Rx, n)), t.push(c));
        }
        return t;
      }
      function oT(n) {
        return (e) => {
          if ("__ngUnwrap__" === e) return n;
          !1 === n(e) && (e.preventDefault(), (e.returnValue = !1));
        };
      }
      let Xy = (() => {
        class n {
          constructor(t, s, c) {
            (this.eventManager = t),
              (this.sharedStylesHost = s),
              (this.appId = c),
              (this.rendererByCompId = new Map()),
              (this.defaultRenderer = new Ox(t));
          }
          createRenderer(t, s) {
            if (!t || !s) return this.defaultRenderer;
            switch (s.encapsulation) {
              case vo.Emulated: {
                let c = this.rendererByCompId.get(s.id);
                return (
                  c ||
                    ((c = new iP(
                      this.eventManager,
                      this.sharedStylesHost,
                      s,
                      this.appId
                    )),
                    this.rendererByCompId.set(s.id, c)),
                  c.applyToHost(t),
                  c
                );
              }
              case 1:
              case vo.ShadowDom:
                return new rP(this.eventManager, this.sharedStylesHost, t, s);
              default:
                if (!this.rendererByCompId.has(s.id)) {
                  const c = Zy(s.id, s.styles, []);
                  this.sharedStylesHost.addStyles(c),
                    this.rendererByCompId.set(s.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
          }
          begin() {}
          end() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(Wy), St(Pg), St(Tg));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class Ox {
        constructor(e) {
          (this.eventManager = e),
            (this.data = Object.create(null)),
            (this.destroyNode = null);
        }
        destroy() {}
        createElement(e, t) {
          return t
            ? document.createElementNS(kx[t] || t, e)
            : document.createElement(e);
        }
        createComment(e) {
          return document.createComment(e);
        }
        createText(e) {
          return document.createTextNode(e);
        }
        appendChild(e, t) {
          (aT(e) ? e.content : e).appendChild(t);
        }
        insertBefore(e, t, s) {
          e && (aT(e) ? e.content : e).insertBefore(t, s);
        }
        removeChild(e, t) {
          e && e.removeChild(t);
        }
        selectRootElement(e, t) {
          let s = "string" == typeof e ? document.querySelector(e) : e;
          if (!s)
            throw new Error(`The selector "${e}" did not match any elements`);
          return t || (s.textContent = ""), s;
        }
        parentNode(e) {
          return e.parentNode;
        }
        nextSibling(e) {
          return e.nextSibling;
        }
        setAttribute(e, t, s, c) {
          if (c) {
            t = c + ":" + t;
            const p = kx[c];
            p ? e.setAttributeNS(p, t, s) : e.setAttribute(t, s);
          } else e.setAttribute(t, s);
        }
        removeAttribute(e, t, s) {
          if (s) {
            const c = kx[s];
            c ? e.removeAttributeNS(c, t) : e.removeAttribute(`${s}:${t}`);
          } else e.removeAttribute(t);
        }
        addClass(e, t) {
          e.classList.add(t);
        }
        removeClass(e, t) {
          e.classList.remove(t);
        }
        setStyle(e, t, s, c) {
          c & (Yi.DashCase | Yi.Important)
            ? e.style.setProperty(t, s, c & Yi.Important ? "important" : "")
            : (e.style[t] = s);
        }
        removeStyle(e, t, s) {
          s & Yi.DashCase ? e.style.removeProperty(t) : (e.style[t] = "");
        }
        setProperty(e, t, s) {
          e[t] = s;
        }
        setValue(e, t) {
          e.nodeValue = t;
        }
        listen(e, t, s) {
          return "string" == typeof e
            ? this.eventManager.addGlobalEventListener(e, t, oT(s))
            : this.eventManager.addEventListener(e, t, oT(s));
        }
      }
      function aT(n) {
        return "TEMPLATE" === n.tagName && void 0 !== n.content;
      }
      class iP extends Ox {
        constructor(e, t, s, c) {
          super(e), (this.component = s);
          const p = Zy(c + "-" + s.id, s.styles, []);
          t.addStyles(p),
            (this.contentAttr = (function eP(n) {
              return "_ngcontent-%COMP%".replace(Rx, n);
            })(c + "-" + s.id)),
            (this.hostAttr = (function tP(n) {
              return "_nghost-%COMP%".replace(Rx, n);
            })(c + "-" + s.id));
        }
        applyToHost(e) {
          super.setAttribute(e, this.hostAttr, "");
        }
        createElement(e, t) {
          const s = super.createElement(e, t);
          return super.setAttribute(s, this.contentAttr, ""), s;
        }
      }
      class rP extends Ox {
        constructor(e, t, s, c) {
          super(e),
            (this.sharedStylesHost = t),
            (this.hostEl = s),
            (this.shadowRoot = s.attachShadow({ mode: "open" })),
            this.sharedStylesHost.addHost(this.shadowRoot);
          const p = Zy(c.id, c.styles, []);
          for (let y = 0; y < p.length; y++) {
            const w = document.createElement("style");
            (w.textContent = p[y]), this.shadowRoot.appendChild(w);
          }
        }
        nodeOrShadowRoot(e) {
          return e === this.hostEl ? this.shadowRoot : e;
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot);
        }
        appendChild(e, t) {
          return super.appendChild(this.nodeOrShadowRoot(e), t);
        }
        insertBefore(e, t, s) {
          return super.insertBefore(this.nodeOrShadowRoot(e), t, s);
        }
        removeChild(e, t) {
          return super.removeChild(this.nodeOrShadowRoot(e), t);
        }
        parentNode(e) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(e))
          );
        }
      }
      let oP = (() => {
        class n extends eT {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return !0;
          }
          addEventListener(t, s, c) {
            return (
              t.addEventListener(s, c, !1),
              () => this.removeEventListener(t, s, c)
            );
          }
          removeEventListener(t, s, c) {
            return t.removeEventListener(s, c);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(ml));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const lT = ["alt", "control", "meta", "shift"],
        sP = {
          "\b": "Backspace",
          "\t": "Tab",
          "\x7f": "Delete",
          "\x1b": "Escape",
          Del: "Delete",
          Esc: "Escape",
          Left: "ArrowLeft",
          Right: "ArrowRight",
          Up: "ArrowUp",
          Down: "ArrowDown",
          Menu: "ContextMenu",
          Scroll: "ScrollLock",
          Win: "OS",
        },
        aP = {
          alt: (n) => n.altKey,
          control: (n) => n.ctrlKey,
          meta: (n) => n.metaKey,
          shift: (n) => n.shiftKey,
        };
      let lP = (() => {
        class n extends eT {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return null != n.parseEventName(t);
          }
          addEventListener(t, s, c) {
            const p = n.parseEventName(s),
              y = n.eventCallback(p.fullKey, c, this.manager.getZone());
            return this.manager
              .getZone()
              .runOutsideAngular(() => Sg().onAndCancel(t, p.domEventName, y));
          }
          static parseEventName(t) {
            const s = t.toLowerCase().split("."),
              c = s.shift();
            if (0 === s.length || ("keydown" !== c && "keyup" !== c))
              return null;
            const p = n._normalizeKey(s.pop());
            let y = "",
              w = s.indexOf("code");
            if (
              (w > -1 && (s.splice(w, 1), (y = "code.")),
              lT.forEach((P) => {
                const N = s.indexOf(P);
                N > -1 && (s.splice(N, 1), (y += P + "."));
              }),
              (y += p),
              0 != s.length || 0 === p.length)
            )
              return null;
            const S = {};
            return (S.domEventName = c), (S.fullKey = y), S;
          }
          static matchEventFullKeyCode(t, s) {
            let c = sP[t.key] || t.key,
              p = "";
            return (
              s.indexOf("code.") > -1 && ((c = t.code), (p = "code.")),
              !(null == c || !c) &&
                ((c = c.toLowerCase()),
                " " === c ? (c = "space") : "." === c && (c = "dot"),
                lT.forEach((y) => {
                  y !== c && (0, aP[y])(t) && (p += y + ".");
                }),
                (p += c),
                p === s)
            );
          }
          static eventCallback(t, s, c) {
            return (p) => {
              n.matchEventFullKeyCode(p, t) && c.runGuarded(() => s(p));
            };
          }
          static _normalizeKey(t) {
            return "esc" === t ? "escape" : t;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(ml));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const dP = dE(KC, "browser", [
          { provide: iE, useValue: "browser" },
          {
            provide: nE,
            useValue: function cP() {
              Lx.makeCurrent();
            },
            multi: !0,
          },
          {
            provide: ml,
            useFactory: function hP() {
              return (
                (function wm(n) {
                  bd = n;
                })(document),
                document
              );
            },
            deps: [],
          },
        ]),
        hT = new nn(""),
        dT = [
          {
            provide: Sy,
            useClass: class KA {
              addToWindow(e) {
                (jn.getAngularTestability = (s, c = !0) => {
                  const p = e.findTestabilityInTree(s, c);
                  if (null == p)
                    throw new Error("Could not find testability for element.");
                  return p;
                }),
                  (jn.getAllAngularTestabilities = () =>
                    e.getAllTestabilities()),
                  (jn.getAllAngularRootElements = () => e.getAllRootElements()),
                  jn.frameworkStabilizers || (jn.frameworkStabilizers = []),
                  jn.frameworkStabilizers.push((s) => {
                    const c = jn.getAllAngularTestabilities();
                    let p = c.length,
                      y = !1;
                    const w = function (S) {
                      (y = y || S), p--, 0 == p && s(y);
                    };
                    c.forEach(function (S) {
                      S.whenStable(w);
                    });
                  });
              }
              findTestabilityInTree(e, t, s) {
                return null == t
                  ? null
                  : e.getTestability(t) ??
                      (s
                        ? Sg().isShadowRoot(t)
                          ? this.findTestabilityInTree(e, t.host, !0)
                          : this.findTestabilityInTree(e, t.parentElement, !0)
                        : null);
              }
            },
            deps: [],
          },
          { provide: cE, useClass: rx, deps: [ur, ox, Sy] },
          { provide: rx, useClass: rx, deps: [ur, ox, Sy] },
        ],
        pT = [
          { provide: Pd, useValue: "root" },
          {
            provide: Uc,
            useFactory: function uP() {
              return new Uc();
            },
            deps: [],
          },
          { provide: qy, useClass: oP, multi: !0, deps: [ml, ur, iE] },
          { provide: qy, useClass: lP, multi: !0, deps: [ml] },
          { provide: Xy, useClass: Xy, deps: [Wy, Pg, Tg] },
          { provide: nh, useExisting: Xy },
          { provide: tT, useExisting: Pg },
          { provide: Pg, useClass: Pg, deps: [ml] },
          { provide: Wy, useClass: Wy, deps: [qy, ur] },
          { provide: class yA {}, useClass: YA, deps: [] },
          [],
        ];
      let fT = (() => {
        class n {
          constructor(t) {}
          static withServerTransition(t) {
            return {
              ngModule: n,
              providers: [
                { provide: Tg, useValue: t.appId },
                { provide: JE, useExisting: Tg },
                XA,
              ],
            };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(hT, 12));
          }),
          (n.ɵmod = or({ type: n })),
          (n.ɵinj = Jn({ providers: [...pT, ...dT], imports: [xh, YC] })),
          n
        );
      })();
      typeof window < "u" && window;
      var zx = su(898);
      let po = (() => {
          class n {}
          return (
            (n.STARTS_WITH = "startsWith"),
            (n.CONTAINS = "contains"),
            (n.NOT_CONTAINS = "notContains"),
            (n.ENDS_WITH = "endsWith"),
            (n.EQUALS = "equals"),
            (n.NOT_EQUALS = "notEquals"),
            (n.IN = "in"),
            (n.LESS_THAN = "lt"),
            (n.LESS_THAN_OR_EQUAL_TO = "lte"),
            (n.GREATER_THAN = "gt"),
            (n.GREATER_THAN_OR_EQUAL_TO = "gte"),
            (n.BETWEEN = "between"),
            (n.IS = "is"),
            (n.IS_NOT = "isNot"),
            (n.BEFORE = "before"),
            (n.AFTER = "after"),
            (n.DATE_IS = "dateIs"),
            (n.DATE_IS_NOT = "dateIsNot"),
            (n.DATE_BEFORE = "dateBefore"),
            (n.DATE_AFTER = "dateAfter"),
            n
          );
        })(),
        yT = (() => {
          class n {
            constructor() {
              (this.ripple = !1),
                (this.overlayOptions = {}),
                (this.filterMatchModeOptions = {
                  text: [
                    po.STARTS_WITH,
                    po.CONTAINS,
                    po.NOT_CONTAINS,
                    po.ENDS_WITH,
                    po.EQUALS,
                    po.NOT_EQUALS,
                  ],
                  numeric: [
                    po.EQUALS,
                    po.NOT_EQUALS,
                    po.LESS_THAN,
                    po.LESS_THAN_OR_EQUAL_TO,
                    po.GREATER_THAN,
                    po.GREATER_THAN_OR_EQUAL_TO,
                  ],
                  date: [
                    po.DATE_IS,
                    po.DATE_IS_NOT,
                    po.DATE_BEFORE,
                    po.DATE_AFTER,
                  ],
                }),
                (this.translation = {
                  startsWith: "Starts with",
                  contains: "Contains",
                  notContains: "Not contains",
                  endsWith: "Ends with",
                  equals: "Equals",
                  notEquals: "Not equals",
                  noFilter: "No Filter",
                  lt: "Less than",
                  lte: "Less than or equal to",
                  gt: "Greater than",
                  gte: "Greater than or equal to",
                  is: "Is",
                  isNot: "Is not",
                  before: "Before",
                  after: "After",
                  dateIs: "Date is",
                  dateIsNot: "Date is not",
                  dateBefore: "Date is before",
                  dateAfter: "Date is after",
                  clear: "Clear",
                  apply: "Apply",
                  matchAll: "Match All",
                  matchAny: "Match Any",
                  addRule: "Add Rule",
                  removeRule: "Remove Rule",
                  accept: "Yes",
                  reject: "No",
                  choose: "Choose",
                  upload: "Upload",
                  cancel: "Cancel",
                  dayNames: [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday",
                  ],
                  dayNamesShort: [
                    "Sun",
                    "Mon",
                    "Tue",
                    "Wed",
                    "Thu",
                    "Fri",
                    "Sat",
                  ],
                  dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                  monthNames: [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                  ],
                  monthNamesShort: [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec",
                  ],
                  dateFormat: "mm/dd/yy",
                  firstDayOfWeek: 0,
                  today: "Today",
                  weekHeader: "Wk",
                  weak: "Weak",
                  medium: "Medium",
                  strong: "Strong",
                  passwordPrompt: "Enter a password",
                  emptyMessage: "No results found",
                  emptyFilterMessage: "No results found",
                }),
                (this.zIndex = {
                  modal: 1100,
                  overlay: 1e3,
                  menu: 1e3,
                  tooltip: 1100,
                }),
                (this.translationSource = new rs()),
                (this.translationObserver =
                  this.translationSource.asObservable());
            }
            getTranslation(t) {
              return this.translation[t];
            }
            setTranslation(t) {
              (this.translation = { ...this.translation, ...t }),
                this.translationSource.next(this.translation);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Sn({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        vT = (() => {
          class n {
            constructor(t) {
              this.template = t;
            }
            getType() {
              return this.name;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Lt(nc));
            }),
            (n.ɵdir = Mi({
              type: n,
              selectors: [["", "pTemplate", ""]],
              inputs: { type: "type", name: ["pTemplate", "name"] },
            })),
            n
          );
        })(),
        Bx = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({ imports: [xh] })),
            n
          );
        })(),
        Jt = (() => {
          class n {
            static addClass(t, s) {
              t &&
                s &&
                (t.classList ? t.classList.add(s) : (t.className += " " + s));
            }
            static addMultipleClasses(t, s) {
              if (t && s)
                if (t.classList) {
                  let c = s.trim().split(" ");
                  for (let p = 0; p < c.length; p++) t.classList.add(c[p]);
                } else {
                  let c = s.split(" ");
                  for (let p = 0; p < c.length; p++) t.className += " " + c[p];
                }
            }
            static removeClass(t, s) {
              t &&
                s &&
                (t.classList
                  ? t.classList.remove(s)
                  : (t.className = t.className.replace(
                      new RegExp(
                        "(^|\\b)" + s.split(" ").join("|") + "(\\b|$)",
                        "gi"
                      ),
                      " "
                    )));
            }
            static hasClass(t, s) {
              return (
                !(!t || !s) &&
                (t.classList
                  ? t.classList.contains(s)
                  : new RegExp("(^| )" + s + "( |$)", "gi").test(t.className))
              );
            }
            static siblings(t) {
              return Array.prototype.filter.call(
                t.parentNode.children,
                function (s) {
                  return s !== t;
                }
              );
            }
            static find(t, s) {
              return Array.from(t.querySelectorAll(s));
            }
            static findSingle(t, s) {
              return t ? t.querySelector(s) : null;
            }
            static index(t) {
              let s = t.parentNode.childNodes,
                c = 0;
              for (var p = 0; p < s.length; p++) {
                if (s[p] == t) return c;
                1 == s[p].nodeType && c++;
              }
              return -1;
            }
            static indexWithinGroup(t, s) {
              let c = t.parentNode ? t.parentNode.childNodes : [],
                p = 0;
              for (var y = 0; y < c.length; y++) {
                if (c[y] == t) return p;
                c[y].attributes &&
                  c[y].attributes[s] &&
                  1 == c[y].nodeType &&
                  p++;
              }
              return -1;
            }
            static appendOverlay(t, s, c = "self") {
              "self" !== c && t && s && this.appendChild(t, s);
            }
            static alignOverlay(t, s, c = "self", p = !0) {
              t &&
                s &&
                (p &&
                  (t.style.minWidth ||
                    (t.style.minWidth = n.getOuterWidth(s) + "px")),
                "self" === c
                  ? this.relativePosition(t, s)
                  : this.absolutePosition(t, s));
            }
            static relativePosition(t, s) {
              const c = (Ee) => {
                  if (Ee)
                    return "relative" ===
                      getComputedStyle(Ee).getPropertyValue("position")
                      ? Ee
                      : c(Ee.parentElement);
                },
                p = t.offsetParent
                  ? { width: t.offsetWidth, height: t.offsetHeight }
                  : this.getHiddenElementDimensions(t),
                y = s.offsetHeight,
                w = s.getBoundingClientRect(),
                S = this.getWindowScrollTop(),
                P = this.getWindowScrollLeft(),
                N = this.getViewport(),
                Q = c(t)?.getBoundingClientRect() || {
                  top: -1 * S,
                  left: -1 * P,
                };
              let ie, pe;
              w.top + y + p.height > N.height
                ? ((ie = w.top - Q.top - p.height),
                  (t.style.transformOrigin = "bottom"),
                  w.top + ie < 0 && (ie = -1 * w.top))
                : ((ie = y + w.top - Q.top), (t.style.transformOrigin = "top")),
                (pe =
                  p.width > N.width
                    ? -1 * (w.left - Q.left)
                    : w.left - Q.left + p.width > N.width
                    ? -1 * (w.left - Q.left + p.width - N.width)
                    : w.left - Q.left),
                (t.style.top = ie + "px"),
                (t.style.left = pe + "px");
            }
            static absolutePosition(t, s) {
              const c = t.offsetParent
                  ? { width: t.offsetWidth, height: t.offsetHeight }
                  : this.getHiddenElementDimensions(t),
                p = c.height,
                y = c.width,
                w = s.offsetHeight,
                S = s.offsetWidth,
                P = s.getBoundingClientRect(),
                N = this.getWindowScrollTop(),
                j = this.getWindowScrollLeft(),
                Q = this.getViewport();
              let ie, pe;
              P.top + w + p > Q.height
                ? ((ie = P.top + N - p),
                  (t.style.transformOrigin = "bottom"),
                  ie < 0 && (ie = N))
                : ((ie = w + P.top + N), (t.style.transformOrigin = "top")),
                (pe =
                  P.left + y > Q.width
                    ? Math.max(0, P.left + j + S - y)
                    : P.left + j),
                (t.style.top = ie + "px"),
                (t.style.left = pe + "px");
            }
            static getParents(t, s = []) {
              return null === t.parentNode
                ? s
                : this.getParents(t.parentNode, s.concat([t.parentNode]));
            }
            static getScrollableParents(t) {
              let s = [];
              if (t) {
                let c = this.getParents(t);
                const p = /(auto|scroll)/,
                  y = (w) => {
                    let S = window.getComputedStyle(w, null);
                    return (
                      p.test(S.getPropertyValue("overflow")) ||
                      p.test(S.getPropertyValue("overflowX")) ||
                      p.test(S.getPropertyValue("overflowY"))
                    );
                  };
                for (let w of c) {
                  let S = 1 === w.nodeType && w.dataset.scrollselectors;
                  if (S) {
                    let P = S.split(",");
                    for (let N of P) {
                      let j = this.findSingle(w, N);
                      j && y(j) && s.push(j);
                    }
                  }
                  9 !== w.nodeType && y(w) && s.push(w);
                }
              }
              return s;
            }
            static getHiddenElementOuterHeight(t) {
              (t.style.visibility = "hidden"), (t.style.display = "block");
              let s = t.offsetHeight;
              return (
                (t.style.display = "none"), (t.style.visibility = "visible"), s
              );
            }
            static getHiddenElementOuterWidth(t) {
              (t.style.visibility = "hidden"), (t.style.display = "block");
              let s = t.offsetWidth;
              return (
                (t.style.display = "none"), (t.style.visibility = "visible"), s
              );
            }
            static getHiddenElementDimensions(t) {
              let s = {};
              return (
                (t.style.visibility = "hidden"),
                (t.style.display = "block"),
                (s.width = t.offsetWidth),
                (s.height = t.offsetHeight),
                (t.style.display = "none"),
                (t.style.visibility = "visible"),
                s
              );
            }
            static scrollInView(t, s) {
              let c = getComputedStyle(t).getPropertyValue("borderTopWidth"),
                p = c ? parseFloat(c) : 0,
                y = getComputedStyle(t).getPropertyValue("paddingTop"),
                w = y ? parseFloat(y) : 0,
                S = t.getBoundingClientRect(),
                N =
                  s.getBoundingClientRect().top +
                  document.body.scrollTop -
                  (S.top + document.body.scrollTop) -
                  p -
                  w,
                j = t.scrollTop,
                Q = t.clientHeight,
                ie = this.getOuterHeight(s);
              N < 0
                ? (t.scrollTop = j + N)
                : N + ie > Q && (t.scrollTop = j + N - Q + ie);
            }
            static fadeIn(t, s) {
              t.style.opacity = 0;
              let c = +new Date(),
                p = 0,
                y = function () {
                  (p =
                    +t.style.opacity.replace(",", ".") +
                    (new Date().getTime() - c) / s),
                    (t.style.opacity = p),
                    (c = +new Date()),
                    +p < 1 &&
                      ((window.requestAnimationFrame &&
                        requestAnimationFrame(y)) ||
                        setTimeout(y, 16));
                };
              y();
            }
            static fadeOut(t, s) {
              var c = 1,
                w = 50 / s;
              let S = setInterval(() => {
                (c -= w) <= 0 && ((c = 0), clearInterval(S)),
                  (t.style.opacity = c);
              }, 50);
            }
            static getWindowScrollTop() {
              let t = document.documentElement;
              return (window.pageYOffset || t.scrollTop) - (t.clientTop || 0);
            }
            static getWindowScrollLeft() {
              let t = document.documentElement;
              return (window.pageXOffset || t.scrollLeft) - (t.clientLeft || 0);
            }
            static matches(t, s) {
              var c = Element.prototype;
              return (
                c.matches ||
                c.webkitMatchesSelector ||
                c.mozMatchesSelector ||
                c.msMatchesSelector ||
                function (y) {
                  return (
                    -1 !== [].indexOf.call(document.querySelectorAll(y), this)
                  );
                }
              ).call(t, s);
            }
            static getOuterWidth(t, s) {
              let c = t.offsetWidth;
              if (s) {
                let p = getComputedStyle(t);
                c += parseFloat(p.marginLeft) + parseFloat(p.marginRight);
              }
              return c;
            }
            static getHorizontalPadding(t) {
              let s = getComputedStyle(t);
              return parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);
            }
            static getHorizontalMargin(t) {
              let s = getComputedStyle(t);
              return parseFloat(s.marginLeft) + parseFloat(s.marginRight);
            }
            static innerWidth(t) {
              let s = t.offsetWidth,
                c = getComputedStyle(t);
              return (
                (s += parseFloat(c.paddingLeft) + parseFloat(c.paddingRight)), s
              );
            }
            static width(t) {
              let s = t.offsetWidth,
                c = getComputedStyle(t);
              return (
                (s -= parseFloat(c.paddingLeft) + parseFloat(c.paddingRight)), s
              );
            }
            static getInnerHeight(t) {
              let s = t.offsetHeight,
                c = getComputedStyle(t);
              return (
                (s += parseFloat(c.paddingTop) + parseFloat(c.paddingBottom)), s
              );
            }
            static getOuterHeight(t, s) {
              let c = t.offsetHeight;
              if (s) {
                let p = getComputedStyle(t);
                c += parseFloat(p.marginTop) + parseFloat(p.marginBottom);
              }
              return c;
            }
            static getHeight(t) {
              let s = t.offsetHeight,
                c = getComputedStyle(t);
              return (
                (s -=
                  parseFloat(c.paddingTop) +
                  parseFloat(c.paddingBottom) +
                  parseFloat(c.borderTopWidth) +
                  parseFloat(c.borderBottomWidth)),
                s
              );
            }
            static getWidth(t) {
              let s = t.offsetWidth,
                c = getComputedStyle(t);
              return (
                (s -=
                  parseFloat(c.paddingLeft) +
                  parseFloat(c.paddingRight) +
                  parseFloat(c.borderLeftWidth) +
                  parseFloat(c.borderRightWidth)),
                s
              );
            }
            static getViewport() {
              let t = window,
                s = document,
                c = s.documentElement,
                p = s.getElementsByTagName("body")[0];
              return {
                width: t.innerWidth || c.clientWidth || p.clientWidth,
                height: t.innerHeight || c.clientHeight || p.clientHeight,
              };
            }
            static getOffset(t) {
              var s = t.getBoundingClientRect();
              return {
                top:
                  s.top +
                  (window.pageYOffset ||
                    document.documentElement.scrollTop ||
                    document.body.scrollTop ||
                    0),
                left:
                  s.left +
                  (window.pageXOffset ||
                    document.documentElement.scrollLeft ||
                    document.body.scrollLeft ||
                    0),
              };
            }
            static replaceElementWith(t, s) {
              let c = t.parentNode;
              if (!c) throw "Can't replace element";
              return c.replaceChild(s, t);
            }
            static getUserAgent() {
              return navigator.userAgent;
            }
            static isIE() {
              var t = window.navigator.userAgent;
              return (
                t.indexOf("MSIE ") > 0 ||
                (t.indexOf("Trident/") > 0
                  ? (t.indexOf("rv:"), !0)
                  : t.indexOf("Edge/") > 0)
              );
            }
            static isIOS() {
              return (
                /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
              );
            }
            static isAndroid() {
              return /(android)/i.test(navigator.userAgent);
            }
            static isTouchDevice() {
              return "ontouchstart" in window || navigator.maxTouchPoints > 0;
            }
            static appendChild(t, s) {
              if (this.isElement(s)) s.appendChild(t);
              else {
                if (!s.el || !s.el.nativeElement)
                  throw "Cannot append " + s + " to " + t;
                s.el.nativeElement.appendChild(t);
              }
            }
            static removeChild(t, s) {
              if (this.isElement(s)) s.removeChild(t);
              else {
                if (!s.el || !s.el.nativeElement)
                  throw "Cannot remove " + t + " from " + s;
                s.el.nativeElement.removeChild(t);
              }
            }
            static removeElement(t) {
              "remove" in Element.prototype
                ? t.remove()
                : t.parentNode.removeChild(t);
            }
            static isElement(t) {
              return "object" == typeof HTMLElement
                ? t instanceof HTMLElement
                : t &&
                    "object" == typeof t &&
                    null !== t &&
                    1 === t.nodeType &&
                    "string" == typeof t.nodeName;
            }
            static calculateScrollbarWidth(t) {
              if (t) {
                let s = getComputedStyle(t);
                return (
                  t.offsetWidth -
                  t.clientWidth -
                  parseFloat(s.borderLeftWidth) -
                  parseFloat(s.borderRightWidth)
                );
              }
              {
                if (null !== this.calculatedScrollbarWidth)
                  return this.calculatedScrollbarWidth;
                let s = document.createElement("div");
                (s.className = "p-scrollbar-measure"),
                  document.body.appendChild(s);
                let c = s.offsetWidth - s.clientWidth;
                return (
                  document.body.removeChild(s),
                  (this.calculatedScrollbarWidth = c),
                  c
                );
              }
            }
            static calculateScrollbarHeight() {
              if (null !== this.calculatedScrollbarHeight)
                return this.calculatedScrollbarHeight;
              let t = document.createElement("div");
              (t.className = "p-scrollbar-measure"),
                document.body.appendChild(t);
              let s = t.offsetHeight - t.clientHeight;
              return (
                document.body.removeChild(t),
                (this.calculatedScrollbarWidth = s),
                s
              );
            }
            static invokeElementMethod(t, s, c) {
              t[s].apply(t, c);
            }
            static clearSelection() {
              if (window.getSelection)
                window.getSelection().empty
                  ? window.getSelection().empty()
                  : window.getSelection().removeAllRanges &&
                    window.getSelection().rangeCount > 0 &&
                    window.getSelection().getRangeAt(0).getClientRects()
                      .length > 0 &&
                    window.getSelection().removeAllRanges();
              else if (document.selection && document.selection.empty)
                try {
                  document.selection.empty();
                } catch {}
            }
            static getBrowser() {
              if (!this.browser) {
                let t = this.resolveUserAgent();
                (this.browser = {}),
                  t.browser &&
                    ((this.browser[t.browser] = !0),
                    (this.browser.version = t.version)),
                  this.browser.chrome
                    ? (this.browser.webkit = !0)
                    : this.browser.webkit && (this.browser.safari = !0);
              }
              return this.browser;
            }
            static resolveUserAgent() {
              let t = navigator.userAgent.toLowerCase(),
                s =
                  /(chrome)[ \/]([\w.]+)/.exec(t) ||
                  /(webkit)[ \/]([\w.]+)/.exec(t) ||
                  /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(t) ||
                  /(msie) ([\w.]+)/.exec(t) ||
                  (t.indexOf("compatible") < 0 &&
                    /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(t)) ||
                  [];
              return { browser: s[1] || "", version: s[2] || "0" };
            }
            static isInteger(t) {
              return Number.isInteger
                ? Number.isInteger(t)
                : "number" == typeof t && isFinite(t) && Math.floor(t) === t;
            }
            static isHidden(t) {
              return !t || null === t.offsetParent;
            }
            static isVisible(t) {
              return t && null != t.offsetParent;
            }
            static isExist(t) {
              return null !== t && typeof t < "u" && t.nodeName && t.parentNode;
            }
            static focus(t, s) {
              t && document.activeElement !== t && t.focus(s);
            }
            static getFocusableElements(t) {
              let s = n.find(
                  t,
                  'button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]), select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]), [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]):not(.p-disabled)'
                ),
                c = [];
              for (let p of s)
                "none" != getComputedStyle(p).display &&
                  "hidden" != getComputedStyle(p).visibility &&
                  c.push(p);
              return c;
            }
            static generateZIndex() {
              return (this.zindex = this.zindex || 999), ++this.zindex;
            }
            static getSelection() {
              return window.getSelection
                ? window.getSelection().toString()
                : document.getSelection
                ? document.getSelection().toString()
                : document.selection
                ? document.selection.createRange().text
                : null;
            }
            static getTargetElement(t, s) {
              if (!t) return null;
              switch (t) {
                case "document":
                  return document;
                case "window":
                  return window;
                case "@next":
                  return s?.nextElementSibling;
                case "@prev":
                  return s?.previousElementSibling;
                case "@parent":
                  return s?.parentElement;
                case "@grandparent":
                  return s?.parentElement.parentElement;
                default:
                  const c = typeof t;
                  if ("string" === c) return document.querySelector(t);
                  if ("object" === c && t.hasOwnProperty("nativeElement"))
                    return this.isExist(t.nativeElement)
                      ? t.nativeElement
                      : void 0;
                  const y =
                    (w = t) && w.constructor && w.call && w.apply ? t() : t;
                  return (y && 9 === y.nodeType) || this.isExist(y) ? y : null;
              }
              var w;
            }
          }
          return (
            (n.zindex = 1e3),
            (n.calculatedScrollbarWidth = null),
            (n.calculatedScrollbarHeight = null),
            n
          );
        })();
      class wP {
        constructor(e, t = () => {}) {
          (this.element = e), (this.listener = t);
        }
        bindScrollListener() {
          this.scrollableParents = Jt.getScrollableParents(this.element);
          for (let e = 0; e < this.scrollableParents.length; e++)
            this.scrollableParents[e].addEventListener("scroll", this.listener);
        }
        unbindScrollListener() {
          if (this.scrollableParents)
            for (let e = 0; e < this.scrollableParents.length; e++)
              this.scrollableParents[e].removeEventListener(
                "scroll",
                this.listener
              );
        }
        destroy() {
          this.unbindScrollListener(),
            (this.element = null),
            (this.listener = null),
            (this.scrollableParents = null);
        }
      }
      var Vx = (function EP() {
        let n = [];
        const c = (p) => (p && parseInt(p.style.zIndex, 10)) || 0;
        return {
          get: c,
          set: (p, y, w) => {
            y &&
              (y.style.zIndex = String(
                ((p, y) => {
                  let w = n.length > 0 ? n[n.length - 1] : { key: p, value: y },
                    S = w.value + (w.key === p ? 0 : y) + 1;
                  return n.push({ key: p, value: S }), S;
                })(p, w)
              ));
          },
          clear: (p) => {
            p &&
              (((p) => {
                n = n.filter((y) => y.value !== p);
              })(c(p)),
              (p.style.zIndex = ""));
          },
          getCurrent: () => (n.length > 0 ? n[n.length - 1].value : 0),
        };
      })();
      let TP = (() => {
          class n {
            constructor(t, s, c) {
              (this.el = t),
                (this.zone = s),
                (this.config = c),
                (this.escape = !0),
                (this.fitContent = !0),
                (this._tooltipOptions = {
                  tooltipPosition: "right",
                  tooltipEvent: "hover",
                  appendTo: "body",
                  tooltipZIndex: "auto",
                  escape: !0,
                  positionTop: 0,
                  positionLeft: 0,
                });
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = t), this.deactivate();
            }
            ngAfterViewInit() {
              this.zone.runOutsideAngular(() => {
                if ("hover" === this.getOption("tooltipEvent"))
                  (this.mouseEnterListener = this.onMouseEnter.bind(this)),
                    (this.mouseLeaveListener = this.onMouseLeave.bind(this)),
                    (this.clickListener = this.onClick.bind(this)),
                    this.el.nativeElement.addEventListener(
                      "mouseenter",
                      this.mouseEnterListener
                    ),
                    this.el.nativeElement.addEventListener(
                      "mouseleave",
                      this.mouseLeaveListener
                    ),
                    this.el.nativeElement.addEventListener(
                      "click",
                      this.clickListener
                    );
                else if ("focus" === this.getOption("tooltipEvent")) {
                  (this.focusListener = this.onFocus.bind(this)),
                    (this.blurListener = this.onBlur.bind(this));
                  let t = this.getTarget(this.el.nativeElement);
                  t.addEventListener("focus", this.focusListener),
                    t.addEventListener("blur", this.blurListener);
                }
              });
            }
            ngOnChanges(t) {
              t.tooltipPosition &&
                this.setOption({
                  tooltipPosition: t.tooltipPosition.currentValue,
                }),
                t.tooltipEvent &&
                  this.setOption({ tooltipEvent: t.tooltipEvent.currentValue }),
                t.appendTo &&
                  this.setOption({ appendTo: t.appendTo.currentValue }),
                t.positionStyle &&
                  this.setOption({
                    positionStyle: t.positionStyle.currentValue,
                  }),
                t.tooltipStyleClass &&
                  this.setOption({
                    tooltipStyleClass: t.tooltipStyleClass.currentValue,
                  }),
                t.tooltipZIndex &&
                  this.setOption({
                    tooltipZIndex: t.tooltipZIndex.currentValue,
                  }),
                t.escape && this.setOption({ escape: t.escape.currentValue }),
                t.showDelay &&
                  this.setOption({ showDelay: t.showDelay.currentValue }),
                t.hideDelay &&
                  this.setOption({ hideDelay: t.hideDelay.currentValue }),
                t.life && this.setOption({ life: t.life.currentValue }),
                t.positionTop &&
                  this.setOption({ positionTop: t.positionTop.currentValue }),
                t.positionLeft &&
                  this.setOption({ positionLeft: t.positionLeft.currentValue }),
                t.disabled &&
                  this.setOption({ disabled: t.disabled.currentValue }),
                t.text &&
                  (this.setOption({ tooltipLabel: t.text.currentValue }),
                  this.active &&
                    (t.text.currentValue
                      ? this.container && this.container.offsetParent
                        ? (this.updateText(), this.align())
                        : this.show()
                      : this.hide())),
                t.tooltipOptions &&
                  ((this._tooltipOptions = {
                    ...this._tooltipOptions,
                    ...t.tooltipOptions.currentValue,
                  }),
                  this.deactivate(),
                  this.active &&
                    (this.getOption("tooltipLabel")
                      ? this.container && this.container.offsetParent
                        ? (this.updateText(), this.align())
                        : this.show()
                      : this.hide()));
            }
            onMouseEnter(t) {
              !this.container && !this.showTimeout && this.activate();
            }
            onMouseLeave(t) {
              this.deactivate();
            }
            onFocus(t) {
              this.activate();
            }
            onBlur(t) {
              this.deactivate();
            }
            onClick(t) {
              this.deactivate();
            }
            activate() {
              if (
                ((this.active = !0),
                this.clearHideTimeout(),
                this.getOption("showDelay")
                  ? (this.showTimeout = setTimeout(() => {
                      this.show();
                    }, this.getOption("showDelay")))
                  : this.show(),
                this.getOption("life"))
              ) {
                let t = this.getOption("showDelay")
                  ? this.getOption("life") + this.getOption("showDelay")
                  : this.getOption("life");
                this.hideTimeout = setTimeout(() => {
                  this.hide();
                }, t);
              }
            }
            deactivate() {
              (this.active = !1),
                this.clearShowTimeout(),
                this.getOption("hideDelay")
                  ? (this.clearHideTimeout(),
                    (this.hideTimeout = setTimeout(() => {
                      this.hide();
                    }, this.getOption("hideDelay"))))
                  : this.hide();
            }
            create() {
              this.container && (this.clearHideTimeout(), this.remove()),
                (this.container = document.createElement("div"));
              let t = document.createElement("div");
              (t.className = "p-tooltip-arrow"),
                this.container.appendChild(t),
                (this.tooltipText = document.createElement("div")),
                (this.tooltipText.className = "p-tooltip-text"),
                this.updateText(),
                this.getOption("positionStyle") &&
                  (this.container.style.position =
                    this.getOption("positionStyle")),
                this.container.appendChild(this.tooltipText),
                "body" === this.getOption("appendTo")
                  ? document.body.appendChild(this.container)
                  : "target" === this.getOption("appendTo")
                  ? Jt.appendChild(this.container, this.el.nativeElement)
                  : Jt.appendChild(this.container, this.getOption("appendTo")),
                (this.container.style.display = "inline-block"),
                this.fitContent && (this.container.style.width = "fit-content");
            }
            show() {
              !this.getOption("tooltipLabel") ||
                this.getOption("disabled") ||
                (this.create(),
                this.align(),
                Jt.fadeIn(this.container, 250),
                "auto" === this.getOption("tooltipZIndex")
                  ? Vx.set(
                      "tooltip",
                      this.container,
                      this.config.zIndex.tooltip
                    )
                  : (this.container.style.zIndex =
                      this.getOption("tooltipZIndex")),
                this.bindDocumentResizeListener(),
                this.bindScrollListener());
            }
            hide() {
              "auto" === this.getOption("tooltipZIndex") &&
                Vx.clear(this.container),
                this.remove();
            }
            updateText() {
              this.getOption("escape")
                ? ((this.tooltipText.innerHTML = ""),
                  this.tooltipText.appendChild(
                    document.createTextNode(this.getOption("tooltipLabel"))
                  ))
                : (this.tooltipText.innerHTML = this.getOption("tooltipLabel"));
            }
            align() {
              switch (this.getOption("tooltipPosition")) {
                case "top":
                  this.alignTop(),
                    this.isOutOfBounds() &&
                      (this.alignBottom(),
                      this.isOutOfBounds() &&
                        (this.alignRight(),
                        this.isOutOfBounds() && this.alignLeft()));
                  break;
                case "bottom":
                  this.alignBottom(),
                    this.isOutOfBounds() &&
                      (this.alignTop(),
                      this.isOutOfBounds() &&
                        (this.alignRight(),
                        this.isOutOfBounds() && this.alignLeft()));
                  break;
                case "left":
                  this.alignLeft(),
                    this.isOutOfBounds() &&
                      (this.alignRight(),
                      this.isOutOfBounds() &&
                        (this.alignTop(),
                        this.isOutOfBounds() && this.alignBottom()));
                  break;
                case "right":
                  this.alignRight(),
                    this.isOutOfBounds() &&
                      (this.alignLeft(),
                      this.isOutOfBounds() &&
                        (this.alignTop(),
                        this.isOutOfBounds() && this.alignBottom()));
              }
            }
            getHostOffset() {
              if (
                "body" === this.getOption("appendTo") ||
                "target" === this.getOption("appendTo")
              ) {
                let t = this.el.nativeElement.getBoundingClientRect();
                return {
                  left: t.left + Jt.getWindowScrollLeft(),
                  top: t.top + Jt.getWindowScrollTop(),
                };
              }
              return { left: 0, top: 0 };
            }
            alignRight() {
              this.preAlign("right");
              let t = this.getHostOffset(),
                s = t.left + Jt.getOuterWidth(this.el.nativeElement),
                c =
                  t.top +
                  (Jt.getOuterHeight(this.el.nativeElement) -
                    Jt.getOuterHeight(this.container)) /
                    2;
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            alignLeft() {
              this.preAlign("left");
              let t = this.getHostOffset(),
                s = t.left - Jt.getOuterWidth(this.container),
                c =
                  t.top +
                  (Jt.getOuterHeight(this.el.nativeElement) -
                    Jt.getOuterHeight(this.container)) /
                    2;
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            alignTop() {
              this.preAlign("top");
              let t = this.getHostOffset(),
                s =
                  t.left +
                  (Jt.getOuterWidth(this.el.nativeElement) -
                    Jt.getOuterWidth(this.container)) /
                    2,
                c = t.top - Jt.getOuterHeight(this.container);
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            alignBottom() {
              this.preAlign("bottom");
              let t = this.getHostOffset(),
                s =
                  t.left +
                  (Jt.getOuterWidth(this.el.nativeElement) -
                    Jt.getOuterWidth(this.container)) /
                    2,
                c = t.top + Jt.getOuterHeight(this.el.nativeElement);
              (this.container.style.left =
                s + this.getOption("positionLeft") + "px"),
                (this.container.style.top =
                  c + this.getOption("positionTop") + "px");
            }
            setOption(t) {
              this._tooltipOptions = { ...this._tooltipOptions, ...t };
            }
            getOption(t) {
              return this._tooltipOptions[t];
            }
            getTarget(t) {
              return Jt.hasClass(t, "p-inputwrapper")
                ? Jt.findSingle(t, "input")
                : t;
            }
            preAlign(t) {
              (this.container.style.left = "-999px"),
                (this.container.style.top = "-999px");
              let s = "p-tooltip p-component p-tooltip-" + t;
              this.container.className = this.getOption("tooltipStyleClass")
                ? s + " " + this.getOption("tooltipStyleClass")
                : s;
            }
            isOutOfBounds() {
              let t = this.container.getBoundingClientRect(),
                s = t.top,
                c = t.left,
                p = Jt.getOuterWidth(this.container),
                y = Jt.getOuterHeight(this.container),
                w = Jt.getViewport();
              return c + p > w.width || c < 0 || s < 0 || s + y > w.height;
            }
            onWindowResize(t) {
              this.hide();
            }
            bindDocumentResizeListener() {
              this.zone.runOutsideAngular(() => {
                (this.resizeListener = this.onWindowResize.bind(this)),
                  window.addEventListener("resize", this.resizeListener);
              });
            }
            unbindDocumentResizeListener() {
              this.resizeListener &&
                (window.removeEventListener("resize", this.resizeListener),
                (this.resizeListener = null));
            }
            bindScrollListener() {
              this.scrollHandler ||
                (this.scrollHandler = new wP(this.el.nativeElement, () => {
                  this.container && this.hide();
                })),
                this.scrollHandler.bindScrollListener();
            }
            unbindScrollListener() {
              this.scrollHandler && this.scrollHandler.unbindScrollListener();
            }
            unbindEvents() {
              if ("hover" === this.getOption("tooltipEvent"))
                this.el.nativeElement.removeEventListener(
                  "mouseenter",
                  this.mouseEnterListener
                ),
                  this.el.nativeElement.removeEventListener(
                    "mouseleave",
                    this.mouseLeaveListener
                  ),
                  this.el.nativeElement.removeEventListener(
                    "click",
                    this.clickListener
                  );
              else if ("focus" === this.getOption("tooltipEvent")) {
                let t = this.getTarget(this.el.nativeElement);
                t.removeEventListener("focus", this.focusListener),
                  t.removeEventListener("blur", this.blurListener);
              }
              this.unbindDocumentResizeListener();
            }
            remove() {
              this.container &&
                this.container.parentElement &&
                ("body" === this.getOption("appendTo")
                  ? document.body.removeChild(this.container)
                  : "target" === this.getOption("appendTo")
                  ? this.el.nativeElement.removeChild(this.container)
                  : Jt.removeChild(this.container, this.getOption("appendTo"))),
                this.unbindDocumentResizeListener(),
                this.unbindScrollListener(),
                this.clearTimeouts(),
                (this.container = null),
                (this.scrollHandler = null);
            }
            clearShowTimeout() {
              this.showTimeout &&
                (clearTimeout(this.showTimeout), (this.showTimeout = null));
            }
            clearHideTimeout() {
              this.hideTimeout &&
                (clearTimeout(this.hideTimeout), (this.hideTimeout = null));
            }
            clearTimeouts() {
              this.clearShowTimeout(), this.clearHideTimeout();
            }
            ngOnDestroy() {
              this.unbindEvents(),
                this.container && Vx.clear(this.container),
                this.remove(),
                this.scrollHandler &&
                  (this.scrollHandler.destroy(), (this.scrollHandler = null));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Lt(sl), Lt(ur), Lt(yT));
            }),
            (n.ɵdir = Mi({
              type: n,
              selectors: [["", "pTooltip", ""]],
              hostAttrs: [1, "p-element"],
              inputs: {
                tooltipPosition: "tooltipPosition",
                tooltipEvent: "tooltipEvent",
                appendTo: "appendTo",
                positionStyle: "positionStyle",
                tooltipStyleClass: "tooltipStyleClass",
                tooltipZIndex: "tooltipZIndex",
                escape: "escape",
                showDelay: "showDelay",
                hideDelay: "hideDelay",
                life: "life",
                positionTop: "positionTop",
                positionLeft: "positionLeft",
                fitContent: "fitContent",
                text: ["pTooltip", "text"],
                disabled: ["tooltipDisabled", "disabled"],
                tooltipOptions: "tooltipOptions",
              },
              features: [Zo],
            })),
            n
          );
        })(),
        wT = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({ imports: [xh] })),
            n
          );
        })(),
        DP = (() => {
          class n {
            constructor(t, s, c) {
              (this.el = t), (this.zone = s), (this.config = c);
            }
            ngAfterViewInit() {
              this.config &&
                this.config.ripple &&
                this.zone.runOutsideAngular(() => {
                  this.create(),
                    (this.mouseDownListener = this.onMouseDown.bind(this)),
                    this.el.nativeElement.addEventListener(
                      "mousedown",
                      this.mouseDownListener
                    );
                });
            }
            onMouseDown(t) {
              let s = this.getInk();
              if (!s || "none" === getComputedStyle(s, null).display) return;
              if (
                (Jt.removeClass(s, "p-ink-active"),
                !Jt.getHeight(s) && !Jt.getWidth(s))
              ) {
                let w = Math.max(
                  Jt.getOuterWidth(this.el.nativeElement),
                  Jt.getOuterHeight(this.el.nativeElement)
                );
                (s.style.height = w + "px"), (s.style.width = w + "px");
              }
              let c = Jt.getOffset(this.el.nativeElement),
                p =
                  t.pageX -
                  c.left +
                  document.body.scrollTop -
                  Jt.getWidth(s) / 2,
                y =
                  t.pageY -
                  c.top +
                  document.body.scrollLeft -
                  Jt.getHeight(s) / 2;
              (s.style.top = y + "px"),
                (s.style.left = p + "px"),
                Jt.addClass(s, "p-ink-active"),
                (this.timeout = setTimeout(() => {
                  let w = this.getInk();
                  w && Jt.removeClass(w, "p-ink-active");
                }, 401));
            }
            getInk() {
              for (let t = 0; t < this.el.nativeElement.children.length; t++)
                if (
                  -1 !==
                  this.el.nativeElement.children[t].className.indexOf("p-ink")
                )
                  return this.el.nativeElement.children[t];
              return null;
            }
            resetInk() {
              let t = this.getInk();
              t && Jt.removeClass(t, "p-ink-active");
            }
            onAnimationEnd(t) {
              this.timeout && clearTimeout(this.timeout),
                Jt.removeClass(t.currentTarget, "p-ink-active");
            }
            create() {
              let t = document.createElement("span");
              (t.className = "p-ink"),
                this.el.nativeElement.appendChild(t),
                (this.animationListener = this.onAnimationEnd.bind(this)),
                t.addEventListener("animationend", this.animationListener);
            }
            remove() {
              let t = this.getInk();
              t &&
                (this.el.nativeElement.removeEventListener(
                  "mousedown",
                  this.mouseDownListener
                ),
                t.removeEventListener("animationend", this.animationListener),
                Jt.removeElement(t));
            }
            ngOnDestroy() {
              this.config && this.config.ripple && this.remove();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Lt(sl), Lt(ur), Lt(yT, 8));
            }),
            (n.ɵdir = Mi({
              type: n,
              selectors: [["", "pRipple", ""]],
              hostAttrs: [1, "p-ripple", "p-element"],
            })),
            n
          );
        })(),
        jx = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({ imports: [xh] })),
            n
          );
        })();
      function SP(n, e) {
        1 & n && my(0);
      }
      function IP(n, e) {
        if (
          (1 & n && (dg(0), Qr(1, SP, 1, 0, "ng-container", 3), pg()), 2 & n)
        ) {
          const t = ho(2);
          Hi(1), bi("ngTemplateOutlet", t.contentTemplate);
        }
      }
      function CP(n, e) {
        if (
          (1 & n &&
            (on(0, "div", 1), C0(1), Qr(2, IP, 2, 1, "ng-container", 2), Pn()),
          2 & n)
        ) {
          const t = ho();
          bi("hidden", !t.selected),
            Is("id", t.id)("aria-hidden", !t.selected)(
              "aria-labelledby",
              t.id + "-label"
            ),
            Hi(2),
            bi("ngIf", t.contentTemplate && (t.cache ? t.loaded : t.selected));
        }
      }
      const ET = ["*"],
        MP = ["content"],
        AP = ["navbar"],
        PP = ["prevBtn"],
        LP = ["nextBtn"],
        kP = ["inkbar"];
      function RP(n, e) {
        if (1 & n) {
          const t = fg();
          on(0, "button", 12, 13),
            gh("click", function () {
              return Ha(t), fi(ho().navBackward());
            }),
            Wi(2, "span", 14),
            Pn();
        }
      }
      function OP(n, e) {
        1 & n && Wi(0, "span", 24),
          2 & n && bi("ngClass", ho(3).$implicit.leftIcon);
      }
      function FP(n, e) {
        1 & n && Wi(0, "span", 25),
          2 & n && bi("ngClass", ho(3).$implicit.rightIcon);
      }
      function NP(n, e) {
        if (
          (1 & n &&
            (dg(0),
            Qr(1, OP, 1, 1, "span", 21),
            on(2, "span", 22),
            Si(3),
            Pn(),
            Qr(4, FP, 1, 1, "span", 23),
            pg()),
          2 & n)
        ) {
          const t = ho(2).$implicit;
          Hi(1),
            bi("ngIf", t.leftIcon),
            Hi(2),
            _y(t.header),
            Hi(1),
            bi("ngIf", t.rightIcon);
        }
      }
      function zP(n, e) {
        1 & n && my(0);
      }
      function BP(n, e) {
        if (1 & n) {
          const t = fg();
          on(0, "span", 26),
            gh("click", function (c) {
              Ha(t);
              const p = ho(2).$implicit;
              return fi(ho().close(c, p));
            }),
            Pn();
        }
      }
      const VP = function (n, e) {
        return { "p-highlight": n, "p-disabled": e };
      };
      function jP(n, e) {
        if (1 & n) {
          const t = fg();
          on(0, "li", 16)(1, "a", 17),
            gh("click", function (c) {
              Ha(t);
              const p = ho().$implicit;
              return fi(ho().open(c, p));
            })("keydown.enter", function (c) {
              Ha(t);
              const p = ho().$implicit;
              return fi(ho().open(c, p));
            }),
            Qr(2, NP, 5, 3, "ng-container", 18),
            Qr(3, zP, 1, 0, "ng-container", 19),
            Qr(4, BP, 1, 0, "span", 20),
            Pn()();
        }
        if (2 & n) {
          const t = ho().$implicit;
          A0(t.headerStyleClass),
            bi("ngClass", ww(16, VP, t.selected, t.disabled))(
              "ngStyle",
              t.headerStyle
            ),
            Hi(1),
            bi("pTooltip", t.tooltip)("tooltipPosition", t.tooltipPosition)(
              "positionStyle",
              t.tooltipPositionStyle
            )("tooltipStyleClass", t.tooltipStyleClass),
            Is("id", t.id + "-label")("aria-selected", t.selected)(
              "aria-controls",
              t.id
            )("aria-selected", t.selected)("tabindex", t.disabled ? null : "0"),
            Hi(1),
            bi("ngIf", !t.headerTemplate),
            Hi(1),
            bi("ngTemplateOutlet", t.headerTemplate),
            Hi(1),
            bi("ngIf", t.closable);
        }
      }
      function UP(n, e) {
        1 & n && Qr(0, jP, 5, 19, "li", 15),
          2 & n && bi("ngIf", !e.$implicit.closed);
      }
      function $P(n, e) {
        if (1 & n) {
          const t = fg();
          on(0, "button", 27, 28),
            gh("click", function () {
              return Ha(t), fi(ho().navForward());
            }),
            Wi(2, "span", 29),
            Pn();
        }
      }
      const HP = function (n) {
        return { "p-tabview p-component": !0, "p-tabview-scrollable": n };
      };
      let GP = 0,
        TT = (() => {
          class n {
            constructor(t, s, c) {
              (this.viewContainer = s),
                (this.cd = c),
                (this.cache = !0),
                (this.tooltipPosition = "top"),
                (this.tooltipPositionStyle = "absolute"),
                (this.id = "p-tabpanel-" + GP++),
                (this.tabView = t);
            }
            ngAfterContentInit() {
              this.templates.forEach((t) => {
                "header" === t.getType()
                  ? (this.headerTemplate = t.template)
                  : (this.contentTemplate = t.template);
              });
            }
            get selected() {
              return this._selected;
            }
            set selected(t) {
              (this._selected = t),
                this.loaded || this.cd.detectChanges(),
                t && (this.loaded = !0);
            }
            get disabled() {
              return this._disabled;
            }
            set disabled(t) {
              (this._disabled = t), this.tabView.cd.markForCheck();
            }
            get header() {
              return this._header;
            }
            set header(t) {
              (this._header = t),
                Promise.resolve().then(() => {
                  this.tabView.updateInkBar(), this.tabView.cd.markForCheck();
                });
            }
            get leftIcon() {
              return this._leftIcon;
            }
            set leftIcon(t) {
              (this._leftIcon = t), this.tabView.cd.markForCheck();
            }
            get rightIcon() {
              return this._rightIcon;
            }
            set rightIcon(t) {
              (this._rightIcon = t), this.tabView.cd.markForCheck();
            }
            ngOnDestroy() {
              this.view = null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Lt(Mr(() => DT)), Lt(pl), Lt(cx));
            }),
            (n.ɵcmp = xo({
              type: n,
              selectors: [["p-tabPanel"]],
              contentQueries: function (t, s, c) {
                if ((1 & t && X0(c, vT, 4), 2 & t)) {
                  let p;
                  _h((p = yh())) && (s.templates = p);
                }
              },
              hostAttrs: [1, "p-element"],
              inputs: {
                closable: "closable",
                headerStyle: "headerStyle",
                headerStyleClass: "headerStyleClass",
                cache: "cache",
                tooltip: "tooltip",
                tooltipPosition: "tooltipPosition",
                tooltipPositionStyle: "tooltipPositionStyle",
                tooltipStyleClass: "tooltipStyleClass",
                selected: "selected",
                disabled: "disabled",
                header: "header",
                leftIcon: "leftIcon",
                rightIcon: "rightIcon",
              },
              ngContentSelectors: ET,
              decls: 1,
              vars: 1,
              consts: [
                [
                  "class",
                  "p-tabview-panel",
                  "role",
                  "tabpanel",
                  3,
                  "hidden",
                  4,
                  "ngIf",
                ],
                ["role", "tabpanel", 1, "p-tabview-panel", 3, "hidden"],
                [4, "ngIf"],
                [4, "ngTemplateOutlet"],
              ],
              template: function (t, s) {
                1 & t && (I0(), Qr(0, CP, 3, 5, "div", 0)),
                  2 & t && bi("ngIf", !s.closed);
              },
              dependencies: [Uy, Ix],
              encapsulation: 2,
            })),
            n
          );
        })(),
        DT = (() => {
          class n {
            constructor(t, s) {
              (this.el = t),
                (this.cd = s),
                (this.orientation = "top"),
                (this.onChange = new xa()),
                (this.onClose = new xa()),
                (this.activeIndexChange = new xa()),
                (this.backwardIsDisabled = !0),
                (this.forwardIsDisabled = !1);
            }
            ngAfterContentInit() {
              this.initTabs(),
                (this.tabChangesSubscription = this.tabPanels.changes.subscribe(
                  (t) => {
                    this.initTabs();
                  }
                ));
            }
            ngAfterViewChecked() {
              this.tabChanged && (this.updateInkBar(), (this.tabChanged = !1));
            }
            ngOnDestroy() {
              this.tabChangesSubscription &&
                this.tabChangesSubscription.unsubscribe();
            }
            initTabs() {
              (this.tabs = this.tabPanels.toArray()),
                !this.findSelectedTab() &&
                  this.tabs.length &&
                  (null != this.activeIndex &&
                  this.tabs.length > this.activeIndex
                    ? (this.tabs[this.activeIndex].selected = !0)
                    : (this.tabs[0].selected = !0),
                  (this.tabChanged = !0)),
                this.cd.markForCheck();
            }
            open(t, s) {
              if (s.disabled) t && t.preventDefault();
              else {
                if (!s.selected) {
                  let c = this.findSelectedTab();
                  c && (c.selected = !1),
                    (this.tabChanged = !0),
                    (s.selected = !0);
                  let p = this.findTabIndex(s);
                  (this.preventActiveIndexPropagation = !0),
                    this.activeIndexChange.emit(p),
                    this.onChange.emit({ originalEvent: t, index: p }),
                    this.updateScrollBar(p);
                }
                t && t.preventDefault();
              }
            }
            close(t, s) {
              this.controlClose
                ? this.onClose.emit({
                    originalEvent: t,
                    index: this.findTabIndex(s),
                    close: () => {
                      this.closeTab(s);
                    },
                  })
                : (this.closeTab(s),
                  this.onClose.emit({
                    originalEvent: t,
                    index: this.findTabIndex(s),
                  })),
                t.stopPropagation();
            }
            closeTab(t) {
              if (!t.disabled) {
                if (t.selected) {
                  (this.tabChanged = !0), (t.selected = !1);
                  for (let s = 0; s < this.tabs.length; s++) {
                    let c = this.tabs[s];
                    if (!c.closed && !t.disabled) {
                      c.selected = !0;
                      break;
                    }
                  }
                }
                t.closed = !0;
              }
            }
            findSelectedTab() {
              for (let t = 0; t < this.tabs.length; t++)
                if (this.tabs[t].selected) return this.tabs[t];
              return null;
            }
            findTabIndex(t) {
              let s = -1;
              for (let c = 0; c < this.tabs.length; c++)
                if (this.tabs[c] == t) {
                  s = c;
                  break;
                }
              return s;
            }
            getBlockableElement() {
              return this.el.nativeElement.children[0];
            }
            get activeIndex() {
              return this._activeIndex;
            }
            set activeIndex(t) {
              (this._activeIndex = t),
                this.preventActiveIndexPropagation
                  ? (this.preventActiveIndexPropagation = !1)
                  : this.tabs &&
                    this.tabs.length &&
                    null != this._activeIndex &&
                    this.tabs.length > this._activeIndex &&
                    ((this.findSelectedTab().selected = !1),
                    (this.tabs[this._activeIndex].selected = !0),
                    (this.tabChanged = !0),
                    this.updateScrollBar(t));
            }
            updateInkBar() {
              if (this.navbar) {
                const t = Jt.findSingle(
                  this.navbar.nativeElement,
                  "li.p-highlight"
                );
                if (!t) return;
                (this.inkbar.nativeElement.style.width = Jt.getWidth(t) + "px"),
                  (this.inkbar.nativeElement.style.left =
                    Jt.getOffset(t).left -
                    Jt.getOffset(this.navbar.nativeElement).left +
                    "px");
              }
            }
            updateScrollBar(t) {
              this.navbar.nativeElement.children[t].scrollIntoView({
                block: "nearest",
              });
            }
            updateButtonState() {
              const t = this.content.nativeElement,
                { scrollLeft: s, scrollWidth: c } = t,
                p = Jt.getWidth(t);
              (this.backwardIsDisabled = 0 === s),
                (this.forwardIsDisabled = parseInt(s) === c - p);
            }
            onScroll(t) {
              this.scrollable && this.updateButtonState(), t.preventDefault();
            }
            getVisibleButtonWidths() {
              return [
                this.prevBtn?.nativeElement,
                this.nextBtn?.nativeElement,
              ].reduce((t, s) => (s ? t + Jt.getWidth(s) : t), 0);
            }
            navBackward() {
              const t = this.content.nativeElement,
                s = Jt.getWidth(t) - this.getVisibleButtonWidths(),
                c = t.scrollLeft - s;
              t.scrollLeft = c <= 0 ? 0 : c;
            }
            navForward() {
              const t = this.content.nativeElement,
                s = Jt.getWidth(t) - this.getVisibleButtonWidths(),
                c = t.scrollLeft + s,
                p = t.scrollWidth - s;
              t.scrollLeft = c >= p ? p : c;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(Lt(sl), Lt(cx));
            }),
            (n.ɵcmp = xo({
              type: n,
              selectors: [["p-tabView"]],
              contentQueries: function (t, s, c) {
                if ((1 & t && X0(c, TT, 4), 2 & t)) {
                  let p;
                  _h((p = yh())) && (s.tabPanels = p);
                }
              },
              viewQuery: function (t, s) {
                if (
                  (1 & t &&
                    (Ef(MP, 5), Ef(AP, 5), Ef(PP, 5), Ef(LP, 5), Ef(kP, 5)),
                  2 & t)
                ) {
                  let c;
                  _h((c = yh())) && (s.content = c.first),
                    _h((c = yh())) && (s.navbar = c.first),
                    _h((c = yh())) && (s.prevBtn = c.first),
                    _h((c = yh())) && (s.nextBtn = c.first),
                    _h((c = yh())) && (s.inkbar = c.first);
                }
              },
              hostAttrs: [1, "p-element"],
              inputs: {
                orientation: "orientation",
                style: "style",
                styleClass: "styleClass",
                controlClose: "controlClose",
                scrollable: "scrollable",
                activeIndex: "activeIndex",
              },
              outputs: {
                onChange: "onChange",
                onClose: "onClose",
                activeIndexChange: "activeIndexChange",
              },
              ngContentSelectors: ET,
              decls: 13,
              vars: 9,
              consts: [
                [3, "ngClass", "ngStyle"],
                [1, "p-tabview-nav-container"],
                [
                  "class",
                  "p-tabview-nav-prev p-tabview-nav-btn p-link",
                  "type",
                  "button",
                  "pRipple",
                  "",
                  3,
                  "click",
                  4,
                  "ngIf",
                ],
                [1, "p-tabview-nav-content", 3, "scroll"],
                ["content", ""],
                ["role", "tablist", 1, "p-tabview-nav"],
                ["navbar", ""],
                ["ngFor", "", 3, "ngForOf"],
                [1, "p-tabview-ink-bar"],
                ["inkbar", ""],
                [
                  "class",
                  "p-tabview-nav-next p-tabview-nav-btn p-link",
                  "type",
                  "button",
                  "pRipple",
                  "",
                  3,
                  "click",
                  4,
                  "ngIf",
                ],
                [1, "p-tabview-panels"],
                [
                  "type",
                  "button",
                  "pRipple",
                  "",
                  1,
                  "p-tabview-nav-prev",
                  "p-tabview-nav-btn",
                  "p-link",
                  3,
                  "click",
                ],
                ["prevBtn", ""],
                [1, "pi", "pi-chevron-left"],
                [
                  "role",
                  "presentation",
                  3,
                  "ngClass",
                  "ngStyle",
                  "class",
                  4,
                  "ngIf",
                ],
                ["role", "presentation", 3, "ngClass", "ngStyle"],
                [
                  "role",
                  "tab",
                  "pRipple",
                  "",
                  1,
                  "p-tabview-nav-link",
                  3,
                  "pTooltip",
                  "tooltipPosition",
                  "positionStyle",
                  "tooltipStyleClass",
                  "click",
                  "keydown.enter",
                ],
                [4, "ngIf"],
                [4, "ngTemplateOutlet"],
                ["class", "p-tabview-close pi pi-times", 3, "click", 4, "ngIf"],
                ["class", "p-tabview-left-icon", 3, "ngClass", 4, "ngIf"],
                [1, "p-tabview-title"],
                ["class", "p-tabview-right-icon", 3, "ngClass", 4, "ngIf"],
                [1, "p-tabview-left-icon", 3, "ngClass"],
                [1, "p-tabview-right-icon", 3, "ngClass"],
                [1, "p-tabview-close", "pi", "pi-times", 3, "click"],
                [
                  "type",
                  "button",
                  "pRipple",
                  "",
                  1,
                  "p-tabview-nav-next",
                  "p-tabview-nav-btn",
                  "p-link",
                  3,
                  "click",
                ],
                ["nextBtn", ""],
                [1, "pi", "pi-chevron-right"],
              ],
              template: function (t, s) {
                1 & t &&
                  (I0(),
                  on(0, "div", 0)(1, "div", 1),
                  Qr(2, RP, 3, 0, "button", 2),
                  on(3, "div", 3, 4),
                  gh("scroll", function (p) {
                    return s.onScroll(p);
                  }),
                  on(5, "ul", 5, 6),
                  Qr(7, UP, 1, 1, "ng-template", 7),
                  Wi(8, "li", 8, 9),
                  Pn()(),
                  Qr(10, $P, 3, 0, "button", 10),
                  Pn(),
                  on(11, "div", 11),
                  C0(12),
                  Pn()()),
                  2 & t &&
                    (A0(s.styleClass),
                    bi("ngClass", bw(7, HP, s.scrollable))("ngStyle", s.style),
                    Hi(2),
                    bi("ngIf", s.scrollable && !s.backwardIsDisabled),
                    Hi(5),
                    bi("ngForOf", s.tabs),
                    Hi(3),
                    bi("ngIf", s.scrollable && !s.forwardIsDisabled));
              },
              dependencies: [Ex, Tx, Uy, Ix, GE, TP, DP],
              styles: [
                ".p-tabview-nav-container{position:relative}.p-tabview-scrollable .p-tabview-nav-container{overflow:hidden}.p-tabview-nav-content{overflow-x:auto;overflow-y:hidden;scroll-behavior:smooth;scrollbar-width:none;overscroll-behavior:contain auto}.p-tabview-nav{display:flex;margin:0;padding:0;list-style-type:none;flex:1 1 auto}.p-tabview-nav-link{cursor:pointer;-webkit-user-select:none;user-select:none;display:flex;align-items:center;position:relative;text-decoration:none;overflow:hidden}.p-tabview-ink-bar{display:none;z-index:1}.p-tabview-nav-link:focus{z-index:1}.p-tabview-title{line-height:1;white-space:nowrap}.p-tabview-nav-btn{position:absolute;top:0;z-index:2;height:100%;display:flex;align-items:center;justify-content:center}.p-tabview-nav-prev{left:0}.p-tabview-nav-next{right:0}.p-tabview-nav-content::-webkit-scrollbar{display:none}.p-tabview-close{z-index:1}\n",
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        qP = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({ imports: [xh, Bx, wT, jx, Bx] })),
            n
          );
        })(),
        WP = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = xo({
              type: n,
              selectors: [["app-intro"]],
              decls: 33,
              vars: 0,
              consts: [
                [
                  "src",
                  "../..luisdebenito/assets/fields.jpeg",
                  1,
                  "img",
                  "rounded",
                ],
                [1, "centered"],
                [1, "pi", "pi-linkedin"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.linkedin.com/in/luis-de-benito/",
                ],
                [1, "pi", "pi-envelope"],
                ["target", "_blank", "href", "mailTo:luisdebenito7@gmail.com"],
                [1, "pi", "pi-instagram"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.instagram.com/luis.bq_/",
                ],
                [1, "pi", "pi-twitter"],
                [
                  "target",
                  "_blank",
                  "href",
                  "https://www.twitter.com/luisbq_/",
                ],
                ["src", "../..luisdebenito/assets/segovia.jpg", 1, "img"],
                ["src", "../..luisdebenito/assets/segovia1.jpg", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (on(0, "h1"),
                  Si(1, "Luis de Benito"),
                  Pn(),
                  on(2, "p"),
                  Si(
                    3,
                    " Hello there! Thanks for getting in here. My name is "
                  ),
                  on(4, "b"),
                  Si(5, "Luis"),
                  Pn(),
                  Si(
                    6,
                    ", and this is the best way I found to tell my story without you falling asleep while reading it.\n"
                  ),
                  Pn(),
                  Wi(7, "img", 0),
                  on(8, "div", 1)(9, "p"),
                  Wi(10, "i", 2),
                  on(11, "a", 3),
                  Si(12, "Luis dB.P."),
                  Pn()(),
                  on(13, "p"),
                  Wi(14, "i", 4),
                  on(15, "a", 5),
                  Si(16, "luisdebenito7@gmail.com"),
                  Pn()(),
                  on(17, "p"),
                  Wi(18, "i", 6),
                  on(19, "a", 7),
                  Si(20, "@luis.bq_"),
                  Pn()(),
                  on(21, "p"),
                  Wi(22, "i", 8),
                  on(23, "a", 9),
                  Si(24, "@luisbq_"),
                  Pn()()(),
                  on(25, "p"),
                  Si(
                    26,
                    " Back in 1995, my parents decided to make my first commit in Segovia, and I spent here the first 17 years of my life. Such a lovely city.\n"
                  ),
                  Pn(),
                  Wi(27, "img", 10),
                  on(28, "p"),
                  Si(
                    29,
                    "I walked by those years mostly playing tennis and studying"
                  ),
                  Pn(),
                  Wi(30, "img", 11),
                  on(31, "p"),
                  Si(
                    32,
                    " I was never a social animal, but thanks to my parents and the influence of some friends, I started building my personality. Outgoing, adventurous, frequent traveller and active as heck (I am learning to stand still doing nothing for more than an hour)\n"
                  ),
                  Pn());
              },
              styles: [
                ".centered[_ngcontent-%COMP%]{margin:auto;padding-left:10px;color:#fff}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] > i[_ngcontent-%COMP%]{margin:15px;font-size:25px}.centered[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{margin:5px}.centered[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{color:#fff}",
              ],
            })),
            n
          );
        })(),
        ZP = (() => {
          class n {
            constructor() {}
            ngOnInit() {}
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = xo({
              type: n,
              selectors: [["app-education"]],
              decls: 25,
              vars: 0,
              consts: [
                ["src", "../..luisdebenito/assets/uni1.jpg", 1, "img"],
                ["src", "../..luisdebenito/assets/unitenis.jpg", 1, "img"],
                ["src", "../..luisdebenito/assets/malt.jpg", 1, "img"],
                ["src", "../..luisdebenito/assets/iowa.jpg", 1, "img"],
              ],
              template: function (t, s) {
                1 & t &&
                  (on(0, "h1"),
                  Si(1, "University in Madrid"),
                  Pn(),
                  on(2, "p"),
                  Si(
                    3,
                    " After a good childhood in the fields, it was my time to move to the big city. I got into UPM (Universidad Polit\xe9cnica de Madrid) to study "
                  ),
                  on(4, "b"),
                  Si(5, "Electronic and Automatic Industrial Engineering"),
                  Pn()(),
                  Wi(6, "img", 0),
                  on(7, "h1"),
                  Si(8, "University of London"),
                  Pn(),
                  on(9, "p"),
                  Si(
                    10,
                    " Lucky me, I got sponsored to do an online MSC in Data Science and Artificial Intelligence. It was nice, but not what I expected, easily replaced by Youtube\n"
                  ),
                  Pn(),
                  Wi(11, "img", 1),
                  on(12, "p")(13, "i"),
                  Si(
                    14,
                    "I was sick the day we got the trophies, don't judge my face"
                  ),
                  Pn()(),
                  on(15, "h1"),
                  Si(16, "Volunteering"),
                  Pn(),
                  on(17, "p"),
                  Si(
                    18,
                    " I have done a lot of volunteering, but Malta was the best one. I got the chance to develop a project to handcraft instruments made by trash, and spent a couple months enjoying the views\n"
                  ),
                  Pn(),
                  Wi(19, "img", 2),
                  on(20, "h1"),
                  Si(21, "Others"),
                  Pn(),
                  on(22, "p"),
                  Si(
                    23,
                    " I got the national tennis teacher license from RFET, did a quarterly exchange in Ames, Iowa, and some other titles that may be interesting for nobody.\n"
                  ),
                  Pn(),
                  Wi(24, "img", 3));
              },
              encapsulation: 2,
            })),
            n
          );
        })();
      function XP(n, e) {
        1 & n && Wi(0, "app-intro");
      }
      function KP(n, e) {
        1 & n && Wi(0, "app-education");
      }
      function YP(n, e) {
        if ((1 & n && (Wi(0, "i"), on(1, "span", 9), Si(2), Pn()), 2 & n)) {
          const t = ho().$implicit;
          (function I1(n, e, t) {
            dl(Xn, tc, mh(Ze(), n, e, t), !0);
          })("pi pi-", t.icon, ""),
            Hi(2),
            _y(t.name);
        }
      }
      function QP(n, e) {
        1 & n && (on(0, "p-tabPanel"), Qr(1, YP, 3, 4, "ng-template", 8), Pn());
      }
      let JP = (() => {
          class n {
            constructor() {
              (this.title = "ostoo"),
                (this.mapbox = zx),
                (this.style = "mapbox://styles/mapbox/navigation-night-v1"),
                (this.indexSelected = 0),
                (this.headers = [
                  { name: "Info", icon: "id-card", lt: [41.15907, -4.570329] },
                  {
                    name: "Education",
                    icon: "user-plus",
                    lt: [40.429561, -3.713232],
                  },
                  {
                    name: "Experience",
                    icon: "star",
                    lt: [45.508237, 12.267826],
                  },
                  {
                    name: "Music",
                    icon: "volume-up",
                    lt: [59.333226, 18.06828],
                  },
                  { name: "Trips", icon: "map", lt: [59.891037, 30.319812] },
                  { name: "Code", icon: "code", lt: [49.373385, 10.180248] },
                  { name: "Sports", icon: "flag", lt: [40.951807, -4.105901] },
                  { name: "Misc", icon: "globe", lt: [17.469947, 78.422454] },
                ]),
                (this.moving = !1),
                (this.mapbox.accessToken =
                  "pk.eyJ1Ijoid3lra3NzIiwiYSI6ImNqMjR6aTdmdzAwNHMzMnBvbjBucjlqNm8ifQ.6GjGpofWBVaIuSnhdXQb5w");
            }
            ngOnInit() {
              (this.map = new zx.Map({
                container: "map",
                style: this.style,
                zoom: 10,
                center: [0, 0],
                interactive: !1,
              })),
                this.initMap(),
                setTimeout(() => {
                  this.flyTo(this.headers[0].lt);
                }, 300);
            }
            initMap() {
              this.drawLocations();
            }
            generateRandomColor() {
              return "#" + Math.floor(16777215 * Math.random()).toString(16);
            }
            drawLocations() {
              this.headers.forEach((t) => {
                new zx.Marker({ color: this.generateRandomColor() })
                  .setLngLat([t.lt[1], t.lt[0]])
                  .addTo(this.map);
              });
            }
            tabChanged(t) {
              t.index != this.indexSelected &&
                ((this.indexSelected = t.index),
                this.flyTo(this.headers[this.indexSelected].lt));
            }
            flyTo(t) {
              (this.moving = !0),
                this.map.flyTo({
                  center: [t[1], t[0]],
                  essential: !0,
                  speed: 1.4,
                  curve: 2.2,
                });
              let s = !1;
              this.map.on("moveend", () => {
                s || (this.moving = !1), (s = !0);
              });
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = xo({
              type: n,
              selectors: [["app-root"]],
              decls: 9,
              vars: 5,
              consts: [
                ["id", "map", 1, "container"],
                ["id", "mdl", 1, "modal", 3, "ngClass"],
                [1, "container"],
                [1, "inContainer"],
                [4, "ngIf"],
                [1, "footer"],
                [3, "activeIndex", "onChange"],
                [4, "ngFor", "ngForOf"],
                ["pTemplate", "header"],
                [1, "spantitle"],
              ],
              template: function (t, s) {
                1 & t &&
                  (Wi(0, "div", 0),
                  on(1, "div", 1)(2, "div", 2)(3, "div", 3),
                  Qr(4, XP, 1, 0, "app-intro", 4),
                  Qr(5, KP, 1, 0, "app-education", 4),
                  Pn()(),
                  on(6, "div", 5)(7, "p-tabView", 6),
                  gh("onChange", function (p) {
                    return s.tabChanged(p);
                  }),
                  Qr(8, QP, 2, 0, "p-tabPanel", 7),
                  Pn()()()),
                  2 & t &&
                    (Hi(1),
                    bi("ngClass", s.moving ? "transp" : ""),
                    Hi(3),
                    bi("ngIf", 0 == s.indexSelected),
                    Hi(1),
                    bi("ngIf", 1 == s.indexSelected),
                    Hi(2),
                    bi("activeIndex", s.indexSelected),
                    Hi(1),
                    bi("ngForOf", s.headers));
              },
              dependencies: [Ex, Tx, Uy, vT, DT, TT, WP, ZP],
              styles: [
                ".container[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .map[_ngcontent-%COMP%]{height:100%}.container[_ngcontent-%COMP%]     .mapboxgl-control-container{display:none}.container[_ngcontent-%COMP%]     .customRoom:hover{cursor:pointer}  .p-tabview-nav-content{overflow-x:auto;overflow-y:hidden;scroll-behavior:smooth;scrollbar-width:none;overscroll-behavior:contain auto}  .p-tabview-nav{display:flex;margin:0;padding:0;list-style-type:none;flex:1 1 auto}  .p-tabview .p-tabview-nav li{border-top:1px solid white;background-color:#544008}  .p-tabview .p-tabview-nav li span.spantitle{margin:auto 10px}  .p-tabview .p-tabview-nav li.p-highlight .p-tabview-nav-link{background-color:#e8fccf;color:#544008}  .p-tabview .p-tabview-nav li .p-tabview-nav-link{transition:background-color .2s,box-shadow .2s}  .p-tabview .p-tabview-nav li .p-tabview-nav-link{color:#fff;padding:1.25rem;font-weight:700;border-bottom-right-radius:10px;border-bottom-left-radius:10px;transition:box-shadow .2s;margin:0 0 -2px}  .p-tabview-nav-link{cursor:pointer;-webkit-user-select:none;user-select:none;display:flex;align-items:center;position:relative;text-decoration:none;overflow:hidden}.addRoom[_ngcontent-%COMP%]{position:fixed;right:20px;bottom:20px;background-color:#3f51b5;height:70px;width:70px;border-radius:50%}.addRoom[_ngcontent-%COMP%]:hover{cursor:pointer}.modal[_ngcontent-%COMP%]{background-color:#544008;color:#f0f7ee;border:5px solid #f0f7ee;border-radius:20px;height:98%;position:fixed;z-index:800;top:1%}.modal[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{width:100%;height:7%;position:absolute;bottom:0;margin:auto}.modal[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]{width:100%;height:90%;max-height:90%;overflow-y:auto;position:absolute;top:0}.modal[_ngcontent-%COMP%]   .container[_ngcontent-%COMP%]   .inContainer[_ngcontent-%COMP%]{text-align:center}@media (max-width: 800px){  .p-tabview .p-tabview-nav li{padding-right:5px;padding-left:5px}.inContainer[_ngcontent-%COMP%]{margin:20px 3%}.modal[_ngcontent-%COMP%]{width:95%;left:1.5%}}@media (min-width: 800px){  .p-tabview .p-tabview-nav li{padding-right:30px;padding-left:30px}.inContainer[_ngcontent-%COMP%]{margin:20px 20%}.modal[_ngcontent-%COMP%]{width:68%;right:16%}}.transp[_ngcontent-%COMP%]{display:none}",
              ],
            })),
            n
          );
        })(),
        t2 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({ imports: [xh, jx] })),
            n
          );
        })();
      class ST {}
      const nu = "*";
      function IT(n, e = null) {
        return { type: 4, styles: e, timings: n };
      }
      function CT(n, e = null) {
        return { type: 2, steps: n, options: e };
      }
      function Ky(n) {
        return { type: 6, styles: n, offset: null };
      }
      function MT(n, e = null) {
        return { type: 8, animation: n, options: e };
      }
      function AT(n) {
        Promise.resolve().then(n);
      }
      class Lg {
        constructor(e = 0, t = 0) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this._started = !1),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._position = 0),
            (this.parentPlayer = null),
            (this.totalTime = e + t);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        init() {}
        play() {
          this.hasStarted() || (this._onStart(), this.triggerMicrotask()),
            (this._started = !0);
        }
        triggerMicrotask() {
          AT(() => this._onFinish());
        }
        _onStart() {
          this._onStartFns.forEach((e) => e()), (this._onStartFns = []);
        }
        pause() {}
        restart() {}
        finish() {
          this._onFinish();
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this.hasStarted() || this._onStart(),
            this.finish(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          (this._started = !1),
            (this._finished = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        setPosition(e) {
          this._position = this.totalTime ? e * this.totalTime : 1;
        }
        getPosition() {
          return this.totalTime ? this._position / this.totalTime : 1;
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((s) => s()), (t.length = 0);
        }
      }
      class PT {
        constructor(e) {
          (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._onDestroyFns = []),
            (this.parentPlayer = null),
            (this.totalTime = 0),
            (this.players = e);
          let t = 0,
            s = 0,
            c = 0;
          const p = this.players.length;
          0 == p
            ? AT(() => this._onFinish())
            : this.players.forEach((y) => {
                y.onDone(() => {
                  ++t == p && this._onFinish();
                }),
                  y.onDestroy(() => {
                    ++s == p && this._onDestroy();
                  }),
                  y.onStart(() => {
                    ++c == p && this._onStart();
                  });
              }),
            (this.totalTime = this.players.reduce(
              (y, w) => Math.max(y, w.totalTime),
              0
            ));
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this.players.forEach((e) => e.init());
        }
        onStart(e) {
          this._onStartFns.push(e);
        }
        _onStart() {
          this.hasStarted() ||
            ((this._started = !0),
            this._onStartFns.forEach((e) => e()),
            (this._onStartFns = []));
        }
        onDone(e) {
          this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this.parentPlayer || this.init(),
            this._onStart(),
            this.players.forEach((e) => e.play());
        }
        pause() {
          this.players.forEach((e) => e.pause());
        }
        restart() {
          this.players.forEach((e) => e.restart());
        }
        finish() {
          this._onFinish(), this.players.forEach((e) => e.finish());
        }
        destroy() {
          this._onDestroy();
        }
        _onDestroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._onFinish(),
            this.players.forEach((e) => e.destroy()),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        reset() {
          this.players.forEach((e) => e.reset()),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1);
        }
        setPosition(e) {
          const t = e * this.totalTime;
          this.players.forEach((s) => {
            const c = s.totalTime ? Math.min(1, t / s.totalTime) : 1;
            s.setPosition(c);
          });
        }
        getPosition() {
          const e = this.players.reduce(
            (t, s) => (null === t || s.totalTime > t.totalTime ? s : t),
            null
          );
          return null != e ? e.getPosition() : 0;
        }
        beforeDestroy() {
          this.players.forEach((e) => {
            e.beforeDestroy && e.beforeDestroy();
          });
        }
        triggerCallback(e) {
          const t = "start" == e ? this._onStartFns : this._onDoneFns;
          t.forEach((s) => s()), (t.length = 0);
        }
      }
      let r2 = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = or({ type: n })),
          (n.ɵinj = Jn({ imports: [xh] })),
          n
        );
      })();
      MT([
        Ky({ transform: "{{transform}}", opacity: 0 }),
        IT("{{transition}}"),
      ]),
        MT([
          IT("{{transition}}", Ky({ transform: "{{transform}}", opacity: 0 })),
        ]);
      let w2 = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵmod = or({ type: n })),
          (n.ɵinj = Jn({ imports: [xh, r2, jx, Bx] })),
          n
        );
      })();
      function LT(n) {
        return new rt(3e3, !1);
      }
      function iL() {
        return typeof window < "u" && typeof window.document < "u";
      }
      function $x() {
        return (
          typeof process < "u" &&
          "[object process]" === {}.toString.call(process)
        );
      }
      function wh(n) {
        switch (n.length) {
          case 0:
            return new Lg();
          case 1:
            return n[0];
          default:
            return new PT(n);
        }
      }
      function kT(n, e, t, s, c = new Map(), p = new Map()) {
        const y = [],
          w = [];
        let S = -1,
          P = null;
        if (
          (s.forEach((N) => {
            const j = N.get("offset"),
              Q = j == S,
              ie = (Q && P) || new Map();
            N.forEach((pe, Ee) => {
              let Oe = Ee,
                Ue = pe;
              if ("offset" !== Ee)
                switch (((Oe = e.normalizePropertyName(Oe, y)), Ue)) {
                  case "!":
                    Ue = c.get(Ee);
                    break;
                  case nu:
                    Ue = p.get(Ee);
                    break;
                  default:
                    Ue = e.normalizeStyleValue(Ee, Oe, Ue, y);
                }
              ie.set(Oe, Ue);
            }),
              Q || w.push(ie),
              (P = ie),
              (S = j);
          }),
          y.length)
        )
          throw (function G2(n) {
            return new rt(3502, !1);
          })();
        return w;
      }
      function Hx(n, e, t, s) {
        switch (e) {
          case "start":
            n.onStart(() => s(t && Gx(t, "start", n)));
            break;
          case "done":
            n.onDone(() => s(t && Gx(t, "done", n)));
            break;
          case "destroy":
            n.onDestroy(() => s(t && Gx(t, "destroy", n)));
        }
      }
      function Gx(n, e, t) {
        const p = qx(
            n.element,
            n.triggerName,
            n.fromState,
            n.toState,
            e || n.phaseName,
            t.totalTime ?? n.totalTime,
            !!t.disabled
          ),
          y = n._data;
        return null != y && (p._data = y), p;
      }
      function qx(n, e, t, s, c = "", p = 0, y) {
        return {
          element: n,
          triggerName: e,
          fromState: t,
          toState: s,
          phaseName: c,
          totalTime: p,
          disabled: !!y,
        };
      }
      function Cs(n, e, t) {
        let s = n.get(e);
        return s || n.set(e, (s = t)), s;
      }
      function RT(n) {
        const e = n.indexOf(":");
        return [n.substring(1, e), n.slice(e + 1)];
      }
      let Wx = (n, e) => !1,
        OT = (n, e, t) => [],
        FT = null;
      function Zx(n) {
        const e = n.parentNode || n.host;
        return e === FT ? null : e;
      }
      ($x() || typeof Element < "u") &&
        (iL()
          ? ((FT = (() => document.documentElement)()),
            (Wx = (n, e) => {
              for (; e; ) {
                if (e === n) return !0;
                e = Zx(e);
              }
              return !1;
            }))
          : (Wx = (n, e) => n.contains(e)),
        (OT = (n, e, t) => {
          if (t) return Array.from(n.querySelectorAll(e));
          const s = n.querySelector(e);
          return s ? [s] : [];
        }));
      let ep = null,
        NT = !1;
      const zT = Wx,
        BT = OT;
      let VT = (() => {
          class n {
            validateStyleProperty(t) {
              return (function oL(n) {
                ep ||
                  ((ep =
                    (function sL() {
                      return typeof document < "u" ? document.body : null;
                    })() || {}),
                  (NT = !!ep.style && "WebkitAppearance" in ep.style));
                let e = !0;
                return (
                  ep.style &&
                    !(function rL(n) {
                      return "ebkit" == n.substring(1, 6);
                    })(n) &&
                    ((e = n in ep.style),
                    !e &&
                      NT &&
                      (e =
                        "Webkit" + n.charAt(0).toUpperCase() + n.slice(1) in
                        ep.style)),
                  e
                );
              })(t);
            }
            matchesElement(t, s) {
              return !1;
            }
            containsElement(t, s) {
              return zT(t, s);
            }
            getParentElement(t) {
              return Zx(t);
            }
            query(t, s, c) {
              return BT(t, s, c);
            }
            computeStyle(t, s, c) {
              return c || "";
            }
            animate(t, s, c, p, y, w = [], S) {
              return new Lg(c, p);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Xx = (() => {
          class n {}
          return (n.NOOP = new VT()), n;
        })();
      const Kx = "ng-enter",
        Yy = "ng-leave",
        Qy = "ng-trigger",
        Jy = ".ng-trigger",
        UT = "ng-animating",
        Yx = ".ng-animating";
      function iu(n) {
        if ("number" == typeof n) return n;
        const e = n.match(/^(-?[\.\d]+)(m?s)/);
        return !e || e.length < 2 ? 0 : Qx(parseFloat(e[1]), e[2]);
      }
      function Qx(n, e) {
        return "s" === e ? 1e3 * n : n;
      }
      function ev(n, e, t) {
        return n.hasOwnProperty("duration")
          ? n
          : (function cL(n, e, t) {
              let c,
                p = 0,
                y = "";
              if ("string" == typeof n) {
                const w = n.match(
                  /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i
                );
                if (null === w)
                  return e.push(LT()), { duration: 0, delay: 0, easing: "" };
                c = Qx(parseFloat(w[1]), w[2]);
                const S = w[3];
                null != S && (p = Qx(parseFloat(S), w[4]));
                const P = w[5];
                P && (y = P);
              } else c = n;
              if (!t) {
                let w = !1,
                  S = e.length;
                c < 0 &&
                  (e.push(
                    (function E2() {
                      return new rt(3100, !1);
                    })()
                  ),
                  (w = !0)),
                  p < 0 &&
                    (e.push(
                      (function T2() {
                        return new rt(3101, !1);
                      })()
                    ),
                    (w = !0)),
                  w && e.splice(S, 0, LT());
              }
              return { duration: c, delay: p, easing: y };
            })(n, e, t);
      }
      function kg(n, e = {}) {
        return (
          Object.keys(n).forEach((t) => {
            e[t] = n[t];
          }),
          e
        );
      }
      function $T(n) {
        const e = new Map();
        return (
          Object.keys(n).forEach((t) => {
            e.set(t, n[t]);
          }),
          e
        );
      }
      function Eh(n, e = new Map(), t) {
        if (t) for (let [s, c] of t) e.set(s, c);
        for (let [s, c] of n) e.set(s, c);
        return e;
      }
      function GT(n, e, t) {
        return t ? e + ":" + t + ";" : "";
      }
      function qT(n) {
        let e = "";
        for (let t = 0; t < n.style.length; t++) {
          const s = n.style.item(t);
          e += GT(0, s, n.style.getPropertyValue(s));
        }
        for (const t in n.style)
          n.style.hasOwnProperty(t) &&
            !t.startsWith("_") &&
            (e += GT(0, pL(t), n.style[t]));
        n.setAttribute("style", e);
      }
      function ic(n, e, t) {
        n.style &&
          (e.forEach((s, c) => {
            const p = eb(c);
            t && !t.has(c) && t.set(c, n.style[p]), (n.style[p] = s);
          }),
          $x() && qT(n));
      }
      function tp(n, e) {
        n.style &&
          (e.forEach((t, s) => {
            const c = eb(s);
            n.style[c] = "";
          }),
          $x() && qT(n));
      }
      function Rg(n) {
        return Array.isArray(n) ? (1 == n.length ? n[0] : CT(n)) : n;
      }
      const Jx = new RegExp("{{\\s*(.+?)\\s*}}", "g");
      function WT(n) {
        let e = [];
        if ("string" == typeof n) {
          let t;
          for (; (t = Jx.exec(n)); ) e.push(t[1]);
          Jx.lastIndex = 0;
        }
        return e;
      }
      function Og(n, e, t) {
        const s = n.toString(),
          c = s.replace(Jx, (p, y) => {
            let w = e[y];
            return (
              null == w &&
                (t.push(
                  (function S2(n) {
                    return new rt(3003, !1);
                  })()
                ),
                (w = "")),
              w.toString()
            );
          });
        return c == s ? n : c;
      }
      function tv(n) {
        const e = [];
        let t = n.next();
        for (; !t.done; ) e.push(t.value), (t = n.next());
        return e;
      }
      const dL = /-+([a-z0-9])/g;
      function eb(n) {
        return n.replace(dL, (...e) => e[1].toUpperCase());
      }
      function pL(n) {
        return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      }
      function Ms(n, e, t) {
        switch (e.type) {
          case 7:
            return n.visitTrigger(e, t);
          case 0:
            return n.visitState(e, t);
          case 1:
            return n.visitTransition(e, t);
          case 2:
            return n.visitSequence(e, t);
          case 3:
            return n.visitGroup(e, t);
          case 4:
            return n.visitAnimate(e, t);
          case 5:
            return n.visitKeyframes(e, t);
          case 6:
            return n.visitStyle(e, t);
          case 8:
            return n.visitReference(e, t);
          case 9:
            return n.visitAnimateChild(e, t);
          case 10:
            return n.visitAnimateRef(e, t);
          case 11:
            return n.visitQuery(e, t);
          case 12:
            return n.visitStagger(e, t);
          default:
            throw (function I2(n) {
              return new rt(3004, !1);
            })();
        }
      }
      function ZT(n, e) {
        return window.getComputedStyle(n)[e];
      }
      function vL(n, e) {
        const t = [];
        return (
          "string" == typeof n
            ? n.split(/\s*,\s*/).forEach((s) =>
                (function xL(n, e, t) {
                  if (":" == n[0]) {
                    const S = (function bL(n, e) {
                      switch (n) {
                        case ":enter":
                          return "void => *";
                        case ":leave":
                          return "* => void";
                        case ":increment":
                          return (t, s) => parseFloat(s) > parseFloat(t);
                        case ":decrement":
                          return (t, s) => parseFloat(s) < parseFloat(t);
                        default:
                          return (
                            e.push(
                              (function j2(n) {
                                return new rt(3016, !1);
                              })()
                            ),
                            "* => *"
                          );
                      }
                    })(n, t);
                    if ("function" == typeof S) return void e.push(S);
                    n = S;
                  }
                  const s = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                  if (null == s || s.length < 4)
                    return (
                      t.push(
                        (function V2(n) {
                          return new rt(3015, !1);
                        })()
                      ),
                      e
                    );
                  const c = s[1],
                    p = s[2],
                    y = s[3];
                  e.push(XT(c, y));
                  "<" == p[0] && !("*" == c && "*" == y) && e.push(XT(y, c));
                })(s, t, e)
              )
            : t.push(n),
          t
        );
      }
      const ov = new Set(["true", "1"]),
        sv = new Set(["false", "0"]);
      function XT(n, e) {
        const t = ov.has(n) || sv.has(n),
          s = ov.has(e) || sv.has(e);
        return (c, p) => {
          let y = "*" == n || n == c,
            w = "*" == e || e == p;
          return (
            !y && t && "boolean" == typeof c && (y = c ? ov.has(n) : sv.has(n)),
            !w && s && "boolean" == typeof p && (w = p ? ov.has(e) : sv.has(e)),
            y && w
          );
        };
      }
      const wL = new RegExp("s*:selfs*,?", "g");
      function tb(n, e, t, s) {
        return new EL(n).build(e, t, s);
      }
      class EL {
        constructor(e) {
          this._driver = e;
        }
        build(e, t, s) {
          const c = new SL(t);
          return this._resetContextStyleTimingState(c), Ms(this, Rg(e), c);
        }
        _resetContextStyleTimingState(e) {
          (e.currentQuerySelector = ""),
            (e.collectedStyles = new Map()),
            e.collectedStyles.set("", new Map()),
            (e.currentTime = 0);
        }
        visitTrigger(e, t) {
          let s = (t.queryCount = 0),
            c = (t.depCount = 0);
          const p = [],
            y = [];
          return (
            "@" == e.name.charAt(0) &&
              t.errors.push(
                (function M2() {
                  return new rt(3006, !1);
                })()
              ),
            e.definitions.forEach((w) => {
              if ((this._resetContextStyleTimingState(t), 0 == w.type)) {
                const S = w,
                  P = S.name;
                P.toString()
                  .split(/\s*,\s*/)
                  .forEach((N) => {
                    (S.name = N), p.push(this.visitState(S, t));
                  }),
                  (S.name = P);
              } else if (1 == w.type) {
                const S = this.visitTransition(w, t);
                (s += S.queryCount), (c += S.depCount), y.push(S);
              } else
                t.errors.push(
                  (function A2() {
                    return new rt(3007, !1);
                  })()
                );
            }),
            {
              type: 7,
              name: e.name,
              states: p,
              transitions: y,
              queryCount: s,
              depCount: c,
              options: null,
            }
          );
        }
        visitState(e, t) {
          const s = this.visitStyle(e.styles, t),
            c = (e.options && e.options.params) || null;
          if (s.containsDynamicStyles) {
            const p = new Set(),
              y = c || {};
            s.styles.forEach((w) => {
              w instanceof Map &&
                w.forEach((S) => {
                  WT(S).forEach((P) => {
                    y.hasOwnProperty(P) || p.add(P);
                  });
                });
            }),
              p.size &&
                (tv(p.values()),
                t.errors.push(
                  (function P2(n, e) {
                    return new rt(3008, !1);
                  })()
                ));
          }
          return {
            type: 0,
            name: e.name,
            style: s,
            options: c ? { params: c } : null,
          };
        }
        visitTransition(e, t) {
          (t.queryCount = 0), (t.depCount = 0);
          const s = Ms(this, Rg(e.animation), t);
          return {
            type: 1,
            matchers: vL(e.expr, t.errors),
            animation: s,
            queryCount: t.queryCount,
            depCount: t.depCount,
            options: np(e.options),
          };
        }
        visitSequence(e, t) {
          return {
            type: 2,
            steps: e.steps.map((s) => Ms(this, s, t)),
            options: np(e.options),
          };
        }
        visitGroup(e, t) {
          const s = t.currentTime;
          let c = 0;
          const p = e.steps.map((y) => {
            t.currentTime = s;
            const w = Ms(this, y, t);
            return (c = Math.max(c, t.currentTime)), w;
          });
          return (
            (t.currentTime = c), { type: 3, steps: p, options: np(e.options) }
          );
        }
        visitAnimate(e, t) {
          const s = (function CL(n, e) {
            if (n.hasOwnProperty("duration")) return n;
            if ("number" == typeof n) return nb(ev(n, e).duration, 0, "");
            const t = n;
            if (
              t
                .split(/\s+/)
                .some((p) => "{" == p.charAt(0) && "{" == p.charAt(1))
            ) {
              const p = nb(0, 0, "");
              return (p.dynamic = !0), (p.strValue = t), p;
            }
            const c = ev(t, e);
            return nb(c.duration, c.delay, c.easing);
          })(e.timings, t.errors);
          t.currentAnimateTimings = s;
          let c,
            p = e.styles ? e.styles : Ky({});
          if (5 == p.type) c = this.visitKeyframes(p, t);
          else {
            let y = e.styles,
              w = !1;
            if (!y) {
              w = !0;
              const P = {};
              s.easing && (P.easing = s.easing), (y = Ky(P));
            }
            t.currentTime += s.duration + s.delay;
            const S = this.visitStyle(y, t);
            (S.isEmptyStep = w), (c = S);
          }
          return (
            (t.currentAnimateTimings = null),
            { type: 4, timings: s, style: c, options: null }
          );
        }
        visitStyle(e, t) {
          const s = this._makeStyleAst(e, t);
          return this._validateStyleAst(s, t), s;
        }
        _makeStyleAst(e, t) {
          const s = [],
            c = Array.isArray(e.styles) ? e.styles : [e.styles];
          for (let w of c)
            "string" == typeof w
              ? w === nu
                ? s.push(w)
                : t.errors.push(new rt(3002, !1))
              : s.push($T(w));
          let p = !1,
            y = null;
          return (
            s.forEach((w) => {
              if (
                w instanceof Map &&
                (w.has("easing") && ((y = w.get("easing")), w.delete("easing")),
                !p)
              )
                for (let S of w.values())
                  if (S.toString().indexOf("{{") >= 0) {
                    p = !0;
                    break;
                  }
            }),
            {
              type: 6,
              styles: s,
              easing: y,
              offset: e.offset,
              containsDynamicStyles: p,
              options: null,
            }
          );
        }
        _validateStyleAst(e, t) {
          const s = t.currentAnimateTimings;
          let c = t.currentTime,
            p = t.currentTime;
          s && p > 0 && (p -= s.duration + s.delay),
            e.styles.forEach((y) => {
              "string" != typeof y &&
                y.forEach((w, S) => {
                  const P = t.collectedStyles.get(t.currentQuerySelector),
                    N = P.get(S);
                  let j = !0;
                  N &&
                    (p != c &&
                      p >= N.startTime &&
                      c <= N.endTime &&
                      (t.errors.push(
                        (function k2(n, e, t, s, c) {
                          return new rt(3010, !1);
                        })()
                      ),
                      (j = !1)),
                    (p = N.startTime)),
                    j && P.set(S, { startTime: p, endTime: c }),
                    t.options &&
                      (function hL(n, e, t) {
                        const s = e.params || {},
                          c = WT(n);
                        c.length &&
                          c.forEach((p) => {
                            s.hasOwnProperty(p) ||
                              t.push(
                                (function D2(n) {
                                  return new rt(3001, !1);
                                })()
                              );
                          });
                      })(w, t.options, t.errors);
                });
            });
        }
        visitKeyframes(e, t) {
          const s = { type: 5, styles: [], options: null };
          if (!t.currentAnimateTimings)
            return (
              t.errors.push(
                (function R2() {
                  return new rt(3011, !1);
                })()
              ),
              s
            );
          let p = 0;
          const y = [];
          let w = !1,
            S = !1,
            P = 0;
          const N = e.steps.map((Ue) => {
            const lt = this._makeStyleAst(Ue, t);
            let ze =
                null != lt.offset
                  ? lt.offset
                  : (function IL(n) {
                      if ("string" == typeof n) return null;
                      let e = null;
                      if (Array.isArray(n))
                        n.forEach((t) => {
                          if (t instanceof Map && t.has("offset")) {
                            const s = t;
                            (e = parseFloat(s.get("offset"))),
                              s.delete("offset");
                          }
                        });
                      else if (n instanceof Map && n.has("offset")) {
                        const t = n;
                        (e = parseFloat(t.get("offset"))), t.delete("offset");
                      }
                      return e;
                    })(lt.styles),
              gt = 0;
            return (
              null != ze && (p++, (gt = lt.offset = ze)),
              (S = S || gt < 0 || gt > 1),
              (w = w || gt < P),
              (P = gt),
              y.push(gt),
              lt
            );
          });
          S &&
            t.errors.push(
              (function O2() {
                return new rt(3012, !1);
              })()
            ),
            w &&
              t.errors.push(
                (function F2() {
                  return new rt(3200, !1);
                })()
              );
          const j = e.steps.length;
          let Q = 0;
          p > 0 && p < j
            ? t.errors.push(
                (function N2() {
                  return new rt(3202, !1);
                })()
              )
            : 0 == p && (Q = 1 / (j - 1));
          const ie = j - 1,
            pe = t.currentTime,
            Ee = t.currentAnimateTimings,
            Oe = Ee.duration;
          return (
            N.forEach((Ue, lt) => {
              const ze = Q > 0 ? (lt == ie ? 1 : Q * lt) : y[lt],
                gt = ze * Oe;
              (t.currentTime = pe + Ee.delay + gt),
                (Ee.duration = gt),
                this._validateStyleAst(Ue, t),
                (Ue.offset = ze),
                s.styles.push(Ue);
            }),
            s
          );
        }
        visitReference(e, t) {
          return {
            type: 8,
            animation: Ms(this, Rg(e.animation), t),
            options: np(e.options),
          };
        }
        visitAnimateChild(e, t) {
          return t.depCount++, { type: 9, options: np(e.options) };
        }
        visitAnimateRef(e, t) {
          return {
            type: 10,
            animation: this.visitReference(e.animation, t),
            options: np(e.options),
          };
        }
        visitQuery(e, t) {
          const s = t.currentQuerySelector,
            c = e.options || {};
          t.queryCount++, (t.currentQuery = e);
          const [p, y] = (function TL(n) {
            const e = !!n.split(/\s*,\s*/).find((t) => ":self" == t);
            return (
              e && (n = n.replace(wL, "")),
              (n = n
                .replace(/@\*/g, Jy)
                .replace(/@\w+/g, (t) => Jy + "-" + t.slice(1))
                .replace(/:animating/g, Yx)),
              [n, e]
            );
          })(e.selector);
          (t.currentQuerySelector = s.length ? s + " " + p : p),
            Cs(t.collectedStyles, t.currentQuerySelector, new Map());
          const w = Ms(this, Rg(e.animation), t);
          return (
            (t.currentQuery = null),
            (t.currentQuerySelector = s),
            {
              type: 11,
              selector: p,
              limit: c.limit || 0,
              optional: !!c.optional,
              includeSelf: y,
              animation: w,
              originalSelector: e.selector,
              options: np(e.options),
            }
          );
        }
        visitStagger(e, t) {
          t.currentQuery ||
            t.errors.push(
              (function z2() {
                return new rt(3013, !1);
              })()
            );
          const s =
            "full" === e.timings
              ? { duration: 0, delay: 0, easing: "full" }
              : ev(e.timings, t.errors, !0);
          return {
            type: 12,
            animation: Ms(this, Rg(e.animation), t),
            timings: s,
            options: null,
          };
        }
      }
      class SL {
        constructor(e) {
          (this.errors = e),
            (this.queryCount = 0),
            (this.depCount = 0),
            (this.currentTransition = null),
            (this.currentQuery = null),
            (this.currentQuerySelector = null),
            (this.currentAnimateTimings = null),
            (this.currentTime = 0),
            (this.collectedStyles = new Map()),
            (this.options = null),
            (this.unsupportedCSSPropertiesFound = new Set());
        }
      }
      function np(n) {
        return (
          n
            ? (n = kg(n)).params &&
              (n.params = (function DL(n) {
                return n ? kg(n) : null;
              })(n.params))
            : (n = {}),
          n
        );
      }
      function nb(n, e, t) {
        return { duration: n, delay: e, easing: t };
      }
      function ib(n, e, t, s, c, p, y = null, w = !1) {
        return {
          type: 1,
          element: n,
          keyframes: e,
          preStyleProps: t,
          postStyleProps: s,
          duration: c,
          delay: p,
          totalTime: c + p,
          easing: y,
          subTimeline: w,
        };
      }
      class av {
        constructor() {
          this._map = new Map();
        }
        get(e) {
          return this._map.get(e) || [];
        }
        append(e, t) {
          let s = this._map.get(e);
          s || this._map.set(e, (s = [])), s.push(...t);
        }
        has(e) {
          return this._map.has(e);
        }
        clear() {
          this._map.clear();
        }
      }
      const PL = new RegExp(":enter", "g"),
        kL = new RegExp(":leave", "g");
      function rb(n, e, t, s, c, p = new Map(), y = new Map(), w, S, P = []) {
        return new RL().buildKeyframes(n, e, t, s, c, p, y, w, S, P);
      }
      class RL {
        buildKeyframes(e, t, s, c, p, y, w, S, P, N = []) {
          P = P || new av();
          const j = new ob(e, t, P, c, p, N, []);
          j.options = S;
          const Q = S.delay ? iu(S.delay) : 0;
          j.currentTimeline.delayNextStep(Q),
            j.currentTimeline.setStyles([y], null, j.errors, S),
            Ms(this, s, j);
          const ie = j.timelines.filter((pe) => pe.containsAnimation());
          if (ie.length && w.size) {
            let pe;
            for (let Ee = ie.length - 1; Ee >= 0; Ee--) {
              const Oe = ie[Ee];
              if (Oe.element === t) {
                pe = Oe;
                break;
              }
            }
            pe &&
              !pe.allowOnlyTimelineStyles() &&
              pe.setStyles([w], null, j.errors, S);
          }
          return ie.length
            ? ie.map((pe) => pe.buildKeyframes())
            : [ib(t, [], [], [], 0, Q, "", !1)];
        }
        visitTrigger(e, t) {}
        visitState(e, t) {}
        visitTransition(e, t) {}
        visitAnimateChild(e, t) {
          const s = t.subInstructions.get(t.element);
          if (s) {
            const c = t.createSubContext(e.options),
              p = t.currentTimeline.currentTime,
              y = this._visitSubInstructions(s, c, c.options);
            p != y && t.transformIntoNewTimeline(y);
          }
          t.previousNode = e;
        }
        visitAnimateRef(e, t) {
          const s = t.createSubContext(e.options);
          s.transformIntoNewTimeline(),
            this._applyAnimationRefDelays(
              [e.options, e.animation.options],
              t,
              s
            ),
            this.visitReference(e.animation, s),
            t.transformIntoNewTimeline(s.currentTimeline.currentTime),
            (t.previousNode = e);
        }
        _applyAnimationRefDelays(e, t, s) {
          for (const c of e) {
            const p = c?.delay;
            if (p) {
              const y =
                "number" == typeof p ? p : iu(Og(p, c?.params ?? {}, t.errors));
              s.delayNextStep(y);
            }
          }
        }
        _visitSubInstructions(e, t, s) {
          let p = t.currentTimeline.currentTime;
          const y = null != s.duration ? iu(s.duration) : null,
            w = null != s.delay ? iu(s.delay) : null;
          return (
            0 !== y &&
              e.forEach((S) => {
                const P = t.appendInstructionToTimeline(S, y, w);
                p = Math.max(p, P.duration + P.delay);
              }),
            p
          );
        }
        visitReference(e, t) {
          t.updateOptions(e.options, !0),
            Ms(this, e.animation, t),
            (t.previousNode = e);
        }
        visitSequence(e, t) {
          const s = t.subContextCount;
          let c = t;
          const p = e.options;
          if (
            p &&
            (p.params || p.delay) &&
            ((c = t.createSubContext(p)),
            c.transformIntoNewTimeline(),
            null != p.delay)
          ) {
            6 == c.previousNode.type &&
              (c.currentTimeline.snapshotCurrentStyles(),
              (c.previousNode = lv));
            const y = iu(p.delay);
            c.delayNextStep(y);
          }
          e.steps.length &&
            (e.steps.forEach((y) => Ms(this, y, c)),
            c.currentTimeline.applyStylesToKeyframe(),
            c.subContextCount > s && c.transformIntoNewTimeline()),
            (t.previousNode = e);
        }
        visitGroup(e, t) {
          const s = [];
          let c = t.currentTimeline.currentTime;
          const p = e.options && e.options.delay ? iu(e.options.delay) : 0;
          e.steps.forEach((y) => {
            const w = t.createSubContext(e.options);
            p && w.delayNextStep(p),
              Ms(this, y, w),
              (c = Math.max(c, w.currentTimeline.currentTime)),
              s.push(w.currentTimeline);
          }),
            s.forEach((y) => t.currentTimeline.mergeTimelineCollectedStyles(y)),
            t.transformIntoNewTimeline(c),
            (t.previousNode = e);
        }
        _visitTiming(e, t) {
          if (e.dynamic) {
            const s = e.strValue;
            return ev(t.params ? Og(s, t.params, t.errors) : s, t.errors);
          }
          return { duration: e.duration, delay: e.delay, easing: e.easing };
        }
        visitAnimate(e, t) {
          const s = (t.currentAnimateTimings = this._visitTiming(e.timings, t)),
            c = t.currentTimeline;
          s.delay && (t.incrementTime(s.delay), c.snapshotCurrentStyles());
          const p = e.style;
          5 == p.type
            ? this.visitKeyframes(p, t)
            : (t.incrementTime(s.duration),
              this.visitStyle(p, t),
              c.applyStylesToKeyframe()),
            (t.currentAnimateTimings = null),
            (t.previousNode = e);
        }
        visitStyle(e, t) {
          const s = t.currentTimeline,
            c = t.currentAnimateTimings;
          !c && s.hasCurrentStyleProperties() && s.forwardFrame();
          const p = (c && c.easing) || e.easing;
          e.isEmptyStep
            ? s.applyEmptyStep(p)
            : s.setStyles(e.styles, p, t.errors, t.options),
            (t.previousNode = e);
        }
        visitKeyframes(e, t) {
          const s = t.currentAnimateTimings,
            c = t.currentTimeline.duration,
            p = s.duration,
            w = t.createSubContext().currentTimeline;
          (w.easing = s.easing),
            e.styles.forEach((S) => {
              w.forwardTime((S.offset || 0) * p),
                w.setStyles(S.styles, S.easing, t.errors, t.options),
                w.applyStylesToKeyframe();
            }),
            t.currentTimeline.mergeTimelineCollectedStyles(w),
            t.transformIntoNewTimeline(c + p),
            (t.previousNode = e);
        }
        visitQuery(e, t) {
          const s = t.currentTimeline.currentTime,
            c = e.options || {},
            p = c.delay ? iu(c.delay) : 0;
          p &&
            (6 === t.previousNode.type ||
              (0 == s && t.currentTimeline.hasCurrentStyleProperties())) &&
            (t.currentTimeline.snapshotCurrentStyles(), (t.previousNode = lv));
          let y = s;
          const w = t.invokeQuery(
            e.selector,
            e.originalSelector,
            e.limit,
            e.includeSelf,
            !!c.optional,
            t.errors
          );
          t.currentQueryTotal = w.length;
          let S = null;
          w.forEach((P, N) => {
            t.currentQueryIndex = N;
            const j = t.createSubContext(e.options, P);
            p && j.delayNextStep(p),
              P === t.element && (S = j.currentTimeline),
              Ms(this, e.animation, j),
              j.currentTimeline.applyStylesToKeyframe(),
              (y = Math.max(y, j.currentTimeline.currentTime));
          }),
            (t.currentQueryIndex = 0),
            (t.currentQueryTotal = 0),
            t.transformIntoNewTimeline(y),
            S &&
              (t.currentTimeline.mergeTimelineCollectedStyles(S),
              t.currentTimeline.snapshotCurrentStyles()),
            (t.previousNode = e);
        }
        visitStagger(e, t) {
          const s = t.parentContext,
            c = t.currentTimeline,
            p = e.timings,
            y = Math.abs(p.duration),
            w = y * (t.currentQueryTotal - 1);
          let S = y * t.currentQueryIndex;
          switch (p.duration < 0 ? "reverse" : p.easing) {
            case "reverse":
              S = w - S;
              break;
            case "full":
              S = s.currentStaggerTime;
          }
          const N = t.currentTimeline;
          S && N.delayNextStep(S);
          const j = N.currentTime;
          Ms(this, e.animation, t),
            (t.previousNode = e),
            (s.currentStaggerTime =
              c.currentTime - j + (c.startTime - s.currentTimeline.startTime));
        }
      }
      const lv = {};
      class ob {
        constructor(e, t, s, c, p, y, w, S) {
          (this._driver = e),
            (this.element = t),
            (this.subInstructions = s),
            (this._enterClassName = c),
            (this._leaveClassName = p),
            (this.errors = y),
            (this.timelines = w),
            (this.parentContext = null),
            (this.currentAnimateTimings = null),
            (this.previousNode = lv),
            (this.subContextCount = 0),
            (this.options = {}),
            (this.currentQueryIndex = 0),
            (this.currentQueryTotal = 0),
            (this.currentStaggerTime = 0),
            (this.currentTimeline = S || new cv(this._driver, t, 0)),
            w.push(this.currentTimeline);
        }
        get params() {
          return this.options.params;
        }
        updateOptions(e, t) {
          if (!e) return;
          const s = e;
          let c = this.options;
          null != s.duration && (c.duration = iu(s.duration)),
            null != s.delay && (c.delay = iu(s.delay));
          const p = s.params;
          if (p) {
            let y = c.params;
            y || (y = this.options.params = {}),
              Object.keys(p).forEach((w) => {
                (!t || !y.hasOwnProperty(w)) &&
                  (y[w] = Og(p[w], y, this.errors));
              });
          }
        }
        _copyOptions() {
          const e = {};
          if (this.options) {
            const t = this.options.params;
            if (t) {
              const s = (e.params = {});
              Object.keys(t).forEach((c) => {
                s[c] = t[c];
              });
            }
          }
          return e;
        }
        createSubContext(e = null, t, s) {
          const c = t || this.element,
            p = new ob(
              this._driver,
              c,
              this.subInstructions,
              this._enterClassName,
              this._leaveClassName,
              this.errors,
              this.timelines,
              this.currentTimeline.fork(c, s || 0)
            );
          return (
            (p.previousNode = this.previousNode),
            (p.currentAnimateTimings = this.currentAnimateTimings),
            (p.options = this._copyOptions()),
            p.updateOptions(e),
            (p.currentQueryIndex = this.currentQueryIndex),
            (p.currentQueryTotal = this.currentQueryTotal),
            (p.parentContext = this),
            this.subContextCount++,
            p
          );
        }
        transformIntoNewTimeline(e) {
          return (
            (this.previousNode = lv),
            (this.currentTimeline = this.currentTimeline.fork(this.element, e)),
            this.timelines.push(this.currentTimeline),
            this.currentTimeline
          );
        }
        appendInstructionToTimeline(e, t, s) {
          const c = {
              duration: t ?? e.duration,
              delay: this.currentTimeline.currentTime + (s ?? 0) + e.delay,
              easing: "",
            },
            p = new OL(
              this._driver,
              e.element,
              e.keyframes,
              e.preStyleProps,
              e.postStyleProps,
              c,
              e.stretchStartingKeyframe
            );
          return this.timelines.push(p), c;
        }
        incrementTime(e) {
          this.currentTimeline.forwardTime(this.currentTimeline.duration + e);
        }
        delayNextStep(e) {
          e > 0 && this.currentTimeline.delayNextStep(e);
        }
        invokeQuery(e, t, s, c, p, y) {
          let w = [];
          if ((c && w.push(this.element), e.length > 0)) {
            e = (e = e.replace(PL, "." + this._enterClassName)).replace(
              kL,
              "." + this._leaveClassName
            );
            let P = this._driver.query(this.element, e, 1 != s);
            0 !== s &&
              (P = s < 0 ? P.slice(P.length + s, P.length) : P.slice(0, s)),
              w.push(...P);
          }
          return (
            !p &&
              0 == w.length &&
              y.push(
                (function B2(n) {
                  return new rt(3014, !1);
                })()
              ),
            w
          );
        }
      }
      class cv {
        constructor(e, t, s, c) {
          (this._driver = e),
            (this.element = t),
            (this.startTime = s),
            (this._elementTimelineStylesLookup = c),
            (this.duration = 0),
            (this._previousKeyframe = new Map()),
            (this._currentKeyframe = new Map()),
            (this._keyframes = new Map()),
            (this._styleSummary = new Map()),
            (this._localTimelineStyles = new Map()),
            (this._pendingStyles = new Map()),
            (this._backFill = new Map()),
            (this._currentEmptyStepKeyframe = null),
            this._elementTimelineStylesLookup ||
              (this._elementTimelineStylesLookup = new Map()),
            (this._globalTimelineStyles =
              this._elementTimelineStylesLookup.get(t)),
            this._globalTimelineStyles ||
              ((this._globalTimelineStyles = this._localTimelineStyles),
              this._elementTimelineStylesLookup.set(
                t,
                this._localTimelineStyles
              )),
            this._loadKeyframe();
        }
        containsAnimation() {
          switch (this._keyframes.size) {
            case 0:
              return !1;
            case 1:
              return this.hasCurrentStyleProperties();
            default:
              return !0;
          }
        }
        hasCurrentStyleProperties() {
          return this._currentKeyframe.size > 0;
        }
        get currentTime() {
          return this.startTime + this.duration;
        }
        delayNextStep(e) {
          const t = 1 === this._keyframes.size && this._pendingStyles.size;
          this.duration || t
            ? (this.forwardTime(this.currentTime + e),
              t && this.snapshotCurrentStyles())
            : (this.startTime += e);
        }
        fork(e, t) {
          return (
            this.applyStylesToKeyframe(),
            new cv(
              this._driver,
              e,
              t || this.currentTime,
              this._elementTimelineStylesLookup
            )
          );
        }
        _loadKeyframe() {
          this._currentKeyframe &&
            (this._previousKeyframe = this._currentKeyframe),
            (this._currentKeyframe = this._keyframes.get(this.duration)),
            this._currentKeyframe ||
              ((this._currentKeyframe = new Map()),
              this._keyframes.set(this.duration, this._currentKeyframe));
        }
        forwardFrame() {
          (this.duration += 1), this._loadKeyframe();
        }
        forwardTime(e) {
          this.applyStylesToKeyframe(),
            (this.duration = e),
            this._loadKeyframe();
        }
        _updateStyle(e, t) {
          this._localTimelineStyles.set(e, t),
            this._globalTimelineStyles.set(e, t),
            this._styleSummary.set(e, { time: this.currentTime, value: t });
        }
        allowOnlyTimelineStyles() {
          return this._currentEmptyStepKeyframe !== this._currentKeyframe;
        }
        applyEmptyStep(e) {
          e && this._previousKeyframe.set("easing", e);
          for (let [t, s] of this._globalTimelineStyles)
            this._backFill.set(t, s || nu), this._currentKeyframe.set(t, nu);
          this._currentEmptyStepKeyframe = this._currentKeyframe;
        }
        setStyles(e, t, s, c) {
          t && this._previousKeyframe.set("easing", t);
          const p = (c && c.params) || {},
            y = (function FL(n, e) {
              const t = new Map();
              let s;
              return (
                n.forEach((c) => {
                  if ("*" === c) {
                    s = s || e.keys();
                    for (let p of s) t.set(p, nu);
                  } else Eh(c, t);
                }),
                t
              );
            })(e, this._globalTimelineStyles);
          for (let [w, S] of y) {
            const P = Og(S, p, s);
            this._pendingStyles.set(w, P),
              this._localTimelineStyles.has(w) ||
                this._backFill.set(w, this._globalTimelineStyles.get(w) ?? nu),
              this._updateStyle(w, P);
          }
        }
        applyStylesToKeyframe() {
          0 != this._pendingStyles.size &&
            (this._pendingStyles.forEach((e, t) => {
              this._currentKeyframe.set(t, e);
            }),
            this._pendingStyles.clear(),
            this._localTimelineStyles.forEach((e, t) => {
              this._currentKeyframe.has(t) || this._currentKeyframe.set(t, e);
            }));
        }
        snapshotCurrentStyles() {
          for (let [e, t] of this._localTimelineStyles)
            this._pendingStyles.set(e, t), this._updateStyle(e, t);
        }
        getFinalKeyframe() {
          return this._keyframes.get(this.duration);
        }
        get properties() {
          const e = [];
          for (let t in this._currentKeyframe) e.push(t);
          return e;
        }
        mergeTimelineCollectedStyles(e) {
          e._styleSummary.forEach((t, s) => {
            const c = this._styleSummary.get(s);
            (!c || t.time > c.time) && this._updateStyle(s, t.value);
          });
        }
        buildKeyframes() {
          this.applyStylesToKeyframe();
          const e = new Set(),
            t = new Set(),
            s = 1 === this._keyframes.size && 0 === this.duration;
          let c = [];
          this._keyframes.forEach((w, S) => {
            const P = Eh(w, new Map(), this._backFill);
            P.forEach((N, j) => {
              "!" === N ? e.add(j) : N === nu && t.add(j);
            }),
              s || P.set("offset", S / this.duration),
              c.push(P);
          });
          const p = e.size ? tv(e.values()) : [],
            y = t.size ? tv(t.values()) : [];
          if (s) {
            const w = c[0],
              S = new Map(w);
            w.set("offset", 0), S.set("offset", 1), (c = [w, S]);
          }
          return ib(
            this.element,
            c,
            p,
            y,
            this.duration,
            this.startTime,
            this.easing,
            !1
          );
        }
      }
      class OL extends cv {
        constructor(e, t, s, c, p, y, w = !1) {
          super(e, t, y.delay),
            (this.keyframes = s),
            (this.preStyleProps = c),
            (this.postStyleProps = p),
            (this._stretchStartingKeyframe = w),
            (this.timings = {
              duration: y.duration,
              delay: y.delay,
              easing: y.easing,
            });
        }
        containsAnimation() {
          return this.keyframes.length > 1;
        }
        buildKeyframes() {
          let e = this.keyframes,
            { delay: t, duration: s, easing: c } = this.timings;
          if (this._stretchStartingKeyframe && t) {
            const p = [],
              y = s + t,
              w = t / y,
              S = Eh(e[0]);
            S.set("offset", 0), p.push(S);
            const P = Eh(e[0]);
            P.set("offset", QT(w)), p.push(P);
            const N = e.length - 1;
            for (let j = 1; j <= N; j++) {
              let Q = Eh(e[j]);
              const ie = Q.get("offset");
              Q.set("offset", QT((t + ie * s) / y)), p.push(Q);
            }
            (s = y), (t = 0), (c = ""), (e = p);
          }
          return ib(
            this.element,
            e,
            this.preStyleProps,
            this.postStyleProps,
            s,
            t,
            c,
            !0
          );
        }
      }
      function QT(n, e = 3) {
        const t = Math.pow(10, e - 1);
        return Math.round(n * t) / t;
      }
      class sb {}
      const NL = new Set([
        "width",
        "height",
        "minWidth",
        "minHeight",
        "maxWidth",
        "maxHeight",
        "left",
        "top",
        "bottom",
        "right",
        "fontSize",
        "outlineWidth",
        "outlineOffset",
        "paddingTop",
        "paddingLeft",
        "paddingBottom",
        "paddingRight",
        "marginTop",
        "marginLeft",
        "marginBottom",
        "marginRight",
        "borderRadius",
        "borderWidth",
        "borderTopWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderBottomWidth",
        "textIndent",
        "perspective",
      ]);
      class zL extends sb {
        normalizePropertyName(e, t) {
          return eb(e);
        }
        normalizeStyleValue(e, t, s, c) {
          let p = "";
          const y = s.toString().trim();
          if (NL.has(t) && 0 !== s && "0" !== s)
            if ("number" == typeof s) p = "px";
            else {
              const w = s.match(/^[+-]?[\d\.]+([a-z]*)$/);
              w &&
                0 == w[1].length &&
                c.push(
                  (function C2(n, e) {
                    return new rt(3005, !1);
                  })()
                );
            }
          return y + p;
        }
      }
      function JT(n, e, t, s, c, p, y, w, S, P, N, j, Q) {
        return {
          type: 0,
          element: n,
          triggerName: e,
          isRemovalTransition: c,
          fromState: t,
          fromStyles: p,
          toState: s,
          toStyles: y,
          timelines: w,
          queriedElements: S,
          preStyleProps: P,
          postStyleProps: N,
          totalTime: j,
          errors: Q,
        };
      }
      const ab = {};
      class eD {
        constructor(e, t, s) {
          (this._triggerName = e), (this.ast = t), (this._stateStyles = s);
        }
        match(e, t, s, c) {
          return (function BL(n, e, t, s, c) {
            return n.some((p) => p(e, t, s, c));
          })(this.ast.matchers, e, t, s, c);
        }
        buildStyles(e, t, s) {
          let c = this._stateStyles.get("*");
          return (
            void 0 !== e && (c = this._stateStyles.get(e?.toString()) || c),
            c ? c.buildStyles(t, s) : new Map()
          );
        }
        build(e, t, s, c, p, y, w, S, P, N) {
          const j = [],
            Q = (this.ast.options && this.ast.options.params) || ab,
            pe = this.buildStyles(s, (w && w.params) || ab, j),
            Ee = (S && S.params) || ab,
            Oe = this.buildStyles(c, Ee, j),
            Ue = new Set(),
            lt = new Map(),
            ze = new Map(),
            gt = "void" === c,
            an = { params: VL(Ee, Q), delay: this.ast.options?.delay },
            Ln = N ? [] : rb(e, t, this.ast.animation, p, y, pe, Oe, an, P, j);
          let ki = 0;
          if (
            (Ln.forEach((Ps) => {
              ki = Math.max(Ps.duration + Ps.delay, ki);
            }),
            j.length)
          )
            return JT(
              t,
              this._triggerName,
              s,
              c,
              gt,
              pe,
              Oe,
              [],
              [],
              lt,
              ze,
              ki,
              j
            );
          Ln.forEach((Ps) => {
            const Ls = Ps.element,
              If = Cs(lt, Ls, new Set());
            Ps.preStyleProps.forEach((yl) => If.add(yl));
            const ru = Cs(ze, Ls, new Set());
            Ps.postStyleProps.forEach((yl) => ru.add(yl)),
              Ls !== t && Ue.add(Ls);
          });
          const As = tv(Ue.values());
          return JT(t, this._triggerName, s, c, gt, pe, Oe, Ln, As, lt, ze, ki);
        }
      }
      function VL(n, e) {
        const t = kg(e);
        for (const s in n) n.hasOwnProperty(s) && null != n[s] && (t[s] = n[s]);
        return t;
      }
      class jL {
        constructor(e, t, s) {
          (this.styles = e), (this.defaultParams = t), (this.normalizer = s);
        }
        buildStyles(e, t) {
          const s = new Map(),
            c = kg(this.defaultParams);
          return (
            Object.keys(e).forEach((p) => {
              const y = e[p];
              null !== y && (c[p] = y);
            }),
            this.styles.styles.forEach((p) => {
              "string" != typeof p &&
                p.forEach((y, w) => {
                  y && (y = Og(y, c, t));
                  const S = this.normalizer.normalizePropertyName(w, t);
                  (y = this.normalizer.normalizeStyleValue(w, S, y, t)),
                    s.set(S, y);
                });
            }),
            s
          );
        }
      }
      class $L {
        constructor(e, t, s) {
          (this.name = e),
            (this.ast = t),
            (this._normalizer = s),
            (this.transitionFactories = []),
            (this.states = new Map()),
            t.states.forEach((c) => {
              this.states.set(
                c.name,
                new jL(c.style, (c.options && c.options.params) || {}, s)
              );
            }),
            tD(this.states, "true", "1"),
            tD(this.states, "false", "0"),
            t.transitions.forEach((c) => {
              this.transitionFactories.push(new eD(e, c, this.states));
            }),
            (this.fallbackTransition = (function HL(n, e, t) {
              return new eD(
                n,
                {
                  type: 1,
                  animation: { type: 2, steps: [], options: null },
                  matchers: [(y, w) => !0],
                  options: null,
                  queryCount: 0,
                  depCount: 0,
                },
                e
              );
            })(e, this.states));
        }
        get containsQueries() {
          return this.ast.queryCount > 0;
        }
        matchTransition(e, t, s, c) {
          return (
            this.transitionFactories.find((y) => y.match(e, t, s, c)) || null
          );
        }
        matchStyles(e, t, s) {
          return this.fallbackTransition.buildStyles(e, t, s);
        }
      }
      function tD(n, e, t) {
        n.has(e)
          ? n.has(t) || n.set(t, n.get(e))
          : n.has(t) && n.set(e, n.get(t));
      }
      const GL = new av();
      class qL {
        constructor(e, t, s) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = s),
            (this._animations = new Map()),
            (this._playersById = new Map()),
            (this.players = []);
        }
        register(e, t) {
          const s = [],
            p = tb(this._driver, t, s, []);
          if (s.length)
            throw (function q2(n) {
              return new rt(3503, !1);
            })();
          this._animations.set(e, p);
        }
        _buildPlayer(e, t, s) {
          const c = e.element,
            p = kT(0, this._normalizer, 0, e.keyframes, t, s);
          return this._driver.animate(
            c,
            p,
            e.duration,
            e.delay,
            e.easing,
            [],
            !0
          );
        }
        create(e, t, s = {}) {
          const c = [],
            p = this._animations.get(e);
          let y;
          const w = new Map();
          if (
            (p
              ? ((y = rb(
                  this._driver,
                  t,
                  p,
                  Kx,
                  Yy,
                  new Map(),
                  new Map(),
                  s,
                  GL,
                  c
                )),
                y.forEach((N) => {
                  const j = Cs(w, N.element, new Map());
                  N.postStyleProps.forEach((Q) => j.set(Q, null));
                }))
              : (c.push(
                  (function W2() {
                    return new rt(3300, !1);
                  })()
                ),
                (y = [])),
            c.length)
          )
            throw (function Z2(n) {
              return new rt(3504, !1);
            })();
          w.forEach((N, j) => {
            N.forEach((Q, ie) => {
              N.set(ie, this._driver.computeStyle(j, ie, nu));
            });
          });
          const P = wh(
            y.map((N) => {
              const j = w.get(N.element);
              return this._buildPlayer(N, new Map(), j);
            })
          );
          return (
            this._playersById.set(e, P),
            P.onDestroy(() => this.destroy(e)),
            this.players.push(P),
            P
          );
        }
        destroy(e) {
          const t = this._getPlayer(e);
          t.destroy(), this._playersById.delete(e);
          const s = this.players.indexOf(t);
          s >= 0 && this.players.splice(s, 1);
        }
        _getPlayer(e) {
          const t = this._playersById.get(e);
          if (!t)
            throw (function X2(n) {
              return new rt(3301, !1);
            })();
          return t;
        }
        listen(e, t, s, c) {
          const p = qx(t, "", "", "");
          return Hx(this._getPlayer(e), s, p, c), () => {};
        }
        command(e, t, s, c) {
          if ("register" == s) return void this.register(e, c[0]);
          if ("create" == s) return void this.create(e, t, c[0] || {});
          const p = this._getPlayer(e);
          switch (s) {
            case "play":
              p.play();
              break;
            case "pause":
              p.pause();
              break;
            case "reset":
              p.reset();
              break;
            case "restart":
              p.restart();
              break;
            case "finish":
              p.finish();
              break;
            case "init":
              p.init();
              break;
            case "setPosition":
              p.setPosition(parseFloat(c[0]));
              break;
            case "destroy":
              this.destroy(e);
          }
        }
      }
      const nD = "ng-animate-queued",
        lb = "ng-animate-disabled",
        YL = [],
        iD = {
          namespaceId: "",
          setForRemoval: !1,
          setForMove: !1,
          hasAnimation: !1,
          removedBeforeQueried: !1,
        },
        QL = {
          namespaceId: "",
          setForMove: !1,
          setForRemoval: !1,
          hasAnimation: !1,
          removedBeforeQueried: !0,
        },
        Ea = "__ng_removed";
      class cb {
        constructor(e, t = "") {
          this.namespaceId = t;
          const s = e && e.hasOwnProperty("value");
          if (
            ((this.value = (function nk(n) {
              return n ?? null;
            })(s ? e.value : e)),
            s)
          ) {
            const p = kg(e);
            delete p.value, (this.options = p);
          } else this.options = {};
          this.options.params || (this.options.params = {});
        }
        get params() {
          return this.options.params;
        }
        absorbOptions(e) {
          const t = e.params;
          if (t) {
            const s = this.options.params;
            Object.keys(t).forEach((c) => {
              null == s[c] && (s[c] = t[c]);
            });
          }
        }
      }
      const Fg = "void",
        ub = new cb(Fg);
      class JL {
        constructor(e, t, s) {
          (this.id = e),
            (this.hostElement = t),
            (this._engine = s),
            (this.players = []),
            (this._triggers = new Map()),
            (this._queue = []),
            (this._elementListeners = new Map()),
            (this._hostClassName = "ng-tns-" + e),
            Ta(t, this._hostClassName);
        }
        listen(e, t, s, c) {
          if (!this._triggers.has(t))
            throw (function K2(n, e) {
              return new rt(3302, !1);
            })();
          if (null == s || 0 == s.length)
            throw (function Y2(n) {
              return new rt(3303, !1);
            })();
          if (
            !(function ik(n) {
              return "start" == n || "done" == n;
            })(s)
          )
            throw (function Q2(n, e) {
              return new rt(3400, !1);
            })();
          const p = Cs(this._elementListeners, e, []),
            y = { name: t, phase: s, callback: c };
          p.push(y);
          const w = Cs(this._engine.statesByElement, e, new Map());
          return (
            w.has(t) || (Ta(e, Qy), Ta(e, Qy + "-" + t), w.set(t, ub)),
            () => {
              this._engine.afterFlush(() => {
                const S = p.indexOf(y);
                S >= 0 && p.splice(S, 1), this._triggers.has(t) || w.delete(t);
              });
            }
          );
        }
        register(e, t) {
          return !this._triggers.has(e) && (this._triggers.set(e, t), !0);
        }
        _getTrigger(e) {
          const t = this._triggers.get(e);
          if (!t)
            throw (function J2(n) {
              return new rt(3401, !1);
            })();
          return t;
        }
        trigger(e, t, s, c = !0) {
          const p = this._getTrigger(t),
            y = new hb(this.id, t, e);
          let w = this._engine.statesByElement.get(e);
          w ||
            (Ta(e, Qy),
            Ta(e, Qy + "-" + t),
            this._engine.statesByElement.set(e, (w = new Map())));
          let S = w.get(t);
          const P = new cb(s, this.id);
          if (
            (!(s && s.hasOwnProperty("value")) &&
              S &&
              P.absorbOptions(S.options),
            w.set(t, P),
            S || (S = ub),
            P.value !== Fg && S.value === P.value)
          ) {
            if (
              !(function sk(n, e) {
                const t = Object.keys(n),
                  s = Object.keys(e);
                if (t.length != s.length) return !1;
                for (let c = 0; c < t.length; c++) {
                  const p = t[c];
                  if (!e.hasOwnProperty(p) || n[p] !== e[p]) return !1;
                }
                return !0;
              })(S.params, P.params)
            ) {
              const Ee = [],
                Oe = p.matchStyles(S.value, S.params, Ee),
                Ue = p.matchStyles(P.value, P.params, Ee);
              Ee.length
                ? this._engine.reportError(Ee)
                : this._engine.afterFlush(() => {
                    tp(e, Oe), ic(e, Ue);
                  });
            }
            return;
          }
          const Q = Cs(this._engine.playersByElement, e, []);
          Q.forEach((Ee) => {
            Ee.namespaceId == this.id &&
              Ee.triggerName == t &&
              Ee.queued &&
              Ee.destroy();
          });
          let ie = p.matchTransition(S.value, P.value, e, P.params),
            pe = !1;
          if (!ie) {
            if (!c) return;
            (ie = p.fallbackTransition), (pe = !0);
          }
          return (
            this._engine.totalQueuedPlayers++,
            this._queue.push({
              element: e,
              triggerName: t,
              transition: ie,
              fromState: S,
              toState: P,
              player: y,
              isFallbackTransition: pe,
            }),
            pe ||
              (Ta(e, nD),
              y.onStart(() => {
                Sf(e, nD);
              })),
            y.onDone(() => {
              let Ee = this.players.indexOf(y);
              Ee >= 0 && this.players.splice(Ee, 1);
              const Oe = this._engine.playersByElement.get(e);
              if (Oe) {
                let Ue = Oe.indexOf(y);
                Ue >= 0 && Oe.splice(Ue, 1);
              }
            }),
            this.players.push(y),
            Q.push(y),
            y
          );
        }
        deregister(e) {
          this._triggers.delete(e),
            this._engine.statesByElement.forEach((t) => t.delete(e)),
            this._elementListeners.forEach((t, s) => {
              this._elementListeners.set(
                s,
                t.filter((c) => c.name != e)
              );
            });
        }
        clearElementCache(e) {
          this._engine.statesByElement.delete(e),
            this._elementListeners.delete(e);
          const t = this._engine.playersByElement.get(e);
          t &&
            (t.forEach((s) => s.destroy()),
            this._engine.playersByElement.delete(e));
        }
        _signalRemovalForInnerTriggers(e, t) {
          const s = this._engine.driver.query(e, Jy, !0);
          s.forEach((c) => {
            if (c[Ea]) return;
            const p = this._engine.fetchNamespacesByElement(c);
            p.size
              ? p.forEach((y) => y.triggerLeaveAnimation(c, t, !1, !0))
              : this.clearElementCache(c);
          }),
            this._engine.afterFlushAnimationsDone(() =>
              s.forEach((c) => this.clearElementCache(c))
            );
        }
        triggerLeaveAnimation(e, t, s, c) {
          const p = this._engine.statesByElement.get(e),
            y = new Map();
          if (p) {
            const w = [];
            if (
              (p.forEach((S, P) => {
                if ((y.set(P, S.value), this._triggers.has(P))) {
                  const N = this.trigger(e, P, Fg, c);
                  N && w.push(N);
                }
              }),
              w.length)
            )
              return (
                this._engine.markElementAsRemoved(this.id, e, !0, t, y),
                s && wh(w).onDone(() => this._engine.processLeaveNode(e)),
                !0
              );
          }
          return !1;
        }
        prepareLeaveAnimationListeners(e) {
          const t = this._elementListeners.get(e),
            s = this._engine.statesByElement.get(e);
          if (t && s) {
            const c = new Set();
            t.forEach((p) => {
              const y = p.name;
              if (c.has(y)) return;
              c.add(y);
              const S = this._triggers.get(y).fallbackTransition,
                P = s.get(y) || ub,
                N = new cb(Fg),
                j = new hb(this.id, y, e);
              this._engine.totalQueuedPlayers++,
                this._queue.push({
                  element: e,
                  triggerName: y,
                  transition: S,
                  fromState: P,
                  toState: N,
                  player: j,
                  isFallbackTransition: !0,
                });
            });
          }
        }
        removeNode(e, t) {
          const s = this._engine;
          if (
            (e.childElementCount && this._signalRemovalForInnerTriggers(e, t),
            this.triggerLeaveAnimation(e, t, !0))
          )
            return;
          let c = !1;
          if (s.totalAnimations) {
            const p = s.players.length ? s.playersByQueriedElement.get(e) : [];
            if (p && p.length) c = !0;
            else {
              let y = e;
              for (; (y = y.parentNode); )
                if (s.statesByElement.get(y)) {
                  c = !0;
                  break;
                }
            }
          }
          if ((this.prepareLeaveAnimationListeners(e), c))
            s.markElementAsRemoved(this.id, e, !1, t);
          else {
            const p = e[Ea];
            (!p || p === iD) &&
              (s.afterFlush(() => this.clearElementCache(e)),
              s.destroyInnerAnimations(e),
              s._onRemovalComplete(e, t));
          }
        }
        insertNode(e, t) {
          Ta(e, this._hostClassName);
        }
        drainQueuedTransitions(e) {
          const t = [];
          return (
            this._queue.forEach((s) => {
              const c = s.player;
              if (c.destroyed) return;
              const p = s.element,
                y = this._elementListeners.get(p);
              y &&
                y.forEach((w) => {
                  if (w.name == s.triggerName) {
                    const S = qx(
                      p,
                      s.triggerName,
                      s.fromState.value,
                      s.toState.value
                    );
                    (S._data = e), Hx(s.player, w.phase, S, w.callback);
                  }
                }),
                c.markedForDestroy
                  ? this._engine.afterFlush(() => {
                      c.destroy();
                    })
                  : t.push(s);
            }),
            (this._queue = []),
            t.sort((s, c) => {
              const p = s.transition.ast.depCount,
                y = c.transition.ast.depCount;
              return 0 == p || 0 == y
                ? p - y
                : this._engine.driver.containsElement(s.element, c.element)
                ? 1
                : -1;
            })
          );
        }
        destroy(e) {
          this.players.forEach((t) => t.destroy()),
            this._signalRemovalForInnerTriggers(this.hostElement, e);
        }
        elementContainsData(e) {
          let t = !1;
          return (
            this._elementListeners.has(e) && (t = !0),
            (t = !!this._queue.find((s) => s.element === e) || t),
            t
          );
        }
      }
      class ek {
        constructor(e, t, s) {
          (this.bodyNode = e),
            (this.driver = t),
            (this._normalizer = s),
            (this.players = []),
            (this.newHostElements = new Map()),
            (this.playersByElement = new Map()),
            (this.playersByQueriedElement = new Map()),
            (this.statesByElement = new Map()),
            (this.disabledNodes = new Set()),
            (this.totalAnimations = 0),
            (this.totalQueuedPlayers = 0),
            (this._namespaceLookup = {}),
            (this._namespaceList = []),
            (this._flushFns = []),
            (this._whenQuietFns = []),
            (this.namespacesByHostElement = new Map()),
            (this.collectedEnterElements = []),
            (this.collectedLeaveElements = []),
            (this.onRemovalComplete = (c, p) => {});
        }
        _onRemovalComplete(e, t) {
          this.onRemovalComplete(e, t);
        }
        get queuedPlayers() {
          const e = [];
          return (
            this._namespaceList.forEach((t) => {
              t.players.forEach((s) => {
                s.queued && e.push(s);
              });
            }),
            e
          );
        }
        createNamespace(e, t) {
          const s = new JL(e, t, this);
          return (
            this.bodyNode && this.driver.containsElement(this.bodyNode, t)
              ? this._balanceNamespaceList(s, t)
              : (this.newHostElements.set(t, s), this.collectEnterElement(t)),
            (this._namespaceLookup[e] = s)
          );
        }
        _balanceNamespaceList(e, t) {
          const s = this._namespaceList,
            c = this.namespacesByHostElement;
          if (s.length - 1 >= 0) {
            let y = !1,
              w = this.driver.getParentElement(t);
            for (; w; ) {
              const S = c.get(w);
              if (S) {
                const P = s.indexOf(S);
                s.splice(P + 1, 0, e), (y = !0);
                break;
              }
              w = this.driver.getParentElement(w);
            }
            y || s.unshift(e);
          } else s.push(e);
          return c.set(t, e), e;
        }
        register(e, t) {
          let s = this._namespaceLookup[e];
          return s || (s = this.createNamespace(e, t)), s;
        }
        registerTrigger(e, t, s) {
          let c = this._namespaceLookup[e];
          c && c.register(t, s) && this.totalAnimations++;
        }
        destroy(e, t) {
          if (!e) return;
          const s = this._fetchNamespace(e);
          this.afterFlush(() => {
            this.namespacesByHostElement.delete(s.hostElement),
              delete this._namespaceLookup[e];
            const c = this._namespaceList.indexOf(s);
            c >= 0 && this._namespaceList.splice(c, 1);
          }),
            this.afterFlushAnimationsDone(() => s.destroy(t));
        }
        _fetchNamespace(e) {
          return this._namespaceLookup[e];
        }
        fetchNamespacesByElement(e) {
          const t = new Set(),
            s = this.statesByElement.get(e);
          if (s)
            for (let c of s.values())
              if (c.namespaceId) {
                const p = this._fetchNamespace(c.namespaceId);
                p && t.add(p);
              }
          return t;
        }
        trigger(e, t, s, c) {
          if (uv(t)) {
            const p = this._fetchNamespace(e);
            if (p) return p.trigger(t, s, c), !0;
          }
          return !1;
        }
        insertNode(e, t, s, c) {
          if (!uv(t)) return;
          const p = t[Ea];
          if (p && p.setForRemoval) {
            (p.setForRemoval = !1), (p.setForMove = !0);
            const y = this.collectedLeaveElements.indexOf(t);
            y >= 0 && this.collectedLeaveElements.splice(y, 1);
          }
          if (e) {
            const y = this._fetchNamespace(e);
            y && y.insertNode(t, s);
          }
          c && this.collectEnterElement(t);
        }
        collectEnterElement(e) {
          this.collectedEnterElements.push(e);
        }
        markElementAsDisabled(e, t) {
          t
            ? this.disabledNodes.has(e) ||
              (this.disabledNodes.add(e), Ta(e, lb))
            : this.disabledNodes.has(e) &&
              (this.disabledNodes.delete(e), Sf(e, lb));
        }
        removeNode(e, t, s, c) {
          if (uv(t)) {
            const p = e ? this._fetchNamespace(e) : null;
            if (
              (p ? p.removeNode(t, c) : this.markElementAsRemoved(e, t, !1, c),
              s)
            ) {
              const y = this.namespacesByHostElement.get(t);
              y && y.id !== e && y.removeNode(t, c);
            }
          } else this._onRemovalComplete(t, c);
        }
        markElementAsRemoved(e, t, s, c, p) {
          this.collectedLeaveElements.push(t),
            (t[Ea] = {
              namespaceId: e,
              setForRemoval: c,
              hasAnimation: s,
              removedBeforeQueried: !1,
              previousTriggersValues: p,
            });
        }
        listen(e, t, s, c, p) {
          return uv(t) ? this._fetchNamespace(e).listen(t, s, c, p) : () => {};
        }
        _buildInstruction(e, t, s, c, p) {
          return e.transition.build(
            this.driver,
            e.element,
            e.fromState.value,
            e.toState.value,
            s,
            c,
            e.fromState.options,
            e.toState.options,
            t,
            p
          );
        }
        destroyInnerAnimations(e) {
          let t = this.driver.query(e, Jy, !0);
          t.forEach((s) => this.destroyActiveAnimationsForElement(s)),
            0 != this.playersByQueriedElement.size &&
              ((t = this.driver.query(e, Yx, !0)),
              t.forEach((s) => this.finishActiveQueriedAnimationOnElement(s)));
        }
        destroyActiveAnimationsForElement(e) {
          const t = this.playersByElement.get(e);
          t &&
            t.forEach((s) => {
              s.queued ? (s.markedForDestroy = !0) : s.destroy();
            });
        }
        finishActiveQueriedAnimationOnElement(e) {
          const t = this.playersByQueriedElement.get(e);
          t && t.forEach((s) => s.finish());
        }
        whenRenderingDone() {
          return new Promise((e) => {
            if (this.players.length) return wh(this.players).onDone(() => e());
            e();
          });
        }
        processLeaveNode(e) {
          const t = e[Ea];
          if (t && t.setForRemoval) {
            if (((e[Ea] = iD), t.namespaceId)) {
              this.destroyInnerAnimations(e);
              const s = this._fetchNamespace(t.namespaceId);
              s && s.clearElementCache(e);
            }
            this._onRemovalComplete(e, t.setForRemoval);
          }
          e.classList?.contains(lb) && this.markElementAsDisabled(e, !1),
            this.driver.query(e, ".ng-animate-disabled", !0).forEach((s) => {
              this.markElementAsDisabled(s, !1);
            });
        }
        flush(e = -1) {
          let t = [];
          if (
            (this.newHostElements.size &&
              (this.newHostElements.forEach((s, c) =>
                this._balanceNamespaceList(s, c)
              ),
              this.newHostElements.clear()),
            this.totalAnimations && this.collectedEnterElements.length)
          )
            for (let s = 0; s < this.collectedEnterElements.length; s++)
              Ta(this.collectedEnterElements[s], "ng-star-inserted");
          if (
            this._namespaceList.length &&
            (this.totalQueuedPlayers || this.collectedLeaveElements.length)
          ) {
            const s = [];
            try {
              t = this._flushAnimations(s, e);
            } finally {
              for (let c = 0; c < s.length; c++) s[c]();
            }
          } else
            for (let s = 0; s < this.collectedLeaveElements.length; s++)
              this.processLeaveNode(this.collectedLeaveElements[s]);
          if (
            ((this.totalQueuedPlayers = 0),
            (this.collectedEnterElements.length = 0),
            (this.collectedLeaveElements.length = 0),
            this._flushFns.forEach((s) => s()),
            (this._flushFns = []),
            this._whenQuietFns.length)
          ) {
            const s = this._whenQuietFns;
            (this._whenQuietFns = []),
              t.length
                ? wh(t).onDone(() => {
                    s.forEach((c) => c());
                  })
                : s.forEach((c) => c());
          }
        }
        reportError(e) {
          throw (function eL(n) {
            return new rt(3402, !1);
          })();
        }
        _flushAnimations(e, t) {
          const s = new av(),
            c = [],
            p = new Map(),
            y = [],
            w = new Map(),
            S = new Map(),
            P = new Map(),
            N = new Set();
          this.disabledNodes.forEach((bt) => {
            N.add(bt);
            const kt = this.driver.query(bt, ".ng-animate-queued", !0);
            for (let Ht = 0; Ht < kt.length; Ht++) N.add(kt[Ht]);
          });
          const j = this.bodyNode,
            Q = Array.from(this.statesByElement.keys()),
            ie = sD(Q, this.collectedEnterElements),
            pe = new Map();
          let Ee = 0;
          ie.forEach((bt, kt) => {
            const Ht = Kx + Ee++;
            pe.set(kt, Ht), bt.forEach((Vn) => Ta(Vn, Ht));
          });
          const Oe = [],
            Ue = new Set(),
            lt = new Set();
          for (let bt = 0; bt < this.collectedLeaveElements.length; bt++) {
            const kt = this.collectedLeaveElements[bt],
              Ht = kt[Ea];
            Ht &&
              Ht.setForRemoval &&
              (Oe.push(kt),
              Ue.add(kt),
              Ht.hasAnimation
                ? this.driver
                    .query(kt, ".ng-star-inserted", !0)
                    .forEach((Vn) => Ue.add(Vn))
                : lt.add(kt));
          }
          const ze = new Map(),
            gt = sD(Q, Array.from(Ue));
          gt.forEach((bt, kt) => {
            const Ht = Yy + Ee++;
            ze.set(kt, Ht), bt.forEach((Vn) => Ta(Vn, Ht));
          }),
            e.push(() => {
              ie.forEach((bt, kt) => {
                const Ht = pe.get(kt);
                bt.forEach((Vn) => Sf(Vn, Ht));
              }),
                gt.forEach((bt, kt) => {
                  const Ht = ze.get(kt);
                  bt.forEach((Vn) => Sf(Vn, Ht));
                }),
                Oe.forEach((bt) => {
                  this.processLeaveNode(bt);
                });
            });
          const an = [],
            Ln = [];
          for (let bt = this._namespaceList.length - 1; bt >= 0; bt--)
            this._namespaceList[bt].drainQueuedTransitions(t).forEach((Ht) => {
              const Vn = Ht.player,
                Br = Ht.element;
              if ((an.push(Vn), this.collectedEnterElements.length)) {
                const fo = Br[Ea];
                if (fo && fo.setForMove) {
                  if (
                    fo.previousTriggersValues &&
                    fo.previousTriggersValues.has(Ht.triggerName)
                  ) {
                    const ip = fo.previousTriggersValues.get(Ht.triggerName),
                      Da = this.statesByElement.get(Ht.element);
                    if (Da && Da.has(Ht.triggerName)) {
                      const pv = Da.get(Ht.triggerName);
                      (pv.value = ip), Da.set(Ht.triggerName, pv);
                    }
                  }
                  return void Vn.destroy();
                }
              }
              const rc = !j || !this.driver.containsElement(j, Br),
                ks = ze.get(Br),
                Th = pe.get(Br),
                Ri = this._buildInstruction(Ht, s, Th, ks, rc);
              if (Ri.errors && Ri.errors.length) return void Ln.push(Ri);
              if (rc)
                return (
                  Vn.onStart(() => tp(Br, Ri.fromStyles)),
                  Vn.onDestroy(() => ic(Br, Ri.toStyles)),
                  void c.push(Vn)
                );
              if (Ht.isFallbackTransition)
                return (
                  Vn.onStart(() => tp(Br, Ri.fromStyles)),
                  Vn.onDestroy(() => ic(Br, Ri.toStyles)),
                  void c.push(Vn)
                );
              const mD = [];
              Ri.timelines.forEach((fo) => {
                (fo.stretchStartingKeyframe = !0),
                  this.disabledNodes.has(fo.element) || mD.push(fo);
              }),
                (Ri.timelines = mD),
                s.append(Br, Ri.timelines),
                y.push({ instruction: Ri, player: Vn, element: Br }),
                Ri.queriedElements.forEach((fo) => Cs(w, fo, []).push(Vn)),
                Ri.preStyleProps.forEach((fo, ip) => {
                  if (fo.size) {
                    let Da = S.get(ip);
                    Da || S.set(ip, (Da = new Set())),
                      fo.forEach((pv, fb) => Da.add(fb));
                  }
                }),
                Ri.postStyleProps.forEach((fo, ip) => {
                  let Da = P.get(ip);
                  Da || P.set(ip, (Da = new Set())),
                    fo.forEach((pv, fb) => Da.add(fb));
                });
            });
          if (Ln.length) {
            const bt = [];
            Ln.forEach((kt) => {
              bt.push(
                (function tL(n, e) {
                  return new rt(3505, !1);
                })()
              );
            }),
              an.forEach((kt) => kt.destroy()),
              this.reportError(bt);
          }
          const ki = new Map(),
            As = new Map();
          y.forEach((bt) => {
            const kt = bt.element;
            s.has(kt) &&
              (As.set(kt, kt),
              this._beforeAnimationBuild(
                bt.player.namespaceId,
                bt.instruction,
                ki
              ));
          }),
            c.forEach((bt) => {
              const kt = bt.element;
              this._getPreviousPlayers(
                kt,
                !1,
                bt.namespaceId,
                bt.triggerName,
                null
              ).forEach((Vn) => {
                Cs(ki, kt, []).push(Vn), Vn.destroy();
              });
            });
          const Ps = Oe.filter((bt) => lD(bt, S, P)),
            Ls = new Map();
          oD(Ls, this.driver, lt, P, nu).forEach((bt) => {
            lD(bt, S, P) && Ps.push(bt);
          });
          const ru = new Map();
          ie.forEach((bt, kt) => {
            oD(ru, this.driver, new Set(bt), S, "!");
          }),
            Ps.forEach((bt) => {
              const kt = Ls.get(bt),
                Ht = ru.get(bt);
              Ls.set(
                bt,
                new Map([
                  ...Array.from(kt?.entries() ?? []),
                  ...Array.from(Ht?.entries() ?? []),
                ])
              );
            });
          const yl = [],
            Cf = [],
            Mf = {};
          y.forEach((bt) => {
            const { element: kt, player: Ht, instruction: Vn } = bt;
            if (s.has(kt)) {
              if (N.has(kt))
                return (
                  Ht.onDestroy(() => ic(kt, Vn.toStyles)),
                  (Ht.disabled = !0),
                  Ht.overrideTotalTime(Vn.totalTime),
                  void c.push(Ht)
                );
              let Br = Mf;
              if (As.size > 1) {
                let ks = kt;
                const Th = [];
                for (; (ks = ks.parentNode); ) {
                  const Ri = As.get(ks);
                  if (Ri) {
                    Br = Ri;
                    break;
                  }
                  Th.push(ks);
                }
                Th.forEach((Ri) => As.set(Ri, Br));
              }
              const rc = this._buildAnimation(
                Ht.namespaceId,
                Vn,
                ki,
                p,
                ru,
                Ls
              );
              if ((Ht.setRealPlayer(rc), Br === Mf)) yl.push(Ht);
              else {
                const ks = this.playersByElement.get(Br);
                ks && ks.length && (Ht.parentPlayer = wh(ks)), c.push(Ht);
              }
            } else
              tp(kt, Vn.fromStyles),
                Ht.onDestroy(() => ic(kt, Vn.toStyles)),
                Cf.push(Ht),
                N.has(kt) && c.push(Ht);
          }),
            Cf.forEach((bt) => {
              const kt = p.get(bt.element);
              if (kt && kt.length) {
                const Ht = wh(kt);
                bt.setRealPlayer(Ht);
              }
            }),
            c.forEach((bt) => {
              bt.parentPlayer
                ? bt.syncPlayerEvents(bt.parentPlayer)
                : bt.destroy();
            });
          for (let bt = 0; bt < Oe.length; bt++) {
            const kt = Oe[bt],
              Ht = kt[Ea];
            if ((Sf(kt, Yy), Ht && Ht.hasAnimation)) continue;
            let Vn = [];
            if (w.size) {
              let rc = w.get(kt);
              rc && rc.length && Vn.push(...rc);
              let ks = this.driver.query(kt, Yx, !0);
              for (let Th = 0; Th < ks.length; Th++) {
                let Ri = w.get(ks[Th]);
                Ri && Ri.length && Vn.push(...Ri);
              }
            }
            const Br = Vn.filter((rc) => !rc.destroyed);
            Br.length ? rk(this, kt, Br) : this.processLeaveNode(kt);
          }
          return (
            (Oe.length = 0),
            yl.forEach((bt) => {
              this.players.push(bt),
                bt.onDone(() => {
                  bt.destroy();
                  const kt = this.players.indexOf(bt);
                  this.players.splice(kt, 1);
                }),
                bt.play();
            }),
            yl
          );
        }
        elementContainsData(e, t) {
          let s = !1;
          const c = t[Ea];
          return (
            c && c.setForRemoval && (s = !0),
            this.playersByElement.has(t) && (s = !0),
            this.playersByQueriedElement.has(t) && (s = !0),
            this.statesByElement.has(t) && (s = !0),
            this._fetchNamespace(e).elementContainsData(t) || s
          );
        }
        afterFlush(e) {
          this._flushFns.push(e);
        }
        afterFlushAnimationsDone(e) {
          this._whenQuietFns.push(e);
        }
        _getPreviousPlayers(e, t, s, c, p) {
          let y = [];
          if (t) {
            const w = this.playersByQueriedElement.get(e);
            w && (y = w);
          } else {
            const w = this.playersByElement.get(e);
            if (w) {
              const S = !p || p == Fg;
              w.forEach((P) => {
                P.queued || (!S && P.triggerName != c) || y.push(P);
              });
            }
          }
          return (
            (s || c) &&
              (y = y.filter(
                (w) => !((s && s != w.namespaceId) || (c && c != w.triggerName))
              )),
            y
          );
        }
        _beforeAnimationBuild(e, t, s) {
          const p = t.element,
            y = t.isRemovalTransition ? void 0 : e,
            w = t.isRemovalTransition ? void 0 : t.triggerName;
          for (const S of t.timelines) {
            const P = S.element,
              N = P !== p,
              j = Cs(s, P, []);
            this._getPreviousPlayers(P, N, y, w, t.toState).forEach((ie) => {
              const pe = ie.getRealPlayer();
              pe.beforeDestroy && pe.beforeDestroy(), ie.destroy(), j.push(ie);
            });
          }
          tp(p, t.fromStyles);
        }
        _buildAnimation(e, t, s, c, p, y) {
          const w = t.triggerName,
            S = t.element,
            P = [],
            N = new Set(),
            j = new Set(),
            Q = t.timelines.map((pe) => {
              const Ee = pe.element;
              N.add(Ee);
              const Oe = Ee[Ea];
              if (Oe && Oe.removedBeforeQueried)
                return new Lg(pe.duration, pe.delay);
              const Ue = Ee !== S,
                lt = (function ok(n) {
                  const e = [];
                  return aD(n, e), e;
                })((s.get(Ee) || YL).map((ki) => ki.getRealPlayer())).filter(
                  (ki) => !!ki.element && ki.element === Ee
                ),
                ze = p.get(Ee),
                gt = y.get(Ee),
                an = kT(0, this._normalizer, 0, pe.keyframes, ze, gt),
                Ln = this._buildPlayer(pe, an, lt);
              if ((pe.subTimeline && c && j.add(Ee), Ue)) {
                const ki = new hb(e, w, Ee);
                ki.setRealPlayer(Ln), P.push(ki);
              }
              return Ln;
            });
          P.forEach((pe) => {
            Cs(this.playersByQueriedElement, pe.element, []).push(pe),
              pe.onDone(() =>
                (function tk(n, e, t) {
                  let s = n.get(e);
                  if (s) {
                    if (s.length) {
                      const c = s.indexOf(t);
                      s.splice(c, 1);
                    }
                    0 == s.length && n.delete(e);
                  }
                  return s;
                })(this.playersByQueriedElement, pe.element, pe)
              );
          }),
            N.forEach((pe) => Ta(pe, UT));
          const ie = wh(Q);
          return (
            ie.onDestroy(() => {
              N.forEach((pe) => Sf(pe, UT)), ic(S, t.toStyles);
            }),
            j.forEach((pe) => {
              Cs(c, pe, []).push(ie);
            }),
            ie
          );
        }
        _buildPlayer(e, t, s) {
          return t.length > 0
            ? this.driver.animate(
                e.element,
                t,
                e.duration,
                e.delay,
                e.easing,
                s
              )
            : new Lg(e.duration, e.delay);
        }
      }
      class hb {
        constructor(e, t, s) {
          (this.namespaceId = e),
            (this.triggerName = t),
            (this.element = s),
            (this._player = new Lg()),
            (this._containsRealPlayer = !1),
            (this._queuedCallbacks = new Map()),
            (this.destroyed = !1),
            (this.markedForDestroy = !1),
            (this.disabled = !1),
            (this.queued = !0),
            (this.totalTime = 0);
        }
        setRealPlayer(e) {
          this._containsRealPlayer ||
            ((this._player = e),
            this._queuedCallbacks.forEach((t, s) => {
              t.forEach((c) => Hx(e, s, void 0, c));
            }),
            this._queuedCallbacks.clear(),
            (this._containsRealPlayer = !0),
            this.overrideTotalTime(e.totalTime),
            (this.queued = !1));
        }
        getRealPlayer() {
          return this._player;
        }
        overrideTotalTime(e) {
          this.totalTime = e;
        }
        syncPlayerEvents(e) {
          const t = this._player;
          t.triggerCallback && e.onStart(() => t.triggerCallback("start")),
            e.onDone(() => this.finish()),
            e.onDestroy(() => this.destroy());
        }
        _queueEvent(e, t) {
          Cs(this._queuedCallbacks, e, []).push(t);
        }
        onDone(e) {
          this.queued && this._queueEvent("done", e), this._player.onDone(e);
        }
        onStart(e) {
          this.queued && this._queueEvent("start", e), this._player.onStart(e);
        }
        onDestroy(e) {
          this.queued && this._queueEvent("destroy", e),
            this._player.onDestroy(e);
        }
        init() {
          this._player.init();
        }
        hasStarted() {
          return !this.queued && this._player.hasStarted();
        }
        play() {
          !this.queued && this._player.play();
        }
        pause() {
          !this.queued && this._player.pause();
        }
        restart() {
          !this.queued && this._player.restart();
        }
        finish() {
          this._player.finish();
        }
        destroy() {
          (this.destroyed = !0), this._player.destroy();
        }
        reset() {
          !this.queued && this._player.reset();
        }
        setPosition(e) {
          this.queued || this._player.setPosition(e);
        }
        getPosition() {
          return this.queued ? 0 : this._player.getPosition();
        }
        triggerCallback(e) {
          const t = this._player;
          t.triggerCallback && t.triggerCallback(e);
        }
      }
      function uv(n) {
        return n && 1 === n.nodeType;
      }
      function rD(n, e) {
        const t = n.style.display;
        return (n.style.display = e ?? "none"), t;
      }
      function oD(n, e, t, s, c) {
        const p = [];
        t.forEach((S) => p.push(rD(S)));
        const y = [];
        s.forEach((S, P) => {
          const N = new Map();
          S.forEach((j) => {
            const Q = e.computeStyle(P, j, c);
            N.set(j, Q), (!Q || 0 == Q.length) && ((P[Ea] = QL), y.push(P));
          }),
            n.set(P, N);
        });
        let w = 0;
        return t.forEach((S) => rD(S, p[w++])), y;
      }
      function sD(n, e) {
        const t = new Map();
        if ((n.forEach((w) => t.set(w, [])), 0 == e.length)) return t;
        const c = new Set(e),
          p = new Map();
        function y(w) {
          if (!w) return 1;
          let S = p.get(w);
          if (S) return S;
          const P = w.parentNode;
          return (S = t.has(P) ? P : c.has(P) ? 1 : y(P)), p.set(w, S), S;
        }
        return (
          e.forEach((w) => {
            const S = y(w);
            1 !== S && t.get(S).push(w);
          }),
          t
        );
      }
      function Ta(n, e) {
        n.classList?.add(e);
      }
      function Sf(n, e) {
        n.classList?.remove(e);
      }
      function rk(n, e, t) {
        wh(t).onDone(() => n.processLeaveNode(e));
      }
      function aD(n, e) {
        for (let t = 0; t < n.length; t++) {
          const s = n[t];
          s instanceof PT ? aD(s.players, e) : e.push(s);
        }
      }
      function lD(n, e, t) {
        const s = t.get(n);
        if (!s) return !1;
        let c = e.get(n);
        return c ? s.forEach((p) => c.add(p)) : e.set(n, s), t.delete(n), !0;
      }
      class hv {
        constructor(e, t, s) {
          (this.bodyNode = e),
            (this._driver = t),
            (this._normalizer = s),
            (this._triggerCache = {}),
            (this.onRemovalComplete = (c, p) => {}),
            (this._transitionEngine = new ek(e, t, s)),
            (this._timelineEngine = new qL(e, t, s)),
            (this._transitionEngine.onRemovalComplete = (c, p) =>
              this.onRemovalComplete(c, p));
        }
        registerTrigger(e, t, s, c, p) {
          const y = e + "-" + c;
          let w = this._triggerCache[y];
          if (!w) {
            const S = [],
              N = tb(this._driver, p, S, []);
            if (S.length)
              throw (function H2(n, e) {
                return new rt(3404, !1);
              })();
            (w = (function UL(n, e, t) {
              return new $L(n, e, t);
            })(c, N, this._normalizer)),
              (this._triggerCache[y] = w);
          }
          this._transitionEngine.registerTrigger(t, c, w);
        }
        register(e, t) {
          this._transitionEngine.register(e, t);
        }
        destroy(e, t) {
          this._transitionEngine.destroy(e, t);
        }
        onInsert(e, t, s, c) {
          this._transitionEngine.insertNode(e, t, s, c);
        }
        onRemove(e, t, s, c) {
          this._transitionEngine.removeNode(e, t, c || !1, s);
        }
        disableAnimations(e, t) {
          this._transitionEngine.markElementAsDisabled(e, t);
        }
        process(e, t, s, c) {
          if ("@" == s.charAt(0)) {
            const [p, y] = RT(s);
            this._timelineEngine.command(p, t, y, c);
          } else this._transitionEngine.trigger(e, t, s, c);
        }
        listen(e, t, s, c, p) {
          if ("@" == s.charAt(0)) {
            const [y, w] = RT(s);
            return this._timelineEngine.listen(y, t, w, p);
          }
          return this._transitionEngine.listen(e, t, s, c, p);
        }
        flush(e = -1) {
          this._transitionEngine.flush(e);
        }
        get players() {
          return this._transitionEngine.players.concat(
            this._timelineEngine.players
          );
        }
        whenRenderingDone() {
          return this._transitionEngine.whenRenderingDone();
        }
      }
      let lk = (() => {
        class n {
          constructor(t, s, c) {
            (this._element = t),
              (this._startStyles = s),
              (this._endStyles = c),
              (this._state = 0);
            let p = n.initialStylesByElement.get(t);
            p || n.initialStylesByElement.set(t, (p = new Map())),
              (this._initialStyles = p);
          }
          start() {
            this._state < 1 &&
              (this._startStyles &&
                ic(this._element, this._startStyles, this._initialStyles),
              (this._state = 1));
          }
          finish() {
            this.start(),
              this._state < 2 &&
                (ic(this._element, this._initialStyles),
                this._endStyles &&
                  (ic(this._element, this._endStyles),
                  (this._endStyles = null)),
                (this._state = 1));
          }
          destroy() {
            this.finish(),
              this._state < 3 &&
                (n.initialStylesByElement.delete(this._element),
                this._startStyles &&
                  (tp(this._element, this._startStyles),
                  (this._endStyles = null)),
                this._endStyles &&
                  (tp(this._element, this._endStyles),
                  (this._endStyles = null)),
                ic(this._element, this._initialStyles),
                (this._state = 3));
          }
        }
        return (n.initialStylesByElement = new WeakMap()), n;
      })();
      function db(n) {
        let e = null;
        return (
          n.forEach((t, s) => {
            (function ck(n) {
              return "display" === n || "position" === n;
            })(s) && ((e = e || new Map()), e.set(s, t));
          }),
          e
        );
      }
      class cD {
        constructor(e, t, s, c) {
          (this.element = e),
            (this.keyframes = t),
            (this.options = s),
            (this._specialStyles = c),
            (this._onDoneFns = []),
            (this._onStartFns = []),
            (this._onDestroyFns = []),
            (this._initialized = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._destroyed = !1),
            (this._originalOnDoneFns = []),
            (this._originalOnStartFns = []),
            (this.time = 0),
            (this.parentPlayer = null),
            (this.currentSnapshot = new Map()),
            (this._duration = s.duration),
            (this._delay = s.delay || 0),
            (this.time = this._duration + this._delay);
        }
        _onFinish() {
          this._finished ||
            ((this._finished = !0),
            this._onDoneFns.forEach((e) => e()),
            (this._onDoneFns = []));
        }
        init() {
          this._buildPlayer(), this._preparePlayerBeforeStart();
        }
        _buildPlayer() {
          if (this._initialized) return;
          this._initialized = !0;
          const e = this.keyframes;
          (this.domPlayer = this._triggerWebAnimation(
            this.element,
            e,
            this.options
          )),
            (this._finalKeyframe = e.length ? e[e.length - 1] : new Map()),
            this.domPlayer.addEventListener("finish", () => this._onFinish());
        }
        _preparePlayerBeforeStart() {
          this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
        }
        _convertKeyframesToObject(e) {
          const t = [];
          return (
            e.forEach((s) => {
              t.push(Object.fromEntries(s));
            }),
            t
          );
        }
        _triggerWebAnimation(e, t, s) {
          return e.animate(this._convertKeyframesToObject(t), s);
        }
        onStart(e) {
          this._originalOnStartFns.push(e), this._onStartFns.push(e);
        }
        onDone(e) {
          this._originalOnDoneFns.push(e), this._onDoneFns.push(e);
        }
        onDestroy(e) {
          this._onDestroyFns.push(e);
        }
        play() {
          this._buildPlayer(),
            this.hasStarted() ||
              (this._onStartFns.forEach((e) => e()),
              (this._onStartFns = []),
              (this._started = !0),
              this._specialStyles && this._specialStyles.start()),
            this.domPlayer.play();
        }
        pause() {
          this.init(), this.domPlayer.pause();
        }
        finish() {
          this.init(),
            this._specialStyles && this._specialStyles.finish(),
            this._onFinish(),
            this.domPlayer.finish();
        }
        reset() {
          this._resetDomPlayerState(),
            (this._destroyed = !1),
            (this._finished = !1),
            (this._started = !1),
            (this._onStartFns = this._originalOnStartFns),
            (this._onDoneFns = this._originalOnDoneFns);
        }
        _resetDomPlayerState() {
          this.domPlayer && this.domPlayer.cancel();
        }
        restart() {
          this.reset(), this.play();
        }
        hasStarted() {
          return this._started;
        }
        destroy() {
          this._destroyed ||
            ((this._destroyed = !0),
            this._resetDomPlayerState(),
            this._onFinish(),
            this._specialStyles && this._specialStyles.destroy(),
            this._onDestroyFns.forEach((e) => e()),
            (this._onDestroyFns = []));
        }
        setPosition(e) {
          void 0 === this.domPlayer && this.init(),
            (this.domPlayer.currentTime = e * this.time);
        }
        getPosition() {
          return this.domPlayer.currentTime / this.time;
        }
        get totalTime() {
          return this._delay + this._duration;
        }
        beforeDestroy() {
          const e = new Map();
          this.hasStarted() &&
            this._finalKeyframe.forEach((s, c) => {
              "offset" !== c &&
                e.set(c, this._finished ? s : ZT(this.element, c));
            }),
            (this.currentSnapshot = e);
        }
        triggerCallback(e) {
          const t = "start" === e ? this._onStartFns : this._onDoneFns;
          t.forEach((s) => s()), (t.length = 0);
        }
      }
      class uk {
        validateStyleProperty(e) {
          return !0;
        }
        validateAnimatableStyleProperty(e) {
          return !0;
        }
        matchesElement(e, t) {
          return !1;
        }
        containsElement(e, t) {
          return zT(e, t);
        }
        getParentElement(e) {
          return Zx(e);
        }
        query(e, t, s) {
          return BT(e, t, s);
        }
        computeStyle(e, t, s) {
          return window.getComputedStyle(e)[t];
        }
        animate(e, t, s, c, p, y = []) {
          const S = {
            duration: s,
            delay: c,
            fill: 0 == c ? "both" : "forwards",
          };
          p && (S.easing = p);
          const P = new Map(),
            N = y.filter((ie) => ie instanceof cD);
          (function fL(n, e) {
            return 0 === n || 0 === e;
          })(s, c) &&
            N.forEach((ie) => {
              ie.currentSnapshot.forEach((pe, Ee) => P.set(Ee, pe));
            });
          let j = (function uL(n) {
            return n.length
              ? n[0] instanceof Map
                ? n
                : n.map((e) => $T(e))
              : [];
          })(t).map((ie) => Eh(ie));
          j = (function mL(n, e, t) {
            if (t.size && e.length) {
              let s = e[0],
                c = [];
              if (
                (t.forEach((p, y) => {
                  s.has(y) || c.push(y), s.set(y, p);
                }),
                c.length)
              )
                for (let p = 1; p < e.length; p++) {
                  let y = e[p];
                  c.forEach((w) => y.set(w, ZT(n, w)));
                }
            }
            return e;
          })(e, j, P);
          const Q = (function ak(n, e) {
            let t = null,
              s = null;
            return (
              Array.isArray(e) && e.length
                ? ((t = db(e[0])), e.length > 1 && (s = db(e[e.length - 1])))
                : e instanceof Map && (t = db(e)),
              t || s ? new lk(n, t, s) : null
            );
          })(e, j);
          return new cD(e, j, S, Q);
        }
      }
      let hk = (() => {
        class n extends ST {
          constructor(t, s) {
            super(),
              (this._nextAnimationId = 0),
              (this._renderer = t.createRenderer(s.body, {
                id: "0",
                encapsulation: vo.None,
                styles: [],
                data: { animation: [] },
              }));
          }
          build(t) {
            const s = this._nextAnimationId.toString();
            this._nextAnimationId++;
            const c = Array.isArray(t) ? CT(t) : t;
            return (
              uD(this._renderer, null, s, "register", [c]),
              new dk(s, this._renderer)
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(nh), St(ml));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class dk extends class n2 {} {
        constructor(e, t) {
          super(), (this._id = e), (this._renderer = t);
        }
        create(e, t) {
          return new pk(this._id, e, t || {}, this._renderer);
        }
      }
      class pk {
        constructor(e, t, s, c) {
          (this.id = e),
            (this.element = t),
            (this._renderer = c),
            (this.parentPlayer = null),
            (this._started = !1),
            (this.totalTime = 0),
            this._command("create", s);
        }
        _listen(e, t) {
          return this._renderer.listen(this.element, `@@${this.id}:${e}`, t);
        }
        _command(e, ...t) {
          return uD(this._renderer, this.element, this.id, e, t);
        }
        onDone(e) {
          this._listen("done", e);
        }
        onStart(e) {
          this._listen("start", e);
        }
        onDestroy(e) {
          this._listen("destroy", e);
        }
        init() {
          this._command("init");
        }
        hasStarted() {
          return this._started;
        }
        play() {
          this._command("play"), (this._started = !0);
        }
        pause() {
          this._command("pause");
        }
        restart() {
          this._command("restart");
        }
        finish() {
          this._command("finish");
        }
        destroy() {
          this._command("destroy");
        }
        reset() {
          this._command("reset"), (this._started = !1);
        }
        setPosition(e) {
          this._command("setPosition", e);
        }
        getPosition() {
          return this._renderer.engine.players[+this.id]?.getPosition() ?? 0;
        }
      }
      function uD(n, e, t, s, c) {
        return n.setProperty(e, `@@${t}:${s}`, c);
      }
      const hD = "@.disabled";
      let fk = (() => {
        class n {
          constructor(t, s, c) {
            (this.delegate = t),
              (this.engine = s),
              (this._zone = c),
              (this._currentId = 0),
              (this._microtaskId = 1),
              (this._animationCallbacksBuffer = []),
              (this._rendererCache = new Map()),
              (this._cdRecurDepth = 0),
              (this.promise = Promise.resolve(0)),
              (s.onRemovalComplete = (p, y) => {
                const w = y?.parentNode(p);
                w && y.removeChild(w, p);
              });
          }
          createRenderer(t, s) {
            const p = this.delegate.createRenderer(t, s);
            if (!(t && s && s.data && s.data.animation)) {
              let N = this._rendererCache.get(p);
              return (
                N ||
                  ((N = new dD("", p, this.engine, () =>
                    this._rendererCache.delete(p)
                  )),
                  this._rendererCache.set(p, N)),
                N
              );
            }
            const y = s.id,
              w = s.id + "-" + this._currentId;
            this._currentId++, this.engine.register(w, t);
            const S = (N) => {
              Array.isArray(N)
                ? N.forEach(S)
                : this.engine.registerTrigger(y, w, t, N.name, N);
            };
            return s.data.animation.forEach(S), new mk(this, w, p, this.engine);
          }
          begin() {
            this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
          }
          _scheduleCountTask() {
            this.promise.then(() => {
              this._microtaskId++;
            });
          }
          scheduleListenerCallback(t, s, c) {
            t >= 0 && t < this._microtaskId
              ? this._zone.run(() => s(c))
              : (0 == this._animationCallbacksBuffer.length &&
                  Promise.resolve(null).then(() => {
                    this._zone.run(() => {
                      this._animationCallbacksBuffer.forEach((p) => {
                        const [y, w] = p;
                        y(w);
                      }),
                        (this._animationCallbacksBuffer = []);
                    });
                  }),
                this._animationCallbacksBuffer.push([s, c]));
          }
          end() {
            this._cdRecurDepth--,
              0 == this._cdRecurDepth &&
                this._zone.runOutsideAngular(() => {
                  this._scheduleCountTask(),
                    this.engine.flush(this._microtaskId);
                }),
              this.delegate.end && this.delegate.end();
          }
          whenRenderingDone() {
            return this.engine.whenRenderingDone();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(St(nh), St(hv), St(ur));
          }),
          (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class dD {
        constructor(e, t, s, c) {
          (this.namespaceId = e),
            (this.delegate = t),
            (this.engine = s),
            (this._onDestroy = c),
            (this.destroyNode = this.delegate.destroyNode
              ? (p) => t.destroyNode(p)
              : null);
        }
        get data() {
          return this.delegate.data;
        }
        destroy() {
          this.engine.destroy(this.namespaceId, this.delegate),
            this.delegate.destroy(),
            this._onDestroy?.();
        }
        createElement(e, t) {
          return this.delegate.createElement(e, t);
        }
        createComment(e) {
          return this.delegate.createComment(e);
        }
        createText(e) {
          return this.delegate.createText(e);
        }
        appendChild(e, t) {
          this.delegate.appendChild(e, t),
            this.engine.onInsert(this.namespaceId, t, e, !1);
        }
        insertBefore(e, t, s, c = !0) {
          this.delegate.insertBefore(e, t, s),
            this.engine.onInsert(this.namespaceId, t, e, c);
        }
        removeChild(e, t, s) {
          this.engine.onRemove(this.namespaceId, t, this.delegate, s);
        }
        selectRootElement(e, t) {
          return this.delegate.selectRootElement(e, t);
        }
        parentNode(e) {
          return this.delegate.parentNode(e);
        }
        nextSibling(e) {
          return this.delegate.nextSibling(e);
        }
        setAttribute(e, t, s, c) {
          this.delegate.setAttribute(e, t, s, c);
        }
        removeAttribute(e, t, s) {
          this.delegate.removeAttribute(e, t, s);
        }
        addClass(e, t) {
          this.delegate.addClass(e, t);
        }
        removeClass(e, t) {
          this.delegate.removeClass(e, t);
        }
        setStyle(e, t, s, c) {
          this.delegate.setStyle(e, t, s, c);
        }
        removeStyle(e, t, s) {
          this.delegate.removeStyle(e, t, s);
        }
        setProperty(e, t, s) {
          "@" == t.charAt(0) && t == hD
            ? this.disableAnimations(e, !!s)
            : this.delegate.setProperty(e, t, s);
        }
        setValue(e, t) {
          this.delegate.setValue(e, t);
        }
        listen(e, t, s) {
          return this.delegate.listen(e, t, s);
        }
        disableAnimations(e, t) {
          this.engine.disableAnimations(e, t);
        }
      }
      class mk extends dD {
        constructor(e, t, s, c, p) {
          super(t, s, c, p), (this.factory = e), (this.namespaceId = t);
        }
        setProperty(e, t, s) {
          "@" == t.charAt(0)
            ? "." == t.charAt(1) && t == hD
              ? this.disableAnimations(e, (s = void 0 === s || !!s))
              : this.engine.process(this.namespaceId, e, t.slice(1), s)
            : this.delegate.setProperty(e, t, s);
        }
        listen(e, t, s) {
          if ("@" == t.charAt(0)) {
            const c = (function gk(n) {
              switch (n) {
                case "body":
                  return document.body;
                case "document":
                  return document;
                case "window":
                  return window;
                default:
                  return n;
              }
            })(e);
            let p = t.slice(1),
              y = "";
            return (
              "@" != p.charAt(0) &&
                ([p, y] = (function _k(n) {
                  const e = n.indexOf(".");
                  return [n.substring(0, e), n.slice(e + 1)];
                })(p)),
              this.engine.listen(this.namespaceId, c, p, y, (w) => {
                this.factory.scheduleListenerCallback(w._data || -1, s, w);
              })
            );
          }
          return this.delegate.listen(e, t, s);
        }
      }
      const pD = [
          { provide: ST, useClass: hk },
          {
            provide: sb,
            useFactory: function vk() {
              return new zL();
            },
          },
          {
            provide: hv,
            useClass: (() => {
              class n extends hv {
                constructor(t, s, c, p) {
                  super(t.body, s, c);
                }
                ngOnDestroy() {
                  this.flush();
                }
              }
              return (
                (n.ɵfac = function (t) {
                  return new (t || n)(St(ml), St(Xx), St(sb), St(Iy));
                }),
                (n.ɵprov = Sn({ token: n, factory: n.ɵfac })),
                n
              );
            })(),
          },
          {
            provide: nh,
            useFactory: function xk(n, e, t) {
              return new fk(n, e, t);
            },
            deps: [Xy, hv, ur],
          },
        ],
        pb = [
          { provide: Xx, useFactory: () => new uk() },
          { provide: rE, useValue: "BrowserAnimations" },
          ...pD,
        ],
        fD = [
          { provide: Xx, useClass: VT },
          { provide: rE, useValue: "NoopAnimations" },
          ...pD,
        ];
      let bk = (() => {
          class n {
            static withConfig(t) {
              return { ngModule: n, providers: t.disableAnimations ? fD : pb };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n })),
            (n.ɵinj = Jn({ providers: pb, imports: [fT] })),
            n
          );
        })(),
        wk = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = or({ type: n, bootstrap: [JP] })),
            (n.ɵinj = Jn({ imports: [fT, bk, t2, w2, wT, qP] })),
            n
          );
        })();
      (function OC() {
        xE = !1;
      })(),
        dP()
          .bootstrapModule(wk)
          .catch((n) => console.error(n));
    },
    898: function (Af) {
      Af.exports = (function () {
        "use strict";
        var ou, su, li;
        function rp(d, Be) {
          if (ou)
            if (su) {
              var Oo =
                  "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" +
                  ou +
                  ")(sharedChunk); (" +
                  su +
                  ")(sharedChunk); self.onerror = null;",
                Jr = {};
              ou(Jr),
                (li = Be(Jr)),
                typeof window < "u" &&
                  window &&
                  window.URL &&
                  window.URL.createObjectURL &&
                  (li.workerUrl = window.URL.createObjectURL(
                    new Blob([Oo], { type: "text/javascript" })
                  ));
            } else su = Be;
          else ou = Be;
        }
        return (
          rp(0, function (d) {
            var Be = typeof self < "u" ? self : {},
              Oo = "2.15.0";
            let Jr;
            const zt = {
                API_URL: "https://api.mapbox.com",
                get API_URL_REGEX() {
                  if (null == Jr) {
                    const r =
                      /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                    try {
                      Jr =
                        null != process.env.API_URL_REGEX
                          ? new RegExp(process.env.API_URL_REGEX)
                          : r;
                    } catch {
                      Jr = r;
                    }
                  }
                  return Jr;
                },
                get API_TILEJSON_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
                },
                get API_SPRITE_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
                },
                get API_FONTS_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
                },
                get API_STYLE_REGEX() {
                  return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
                },
                get API_CDN_URL_REGEX() {
                  return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
                },
                get EVENTS_URL() {
                  if (!zt.API_URL) return null;
                  try {
                    const r = new URL(zt.API_URL);
                    return "api.mapbox.cn" === r.hostname
                      ? "https://events.mapbox.cn/events/v2"
                      : "api.mapbox.com" === r.hostname
                      ? "https://events.mapbox.com/events/v2"
                      : null;
                  } catch {
                    return null;
                  }
                },
                SESSION_PATH: "/map-sessions/v1",
                FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                TILE_URL_VERSION: "v4",
                RASTER_URL_PREFIX: "raster/v1",
                REQUIRE_ACCESS_TOKEN: !0,
                ACCESS_TOKEN: null,
                MAX_PARALLEL_IMAGE_REQUESTS: 16,
              },
              Ot = {
                supported: !1,
                testSupport: function (r) {
                  !Fo && pr && (ns ? oc(r) : (Ii = r));
                },
              };
            let Ii,
              pr,
              Fo = !1,
              ns = !1;
            function oc(r) {
              const i = r.createTexture();
              r.bindTexture(r.TEXTURE_2D, i);
              try {
                if (
                  (r.texImage2D(
                    r.TEXTURE_2D,
                    0,
                    r.RGBA,
                    r.RGBA,
                    r.UNSIGNED_BYTE,
                    pr
                  ),
                  r.isContextLost())
                )
                  return;
                Ot.supported = !0;
              } catch {}
              r.deleteTexture(i), (Fo = !0);
            }
            Be.document &&
              ((pr = Be.document.createElement("img")),
              (pr.onload = function () {
                Ii && oc(Ii), (Ii = null), (ns = !0);
              }),
              (pr.onerror = function () {
                (Fo = !0), (Ii = null);
              }),
              (pr.src =
                "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="));
            const vl = "01";
            function Vr(r) {
              return r &&
                r.__esModule &&
                Object.prototype.hasOwnProperty.call(r, "default")
                ? r.default
                : r;
            }
            var eo = Ir;
            function Ir(r, i, o, l) {
              (this.cx = 3 * r),
                (this.bx = 3 * (o - r) - this.cx),
                (this.ax = 1 - this.cx - this.bx),
                (this.cy = 3 * i),
                (this.by = 3 * (l - i) - this.cy),
                (this.ay = 1 - this.cy - this.by),
                (this.p1x = r),
                (this.p1y = i),
                (this.p2x = o),
                (this.p2y = l);
            }
            Ir.prototype = {
              sampleCurveX: function (r) {
                return ((this.ax * r + this.bx) * r + this.cx) * r;
              },
              sampleCurveY: function (r) {
                return ((this.ay * r + this.by) * r + this.cy) * r;
              },
              sampleCurveDerivativeX: function (r) {
                return (3 * this.ax * r + 2 * this.bx) * r + this.cx;
              },
              solveCurveX: function (r, i) {
                if ((void 0 === i && (i = 1e-6), r < 0)) return 0;
                if (r > 1) return 1;
                for (var o = r, l = 0; l < 8; l++) {
                  var h = this.sampleCurveX(o) - r;
                  if (Math.abs(h) < i) return o;
                  var m = this.sampleCurveDerivativeX(o);
                  if (Math.abs(m) < 1e-6) break;
                  o -= h / m;
                }
                var _ = 0,
                  x = 1;
                for (
                  o = r, l = 0;
                  l < 20 &&
                  ((h = this.sampleCurveX(o)), !(Math.abs(h - r) < i));
                  l++
                )
                  r > h ? (_ = o) : (x = o), (o = 0.5 * (x - _) + _);
                return o;
              },
              solve: function (r, i) {
                return this.sampleCurveY(this.solveCurveX(r, i));
              },
            };
            var Sa = Vr(eo),
              is = mo;
            function mo(r, i) {
              (this.x = r), (this.y = i);
            }
            (mo.prototype = {
              clone: function () {
                return new mo(this.x, this.y);
              },
              add: function (r) {
                return this.clone()._add(r);
              },
              sub: function (r) {
                return this.clone()._sub(r);
              },
              multByPoint: function (r) {
                return this.clone()._multByPoint(r);
              },
              divByPoint: function (r) {
                return this.clone()._divByPoint(r);
              },
              mult: function (r) {
                return this.clone()._mult(r);
              },
              div: function (r) {
                return this.clone()._div(r);
              },
              rotate: function (r) {
                return this.clone()._rotate(r);
              },
              rotateAround: function (r, i) {
                return this.clone()._rotateAround(r, i);
              },
              matMult: function (r) {
                return this.clone()._matMult(r);
              },
              unit: function () {
                return this.clone()._unit();
              },
              perp: function () {
                return this.clone()._perp();
              },
              round: function () {
                return this.clone()._round();
              },
              mag: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              },
              equals: function (r) {
                return this.x === r.x && this.y === r.y;
              },
              dist: function (r) {
                return Math.sqrt(this.distSqr(r));
              },
              distSqr: function (r) {
                var i = r.x - this.x,
                  o = r.y - this.y;
                return i * i + o * o;
              },
              angle: function () {
                return Math.atan2(this.y, this.x);
              },
              angleTo: function (r) {
                return Math.atan2(this.y - r.y, this.x - r.x);
              },
              angleWith: function (r) {
                return this.angleWithSep(r.x, r.y);
              },
              angleWithSep: function (r, i) {
                return Math.atan2(
                  this.x * i - this.y * r,
                  this.x * r + this.y * i
                );
              },
              _matMult: function (r) {
                var i = r[2] * this.x + r[3] * this.y;
                return (
                  (this.x = r[0] * this.x + r[1] * this.y), (this.y = i), this
                );
              },
              _add: function (r) {
                return (this.x += r.x), (this.y += r.y), this;
              },
              _sub: function (r) {
                return (this.x -= r.x), (this.y -= r.y), this;
              },
              _mult: function (r) {
                return (this.x *= r), (this.y *= r), this;
              },
              _div: function (r) {
                return (this.x /= r), (this.y /= r), this;
              },
              _multByPoint: function (r) {
                return (this.x *= r.x), (this.y *= r.y), this;
              },
              _divByPoint: function (r) {
                return (this.x /= r.x), (this.y /= r.y), this;
              },
              _unit: function () {
                return this._div(this.mag()), this;
              },
              _perp: function () {
                var r = this.y;
                return (this.y = this.x), (this.x = -r), this;
              },
              _rotate: function (r) {
                var i = Math.cos(r),
                  o = Math.sin(r),
                  l = o * this.x + i * this.y;
                return (this.x = i * this.x - o * this.y), (this.y = l), this;
              },
              _rotateAround: function (r, i) {
                var o = Math.cos(r),
                  l = Math.sin(r),
                  h = i.y + l * (this.x - i.x) + o * (this.y - i.y);
                return (
                  (this.x = i.x + o * (this.x - i.x) - l * (this.y - i.y)),
                  (this.y = h),
                  this
                );
              },
              _round: function () {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  this
                );
              },
            }),
              (mo.convert = function (r) {
                return r instanceof mo
                  ? r
                  : Array.isArray(r)
                  ? new mo(r[0], r[1])
                  : r;
              });
            var et = Vr(is);
            const Dh = Math.PI / 180,
              Ia = 180 / Math.PI;
            function Xt(r) {
              return r * Dh;
            }
            function Oi(r) {
              return r * Ia;
            }
            const sc = [
              [0, 0],
              [1, 0],
              [1, 1],
              [0, 1],
            ];
            function au(r) {
              if (r <= 0) return 0;
              if (r >= 1) return 1;
              const i = r * r,
                o = i * r;
              return 4 * (r < 0.5 ? o : 3 * (r - i) + o - 0.75);
            }
            function Ca(r, i, o, l) {
              const h = new Sa(r, i, o, l);
              return function (m) {
                return h.solve(m);
              };
            }
            const ac = Ca(0.25, 0.1, 0.25, 1);
            function Qt(r, i, o) {
              return Math.min(o, Math.max(i, r));
            }
            function Ma(r, i, o) {
              return (o = Qt((o - r) / (i - r), 0, 1)) * o * (3 - 2 * o);
            }
            function bn(r, i, o) {
              const l = o - i,
                h = ((((r - i) % l) + l) % l) + i;
              return h === i ? o : h;
            }
            function Ci(r, i, o) {
              if (!r.length) return o(null, []);
              let l = r.length;
              const h = new Array(r.length);
              let m = null;
              r.forEach((_, x) => {
                i(_, (E, T) => {
                  E && (m = E), (h[x] = T), 0 == --l && o(m, h);
                });
              });
            }
            function Rs(r) {
              const i = [];
              for (const o in r) i.push(r[o]);
              return i;
            }
            function ci(r, ...i) {
              for (const o of i) for (const l in o) r[l] = o[l];
              return r;
            }
            let Os = 1;
            function rs() {
              return Os++;
            }
            function os() {
              return (function r(i) {
                return i
                  ? (i ^ (Math.random() * (16 >> (i / 4)))).toString(16)
                  : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
              })();
            }
            function ss(r) {
              return r <= 1
                ? 1
                : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
            }
            function Fs(r) {
              return (
                !!r &&
                /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                  r
                )
              );
            }
            function No(r, i) {
              r.forEach((o) => {
                i[o] && (i[o] = i[o].bind(i));
              });
            }
            function xl(r, i) {
              return -1 !== r.indexOf(i, r.length - i.length);
            }
            function en(r, i, o) {
              const l = {};
              for (const h in r) l[h] = i.call(o || this, r[h], h, r);
              return l;
            }
            function Ns(r, i, o) {
              const l = {};
              for (const h in r) i.call(o || this, r[h], h, r) && (l[h] = r[h]);
              return l;
            }
            function jr(r) {
              return Array.isArray(r)
                ? r.map(jr)
                : "object" == typeof r && r
                ? en(r, jr)
                : r;
            }
            const Aa = {};
            function Hn(r) {
              Aa[r] || (typeof console < "u" && console.warn(r), (Aa[r] = !0));
            }
            function to(r, i, o) {
              return (o.y - r.y) * (i.x - r.x) > (i.y - r.y) * (o.x - r.x);
            }
            function lu(r) {
              let i = 0;
              for (let o, l, h = 0, m = r.length, _ = m - 1; h < m; _ = h++)
                (o = r[h]), (l = r[_]), (i += (l.x - o.x) * (o.y + l.y));
              return i;
            }
            function zs() {
              return (
                typeof WorkerGlobalScope < "u" &&
                typeof self < "u" &&
                self instanceof WorkerGlobalScope
              );
            }
            function no(r) {
              const i = {};
              if (
                (r.replace(
                  /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
                  (o, l, h, m) => {
                    const _ = h || m;
                    return (i[l] = !_ || _.toLowerCase()), "";
                  }
                ),
                i["max-age"])
              ) {
                const o = parseInt(i["max-age"], 10);
                isNaN(o) ? delete i["max-age"] : (i["max-age"] = o);
              }
              return i;
            }
            let cu = null;
            function lc(r) {
              if (null == cu) {
                const i = r.navigator ? r.navigator.userAgent : null;
                cu =
                  !!r.safari ||
                  !(
                    !i ||
                    !(
                      /\b(iPad|iPhone|iPod)\b/.test(i) ||
                      (i.match("Safari") && !i.match("Chrome"))
                    )
                  );
              }
              return cu;
            }
            function cc(r) {
              try {
                const i = Be[r];
                return (
                  i.setItem("_mapbox_test_", 1),
                  i.removeItem("_mapbox_test_"),
                  !0
                );
              } catch {
                return !1;
              }
            }
            function as(r, i) {
              return [r[4 * i], r[4 * i + 1], r[4 * i + 2], r[4 * i + 3]];
            }
            const bl = "mapbox-tiles";
            let Cr,
              ls,
              wl = 500,
              uu = 50;
            function uc() {
              try {
                return Be.caches;
              } catch {}
            }
            function Pa() {
              uc() && !Cr && (Cr = Be.caches.open(bl));
            }
            function El(r) {
              const i = r.indexOf("?");
              if (i < 0) return r;
              const l = (function (h) {
                const m = h.indexOf("?");
                return m > 0 ? h.slice(m + 1).split("&") : [];
              })(r).filter((h) => {
                const m = h.split("=");
                return "language" === m[0] || "worldview" === m[0];
              });
              return l.length
                ? `${r.slice(0, i)}?${l.join("&")}`
                : r.slice(0, i);
            }
            let io = 1 / 0;
            const Bs = {
              Unknown: "Unknown",
              Style: "Style",
              Source: "Source",
              Tile: "Tile",
              Glyphs: "Glyphs",
              SpriteImage: "SpriteImage",
              SpriteJSON: "SpriteJSON",
              Image: "Image",
            };
            "function" == typeof Object.freeze && Object.freeze(Bs);
            class Vs extends Error {
              constructor(i, o, l) {
                401 === o &&
                  ve(l) &&
                  (i +=
                    ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                  super(i),
                  (this.status = o),
                  (this.url = l);
              }
              toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
              }
            }
            const js = zs()
                ? () => self.worker && self.worker.referrer
                : () =>
                    ("blob:" === Be.location.protocol ? Be.parent : Be).location
                      .href,
              La = function (r, i) {
                if (
                  !(
                    /^file:/.test((o = r.url)) ||
                    (/^file:/.test(js()) && !/^\w+:/.test(o))
                  )
                ) {
                  if (
                    Be.fetch &&
                    Be.Request &&
                    Be.AbortController &&
                    Be.Request.prototype.hasOwnProperty("signal")
                  )
                    return (function (l, h) {
                      const m = new Be.AbortController(),
                        _ = new Be.Request(l.url, {
                          method: l.method || "GET",
                          body: l.body,
                          credentials: l.credentials,
                          headers: l.headers,
                          referrer: js(),
                          referrerPolicy: l.referrerPolicy,
                          signal: m.signal,
                        });
                      let x = !1,
                        E = !1;
                      const T = (C = _.url).indexOf("sku=") > 0 && ve(C);
                      var C;
                      "json" === l.type &&
                        _.headers.set("Accept", "application/json");
                      const A = (O, F, V) => {
                          if (E) return;
                          if (
                            (O &&
                              "SecurityError" !== O.message &&
                              Hn(O.toString()),
                            F && V)
                          )
                            return L(F);
                          const G = Date.now();
                          Be.fetch(_)
                            .then((K) => {
                              if (K.ok) {
                                const oe = T ? K.clone() : null;
                                return L(K, oe, G);
                              }
                              return h(new Vs(K.statusText, K.status, l.url));
                            })
                            .catch((K) => {
                              "AbortError" !== K.name &&
                                h(new Error(`${K.message} ${l.url}`));
                            });
                        },
                        L = (O, F, V) => {
                          ("arrayBuffer" === l.type
                            ? O.arrayBuffer()
                            : "json" === l.type
                            ? O.json()
                            : O.text()
                          )
                            .then((G) => {
                              E ||
                                (F &&
                                  V &&
                                  (function (K, oe, J) {
                                    if ((Pa(), !Cr)) return;
                                    const re = {
                                      status: oe.status,
                                      statusText: oe.statusText,
                                      headers: new Be.Headers(),
                                    };
                                    oe.headers.forEach((De, xe) =>
                                      re.headers.set(xe, De)
                                    );
                                    const le = no(
                                      oe.headers.get("Cache-Control") || ""
                                    );
                                    if (le["no-store"]) return;
                                    le["max-age"] &&
                                      re.headers.set(
                                        "Expires",
                                        new Date(
                                          J + 1e3 * le["max-age"]
                                        ).toUTCString()
                                      );
                                    const ae = re.headers.get("Expires");
                                    ae &&
                                      (new Date(ae).getTime() - J < 42e4 ||
                                        (function (De, xe) {
                                          if (void 0 === ls)
                                            try {
                                              new Response(
                                                new ReadableStream()
                                              ),
                                                (ls = !0);
                                            } catch {
                                              ls = !1;
                                            }
                                          ls ? xe(De.body) : De.blob().then(xe);
                                        })(oe, (De) => {
                                          const xe = new Be.Response(De, re);
                                          Pa(),
                                            Cr &&
                                              Cr.then((Pe) =>
                                                Pe.put(El(K.url), xe)
                                              ).catch((Pe) => Hn(Pe.message));
                                        }));
                                  })(_, F, V),
                                (x = !0),
                                h(
                                  null,
                                  G,
                                  O.headers.get("Cache-Control"),
                                  O.headers.get("Expires")
                                ));
                            })
                            .catch((G) => {
                              E || h(new Error(G.message));
                            });
                        };
                      return (
                        T
                          ? (function (O, F) {
                              if ((Pa(), !Cr)) return F(null);
                              const V = El(O.url);
                              Cr.then((G) => {
                                G.match(V)
                                  .then((K) => {
                                    const oe = (function (J) {
                                      if (!J) return !1;
                                      const re = new Date(
                                          J.headers.get("Expires") || 0
                                        ),
                                        le = no(
                                          J.headers.get("Cache-Control") || ""
                                        );
                                      return re > Date.now() && !le["no-cache"];
                                    })(K);
                                    G.delete(V),
                                      oe && G.put(V, K.clone()),
                                      F(null, K, oe);
                                  })
                                  .catch(F);
                              }).catch(F);
                            })(_, A)
                          : A(null, null),
                        {
                          cancel: () => {
                            (E = !0), x || m.abort();
                          },
                        }
                      );
                    })(r, i);
                  if (zs() && self.worker && self.worker.actor)
                    return self.worker.actor.send(
                      "getResource",
                      r,
                      i,
                      void 0,
                      !0
                    );
                }
                var o;
                return (function (l, h) {
                  const m = new Be.XMLHttpRequest();
                  m.open(l.method || "GET", l.url, !0),
                    "arrayBuffer" === l.type &&
                      (m.responseType = "arraybuffer");
                  for (const _ in l.headers)
                    m.setRequestHeader(_, l.headers[_]);
                  return (
                    "json" === l.type &&
                      ((m.responseType = "text"),
                      m.setRequestHeader("Accept", "application/json")),
                    (m.withCredentials = "include" === l.credentials),
                    (m.onerror = () => {
                      h(new Error(m.statusText));
                    }),
                    (m.onload = () => {
                      if (
                        ((m.status >= 200 && m.status < 300) ||
                          0 === m.status) &&
                        null !== m.response
                      ) {
                        let _ = m.response;
                        if ("json" === l.type)
                          try {
                            _ = JSON.parse(m.response);
                          } catch (x) {
                            return h(x);
                          }
                        h(
                          null,
                          _,
                          m.getResponseHeader("Cache-Control"),
                          m.getResponseHeader("Expires")
                        );
                      } else h(new Vs(m.statusText, m.status, l.url));
                    }),
                    m.send(l.body),
                    { cancel: () => m.abort() }
                  );
                })(r, i);
              },
              Tl = function (r, i) {
                return La(ci(r, { type: "arrayBuffer" }), i);
              };
            function hu(r) {
              const i = Be.document.createElement("a");
              return (
                (i.href = r),
                i.protocol === Be.document.location.protocol &&
                  i.host === Be.document.location.host
              );
            }
            const se =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let U, $;
            (U = []), ($ = 0);
            const ne = function (r, i) {
                if (
                  (Ot.supported &&
                    (r.headers || (r.headers = {}),
                    (r.headers.accept = "image/webp,*/*")),
                  $ >= zt.MAX_PARALLEL_IMAGE_REQUESTS)
                ) {
                  const m = {
                    requestParameters: r,
                    callback: i,
                    cancelled: !1,
                    cancel() {
                      this.cancelled = !0;
                    },
                  };
                  return U.push(m), m;
                }
                $++;
                let o = !1;
                const l = () => {
                    if (!o)
                      for (
                        o = !0, $--;
                        U.length && $ < zt.MAX_PARALLEL_IMAGE_REQUESTS;

                      ) {
                        const m = U.shift(),
                          {
                            requestParameters: _,
                            callback: x,
                            cancelled: E,
                          } = m;
                        E || (m.cancel = ne(_, x).cancel);
                      }
                  },
                  h = Tl(r, (m, _, x, E) => {
                    l(),
                      m
                        ? i(m)
                        : _ &&
                          (Be.createImageBitmap
                            ? (function (T, C) {
                                const A = new Be.Blob([new Uint8Array(T)], {
                                  type: "image/png",
                                });
                                Be.createImageBitmap(A)
                                  .then((L) => {
                                    C(null, L);
                                  })
                                  .catch((L) => {
                                    C(
                                      new Error(
                                        `Could not load image because of ${L.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
                                      )
                                    );
                                  });
                              })(_, (T, C) => i(T, C, x, E))
                            : (function (T, C) {
                                const A = new Be.Image(),
                                  L = Be.URL;
                                (A.onload = () => {
                                  C(null, A),
                                    L.revokeObjectURL(A.src),
                                    (A.onload = null),
                                    Be.requestAnimationFrame(() => {
                                      A.src = se;
                                    });
                                }),
                                  (A.onerror = () =>
                                    C(
                                      new Error(
                                        "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
                                      )
                                    ));
                                const O = new Be.Blob([new Uint8Array(T)], {
                                  type: "image/png",
                                });
                                A.src = T.byteLength
                                  ? L.createObjectURL(O)
                                  : se;
                              })(_, (T, C) => i(T, C, x, E)));
                  });
                return {
                  cancel: () => {
                    h.cancel(), l();
                  },
                };
              },
              ce = "NO_ACCESS_TOKEN";
            function me(r) {
              return 0 === r.indexOf("mapbox:");
            }
            function ve(r) {
              return zt.API_URL_REGEX.test(r);
            }
            function ye(r) {
              return zt.API_CDN_URL_REGEX.test(r);
            }
            function fe(r) {
              return zt.API_STYLE_REGEX.test(r) && !Se(r);
            }
            function Se(r) {
              return zt.API_SPRITE_REGEX.test(r);
            }
            const Ye = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
            function Qe(r) {
              const i = r.match(Ye);
              if (!i) throw new Error("Unable to parse URL object");
              return {
                protocol: i[1],
                authority: i[2],
                path: i[3] || "/",
                params: i[4] ? i[4].split("&") : [],
              };
            }
            function We(r) {
              const i = r.params.length ? `?${r.params.join("&")}` : "";
              return `${r.protocol}://${r.authority}${r.path}${i}`;
            }
            const Pt = "mapbox.eventData";
            function Bt(r) {
              if (!r) return null;
              const i = r.split(".");
              if (!i || 3 !== i.length) return null;
              try {
                return JSON.parse(
                  decodeURIComponent(
                    Be.atob(i[1])
                      .split("")
                      .map(
                        (o) =>
                          "%" + ("00" + o.charCodeAt(0).toString(16)).slice(-2)
                      )
                      .join("")
                  )
                );
              } catch {
                return null;
              }
            }
            class Et {
              constructor(i) {
                (this.type = i),
                  (this.anonId = null),
                  (this.eventData = {}),
                  (this.queue = []),
                  (this.pendingRequest = null);
              }
              getStorageKey(i) {
                const o = Bt(zt.ACCESS_TOKEN);
                let l = "";
                return (
                  (l =
                    o && o.u
                      ? Be.btoa(
                          encodeURIComponent(o.u).replace(
                            /%([0-9A-F]{2})/g,
                            (h, m) => String.fromCharCode(Number("0x" + m))
                          )
                        )
                      : zt.ACCESS_TOKEN || ""),
                  i ? `${Pt}.${i}:${l}` : `${Pt}:${l}`
                );
              }
              fetchEventData() {
                const i = cc("localStorage"),
                  o = this.getStorageKey(),
                  l = this.getStorageKey("uuid");
                if (i)
                  try {
                    const h = Be.localStorage.getItem(o);
                    h && (this.eventData = JSON.parse(h));
                    const m = Be.localStorage.getItem(l);
                    m && (this.anonId = m);
                  } catch {
                    Hn("Unable to read from LocalStorage");
                  }
              }
              saveEventData() {
                const i = cc("localStorage"),
                  o = this.getStorageKey(),
                  l = this.getStorageKey("uuid");
                if (i)
                  try {
                    Be.localStorage.setItem(l, this.anonId),
                      Object.keys(this.eventData).length >= 1 &&
                        Be.localStorage.setItem(
                          o,
                          JSON.stringify(this.eventData)
                        );
                  } catch {
                    Hn("Unable to write to LocalStorage");
                  }
              }
              processRequests(i) {}
              postEvent(i, o, l, h) {
                if (!zt.EVENTS_URL) return;
                const m = Qe(zt.EVENTS_URL);
                m.params.push(`access_token=${h || zt.ACCESS_TOKEN || ""}`);
                const _ = {
                    event: this.type,
                    created: new Date(i).toISOString(),
                  },
                  x = o ? ci(_, o) : _,
                  E = {
                    url: We(m),
                    headers: { "Content-Type": "text/plain" },
                    body: JSON.stringify([x]),
                  };
                var C;
                this.pendingRequest =
                  ((C = (T) => {
                    (this.pendingRequest = null),
                      l(T),
                      this.saveEventData(),
                      this.processRequests(h);
                  }),
                  La(ci(E, { method: "POST" }), C));
              }
              queueRequest(i, o) {
                this.queue.push(i), this.processRequests(o);
              }
            }
            const Gt = new (class extends Et {
                constructor(r) {
                  super("appUserTurnstile"), (this._customAccessToken = r);
                }
                postTurnstileEvent(r, i) {
                  zt.EVENTS_URL &&
                    zt.ACCESS_TOKEN &&
                    Array.isArray(r) &&
                    r.some((o) => me(o) || ve(o)) &&
                    this.queueRequest(Date.now(), i);
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  (this.anonId &&
                    this.eventData.lastSuccess &&
                    this.eventData.tokenU) ||
                    this.fetchEventData();
                  const i = Bt(zt.ACCESS_TOKEN),
                    o = i ? i.u : zt.ACCESS_TOKEN;
                  let l = o !== this.eventData.tokenU;
                  Fs(this.anonId) || ((this.anonId = os()), (l = !0));
                  const h = this.queue.shift();
                  if (this.eventData.lastSuccess) {
                    const m = new Date(this.eventData.lastSuccess),
                      _ = new Date(h),
                      x = (h - this.eventData.lastSuccess) / 864e5;
                    l = l || x >= 1 || x < -1 || m.getDate() !== _.getDate();
                  } else l = !0;
                  l
                    ? this.postEvent(
                        h,
                        {
                          sdkIdentifier: "mapbox-gl-js",
                          sdkVersion: Oo,
                          skuId: vl,
                          "enabled.telemetry": !1,
                          userId: this.anonId,
                        },
                        (m) => {
                          m ||
                            ((this.eventData.lastSuccess = h),
                            (this.eventData.tokenU = o));
                        },
                        r
                      )
                    : this.processRequests();
                }
              })(),
              tn = Gt.postTurnstileEvent.bind(Gt),
              Gn = new (class extends Et {
                constructor() {
                  super("map.load"), (this.success = {}), (this.skuToken = "");
                }
                postMapLoadEvent(r, i, o, l) {
                  (this.skuToken = i),
                    (this.errorCb = l),
                    zt.EVENTS_URL &&
                      (o || zt.ACCESS_TOKEN
                        ? this.queueRequest({ id: r, timestamp: Date.now() }, o)
                        : this.errorCb(new Error(ce)));
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: i, timestamp: o } = this.queue.shift();
                  (i && this.success[i]) ||
                    (this.anonId || this.fetchEventData(),
                    Fs(this.anonId) || (this.anonId = os()),
                    this.postEvent(
                      o,
                      {
                        sdkIdentifier: "mapbox-gl-js",
                        sdkVersion: Oo,
                        skuId: vl,
                        skuToken: this.skuToken,
                        userId: this.anonId,
                      },
                      (l) => {
                        l ? this.errorCb(l) : i && (this.success[i] = !0);
                      },
                      r
                    ));
                }
              })(),
              ui = Gn.postMapLoadEvent.bind(Gn),
              Xi = new (class extends Et {
                constructor() {
                  super("gljs.performance");
                }
                postPerformanceEvent(r, i) {
                  zt.EVENTS_URL &&
                    (r || zt.ACCESS_TOKEN) &&
                    this.queueRequest(
                      { timestamp: Date.now(), performanceData: i },
                      r
                    );
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { timestamp: i, performanceData: o } =
                      this.queue.shift(),
                    l = (function (h) {
                      const m = Be.performance.getEntriesByType("resource"),
                        _ = Be.performance.getEntriesByType("mark"),
                        x = (function (L) {
                          const O = {};
                          if (L)
                            for (const F in L)
                              if ("other" !== F)
                                for (const V of L[F]) {
                                  const G = `${F}ResolveRangeMin`,
                                    K = `${F}ResolveRangeMax`,
                                    oe = `${F}RequestCount`,
                                    J = `${F}RequestCachedCount`;
                                  (O[G] = Math.min(O[G] || 1 / 0, V.startTime)),
                                    (O[K] = Math.max(
                                      O[K] || -1 / 0,
                                      V.responseEnd
                                    ));
                                  const re = (le) => {
                                    void 0 === O[le] && (O[le] = 0), ++O[le];
                                  };
                                  void 0 !== V.transferSize &&
                                    0 === V.transferSize &&
                                    re(J),
                                    re(oe);
                                }
                          return O;
                        })(
                          (function (L, O) {
                            const F = {};
                            if (L)
                              for (const V of L) {
                                const G = O(V);
                                void 0 === F[G] && (F[G] = []), F[G].push(V);
                              }
                            return F;
                          })(m, Sh)
                        ),
                        E = Be.devicePixelRatio,
                        T =
                          Be.navigator.connection ||
                          Be.navigator.mozConnection ||
                          Be.navigator.webkitConnection,
                        C = { counters: [], metadata: [], attributes: [] },
                        A = (L, O, F) => {
                          null != F && L.push({ name: O, value: F.toString() });
                        };
                      for (const L in x) A(C.counters, L, x[L]);
                      if (
                        (h.interactionRange[0] !== 1 / 0 &&
                          h.interactionRange[1] !== -1 / 0 &&
                          (A(
                            C.counters,
                            "interactionRangeMin",
                            h.interactionRange[0]
                          ),
                          A(
                            C.counters,
                            "interactionRangeMax",
                            h.interactionRange[1]
                          )),
                        _)
                      )
                        for (const L of Object.keys(ka)) {
                          const O = ka[L],
                            F = _.find((V) => V.name === O);
                          F && A(C.counters, O, F.startTime);
                        }
                      return (
                        A(C.counters, "visibilityHidden", h.visibilityHidden),
                        A(
                          C.attributes,
                          "style",
                          (function (L) {
                            if (L)
                              for (const O of L) {
                                const F = O.name.split("?")[0];
                                if (fe(F)) {
                                  const V = F.split("/").slice(-2);
                                  if (2 === V.length)
                                    return `mapbox://styles/${V[0]}/${V[1]}`;
                                }
                              }
                          })(m)
                        ),
                        A(
                          C.attributes,
                          "terrainEnabled",
                          h.terrainEnabled ? "true" : "false"
                        ),
                        A(
                          C.attributes,
                          "fogEnabled",
                          h.fogEnabled ? "true" : "false"
                        ),
                        A(C.attributes, "projection", h.projection),
                        A(C.attributes, "zoom", h.zoom),
                        A(C.metadata, "devicePixelRatio", E),
                        A(
                          C.metadata,
                          "connectionEffectiveType",
                          T ? T.effectiveType : void 0
                        ),
                        A(
                          C.metadata,
                          "navigatorUserAgent",
                          Be.navigator.userAgent
                        ),
                        A(C.metadata, "screenWidth", Be.screen.width),
                        A(C.metadata, "screenHeight", Be.screen.height),
                        A(C.metadata, "windowWidth", Be.innerWidth),
                        A(C.metadata, "windowHeight", Be.innerHeight),
                        A(C.metadata, "mapWidth", h.width / E),
                        A(C.metadata, "mapHeight", h.height / E),
                        A(C.metadata, "webglRenderer", h.renderer),
                        A(C.metadata, "webglVendor", h.vendor),
                        A(C.metadata, "sdkVersion", Oo),
                        A(C.metadata, "sdkIdentifier", "mapbox-gl-js"),
                        C
                      );
                    })(o);
                  for (const h of l.metadata);
                  for (const h of l.counters);
                  for (const h of l.attributes);
                  this.postEvent(i, l, () => {}, r);
                }
              })(),
              wi = Xi.postPerformanceEvent.bind(Xi),
              zo = new (class extends Et {
                constructor() {
                  super("map.auth"), (this.success = {}), (this.skuToken = "");
                }
                getSession(r, i, o, l) {
                  if (!zt.API_URL || !zt.SESSION_PATH) return;
                  const h = Qe(zt.API_URL + zt.SESSION_PATH);
                  h.params.push(`sku=${i || ""}`),
                    h.params.push(`access_token=${l || zt.ACCESS_TOKEN || ""}`);
                  const m = {
                    url: We(h),
                    headers: { "Content-Type": "text/plain" },
                  };
                  var x;
                  this.pendingRequest =
                    ((x = (_) => {
                      (this.pendingRequest = null),
                        o(_),
                        this.saveEventData(),
                        this.processRequests(l);
                    }),
                    La(ci(m, { method: "GET" }), x));
                }
                getSessionAPI(r, i, o, l) {
                  (this.skuToken = i),
                    (this.errorCb = l),
                    zt.SESSION_PATH &&
                      zt.API_URL &&
                      (o || zt.ACCESS_TOKEN
                        ? this.queueRequest({ id: r, timestamp: Date.now() }, o)
                        : this.errorCb(new Error(ce)));
                }
                processRequests(r) {
                  if (this.pendingRequest || 0 === this.queue.length) return;
                  const { id: i, timestamp: o } = this.queue.shift();
                  (i && this.success[i]) ||
                    this.getSession(
                      o,
                      this.skuToken,
                      (l) => {
                        l ? this.errorCb(l) : i && (this.success[i] = !0);
                      },
                      r
                    );
                }
              })(),
              qn = zo.getSessionAPI.bind(zo),
              fr = new Set(),
              ka = { create: "create", load: "load", fullLoad: "fullLoad" },
              Lf = {
                mark(r) {
                  Be.performance.mark(r);
                },
                measure(r, i, o) {
                  Be.performance.measure(r, i, o);
                },
              };
            function Sh(r) {
              const i = r.name.split("?")[0];
              return ye(i) && i.includes("mapbox-gl.js")
                ? "javascript"
                : ye(i) && i.includes("mapbox-gl.css")
                ? "css"
                : zt.API_FONTS_REGEX.test(i)
                ? "fontRange"
                : Se(i)
                ? "sprite"
                : fe(i)
                ? "style"
                : zt.API_TILEJSON_REGEX.test(i)
                ? "tilejson"
                : "other";
            }
            const _n = Be.performance;
            function Ih(r) {
              const i = r ? r.url.toString() : void 0;
              return _n.getEntriesByName(i);
            }
            let hc, dc, Ch, Bo;
            const cs = {
              now: () => (void 0 !== Ch ? Ch : Be.performance.now()),
              setNow(r) {
                Ch = r;
              },
              restoreNow() {
                Ch = void 0;
              },
              frame(r) {
                const i = Be.requestAnimationFrame(r);
                return { cancel: () => Be.cancelAnimationFrame(i) };
              },
              getImageData(r, i = 0) {
                const { width: o, height: l } = r;
                Bo || (Bo = Be.document.createElement("canvas"));
                const h = Bo.getContext("2d", { willReadFrequently: !0 });
                if (!h) throw new Error("failed to create canvas 2d context");
                return (
                  (o > Bo.width || l > Bo.height) &&
                    ((Bo.width = o), (Bo.height = l)),
                  h.clearRect(-i, -i, o + 2 * i, l + 2 * i),
                  h.drawImage(r, 0, 0, o, l),
                  h.getImageData(-i, -i, o + 2 * i, l + 2 * i)
                );
              },
              resolveURL: (r) => (
                hc || (hc = Be.document.createElement("a")),
                (hc.href = r),
                hc.href
              ),
              get devicePixelRatio() {
                return Be.devicePixelRatio;
              },
              get prefersReducedMotion() {
                return (
                  !!Be.matchMedia &&
                  (null == dc &&
                    (dc = Be.matchMedia("(prefers-reduced-motion: reduce)")),
                  dc.matches)
                );
              },
            };
            function du(r, i, o) {
              (o[r] && -1 !== o[r].indexOf(i)) ||
                ((o[r] = o[r] || []), o[r].push(i));
            }
            function pu(r, i, o) {
              if (o && o[r]) {
                const l = o[r].indexOf(i);
                -1 !== l && o[r].splice(l, 1);
              }
            }
            class Ra {
              constructor(i, o = {}) {
                ci(this, o), (this.type = i);
              }
            }
            class us extends Ra {
              constructor(i, o = {}) {
                super("error", ci({ error: i }, o));
              }
            }
            class pc {
              on(i, o) {
                return (
                  (this._listeners = this._listeners || {}),
                  du(i, o, this._listeners),
                  this
                );
              }
              off(i, o) {
                return (
                  pu(i, o, this._listeners),
                  pu(i, o, this._oneTimeListeners),
                  this
                );
              }
              once(i, o) {
                return o
                  ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
                    du(i, o, this._oneTimeListeners),
                    this)
                  : new Promise((l) => this.once(i, l));
              }
              fire(i, o) {
                "string" == typeof i && (i = new Ra(i, o || {}));
                const l = i.type;
                if (this.listens(l)) {
                  i.target = this;
                  const h =
                    this._listeners && this._listeners[l]
                      ? this._listeners[l].slice()
                      : [];
                  for (const x of h) x.call(this, i);
                  const m =
                    this._oneTimeListeners && this._oneTimeListeners[l]
                      ? this._oneTimeListeners[l].slice()
                      : [];
                  for (const x of m)
                    pu(l, x, this._oneTimeListeners), x.call(this, i);
                  const _ = this._eventedParent;
                  _ &&
                    (ci(
                      i,
                      "function" == typeof this._eventedParentData
                        ? this._eventedParentData()
                        : this._eventedParentData
                    ),
                    _.fire(i));
                } else i instanceof us && console.error(i.error);
                return this;
              }
              listens(i) {
                return !!(
                  (this._listeners &&
                    this._listeners[i] &&
                    this._listeners[i].length > 0) ||
                  (this._oneTimeListeners &&
                    this._oneTimeListeners[i] &&
                    this._oneTimeListeners[i].length > 0) ||
                  (this._eventedParent && this._eventedParent.listens(i))
                );
              }
              setEventedParent(i, o) {
                return (
                  (this._eventedParent = i), (this._eventedParentData = o), this
                );
              }
            }
            var Ae = JSON.parse(
              '{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}'
            );
            function Vo(r, ...i) {
              for (const o of i) for (const l in o) r[l] = o[l];
              return r;
            }
            function hi(r) {
              return r instanceof Number ||
                r instanceof String ||
                r instanceof Boolean
                ? r.valueOf()
                : r;
            }
            function Fi(r) {
              if (Array.isArray(r)) return r.map(Fi);
              if (
                r instanceof Object &&
                !(
                  r instanceof Number ||
                  r instanceof String ||
                  r instanceof Boolean
                )
              ) {
                const i = {};
                for (const o in r) i[o] = Fi(r[o]);
                return i;
              }
              return hi(r);
            }
            class op extends Error {
              constructor(i, o) {
                super(o), (this.message = o), (this.key = i);
              }
            }
            var jo = op;
            class Mh {
              constructor(i, o = []) {
                (this.parent = i), (this.bindings = {});
                for (const [l, h] of o) this.bindings[l] = h;
              }
              concat(i) {
                return new Mh(this, i);
              }
              get(i) {
                if (this.bindings[i]) return this.bindings[i];
                if (this.parent) return this.parent.get(i);
                throw new Error(`${i} not found in scope.`);
              }
              has(i) {
                return (
                  !!this.bindings[i] || (!!this.parent && this.parent.has(i))
                );
              }
            }
            var fu = Mh;
            const wn = { kind: "null" },
              it = { kind: "number" },
              _t = { kind: "string" },
              Vt = { kind: "boolean" },
              Ur = { kind: "color" },
              Mr = { kind: "object" },
              tt = { kind: "value" },
              mr = { kind: "collator" },
              mu = { kind: "formatted" },
              rt = { kind: "resolvedImage" };
            function gr(r, i) {
              return { kind: "array", itemType: r, N: i };
            }
            function pt(r) {
              if ("array" === r.kind) {
                const i = pt(r.itemType);
                return "number" == typeof r.N
                  ? `array<${i}, ${r.N}>`
                  : "value" === r.itemType.kind
                  ? "array"
                  : `array<${i}>`;
              }
              return r.kind;
            }
            const En = [wn, it, _t, Vt, Ur, mu, Mr, gr(tt), rt];
            function hs(r, i) {
              if ("error" === i.kind) return null;
              if ("array" === r.kind) {
                if (
                  "array" === i.kind &&
                  ((0 === i.N && "value" === i.itemType.kind) ||
                    !hs(r.itemType, i.itemType)) &&
                  ("number" != typeof r.N || r.N === i.N)
                )
                  return null;
              } else {
                if (r.kind === i.kind) return null;
                if ("value" === r.kind)
                  for (const o of En) if (!hs(o, i)) return null;
              }
              return `Expected ${pt(r)} but found ${pt(i)} instead.`;
            }
            function gu(r, i) {
              return i.some((o) => o.kind === r.kind);
            }
            function fc(r, i) {
              return i.some((o) =>
                "null" === o
                  ? null === r
                  : "array" === o
                  ? Array.isArray(r)
                  : "object" === o
                  ? r && !Array.isArray(r) && "object" == typeof r
                  : o === typeof r
              );
            }
            var Dl,
              Ar = {
                transparent: [0, 0, 0, 0],
                aliceblue: [240, 248, 255, 1],
                antiquewhite: [250, 235, 215, 1],
                aqua: [0, 255, 255, 1],
                aquamarine: [127, 255, 212, 1],
                azure: [240, 255, 255, 1],
                beige: [245, 245, 220, 1],
                bisque: [255, 228, 196, 1],
                black: [0, 0, 0, 1],
                blanchedalmond: [255, 235, 205, 1],
                blue: [0, 0, 255, 1],
                blueviolet: [138, 43, 226, 1],
                brown: [165, 42, 42, 1],
                burlywood: [222, 184, 135, 1],
                cadetblue: [95, 158, 160, 1],
                chartreuse: [127, 255, 0, 1],
                chocolate: [210, 105, 30, 1],
                coral: [255, 127, 80, 1],
                cornflowerblue: [100, 149, 237, 1],
                cornsilk: [255, 248, 220, 1],
                crimson: [220, 20, 60, 1],
                cyan: [0, 255, 255, 1],
                darkblue: [0, 0, 139, 1],
                darkcyan: [0, 139, 139, 1],
                darkgoldenrod: [184, 134, 11, 1],
                darkgray: [169, 169, 169, 1],
                darkgreen: [0, 100, 0, 1],
                darkgrey: [169, 169, 169, 1],
                darkkhaki: [189, 183, 107, 1],
                darkmagenta: [139, 0, 139, 1],
                darkolivegreen: [85, 107, 47, 1],
                darkorange: [255, 140, 0, 1],
                darkorchid: [153, 50, 204, 1],
                darkred: [139, 0, 0, 1],
                darksalmon: [233, 150, 122, 1],
                darkseagreen: [143, 188, 143, 1],
                darkslateblue: [72, 61, 139, 1],
                darkslategray: [47, 79, 79, 1],
                darkslategrey: [47, 79, 79, 1],
                darkturquoise: [0, 206, 209, 1],
                darkviolet: [148, 0, 211, 1],
                deeppink: [255, 20, 147, 1],
                deepskyblue: [0, 191, 255, 1],
                dimgray: [105, 105, 105, 1],
                dimgrey: [105, 105, 105, 1],
                dodgerblue: [30, 144, 255, 1],
                firebrick: [178, 34, 34, 1],
                floralwhite: [255, 250, 240, 1],
                forestgreen: [34, 139, 34, 1],
                fuchsia: [255, 0, 255, 1],
                gainsboro: [220, 220, 220, 1],
                ghostwhite: [248, 248, 255, 1],
                gold: [255, 215, 0, 1],
                goldenrod: [218, 165, 32, 1],
                gray: [128, 128, 128, 1],
                green: [0, 128, 0, 1],
                greenyellow: [173, 255, 47, 1],
                grey: [128, 128, 128, 1],
                honeydew: [240, 255, 240, 1],
                hotpink: [255, 105, 180, 1],
                indianred: [205, 92, 92, 1],
                indigo: [75, 0, 130, 1],
                ivory: [255, 255, 240, 1],
                khaki: [240, 230, 140, 1],
                lavender: [230, 230, 250, 1],
                lavenderblush: [255, 240, 245, 1],
                lawngreen: [124, 252, 0, 1],
                lemonchiffon: [255, 250, 205, 1],
                lightblue: [173, 216, 230, 1],
                lightcoral: [240, 128, 128, 1],
                lightcyan: [224, 255, 255, 1],
                lightgoldenrodyellow: [250, 250, 210, 1],
                lightgray: [211, 211, 211, 1],
                lightgreen: [144, 238, 144, 1],
                lightgrey: [211, 211, 211, 1],
                lightpink: [255, 182, 193, 1],
                lightsalmon: [255, 160, 122, 1],
                lightseagreen: [32, 178, 170, 1],
                lightskyblue: [135, 206, 250, 1],
                lightslategray: [119, 136, 153, 1],
                lightslategrey: [119, 136, 153, 1],
                lightsteelblue: [176, 196, 222, 1],
                lightyellow: [255, 255, 224, 1],
                lime: [0, 255, 0, 1],
                limegreen: [50, 205, 50, 1],
                linen: [250, 240, 230, 1],
                magenta: [255, 0, 255, 1],
                maroon: [128, 0, 0, 1],
                mediumaquamarine: [102, 205, 170, 1],
                mediumblue: [0, 0, 205, 1],
                mediumorchid: [186, 85, 211, 1],
                mediumpurple: [147, 112, 219, 1],
                mediumseagreen: [60, 179, 113, 1],
                mediumslateblue: [123, 104, 238, 1],
                mediumspringgreen: [0, 250, 154, 1],
                mediumturquoise: [72, 209, 204, 1],
                mediumvioletred: [199, 21, 133, 1],
                midnightblue: [25, 25, 112, 1],
                mintcream: [245, 255, 250, 1],
                mistyrose: [255, 228, 225, 1],
                moccasin: [255, 228, 181, 1],
                navajowhite: [255, 222, 173, 1],
                navy: [0, 0, 128, 1],
                oldlace: [253, 245, 230, 1],
                olive: [128, 128, 0, 1],
                olivedrab: [107, 142, 35, 1],
                orange: [255, 165, 0, 1],
                orangered: [255, 69, 0, 1],
                orchid: [218, 112, 214, 1],
                palegoldenrod: [238, 232, 170, 1],
                palegreen: [152, 251, 152, 1],
                paleturquoise: [175, 238, 238, 1],
                palevioletred: [219, 112, 147, 1],
                papayawhip: [255, 239, 213, 1],
                peachpuff: [255, 218, 185, 1],
                peru: [205, 133, 63, 1],
                pink: [255, 192, 203, 1],
                plum: [221, 160, 221, 1],
                powderblue: [176, 224, 230, 1],
                purple: [128, 0, 128, 1],
                rebeccapurple: [102, 51, 153, 1],
                red: [255, 0, 0, 1],
                rosybrown: [188, 143, 143, 1],
                royalblue: [65, 105, 225, 1],
                saddlebrown: [139, 69, 19, 1],
                salmon: [250, 128, 114, 1],
                sandybrown: [244, 164, 96, 1],
                seagreen: [46, 139, 87, 1],
                seashell: [255, 245, 238, 1],
                sienna: [160, 82, 45, 1],
                silver: [192, 192, 192, 1],
                skyblue: [135, 206, 235, 1],
                slateblue: [106, 90, 205, 1],
                slategray: [112, 128, 144, 1],
                slategrey: [112, 128, 144, 1],
                snow: [255, 250, 250, 1],
                springgreen: [0, 255, 127, 1],
                steelblue: [70, 130, 180, 1],
                tan: [210, 180, 140, 1],
                teal: [0, 128, 128, 1],
                thistle: [216, 191, 216, 1],
                tomato: [255, 99, 71, 1],
                turquoise: [64, 224, 208, 1],
                violet: [238, 130, 238, 1],
                wheat: [245, 222, 179, 1],
                white: [255, 255, 255, 1],
                whitesmoke: [245, 245, 245, 1],
                yellow: [255, 255, 0, 1],
                yellowgreen: [154, 205, 50, 1],
              };
            function _u(r) {
              return (r = Math.round(r)) < 0 ? 0 : r > 255 ? 255 : r;
            }
            function mc(r) {
              return _u(
                "%" === r[r.length - 1]
                  ? (parseFloat(r) / 100) * 255
                  : parseInt(r)
              );
            }
            function Ah(r) {
              return (i =
                "%" === r[r.length - 1] ? parseFloat(r) / 100 : parseFloat(r)) <
                0
                ? 0
                : i > 1
                ? 1
                : i;
              var i;
            }
            function Pr(r, i, o) {
              return (
                o < 0 ? (o += 1) : o > 1 && (o -= 1),
                6 * o < 1
                  ? r + (i - r) * o * 6
                  : 2 * o < 1
                  ? i
                  : 3 * o < 2
                  ? r + (i - r) * (2 / 3 - o) * 6
                  : r
              );
            }
            try {
              Dl = {}.parseCSSColor = function (r) {
                var i,
                  o = r.replace(/ /g, "").toLowerCase();
                if (o in Ar) return Ar[o].slice();
                if ("#" === o[0])
                  return 4 === o.length
                    ? (i = parseInt(o.substr(1), 16)) >= 0 && i <= 4095
                      ? [
                          ((3840 & i) >> 4) | ((3840 & i) >> 8),
                          (240 & i) | ((240 & i) >> 4),
                          (15 & i) | ((15 & i) << 4),
                          1,
                        ]
                      : null
                    : 7 === o.length &&
                      (i = parseInt(o.substr(1), 16)) >= 0 &&
                      i <= 16777215
                    ? [(16711680 & i) >> 16, (65280 & i) >> 8, 255 & i, 1]
                    : null;
                var l = o.indexOf("("),
                  h = o.indexOf(")");
                if (-1 !== l && h + 1 === o.length) {
                  var m = o.substr(0, l),
                    _ = o.substr(l + 1, h - (l + 1)).split(","),
                    x = 1;
                  switch (m) {
                    case "rgba":
                      if (4 !== _.length) return null;
                      x = Ah(_.pop());
                    case "rgb":
                      return 3 !== _.length
                        ? null
                        : [mc(_[0]), mc(_[1]), mc(_[2]), x];
                    case "hsla":
                      if (4 !== _.length) return null;
                      x = Ah(_.pop());
                    case "hsl":
                      if (3 !== _.length) return null;
                      var E = (((parseFloat(_[0]) % 360) + 360) % 360) / 360,
                        T = Ah(_[1]),
                        C = Ah(_[2]),
                        A = C <= 0.5 ? C * (T + 1) : C + T - C * T,
                        L = 2 * C - A;
                      return [
                        _u(255 * Pr(L, A, E + 1 / 3)),
                        _u(255 * Pr(L, A, E)),
                        _u(255 * Pr(L, A, E - 1 / 3)),
                        x,
                      ];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch {}
            class $r {
              constructor(i, o, l, h = 1) {
                (this.r = i), (this.g = o), (this.b = l), (this.a = h);
              }
              static parse(i) {
                if (!i) return;
                if (i instanceof $r) return i;
                if ("string" != typeof i) return;
                const o = Dl(i);
                return o
                  ? new $r(
                      (o[0] / 255) * o[3],
                      (o[1] / 255) * o[3],
                      (o[2] / 255) * o[3],
                      o[3]
                    )
                  : void 0;
              }
              toString() {
                const [i, o, l, h] = this.toArray();
                return `rgba(${Math.round(
                  i
                )},${Math.round(o)},${Math.round(l)},${h})`;
              }
              toArray() {
                const { r: i, g: o, b: l, a: h } = this;
                return 0 === h
                  ? [0, 0, 0, 0]
                  : [(255 * i) / h, (255 * o) / h, (255 * l) / h, h];
              }
              toArray01() {
                const { r: i, g: o, b: l, a: h } = this;
                return 0 === h ? [0, 0, 0, 0] : [i / h, o / h, l / h, h];
              }
              toArray01PremultipliedAlpha() {
                const { r: i, g: o, b: l, a: h } = this;
                return [i, o, l, h];
              }
            }
            ($r.black = new $r(0, 0, 0, 1)),
              ($r.white = new $r(1, 1, 1, 1)),
              ($r.transparent = new $r(0, 0, 0, 0)),
              ($r.red = new $r(1, 0, 0, 1)),
              ($r.blue = new $r(0, 0, 1, 1));
            var di = $r;
            class sp {
              constructor(i, o, l) {
                (this.sensitivity = i
                  ? o
                    ? "variant"
                    : "case"
                  : o
                  ? "accent"
                  : "base"),
                  (this.locale = l),
                  (this.collator = new Intl.Collator(
                    this.locale ? this.locale : [],
                    { sensitivity: this.sensitivity, usage: "search" }
                  ));
              }
              compare(i, o) {
                return this.collator.compare(i, o);
              }
              resolvedLocale() {
                return new Intl.Collator(
                  this.locale ? this.locale : []
                ).resolvedOptions().locale;
              }
            }
            class ap {
              constructor(i, o, l, h, m) {
                (this.text = i.normalize ? i.normalize() : i),
                  (this.image = o),
                  (this.scale = l),
                  (this.fontStack = h),
                  (this.textColor = m);
              }
            }
            class Lr {
              constructor(i) {
                this.sections = i;
              }
              static fromString(i) {
                return new Lr([new ap(i, null, null, null, null)]);
              }
              isEmpty() {
                return (
                  0 === this.sections.length ||
                  !this.sections.some(
                    (i) =>
                      0 !== i.text.length ||
                      (i.image && 0 !== i.image.name.length)
                  )
                );
              }
              static factory(i) {
                return i instanceof Lr ? i : Lr.fromString(i);
              }
              toString() {
                return 0 === this.sections.length
                  ? ""
                  : this.sections.map((i) => i.text).join("");
              }
              serialize() {
                const i = ["format"];
                for (const o of this.sections) {
                  if (o.image) {
                    i.push(["image", o.image.name]);
                    continue;
                  }
                  i.push(o.text);
                  const l = {};
                  o.fontStack &&
                    (l["text-font"] = ["literal", o.fontStack.split(",")]),
                    o.scale && (l["font-scale"] = o.scale),
                    o.textColor &&
                      (l["text-color"] = ["rgba"].concat(
                        o.textColor.toArray()
                      )),
                    i.push(l);
                }
                return i;
              }
            }
            class go {
              constructor(i) {
                (this.name = i.name), (this.available = i.available);
              }
              toString() {
                return this.name;
              }
              static fromString(i) {
                return i ? new go({ name: i, available: !1 }) : null;
              }
              serialize() {
                return ["image", this.name];
              }
            }
            function lp(r, i, o, l) {
              return "number" == typeof r &&
                r >= 0 &&
                r <= 255 &&
                "number" == typeof i &&
                i >= 0 &&
                i <= 255 &&
                "number" == typeof o &&
                o >= 0 &&
                o <= 255
                ? void 0 === l || ("number" == typeof l && l >= 0 && l <= 1)
                  ? null
                  : `Invalid rgba value [${[r, i, o, l].join(
                      ", "
                    )}]: 'a' must be between 0 and 1.`
                : `Invalid rgba value [${("number" == typeof l
                    ? [r, i, o, l]
                    : [r, i, o]
                  ).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
            }
            function yu(r) {
              if (
                null === r ||
                "string" == typeof r ||
                "boolean" == typeof r ||
                "number" == typeof r ||
                r instanceof di ||
                r instanceof sp ||
                r instanceof Lr ||
                r instanceof go
              )
                return !0;
              if (Array.isArray(r)) {
                for (const i of r) if (!yu(i)) return !1;
                return !0;
              }
              if ("object" == typeof r) {
                for (const i in r) if (!yu(r[i])) return !1;
                return !0;
              }
              return !1;
            }
            function un(r) {
              if (null === r) return wn;
              if ("string" == typeof r) return _t;
              if ("boolean" == typeof r) return Vt;
              if ("number" == typeof r) return it;
              if (r instanceof di) return Ur;
              if (r instanceof sp) return mr;
              if (r instanceof Lr) return mu;
              if (r instanceof go) return rt;
              if (Array.isArray(r)) {
                const i = r.length;
                let o;
                for (const l of r) {
                  const h = un(l);
                  if (o) {
                    if (o === h) continue;
                    o = tt;
                    break;
                  }
                  o = h;
                }
                return gr(o || tt, i);
              }
              return Mr;
            }
            function pn(r) {
              const i = typeof r;
              return null === r
                ? ""
                : "string" === i || "number" === i || "boolean" === i
                ? String(r)
                : r instanceof di || r instanceof Lr || r instanceof go
                ? r.toString()
                : JSON.stringify(r);
            }
            class cp {
              constructor(i, o) {
                (this.type = i), (this.value = o);
              }
              static parse(i, o) {
                if (2 !== i.length)
                  return o.error(
                    `'literal' expression requires exactly one argument, but found ${
                      i.length - 1
                    } instead.`
                  );
                if (!yu(i[1])) return o.error("invalid value");
                const l = i[1];
                let h = un(l);
                const m = o.expectedType;
                return (
                  "array" !== h.kind ||
                    0 !== h.N ||
                    !m ||
                    "array" !== m.kind ||
                    ("number" == typeof m.N && 0 !== m.N) ||
                    (h = m),
                  new cp(h, l)
                );
              }
              evaluate() {
                return this.value;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return "array" === this.type.kind || "object" === this.type.kind
                  ? ["literal", this.value]
                  : this.value instanceof di
                  ? ["rgba"].concat(this.value.toArray())
                  : this.value instanceof Lr
                  ? this.value.serialize()
                  : this.value;
              }
            }
            var Sl = cp,
              ir = class {
                constructor(r) {
                  (this.name = "ExpressionEvaluationError"), (this.message = r);
                }
                toJSON() {
                  return this.message;
                }
              };
            const Sn = { string: _t, number: it, boolean: Vt, object: Mr };
            class up {
              constructor(i, o) {
                (this.type = i), (this.args = o);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expected at least one argument.");
                let l,
                  h = 1;
                const m = i[0];
                if ("array" === m) {
                  let x, E;
                  if (i.length > 2) {
                    const T = i[1];
                    if ("string" != typeof T || !(T in Sn) || "object" === T)
                      return o.error(
                        'The item type argument of "array" must be one of string, number, boolean',
                        1
                      );
                    (x = Sn[T]), h++;
                  } else x = tt;
                  if (i.length > 3) {
                    if (
                      null !== i[2] &&
                      ("number" != typeof i[2] ||
                        i[2] < 0 ||
                        i[2] !== Math.floor(i[2]))
                    )
                      return o.error(
                        'The length argument to "array" must be a positive integer literal',
                        2
                      );
                    (E = i[2]), h++;
                  }
                  l = gr(x, E);
                } else l = Sn[m];
                const _ = [];
                for (; h < i.length; h++) {
                  const x = o.parse(i[h], h, tt);
                  if (!x) return null;
                  _.push(x);
                }
                return new up(l, _);
              }
              evaluate(i) {
                for (let o = 0; o < this.args.length; o++) {
                  const l = this.args[o].evaluate(i);
                  if (!hs(this.type, un(l))) return l;
                  if (o === this.args.length - 1)
                    throw new ir(
                      `Expected value to be of type ${pt(
                        this.type
                      )}, but found ${pt(un(l))} instead.`
                    );
                }
                return null;
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return this.args.every((i) => i.outputDefined());
              }
              serialize() {
                const i = this.type,
                  o = [i.kind];
                if ("array" === i.kind) {
                  const l = i.itemType;
                  if (
                    "string" === l.kind ||
                    "number" === l.kind ||
                    "boolean" === l.kind
                  ) {
                    o.push(l.kind);
                    const h = i.N;
                    ("number" == typeof h || this.args.length > 1) && o.push(h);
                  }
                }
                return o.concat(this.args.map((l) => l.serialize()));
              }
            }
            var Jn = up;
            class _o {
              constructor(i) {
                (this.type = mu), (this.sections = i);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expected at least one argument.");
                const l = i[1];
                if (!Array.isArray(l) && "object" == typeof l)
                  return o.error(
                    "First argument must be an image or text section."
                  );
                const h = [];
                let m = !1;
                for (let _ = 1; _ <= i.length - 1; ++_) {
                  const x = i[_];
                  if (m && "object" == typeof x && !Array.isArray(x)) {
                    m = !1;
                    let E = null;
                    if (
                      x["font-scale"] &&
                      ((E = o.parse(x["font-scale"], 1, it)), !E)
                    )
                      return null;
                    let T = null;
                    if (
                      x["text-font"] &&
                      ((T = o.parse(x["text-font"], 1, gr(_t))), !T)
                    )
                      return null;
                    let C = null;
                    if (
                      x["text-color"] &&
                      ((C = o.parse(x["text-color"], 1, Ur)), !C)
                    )
                      return null;
                    const A = h[h.length - 1];
                    (A.scale = E), (A.font = T), (A.textColor = C);
                  } else {
                    const E = o.parse(i[_], 1, tt);
                    if (!E) return null;
                    const T = E.type.kind;
                    if (
                      "string" !== T &&
                      "value" !== T &&
                      "null" !== T &&
                      "resolvedImage" !== T
                    )
                      return o.error(
                        "Formatted text type must be 'string', 'value', 'image' or 'null'."
                      );
                    (m = !0),
                      h.push({
                        content: E,
                        scale: null,
                        font: null,
                        textColor: null,
                      });
                  }
                }
                return new _o(h);
              }
              evaluate(i) {
                return new Lr(
                  this.sections.map((o) => {
                    const l = o.content.evaluate(i);
                    return un(l) === rt
                      ? new ap("", l, null, null, null)
                      : new ap(
                          pn(l),
                          null,
                          o.scale ? o.scale.evaluate(i) : null,
                          o.font ? o.font.evaluate(i).join(",") : null,
                          o.textColor ? o.textColor.evaluate(i) : null
                        );
                  })
                );
              }
              eachChild(i) {
                for (const o of this.sections)
                  i(o.content),
                    o.scale && i(o.scale),
                    o.font && i(o.font),
                    o.textColor && i(o.textColor);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = ["format"];
                for (const o of this.sections) {
                  i.push(o.content.serialize());
                  const l = {};
                  o.scale && (l["font-scale"] = o.scale.serialize()),
                    o.font && (l["text-font"] = o.font.serialize()),
                    o.textColor && (l["text-color"] = o.textColor.serialize()),
                    i.push(l);
                }
                return i;
              }
            }
            class Ph {
              constructor(i) {
                (this.type = rt), (this.input = i);
              }
              static parse(i, o) {
                if (2 !== i.length) return o.error("Expected two arguments.");
                const l = o.parse(i[1], 1, _t);
                return l ? new Ph(l) : o.error("No image name provided.");
              }
              evaluate(i) {
                const o = this.input.evaluate(i),
                  l = go.fromString(o);
                return (
                  l &&
                    i.availableImages &&
                    (l.available = i.availableImages.indexOf(o) > -1),
                  l
                );
              }
              eachChild(i) {
                i(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["image", this.input.serialize()];
              }
            }
            const hp = {
              "to-boolean": Vt,
              "to-color": Ur,
              "to-number": it,
              "to-string": _t,
            };
            class Lh {
              constructor(i, o) {
                (this.type = i), (this.args = o);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expected at least one argument.");
                const l = i[0];
                if (("to-boolean" === l || "to-string" === l) && 2 !== i.length)
                  return o.error("Expected one argument.");
                const h = hp[l],
                  m = [];
                for (let _ = 1; _ < i.length; _++) {
                  const x = o.parse(i[_], _, tt);
                  if (!x) return null;
                  m.push(x);
                }
                return new Lh(h, m);
              }
              evaluate(i) {
                if ("boolean" === this.type.kind)
                  return Boolean(this.args[0].evaluate(i));
                if ("color" === this.type.kind) {
                  let o, l;
                  for (const h of this.args) {
                    if (((o = h.evaluate(i)), (l = null), o instanceof di))
                      return o;
                    if ("string" == typeof o) {
                      const m = i.parseColor(o);
                      if (m) return m;
                    } else if (
                      Array.isArray(o) &&
                      ((l =
                        o.length < 3 || o.length > 4
                          ? `Invalid rbga value ${JSON.stringify(
                              o
                            )}: expected an array containing either three or four numeric values.`
                          : lp(o[0], o[1], o[2], o[3])),
                      !l)
                    )
                      return new di(o[0] / 255, o[1] / 255, o[2] / 255, o[3]);
                  }
                  throw new ir(
                    l ||
                      `Could not parse color from value '${
                        "string" == typeof o ? o : String(JSON.stringify(o))
                      }'`
                  );
                }
                if ("number" === this.type.kind) {
                  let o = null;
                  for (const l of this.args) {
                    if (((o = l.evaluate(i)), null === o)) return 0;
                    const h = Number(o);
                    if (!isNaN(h)) return h;
                  }
                  throw new ir(
                    `Could not convert ${JSON.stringify(o)} to number.`
                  );
                }
                return "formatted" === this.type.kind
                  ? Lr.fromString(pn(this.args[0].evaluate(i)))
                  : "resolvedImage" === this.type.kind
                  ? go.fromString(pn(this.args[0].evaluate(i)))
                  : pn(this.args[0].evaluate(i));
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return this.args.every((i) => i.outputDefined());
              }
              serialize() {
                if ("formatted" === this.type.kind)
                  return new _o([
                    {
                      content: this.args[0],
                      scale: null,
                      font: null,
                      textColor: null,
                    },
                  ]).serialize();
                if ("resolvedImage" === this.type.kind)
                  return new Ph(this.args[0]).serialize();
                const i = [`to-${this.type.kind}`];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            var Il = Lh;
            const yo = ["Unknown", "Point", "LineString", "Polygon"];
            var Cl = class {
              constructor() {
                (this.globals = null),
                  (this.feature = null),
                  (this.featureState = null),
                  (this.formattedSection = null),
                  (this._parseColorCache = {}),
                  (this.availableImages = null),
                  (this.canonical = null),
                  (this.featureTileCoord = null),
                  (this.featureDistanceData = null);
              }
              id() {
                return this.feature && void 0 !== this.feature.id
                  ? this.feature.id
                  : null;
              }
              geometryType() {
                return this.feature
                  ? "number" == typeof this.feature.type
                    ? yo[this.feature.type]
                    : this.feature.type
                  : null;
              }
              geometry() {
                return this.feature && "geometry" in this.feature
                  ? this.feature.geometry
                  : null;
              }
              canonicalID() {
                return this.canonical;
              }
              properties() {
                return (this.feature && this.feature.properties) || {};
              }
              distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                  const r = this.featureDistanceData.center,
                    i = this.featureDistanceData.scale,
                    { x: o, y: l } = this.featureTileCoord;
                  return (
                    this.featureDistanceData.bearing[0] * (o * i - r[0]) +
                    this.featureDistanceData.bearing[1] * (l * i - r[1])
                  );
                }
                return 0;
              }
              parseColor(r) {
                let i = this._parseColorCache[r];
                return i || (i = this._parseColorCache[r] = di.parse(r)), i;
              }
            };
            class ds {
              constructor(i, o, l, h) {
                (this.name = i),
                  (this.type = o),
                  (this._evaluate = l),
                  (this.args = h);
              }
              evaluate(i) {
                return this._evaluate(i, this.args);
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return [this.name].concat(this.args.map((i) => i.serialize()));
              }
              static parse(i, o) {
                const l = i[0],
                  h = ds.definitions[l];
                if (!h)
                  return o.error(
                    `Unknown expression "${l}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                const m = Array.isArray(h) ? h[0] : h.type,
                  _ = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads,
                  x = _.filter(
                    ([T]) => !Array.isArray(T) || T.length === i.length - 1
                  );
                let E = null;
                for (const [T, C] of x) {
                  E = new Oh(o.registry, o.path, null, o.scope);
                  const A = [];
                  let L = !1;
                  for (let O = 1; O < i.length; O++) {
                    const F = i[O],
                      V = Array.isArray(T) ? T[O - 1] : T.type,
                      G = E.parse(F, 1 + A.length, V);
                    if (!G) {
                      L = !0;
                      break;
                    }
                    A.push(G);
                  }
                  if (!L)
                    if (Array.isArray(T) && T.length !== A.length)
                      E.error(
                        `Expected ${T.length} arguments, but found ${A.length} instead.`
                      );
                    else {
                      for (let O = 0; O < A.length; O++) {
                        const F = Array.isArray(T) ? T[O] : T.type,
                          V = A[O];
                        E.concat(O + 1).checkSubtype(F, V.type);
                      }
                      if (0 === E.errors.length) return new ds(l, m, C, A);
                    }
                }
                if (1 === x.length) o.errors.push(...E.errors);
                else {
                  const T = (x.length ? x : _)
                      .map(([A]) => {
                        return (
                          (L = A),
                          Array.isArray(L)
                            ? `(${L.map(pt).join(", ")})`
                            : `(${pt(L.type)}...)`
                        );
                        var L;
                      })
                      .join(" | "),
                    C = [];
                  for (let A = 1; A < i.length; A++) {
                    const L = o.parse(i[A], 1 + C.length);
                    if (!L) return null;
                    C.push(pt(L.type));
                  }
                  o.error(
                    `Expected arguments of type ${T}, but found (${C.join(
                      ", "
                    )}) instead.`
                  );
                }
                return null;
              }
              static register(i, o) {
                ds.definitions = o;
                for (const l in o) i[l] = ds;
              }
            }
            var Uo = ds;
            class gc {
              constructor(i, o, l) {
                (this.type = mr),
                  (this.locale = l),
                  (this.caseSensitive = i),
                  (this.diacriticSensitive = o);
              }
              static parse(i, o) {
                if (2 !== i.length) return o.error("Expected one argument.");
                const l = i[1];
                if ("object" != typeof l || Array.isArray(l))
                  return o.error(
                    "Collator options argument must be an object."
                  );
                const h = o.parse(
                  void 0 !== l["case-sensitive"] && l["case-sensitive"],
                  1,
                  Vt
                );
                if (!h) return null;
                const m = o.parse(
                  void 0 !== l["diacritic-sensitive"] &&
                    l["diacritic-sensitive"],
                  1,
                  Vt
                );
                if (!m) return null;
                let _ = null;
                return l.locale && ((_ = o.parse(l.locale, 1, _t)), !_)
                  ? null
                  : new gc(h, m, _);
              }
              evaluate(i) {
                return new sp(
                  this.caseSensitive.evaluate(i),
                  this.diacriticSensitive.evaluate(i),
                  this.locale ? this.locale.evaluate(i) : null
                );
              }
              eachChild(i) {
                i(this.caseSensitive),
                  i(this.diacriticSensitive),
                  this.locale && i(this.locale);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = {};
                return (
                  (i["case-sensitive"] = this.caseSensitive.serialize()),
                  (i["diacritic-sensitive"] =
                    this.diacriticSensitive.serialize()),
                  this.locale && (i.locale = this.locale.serialize()),
                  ["collator", i]
                );
              }
            }
            const Tt = 8192;
            function Ml(r, i) {
              (r[0] = Math.min(r[0], i[0])),
                (r[1] = Math.min(r[1], i[1])),
                (r[2] = Math.max(r[2], i[0])),
                (r[3] = Math.max(r[3], i[1]));
            }
            function Al(r, i) {
              return !(
                r[0] <= i[0] ||
                r[2] >= i[2] ||
                r[1] <= i[1] ||
                r[3] >= i[3]
              );
            }
            function rr(r, i) {
              const o = (180 + r[0]) / 360,
                l =
                  (180 -
                    (180 / Math.PI) *
                      Math.log(
                        Math.tan(Math.PI / 4 + (r[1] * Math.PI) / 360)
                      )) /
                  360,
                h = Math.pow(2, i.z);
              return [Math.round(o * h * Tt), Math.round(l * h * Tt)];
            }
            function kh(r, i, o) {
              const l = r[0] - i[0],
                h = r[1] - i[1],
                m = r[0] - o[0],
                _ = r[1] - o[1];
              return l * _ - m * h == 0 && l * m <= 0 && h * _ <= 0;
            }
            function Rh(r, i) {
              let o = !1;
              for (let _ = 0, x = i.length; _ < x; _++) {
                const E = i[_];
                for (let T = 0, C = E.length; T < C - 1; T++) {
                  if (kh(r, E[T], E[T + 1])) return !1;
                  (h = E[T])[1] > (l = r)[1] != (m = E[T + 1])[1] > l[1] &&
                    l[0] <
                      ((m[0] - h[0]) * (l[1] - h[1])) / (m[1] - h[1]) + h[0] &&
                    (o = !o);
                }
              }
              var l, h, m;
              return o;
            }
            function $o(r, i) {
              for (let o = 0; o < i.length; o++) if (Rh(r, i[o])) return !0;
              return !1;
            }
            function Hr(r, i, o, l) {
              const h = l[0] - o[0],
                m = l[1] - o[1],
                _ = (r[0] - o[0]) * m - h * (r[1] - o[1]),
                x = (i[0] - o[0]) * m - h * (i[1] - o[1]);
              return (_ > 0 && x < 0) || (_ < 0 && x > 0);
            }
            function _c(r, i, o) {
              for (const T of o)
                for (let C = 0; C < T.length - 1; ++C)
                  if (
                    (x = [(_ = T[C + 1])[0] - (m = T[C])[0], _[1] - m[1]])[0] *
                      (E = [(h = i)[0] - (l = r)[0], h[1] - l[1]])[1] -
                      x[1] * E[0] !=
                      0 &&
                    Hr(l, h, m, _) &&
                    Hr(m, _, l, h)
                  )
                    return !0;
              var l, h, m, _, x, E;
              return !1;
            }
            function yn(r, i) {
              for (let o = 0; o < r.length; ++o) if (!Rh(r[o], i)) return !1;
              for (let o = 0; o < r.length - 1; ++o)
                if (_c(r[o], r[o + 1], i)) return !1;
              return !0;
            }
            function vo(r, i) {
              for (let o = 0; o < i.length; o++) if (yn(r, i[o])) return !0;
              return !1;
            }
            function jn(r, i, o) {
              const l = [];
              for (let h = 0; h < r.length; h++) {
                const m = [];
                for (let _ = 0; _ < r[h].length; _++) {
                  const x = rr(r[h][_], o);
                  Ml(i, x), m.push(x);
                }
                l.push(m);
              }
              return l;
            }
            function kf(r, i, o) {
              const l = [];
              for (let h = 0; h < r.length; h++) {
                const m = jn(r[h], i, o);
                l.push(m);
              }
              return l;
            }
            function dp(r, i, o, l) {
              if (r[0] < o[0] || r[0] > o[2]) {
                const h = 0.5 * l;
                let m = r[0] - o[0] > h ? -l : o[0] - r[0] > h ? l : 0;
                0 === m && (m = r[0] - o[2] > h ? -l : o[2] - r[0] > h ? l : 0),
                  (r[0] += m);
              }
              Ml(i, r);
            }
            function Oa(r, i, o, l) {
              const h = Math.pow(2, l.z) * Tt,
                m = [l.x * Tt, l.y * Tt],
                _ = [];
              if (!r) return _;
              for (const x of r)
                for (const E of x) {
                  const T = [E.x + m[0], E.y + m[1]];
                  dp(T, i, o, h), _.push(T);
                }
              return _;
            }
            function vn(r, i, o, l) {
              const h = Math.pow(2, l.z) * Tt,
                m = [l.x * Tt, l.y * Tt],
                _ = [];
              if (!r) return _;
              for (const E of r) {
                const T = [];
                for (const C of E) {
                  const A = [C.x + m[0], C.y + m[1]];
                  Ml(i, A), T.push(A);
                }
                _.push(T);
              }
              if (i[2] - i[0] <= h / 2) {
                ((x = i)[0] = x[1] = 1 / 0), (x[2] = x[3] = -1 / 0);
                for (const E of _) for (const T of E) dp(T, i, o, h);
              }
              var x;
              return _;
            }
            class ps {
              constructor(i, o) {
                (this.type = Vt), (this.geojson = i), (this.geometries = o);
              }
              static parse(i, o) {
                if (2 !== i.length)
                  return o.error(
                    `'within' expression requires exactly one argument, but found ${
                      i.length - 1
                    } instead.`
                  );
                if (yu(i[1])) {
                  const l = i[1];
                  if ("FeatureCollection" === l.type)
                    for (let h = 0; h < l.features.length; ++h) {
                      const m = l.features[h].geometry.type;
                      if ("Polygon" === m || "MultiPolygon" === m)
                        return new ps(l, l.features[h].geometry);
                    }
                  else if ("Feature" === l.type) {
                    const h = l.geometry.type;
                    if ("Polygon" === h || "MultiPolygon" === h)
                      return new ps(l, l.geometry);
                  } else if ("Polygon" === l.type || "MultiPolygon" === l.type)
                    return new ps(l, l);
                }
                return o.error(
                  "'within' expression requires valid geojson object that contains polygon geometry type."
                );
              }
              evaluate(i) {
                if (null != i.geometry() && null != i.canonicalID()) {
                  if ("Point" === i.geometryType())
                    return (function (o, l) {
                      const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        m = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        _ = o.canonicalID();
                      if (!_) return !1;
                      if ("Polygon" === l.type) {
                        const x = jn(l.coordinates, m, _),
                          E = Oa(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!Rh(T, x)) return !1;
                      }
                      if ("MultiPolygon" === l.type) {
                        const x = kf(l.coordinates, m, _),
                          E = Oa(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!$o(T, x)) return !1;
                      }
                      return !0;
                    })(i, this.geometries);
                  if ("LineString" === i.geometryType())
                    return (function (o, l) {
                      const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        m = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        _ = o.canonicalID();
                      if (!_) return !1;
                      if ("Polygon" === l.type) {
                        const x = jn(l.coordinates, m, _),
                          E = vn(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!yn(T, x)) return !1;
                      }
                      if ("MultiPolygon" === l.type) {
                        const x = kf(l.coordinates, m, _),
                          E = vn(o.geometry(), h, m, _);
                        if (!Al(h, m)) return !1;
                        for (const T of E) if (!vo(T, x)) return !1;
                      }
                      return !0;
                    })(i, this.geometries);
                }
                return !1;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return ["within", this.geojson];
              }
            }
            var Pl = ps;
            function Us(r) {
              if (
                (r instanceof Uo &&
                  (("get" === r.name && 1 === r.args.length) ||
                    "feature-state" === r.name ||
                    ("has" === r.name && 1 === r.args.length) ||
                    "properties" === r.name ||
                    "geometry-type" === r.name ||
                    "id" === r.name ||
                    /^filter-/.test(r.name))) ||
                r instanceof Pl
              )
                return !1;
              let i = !0;
              return (
                r.eachChild((o) => {
                  i && !Us(o) && (i = !1);
                }),
                i
              );
            }
            function Ho(r) {
              if (r instanceof Uo && "feature-state" === r.name) return !1;
              let i = !0;
              return (
                r.eachChild((o) => {
                  i && !Ho(o) && (i = !1);
                }),
                i
              );
            }
            function _r(r, i) {
              if (r instanceof Uo && i.indexOf(r.name) >= 0) return !1;
              let o = !0;
              return (
                r.eachChild((l) => {
                  o && !_r(l, i) && (o = !1);
                }),
                o
              );
            }
            class $s {
              constructor(i, o) {
                (this.type = o.type),
                  (this.name = i),
                  (this.boundExpression = o);
              }
              static parse(i, o) {
                if (2 !== i.length || "string" != typeof i[1])
                  return o.error(
                    "'var' expression requires exactly one string literal argument."
                  );
                const l = i[1];
                return o.scope.has(l)
                  ? new $s(l, o.scope.get(l))
                  : o.error(
                      `Unknown variable "${l}". Make sure "${l}" has been bound in an enclosing "let" expression before using it.`,
                      1
                    );
              }
              evaluate(i) {
                return this.boundExpression.evaluate(i);
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["var", this.name];
              }
            }
            var pp = $s;
            class xo {
              constructor(i, o = [], l, h = new fu(), m = []) {
                (this.registry = i),
                  (this.path = o),
                  (this.key = o.map((_) => `[${_}]`).join("")),
                  (this.scope = h),
                  (this.errors = m),
                  (this.expectedType = l);
              }
              parse(i, o, l, h, m = {}) {
                return o
                  ? this.concat(o, l, h)._parse(i, m)
                  : this._parse(i, m);
              }
              _parse(i, o) {
                function l(h, m, _) {
                  return "assert" === _
                    ? new Jn(m, [h])
                    : "coerce" === _
                    ? new Il(m, [h])
                    : h;
                }
                if (
                  ((null !== i &&
                    "string" != typeof i &&
                    "boolean" != typeof i &&
                    "number" != typeof i) ||
                    (i = ["literal", i]),
                  Array.isArray(i))
                ) {
                  if (0 === i.length)
                    return this.error(
                      'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'
                    );
                  const h = i[0];
                  if ("string" != typeof h)
                    return (
                      this.error(
                        `Expression name must be a string, but found ${typeof h} instead. If you wanted a literal array, use ["literal", [...]].`,
                        0
                      ),
                      null
                    );
                  const m = this.registry[h];
                  if (m) {
                    let _ = m.parse(i, this);
                    if (!_) return null;
                    if (this.expectedType) {
                      const x = this.expectedType,
                        E = _.type;
                      if (
                        ("string" !== x.kind &&
                          "number" !== x.kind &&
                          "boolean" !== x.kind &&
                          "object" !== x.kind &&
                          "array" !== x.kind) ||
                        "value" !== E.kind
                      )
                        if (
                          ("color" !== x.kind &&
                            "formatted" !== x.kind &&
                            "resolvedImage" !== x.kind) ||
                          ("value" !== E.kind && "string" !== E.kind)
                        ) {
                          if (this.checkSubtype(x, E)) return null;
                        } else _ = l(_, x, o.typeAnnotation || "coerce");
                      else _ = l(_, x, o.typeAnnotation || "assert");
                    }
                    if (
                      !(_ instanceof Sl) &&
                      "resolvedImage" !== _.type.kind &&
                      vu(_)
                    ) {
                      const x = new Cl();
                      try {
                        _ = new Sl(_.type, _.evaluate(x));
                      } catch (E) {
                        return this.error(E.message), null;
                      }
                    }
                    return _;
                  }
                  return this.error(
                    `Unknown expression "${h}". If you wanted a literal array, use ["literal", [...]].`,
                    0
                  );
                }
                return this.error(
                  void 0 === i
                    ? "'undefined' value invalid. Use null instead."
                    : "object" == typeof i
                    ? 'Bare objects invalid. Use ["literal", {...}] instead.'
                    : `Expected an array, but found ${typeof i} instead.`
                );
              }
              concat(i, o, l) {
                const h =
                    "number" == typeof i ? this.path.concat(i) : this.path,
                  m = l ? this.scope.concat(l) : this.scope;
                return new xo(this.registry, h, o || null, m, this.errors);
              }
              error(i, ...o) {
                const l = `${this.key}${o.map((h) => `[${h}]`).join("")}`;
                this.errors.push(new jo(l, i));
              }
              checkSubtype(i, o) {
                const l = hs(i, o);
                return l && this.error(l), l;
              }
            }
            var Oh = xo;
            function vu(r) {
              if (r instanceof pp) return vu(r.boundExpression);
              if (
                (r instanceof Uo && "error" === r.name) ||
                r instanceof gc ||
                r instanceof Pl
              )
                return !1;
              const i = r instanceof Il || r instanceof Jn;
              let o = !0;
              return (
                r.eachChild((l) => {
                  o = i ? o && vu(l) : o && l instanceof Sl;
                }),
                !!o &&
                  Us(r) &&
                  _r(r, [
                    "zoom",
                    "heatmap-density",
                    "line-progress",
                    "sky-radial-progress",
                    "accumulated",
                    "is-supported-script",
                    "pitch",
                    "distance-from-center",
                  ])
              );
            }
            function yc(r, i) {
              const o = r.length - 1;
              let l,
                h,
                m = 0,
                _ = o,
                x = 0;
              for (; m <= _; )
                if (
                  ((x = Math.floor((m + _) / 2)),
                  (l = r[x]),
                  (h = r[x + 1]),
                  l <= i)
                ) {
                  if (x === o || i < h) return x;
                  m = x + 1;
                } else {
                  if (!(l > i)) throw new ir("Input is not a number.");
                  _ = x - 1;
                }
              return 0;
            }
            class or {
              constructor(i, o, l) {
                (this.type = i),
                  (this.input = o),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [h, m] of l)
                  this.labels.push(h), this.outputs.push(m);
              }
              static parse(i, o) {
                if (i.length - 1 < 4)
                  return o.error(
                    `Expected at least 4 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if ((i.length - 1) % 2 != 0)
                  return o.error("Expected an even number of arguments.");
                const l = o.parse(i[1], 1, it);
                if (!l) return null;
                const h = [];
                let m = null;
                o.expectedType &&
                  "value" !== o.expectedType.kind &&
                  (m = o.expectedType);
                for (let _ = 1; _ < i.length; _ += 2) {
                  const x = 1 === _ ? -1 / 0 : i[_],
                    E = i[_ + 1],
                    T = _,
                    C = _ + 1;
                  if ("number" != typeof x)
                    return o.error(
                      'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      T
                    );
                  if (h.length && h[h.length - 1][0] >= x)
                    return o.error(
                      'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                      T
                    );
                  const A = o.parse(E, C, m);
                  if (!A) return null;
                  (m = m || A.type), h.push([x, A]);
                }
                return new or(m, l, h);
              }
              evaluate(i) {
                const o = this.labels,
                  l = this.outputs;
                if (1 === o.length) return l[0].evaluate(i);
                const h = this.input.evaluate(i);
                if (h <= o[0]) return l[0].evaluate(i);
                const m = o.length;
                return h >= o[m - 1]
                  ? l[m - 1].evaluate(i)
                  : l[yc(o, h)].evaluate(i);
              }
              eachChild(i) {
                i(this.input);
                for (const o of this.outputs) i(o);
              }
              outputDefined() {
                return this.outputs.every((i) => i.outputDefined());
              }
              serialize() {
                const i = ["step", this.input.serialize()];
                for (let o = 0; o < this.labels.length; o++)
                  o > 0 && i.push(this.labels[o]),
                    i.push(this.outputs[o].serialize());
                return i;
              }
            }
            var Fh = or;
            function rn(r, i, o) {
              return r * (1 - o) + i * o;
            }
            var Mi = Object.freeze({
              __proto__: null,
              array: function (r, i, o) {
                return r.map((l, h) => rn(l, i[h], o));
              },
              color: function (r, i, o) {
                return new di(
                  rn(r.r, i.r, o),
                  rn(r.g, i.g, o),
                  rn(r.b, i.b, o),
                  rn(r.a, i.a, o)
                );
              },
              number: rn,
            });
            const sr = 4 / 29,
              pi = 6 / 29,
              Fa = 3 * pi * pi,
              ro = Math.PI / 180,
              ht = 180 / Math.PI;
            function qt(r) {
              return r > 0.008856451679035631
                ? Math.pow(r, 1 / 3)
                : r / Fa + sr;
            }
            function $n(r) {
              return r > pi ? r * r * r : Fa * (r - sr);
            }
            function vr(r) {
              return (
                255 *
                (r <= 0.0031308
                  ? 12.92 * r
                  : 1.055 * Math.pow(r, 1 / 2.4) - 0.055)
              );
            }
            function Go(r) {
              return (r /= 255) <= 0.04045
                ? r / 12.92
                : Math.pow((r + 0.055) / 1.055, 2.4);
            }
            function Ai(r) {
              const i = Go(r.r),
                o = Go(r.g),
                l = Go(r.b),
                h = qt(
                  (0.4124564 * i + 0.3575761 * o + 0.1804375 * l) / 0.95047
                ),
                m = qt((0.2126729 * i + 0.7151522 * o + 0.072175 * l) / 1);
              return {
                l: 116 * m - 16,
                a: 500 * (h - m),
                b:
                  200 *
                  (m -
                    qt(
                      (0.0193339 * i + 0.119192 * o + 0.9503041 * l) / 1.08883
                    )),
                alpha: r.a,
              };
            }
            function Hs(r) {
              let i = (r.l + 16) / 116,
                o = isNaN(r.a) ? i : i + r.a / 500,
                l = isNaN(r.b) ? i : i - r.b / 200;
              return (
                (i = 1 * $n(i)),
                (o = 0.95047 * $n(o)),
                (l = 1.08883 * $n(l)),
                new di(
                  vr(3.2404542 * o - 1.5371385 * i - 0.4985314 * l),
                  vr(-0.969266 * o + 1.8760108 * i + 0.041556 * l),
                  vr(0.0556434 * o - 0.2040259 * i + 1.0572252 * l),
                  r.alpha
                )
              );
            }
            function ei(r, i, o) {
              const l = i - r;
              return (
                r +
                o * (l > 180 || l < -180 ? l - 360 * Math.round(l / 360) : l)
              );
            }
            const fs = {
                forward: Ai,
                reverse: Hs,
                interpolate: function (r, i, o) {
                  return {
                    l: rn(r.l, i.l, o),
                    a: rn(r.a, i.a, o),
                    b: rn(r.b, i.b, o),
                    alpha: rn(r.alpha, i.alpha, o),
                  };
                },
              },
              qo = {
                forward: function (r) {
                  const { l: i, a: o, b: l } = Ai(r),
                    h = Math.atan2(l, o) * ht;
                  return {
                    h: h < 0 ? h + 360 : h,
                    c: Math.sqrt(o * o + l * l),
                    l: i,
                    alpha: r.a,
                  };
                },
                reverse: function (r) {
                  const i = r.h * ro,
                    o = r.c;
                  return Hs({
                    l: r.l,
                    a: Math.cos(i) * o,
                    b: Math.sin(i) * o,
                    alpha: r.alpha,
                  });
                },
                interpolate: function (r, i, o) {
                  return {
                    h: ei(r.h, i.h, o),
                    c: rn(r.c, i.c, o),
                    l: rn(r.l, i.l, o),
                    alpha: rn(r.alpha, i.alpha, o),
                  };
                },
              };
            var Kt = Object.freeze({ __proto__: null, hcl: qo, lab: fs });
            class Gs {
              constructor(i, o, l, h, m) {
                (this.type = i),
                  (this.operator = o),
                  (this.interpolation = l),
                  (this.input = h),
                  (this.labels = []),
                  (this.outputs = []);
                for (const [_, x] of m)
                  this.labels.push(_), this.outputs.push(x);
              }
              static interpolationFactor(i, o, l, h) {
                let m = 0;
                if ("exponential" === i.name) m = qs(o, i.base, l, h);
                else if ("linear" === i.name) m = qs(o, 1, l, h);
                else if ("cubic-bezier" === i.name) {
                  const _ = i.controlPoints;
                  m = new Sa(_[0], _[1], _[2], _[3]).solve(qs(o, 1, l, h));
                }
                return m;
              }
              static parse(i, o) {
                let [l, h, m, ..._] = i;
                if (!Array.isArray(h) || 0 === h.length)
                  return o.error(
                    "Expected an interpolation type expression.",
                    1
                  );
                if ("linear" === h[0]) h = { name: "linear" };
                else if ("exponential" === h[0]) {
                  const T = h[1];
                  if ("number" != typeof T)
                    return o.error(
                      "Exponential interpolation requires a numeric base.",
                      1,
                      1
                    );
                  h = { name: "exponential", base: T };
                } else {
                  if ("cubic-bezier" !== h[0])
                    return o.error(
                      `Unknown interpolation type ${String(h[0])}`,
                      1,
                      0
                    );
                  {
                    const T = h.slice(1);
                    if (
                      4 !== T.length ||
                      T.some((C) => "number" != typeof C || C < 0 || C > 1)
                    )
                      return o.error(
                        "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                        1
                      );
                    h = { name: "cubic-bezier", controlPoints: T };
                  }
                }
                if (i.length - 1 < 4)
                  return o.error(
                    `Expected at least 4 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if ((i.length - 1) % 2 != 0)
                  return o.error("Expected an even number of arguments.");
                if (((m = o.parse(m, 2, it)), !m)) return null;
                const x = [];
                let E = null;
                "interpolate-hcl" === l || "interpolate-lab" === l
                  ? (E = Ur)
                  : o.expectedType &&
                    "value" !== o.expectedType.kind &&
                    (E = o.expectedType);
                for (let T = 0; T < _.length; T += 2) {
                  const C = _[T],
                    A = _[T + 1],
                    L = T + 3,
                    O = T + 4;
                  if ("number" != typeof C)
                    return o.error(
                      'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      L
                    );
                  if (x.length && x[x.length - 1][0] >= C)
                    return o.error(
                      'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                      L
                    );
                  const F = o.parse(A, O, E);
                  if (!F) return null;
                  (E = E || F.type), x.push([C, F]);
                }
                return "number" === E.kind ||
                  "color" === E.kind ||
                  ("array" === E.kind &&
                    "number" === E.itemType.kind &&
                    "number" == typeof E.N)
                  ? new Gs(E, l, h, m, x)
                  : o.error(`Type ${pt(E)} is not interpolatable.`);
              }
              evaluate(i) {
                const o = this.labels,
                  l = this.outputs;
                if (1 === o.length) return l[0].evaluate(i);
                const h = this.input.evaluate(i);
                if (h <= o[0]) return l[0].evaluate(i);
                const m = o.length;
                if (h >= o[m - 1]) return l[m - 1].evaluate(i);
                const _ = yc(o, h),
                  x = Gs.interpolationFactor(
                    this.interpolation,
                    h,
                    o[_],
                    o[_ + 1]
                  ),
                  E = l[_].evaluate(i),
                  T = l[_ + 1].evaluate(i);
                return "interpolate" === this.operator
                  ? Mi[this.type.kind.toLowerCase()](E, T, x)
                  : "interpolate-hcl" === this.operator
                  ? qo.reverse(qo.interpolate(qo.forward(E), qo.forward(T), x))
                  : fs.reverse(fs.interpolate(fs.forward(E), fs.forward(T), x));
              }
              eachChild(i) {
                i(this.input);
                for (const o of this.outputs) i(o);
              }
              outputDefined() {
                return this.outputs.every((i) => i.outputDefined());
              }
              serialize() {
                let i;
                i =
                  "linear" === this.interpolation.name
                    ? ["linear"]
                    : "exponential" === this.interpolation.name
                    ? 1 === this.interpolation.base
                      ? ["linear"]
                      : ["exponential", this.interpolation.base]
                    : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                const o = [this.operator, i, this.input.serialize()];
                for (let l = 0; l < this.labels.length; l++)
                  o.push(this.labels[l], this.outputs[l].serialize());
                return o;
              }
            }
            function qs(r, i, o, l) {
              const h = l - o,
                m = r - o;
              return 0 === h
                ? 0
                : 1 === i
                ? m / h
                : (Math.pow(i, m) - 1) / (Math.pow(i, h) - 1);
            }
            var oo = Gs;
            class Wo {
              constructor(i, o) {
                (this.type = i), (this.args = o);
              }
              static parse(i, o) {
                if (i.length < 2)
                  return o.error("Expectected at least one argument.");
                let l = null;
                const h = o.expectedType;
                h && "value" !== h.kind && (l = h);
                const m = [];
                for (const x of i.slice(1)) {
                  const E = o.parse(x, 1 + m.length, l, void 0, {
                    typeAnnotation: "omit",
                  });
                  if (!E) return null;
                  (l = l || E.type), m.push(E);
                }
                const _ = h && m.some((x) => hs(h, x.type));
                return new Wo(_ ? tt : l, m);
              }
              evaluate(i) {
                let o,
                  l = null,
                  h = 0;
                for (const m of this.args) {
                  if (
                    (h++,
                    (l = m.evaluate(i)),
                    l &&
                      l instanceof go &&
                      !l.available &&
                      (o || (o = l), (l = null), h === this.args.length))
                  )
                    return o;
                  if (null !== l) break;
                }
                return l;
              }
              eachChild(i) {
                this.args.forEach(i);
              }
              outputDefined() {
                return this.args.every((i) => i.outputDefined());
              }
              serialize() {
                const i = ["coalesce"];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            var Ni = Wo;
            class Ws {
              constructor(i, o) {
                (this.type = o.type),
                  (this.bindings = [].concat(i)),
                  (this.result = o);
              }
              evaluate(i) {
                return this.result.evaluate(i);
              }
              eachChild(i) {
                for (const o of this.bindings) i(o[1]);
                i(this.result);
              }
              static parse(i, o) {
                if (i.length < 4)
                  return o.error(
                    `Expected at least 3 arguments, but found ${
                      i.length - 1
                    } instead.`
                  );
                const l = [];
                for (let m = 1; m < i.length - 1; m += 2) {
                  const _ = i[m];
                  if ("string" != typeof _)
                    return o.error(
                      `Expected string, but found ${typeof _} instead.`,
                      m
                    );
                  if (/[^a-zA-Z0-9_]/.test(_))
                    return o.error(
                      "Variable names must contain only alphanumeric characters or '_'.",
                      m
                    );
                  const x = o.parse(i[m + 1], m + 1);
                  if (!x) return null;
                  l.push([_, x]);
                }
                const h = o.parse(
                  i[i.length - 1],
                  i.length - 1,
                  o.expectedType,
                  l
                );
                return h ? new Ws(l, h) : null;
              }
              outputDefined() {
                return this.result.outputDefined();
              }
              serialize() {
                const i = ["let"];
                for (const [o, l] of this.bindings) i.push(o, l.serialize());
                return i.push(this.result.serialize()), i;
              }
            }
            var Na = Ws;
            class qr {
              constructor(i, o, l) {
                (this.type = i), (this.index = o), (this.input = l);
              }
              static parse(i, o) {
                if (3 !== i.length)
                  return o.error(
                    `Expected 2 arguments, but found ${i.length - 1} instead.`
                  );
                const l = o.parse(i[1], 1, it),
                  h = o.parse(i[2], 2, gr(o.expectedType || tt));
                return l && h ? new qr(h.type.itemType, l, h) : null;
              }
              evaluate(i) {
                const o = this.index.evaluate(i),
                  l = this.input.evaluate(i);
                if (o < 0) throw new ir(`Array index out of bounds: ${o} < 0.`);
                if (o >= l.length)
                  throw new ir(
                    `Array index out of bounds: ${o} > ${l.length - 1}.`
                  );
                if (o !== Math.floor(o))
                  throw new ir(
                    `Array index must be an integer, but found ${o} instead.`
                  );
                return l[o];
              }
              eachChild(i) {
                i(this.index), i(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["at", this.index.serialize(), this.input.serialize()];
              }
            }
            var Ll = qr;
            class xu {
              constructor(i, o) {
                (this.type = Vt), (this.needle = i), (this.haystack = o);
              }
              static parse(i, o) {
                if (3 !== i.length)
                  return o.error(
                    `Expected 2 arguments, but found ${i.length - 1} instead.`
                  );
                const l = o.parse(i[1], 1, tt),
                  h = o.parse(i[2], 2, tt);
                return l && h
                  ? gu(l.type, [Vt, _t, it, wn, tt])
                    ? new xu(l, h)
                    : o.error(
                        `Expected first argument to be of type boolean, string, number or null, but found ${pt(
                          l.type
                        )} instead`
                      )
                  : null;
              }
              evaluate(i) {
                const o = this.needle.evaluate(i),
                  l = this.haystack.evaluate(i);
                if (null == l) return !1;
                if (!fc(o, ["boolean", "string", "number", "null"]))
                  throw new ir(
                    `Expected first argument to be of type boolean, string, number or null, but found ${pt(
                      un(o)
                    )} instead.`
                  );
                if (!fc(l, ["string", "array"]))
                  throw new ir(
                    `Expected second argument to be of type array or string, but found ${pt(
                      un(l)
                    )} instead.`
                  );
                return l.indexOf(o) >= 0;
              }
              eachChild(i) {
                i(this.needle), i(this.haystack);
              }
              outputDefined() {
                return !0;
              }
              serialize() {
                return [
                  "in",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            var On = xu;
            class vc {
              constructor(i, o, l) {
                (this.type = it),
                  (this.needle = i),
                  (this.haystack = o),
                  (this.fromIndex = l);
              }
              static parse(i, o) {
                if (i.length <= 2 || i.length >= 5)
                  return o.error(
                    `Expected 3 or 4 arguments, but found ${
                      i.length - 1
                    } instead.`
                  );
                const l = o.parse(i[1], 1, tt),
                  h = o.parse(i[2], 2, tt);
                if (!l || !h) return null;
                if (!gu(l.type, [Vt, _t, it, wn, tt]))
                  return o.error(
                    `Expected first argument to be of type boolean, string, number or null, but found ${pt(
                      l.type
                    )} instead`
                  );
                if (4 === i.length) {
                  const m = o.parse(i[3], 3, it);
                  return m ? new vc(l, h, m) : null;
                }
                return new vc(l, h);
              }
              evaluate(i) {
                const o = this.needle.evaluate(i),
                  l = this.haystack.evaluate(i);
                if (!fc(o, ["boolean", "string", "number", "null"]))
                  throw new ir(
                    `Expected first argument to be of type boolean, string, number or null, but found ${pt(
                      un(o)
                    )} instead.`
                  );
                if (!fc(l, ["string", "array"]))
                  throw new ir(
                    `Expected second argument to be of type array or string, but found ${pt(
                      un(l)
                    )} instead.`
                  );
                if (this.fromIndex) {
                  const h = this.fromIndex.evaluate(i);
                  return l.indexOf(o, h);
                }
                return l.indexOf(o);
              }
              eachChild(i) {
                i(this.needle),
                  i(this.haystack),
                  this.fromIndex && i(this.fromIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                  const i = this.fromIndex.serialize();
                  return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize(),
                    i,
                  ];
                }
                return [
                  "index-of",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            var fp = vc;
            class kl {
              constructor(i, o, l, h, m, _) {
                (this.inputType = i),
                  (this.type = o),
                  (this.input = l),
                  (this.cases = h),
                  (this.outputs = m),
                  (this.otherwise = _);
              }
              static parse(i, o) {
                if (i.length < 5)
                  return o.error(
                    `Expected at least 4 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if (i.length % 2 != 1)
                  return o.error("Expected an even number of arguments.");
                let l, h;
                o.expectedType &&
                  "value" !== o.expectedType.kind &&
                  (h = o.expectedType);
                const m = {},
                  _ = [];
                for (let T = 2; T < i.length - 1; T += 2) {
                  let C = i[T];
                  const A = i[T + 1];
                  Array.isArray(C) || (C = [C]);
                  const L = o.concat(T);
                  if (0 === C.length)
                    return L.error("Expected at least one branch label.");
                  for (const F of C) {
                    if ("number" != typeof F && "string" != typeof F)
                      return L.error(
                        "Branch labels must be numbers or strings."
                      );
                    if (
                      "number" == typeof F &&
                      Math.abs(F) > Number.MAX_SAFE_INTEGER
                    )
                      return L.error(
                        `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`
                      );
                    if ("number" == typeof F && Math.floor(F) !== F)
                      return L.error(
                        "Numeric branch labels must be integer values."
                      );
                    if (l) {
                      if (L.checkSubtype(l, un(F))) return null;
                    } else l = un(F);
                    if (void 0 !== m[String(F)])
                      return L.error("Branch labels must be unique.");
                    m[String(F)] = _.length;
                  }
                  const O = o.parse(A, T, h);
                  if (!O) return null;
                  (h = h || O.type), _.push(O);
                }
                const x = o.parse(i[1], 1, tt);
                if (!x) return null;
                const E = o.parse(i[i.length - 1], i.length - 1, h);
                return E
                  ? "value" !== x.type.kind &&
                    o.concat(1).checkSubtype(l, x.type)
                    ? null
                    : new kl(l, h, x, m, _, E)
                  : null;
              }
              evaluate(i) {
                const o = this.input.evaluate(i);
                return (
                  (un(o) === this.inputType && this.outputs[this.cases[o]]) ||
                  this.otherwise
                ).evaluate(i);
              }
              eachChild(i) {
                i(this.input), this.outputs.forEach(i), i(this.otherwise);
              }
              outputDefined() {
                return (
                  this.outputs.every((i) => i.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const i = ["match", this.input.serialize()],
                  o = Object.keys(this.cases).sort(),
                  l = [],
                  h = {};
                for (const _ of o) {
                  const x = h[this.cases[_]];
                  void 0 === x
                    ? ((h[this.cases[_]] = l.length),
                      l.push([this.cases[_], [_]]))
                    : l[x][1].push(_);
                }
                const m = (_) =>
                  "number" === this.inputType.kind ? Number(_) : _;
                for (const [_, x] of l)
                  i.push(1 === x.length ? m(x[0]) : x.map(m)),
                    i.push(this.outputs[_].serialize());
                return i.push(this.otherwise.serialize()), i;
              }
            }
            var Nh = kl;
            class za {
              constructor(i, o, l) {
                (this.type = i), (this.branches = o), (this.otherwise = l);
              }
              static parse(i, o) {
                if (i.length < 4)
                  return o.error(
                    `Expected at least 3 arguments, but found only ${
                      i.length - 1
                    }.`
                  );
                if (i.length % 2 != 0)
                  return o.error("Expected an odd number of arguments.");
                let l;
                o.expectedType &&
                  "value" !== o.expectedType.kind &&
                  (l = o.expectedType);
                const h = [];
                for (let _ = 1; _ < i.length - 1; _ += 2) {
                  const x = o.parse(i[_], _, Vt);
                  if (!x) return null;
                  const E = o.parse(i[_ + 1], _ + 1, l);
                  if (!E) return null;
                  h.push([x, E]), (l = l || E.type);
                }
                const m = o.parse(i[i.length - 1], i.length - 1, l);
                return m ? new za(l, h, m) : null;
              }
              evaluate(i) {
                for (const [o, l] of this.branches)
                  if (o.evaluate(i)) return l.evaluate(i);
                return this.otherwise.evaluate(i);
              }
              eachChild(i) {
                for (const [o, l] of this.branches) i(o), i(l);
                i(this.otherwise);
              }
              outputDefined() {
                return (
                  this.branches.every(([i, o]) => o.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const i = ["case"];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            var xc = za;
            class bo {
              constructor(i, o, l, h) {
                (this.type = i),
                  (this.input = o),
                  (this.beginIndex = l),
                  (this.endIndex = h);
              }
              static parse(i, o) {
                if (i.length <= 2 || i.length >= 5)
                  return o.error(
                    `Expected 3 or 4 arguments, but found ${
                      i.length - 1
                    } instead.`
                  );
                const l = o.parse(i[1], 1, tt),
                  h = o.parse(i[2], 2, it);
                if (!l || !h) return null;
                if (!gu(l.type, [gr(tt), _t, tt]))
                  return o.error(
                    `Expected first argument to be of type array or string, but found ${pt(
                      l.type
                    )} instead`
                  );
                if (4 === i.length) {
                  const m = o.parse(i[3], 3, it);
                  return m ? new bo(l.type, l, h, m) : null;
                }
                return new bo(l.type, l, h);
              }
              evaluate(i) {
                const o = this.input.evaluate(i),
                  l = this.beginIndex.evaluate(i);
                if (!fc(o, ["string", "array"]))
                  throw new ir(
                    `Expected first argument to be of type array or string, but found ${pt(
                      un(o)
                    )} instead.`
                  );
                if (this.endIndex) {
                  const h = this.endIndex.evaluate(i);
                  return o.slice(l, h);
                }
                return o.slice(l);
              }
              eachChild(i) {
                i(this.input),
                  i(this.beginIndex),
                  this.endIndex && i(this.endIndex);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                  const i = this.endIndex.serialize();
                  return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize(),
                    i,
                  ];
                }
                return [
                  "slice",
                  this.input.serialize(),
                  this.beginIndex.serialize(),
                ];
              }
            }
            var Ki = bo;
            function bu(r, i) {
              return "==" === r || "!=" === r
                ? "boolean" === i.kind ||
                    "string" === i.kind ||
                    "number" === i.kind ||
                    "null" === i.kind ||
                    "value" === i.kind
                : "string" === i.kind ||
                    "number" === i.kind ||
                    "value" === i.kind;
            }
            function xr(r, i, o, l) {
              return 0 === l.compare(i, o);
            }
            function ar(r, i, o) {
              const l = "==" !== r && "!=" !== r;
              return class gD {
                constructor(m, _, x) {
                  (this.type = Vt),
                    (this.lhs = m),
                    (this.rhs = _),
                    (this.collator = x),
                    (this.hasUntypedArgument =
                      "value" === m.type.kind || "value" === _.type.kind);
                }
                static parse(m, _) {
                  if (3 !== m.length && 4 !== m.length)
                    return _.error("Expected two or three arguments.");
                  const x = m[0];
                  let E = _.parse(m[1], 1, tt);
                  if (!E) return null;
                  if (!bu(x, E.type))
                    return _.concat(1).error(
                      `"${x}" comparisons are not supported for type '${pt(
                        E.type
                      )}'.`
                    );
                  let T = _.parse(m[2], 2, tt);
                  if (!T) return null;
                  if (!bu(x, T.type))
                    return _.concat(2).error(
                      `"${x}" comparisons are not supported for type '${pt(
                        T.type
                      )}'.`
                    );
                  if (
                    E.type.kind !== T.type.kind &&
                    "value" !== E.type.kind &&
                    "value" !== T.type.kind
                  )
                    return _.error(
                      `Cannot compare types '${pt(E.type)}' and '${pt(
                        T.type
                      )}'.`
                    );
                  l &&
                    ("value" === E.type.kind && "value" !== T.type.kind
                      ? (E = new Jn(T.type, [E]))
                      : "value" !== E.type.kind &&
                        "value" === T.type.kind &&
                        (T = new Jn(E.type, [T])));
                  let C = null;
                  if (4 === m.length) {
                    if (
                      "string" !== E.type.kind &&
                      "string" !== T.type.kind &&
                      "value" !== E.type.kind &&
                      "value" !== T.type.kind
                    )
                      return _.error(
                        "Cannot use collator to compare non-string types."
                      );
                    if (((C = _.parse(m[3], 3, mr)), !C)) return null;
                  }
                  return new gD(E, T, C);
                }
                evaluate(m) {
                  const _ = this.lhs.evaluate(m),
                    x = this.rhs.evaluate(m);
                  if (l && this.hasUntypedArgument) {
                    const E = un(_),
                      T = un(x);
                    if (
                      E.kind !== T.kind ||
                      ("string" !== E.kind && "number" !== E.kind)
                    )
                      throw new ir(
                        `Expected arguments for "${r}" to be (string, string) or (number, number), but found (${E.kind}, ${T.kind}) instead.`
                      );
                  }
                  if (this.collator && !l && this.hasUntypedArgument) {
                    const E = un(_),
                      T = un(x);
                    if ("string" !== E.kind || "string" !== T.kind)
                      return i(m, _, x);
                  }
                  return this.collator
                    ? o(m, _, x, this.collator.evaluate(m))
                    : i(m, _, x);
                }
                eachChild(m) {
                  m(this.lhs), m(this.rhs), this.collator && m(this.collator);
                }
                outputDefined() {
                  return !0;
                }
                serialize() {
                  const m = [r];
                  return (
                    this.eachChild((_) => {
                      m.push(_.serialize());
                    }),
                    m
                  );
                }
              };
            }
            const zh = ar(
                "==",
                function (r, i, o) {
                  return i === o;
                },
                xr
              ),
              wu = ar(
                "!=",
                function (r, i, o) {
                  return i !== o;
                },
                function (r, i, o, l) {
                  return !xr(0, i, o, l);
                }
              ),
              Eu = ar(
                "<",
                function (r, i, o) {
                  return i < o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) < 0;
                }
              ),
              wo = ar(
                ">",
                function (r, i, o) {
                  return i > o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) > 0;
                }
              ),
              Rf = ar(
                "<=",
                function (r, i, o) {
                  return i <= o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) <= 0;
                }
              ),
              Of = ar(
                ">=",
                function (r, i, o) {
                  return i >= o;
                },
                function (r, i, o, l) {
                  return l.compare(i, o) >= 0;
                }
              );
            class Tu {
              constructor(i, o, l, h, m, _) {
                (this.type = _t),
                  (this.number = i),
                  (this.locale = o),
                  (this.currency = l),
                  (this.unit = h),
                  (this.minFractionDigits = m),
                  (this.maxFractionDigits = _);
              }
              static parse(i, o) {
                if (3 !== i.length) return o.error("Expected two arguments.");
                const l = o.parse(i[1], 1, it);
                if (!l) return null;
                const h = i[2];
                if ("object" != typeof h || Array.isArray(h))
                  return o.error(
                    "NumberFormat options argument must be an object."
                  );
                let m = null;
                if (h.locale && ((m = o.parse(h.locale, 1, _t)), !m))
                  return null;
                let _ = null;
                if (h.currency && ((_ = o.parse(h.currency, 1, _t)), !_))
                  return null;
                let x = null;
                if (h.unit && ((x = o.parse(h.unit, 1, _t)), !x)) return null;
                let E = null;
                if (
                  h["min-fraction-digits"] &&
                  ((E = o.parse(h["min-fraction-digits"], 1, it)), !E)
                )
                  return null;
                let T = null;
                return h["max-fraction-digits"] &&
                  ((T = o.parse(h["max-fraction-digits"], 1, it)), !T)
                  ? null
                  : new Tu(l, m, _, x, E, T);
              }
              evaluate(i) {
                return new Intl.NumberFormat(
                  this.locale ? this.locale.evaluate(i) : [],
                  {
                    style:
                      (this.currency ? "currency" : this.unit && "unit") ||
                      "decimal",
                    currency: this.currency
                      ? this.currency.evaluate(i)
                      : void 0,
                    unit: this.unit ? this.unit.evaluate(i) : void 0,
                    minimumFractionDigits: this.minFractionDigits
                      ? this.minFractionDigits.evaluate(i)
                      : void 0,
                    maximumFractionDigits: this.maxFractionDigits
                      ? this.maxFractionDigits.evaluate(i)
                      : void 0,
                  }
                ).format(this.number.evaluate(i));
              }
              eachChild(i) {
                i(this.number),
                  this.locale && i(this.locale),
                  this.currency && i(this.currency),
                  this.unit && i(this.unit),
                  this.minFractionDigits && i(this.minFractionDigits),
                  this.maxFractionDigits && i(this.maxFractionDigits);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = {};
                return (
                  this.locale && (i.locale = this.locale.serialize()),
                  this.currency && (i.currency = this.currency.serialize()),
                  this.unit && (i.unit = this.unit.serialize()),
                  this.minFractionDigits &&
                    (i["min-fraction-digits"] =
                      this.minFractionDigits.serialize()),
                  this.maxFractionDigits &&
                    (i["max-fraction-digits"] =
                      this.maxFractionDigits.serialize()),
                  ["number-format", this.number.serialize(), i]
                );
              }
            }
            class Rl {
              constructor(i) {
                (this.type = it), (this.input = i);
              }
              static parse(i, o) {
                if (2 !== i.length)
                  return o.error(
                    `Expected 1 argument, but found ${i.length - 1} instead.`
                  );
                const l = o.parse(i[1], 1);
                return l
                  ? "array" !== l.type.kind &&
                    "string" !== l.type.kind &&
                    "value" !== l.type.kind
                    ? o.error(
                        `Expected argument of type string or array, but found ${pt(
                          l.type
                        )} instead.`
                      )
                    : new Rl(l)
                  : null;
              }
              evaluate(i) {
                const o = this.input.evaluate(i);
                if ("string" == typeof o || Array.isArray(o)) return o.length;
                throw new ir(
                  `Expected value to be of type string or array, but found ${pt(
                    un(o)
                  )} instead.`
                );
              }
              eachChild(i) {
                i(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const i = ["length"];
                return (
                  this.eachChild((o) => {
                    i.push(o.serialize());
                  }),
                  i
                );
              }
            }
            const Ff = {
              "==": zh,
              "!=": wu,
              ">": wo,
              "<": Eu,
              ">=": Of,
              "<=": Rf,
              array: Jn,
              at: Ll,
              boolean: Jn,
              case: xc,
              coalesce: Ni,
              collator: gc,
              format: _o,
              image: Ph,
              in: On,
              "index-of": fp,
              interpolate: oo,
              "interpolate-hcl": oo,
              "interpolate-lab": oo,
              length: Rl,
              let: Na,
              literal: Sl,
              match: Nh,
              number: Jn,
              "number-format": Tu,
              object: Jn,
              slice: Ki,
              step: Fh,
              string: Jn,
              "to-boolean": Il,
              "to-color": Il,
              "to-number": Il,
              "to-string": Il,
              var: pp,
              within: Pl,
            };
            function Nf(r, [i, o, l, h]) {
              (i = i.evaluate(r)), (o = o.evaluate(r)), (l = l.evaluate(r));
              const m = h ? h.evaluate(r) : 1,
                _ = lp(i, o, l, m);
              if (_) throw new ir(_);
              return new di((i / 255) * m, (o / 255) * m, (l / 255) * m, m);
            }
            function Zs(r, i) {
              return r in i;
            }
            function Bh(r, i) {
              const o = i[r];
              return void 0 === o ? null : o;
            }
            function Eo(r) {
              return { type: r };
            }
            Uo.register(Ff, {
              error: [
                { kind: "error" },
                [_t],
                (r, [i]) => {
                  throw new ir(i.evaluate(r));
                },
              ],
              typeof: [_t, [tt], (r, [i]) => pt(un(i.evaluate(r)))],
              "to-rgba": [gr(it, 4), [Ur], (r, [i]) => i.evaluate(r).toArray()],
              rgb: [Ur, [it, it, it], Nf],
              rgba: [Ur, [it, it, it, it], Nf],
              has: {
                type: Vt,
                overloads: [
                  [[_t], (r, [i]) => Zs(i.evaluate(r), r.properties())],
                  [[_t, Mr], (r, [i, o]) => Zs(i.evaluate(r), o.evaluate(r))],
                ],
              },
              get: {
                type: tt,
                overloads: [
                  [[_t], (r, [i]) => Bh(i.evaluate(r), r.properties())],
                  [[_t, Mr], (r, [i, o]) => Bh(i.evaluate(r), o.evaluate(r))],
                ],
              },
              "feature-state": [
                tt,
                [_t],
                (r, [i]) => Bh(i.evaluate(r), r.featureState || {}),
              ],
              properties: [Mr, [], (r) => r.properties()],
              "geometry-type": [_t, [], (r) => r.geometryType()],
              id: [tt, [], (r) => r.id()],
              zoom: [it, [], (r) => r.globals.zoom],
              pitch: [it, [], (r) => r.globals.pitch || 0],
              "distance-from-center": [it, [], (r) => r.distanceFromCenter()],
              "heatmap-density": [it, [], (r) => r.globals.heatmapDensity || 0],
              "line-progress": [it, [], (r) => r.globals.lineProgress || 0],
              "sky-radial-progress": [
                it,
                [],
                (r) => r.globals.skyRadialProgress || 0,
              ],
              accumulated: [
                tt,
                [],
                (r) =>
                  void 0 === r.globals.accumulated
                    ? null
                    : r.globals.accumulated,
              ],
              "+": [
                it,
                Eo(it),
                (r, i) => {
                  let o = 0;
                  for (const l of i) o += l.evaluate(r);
                  return o;
                },
              ],
              "*": [
                it,
                Eo(it),
                (r, i) => {
                  let o = 1;
                  for (const l of i) o *= l.evaluate(r);
                  return o;
                },
              ],
              "-": {
                type: it,
                overloads: [
                  [[it, it], (r, [i, o]) => i.evaluate(r) - o.evaluate(r)],
                  [[it], (r, [i]) => -i.evaluate(r)],
                ],
              },
              "/": [it, [it, it], (r, [i, o]) => i.evaluate(r) / o.evaluate(r)],
              "%": [it, [it, it], (r, [i, o]) => i.evaluate(r) % o.evaluate(r)],
              ln2: [it, [], () => Math.LN2],
              pi: [it, [], () => Math.PI],
              e: [it, [], () => Math.E],
              "^": [
                it,
                [it, it],
                (r, [i, o]) => Math.pow(i.evaluate(r), o.evaluate(r)),
              ],
              sqrt: [it, [it], (r, [i]) => Math.sqrt(i.evaluate(r))],
              log10: [
                it,
                [it],
                (r, [i]) => Math.log(i.evaluate(r)) / Math.LN10,
              ],
              ln: [it, [it], (r, [i]) => Math.log(i.evaluate(r))],
              log2: [it, [it], (r, [i]) => Math.log(i.evaluate(r)) / Math.LN2],
              sin: [it, [it], (r, [i]) => Math.sin(i.evaluate(r))],
              cos: [it, [it], (r, [i]) => Math.cos(i.evaluate(r))],
              tan: [it, [it], (r, [i]) => Math.tan(i.evaluate(r))],
              asin: [it, [it], (r, [i]) => Math.asin(i.evaluate(r))],
              acos: [it, [it], (r, [i]) => Math.acos(i.evaluate(r))],
              atan: [it, [it], (r, [i]) => Math.atan(i.evaluate(r))],
              min: [
                it,
                Eo(it),
                (r, i) => Math.min(...i.map((o) => o.evaluate(r))),
              ],
              max: [
                it,
                Eo(it),
                (r, i) => Math.max(...i.map((o) => o.evaluate(r))),
              ],
              abs: [it, [it], (r, [i]) => Math.abs(i.evaluate(r))],
              round: [
                it,
                [it],
                (r, [i]) => {
                  const o = i.evaluate(r);
                  return o < 0 ? -Math.round(-o) : Math.round(o);
                },
              ],
              floor: [it, [it], (r, [i]) => Math.floor(i.evaluate(r))],
              ceil: [it, [it], (r, [i]) => Math.ceil(i.evaluate(r))],
              "filter-==": [
                Vt,
                [_t, tt],
                (r, [i, o]) => r.properties()[i.value] === o.value,
              ],
              "filter-id-==": [Vt, [tt], (r, [i]) => r.id() === i.value],
              "filter-type-==": [
                Vt,
                [_t],
                (r, [i]) => r.geometryType() === i.value,
              ],
              "filter-<": [
                Vt,
                [_t, tt],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l < h;
                },
              ],
              "filter-id-<": [
                Vt,
                [tt],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o < l;
                },
              ],
              "filter->": [
                Vt,
                [_t, tt],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l > h;
                },
              ],
              "filter-id->": [
                Vt,
                [tt],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o > l;
                },
              ],
              "filter-<=": [
                Vt,
                [_t, tt],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l <= h;
                },
              ],
              "filter-id-<=": [
                Vt,
                [tt],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o <= l;
                },
              ],
              "filter->=": [
                Vt,
                [_t, tt],
                (r, [i, o]) => {
                  const l = r.properties()[i.value],
                    h = o.value;
                  return typeof l == typeof h && l >= h;
                },
              ],
              "filter-id->=": [
                Vt,
                [tt],
                (r, [i]) => {
                  const o = r.id(),
                    l = i.value;
                  return typeof o == typeof l && o >= l;
                },
              ],
              "filter-has": [Vt, [tt], (r, [i]) => i.value in r.properties()],
              "filter-has-id": [
                Vt,
                [],
                (r) => null !== r.id() && void 0 !== r.id(),
              ],
              "filter-type-in": [
                Vt,
                [gr(_t)],
                (r, [i]) => i.value.indexOf(r.geometryType()) >= 0,
              ],
              "filter-id-in": [
                Vt,
                [gr(tt)],
                (r, [i]) => i.value.indexOf(r.id()) >= 0,
              ],
              "filter-in-small": [
                Vt,
                [_t, gr(tt)],
                (r, [i, o]) => o.value.indexOf(r.properties()[i.value]) >= 0,
              ],
              "filter-in-large": [
                Vt,
                [_t, gr(tt)],
                (r, [i, o]) =>
                  (function (l, h, m, _) {
                    for (; m <= _; ) {
                      const x = (m + _) >> 1;
                      if (h[x] === l) return !0;
                      h[x] > l ? (_ = x - 1) : (m = x + 1);
                    }
                    return !1;
                  })(r.properties()[i.value], o.value, 0, o.value.length - 1),
              ],
              all: {
                type: Vt,
                overloads: [
                  [[Vt, Vt], (r, [i, o]) => i.evaluate(r) && o.evaluate(r)],
                  [
                    Eo(Vt),
                    (r, i) => {
                      for (const o of i) if (!o.evaluate(r)) return !1;
                      return !0;
                    },
                  ],
                ],
              },
              any: {
                type: Vt,
                overloads: [
                  [[Vt, Vt], (r, [i, o]) => i.evaluate(r) || o.evaluate(r)],
                  [
                    Eo(Vt),
                    (r, i) => {
                      for (const o of i) if (o.evaluate(r)) return !0;
                      return !1;
                    },
                  ],
                ],
              },
              "!": [Vt, [Vt], (r, [i]) => !i.evaluate(r)],
              "is-supported-script": [
                Vt,
                [_t],
                (r, [i]) => {
                  const o = r.globals && r.globals.isSupportedScript;
                  return !o || o(i.evaluate(r));
                },
              ],
              upcase: [_t, [_t], (r, [i]) => i.evaluate(r).toUpperCase()],
              downcase: [_t, [_t], (r, [i]) => i.evaluate(r).toLowerCase()],
              concat: [
                _t,
                Eo(tt),
                (r, i) => i.map((o) => pn(o.evaluate(r))).join(""),
              ],
              "resolved-locale": [
                _t,
                [mr],
                (r, [i]) => i.evaluate(r).resolvedLocale(),
              ],
            });
            var Du = Ff;
            function zf(r) {
              return { result: "success", value: r };
            }
            function Ol(r) {
              return { result: "error", value: r };
            }
            function bc(r) {
              return "data-driven" === r["property-type"];
            }
            function Vh(r) {
              return (
                !!r.expression && r.expression.parameters.indexOf("zoom") > -1
              );
            }
            function jh(r) {
              return !!r.expression && r.expression.interpolated;
            }
            function hn(r) {
              return r instanceof Number
                ? "number"
                : r instanceof String
                ? "string"
                : r instanceof Boolean
                ? "boolean"
                : Array.isArray(r)
                ? "array"
                : null === r
                ? "null"
                : typeof r;
            }
            function Su(r) {
              return "object" == typeof r && null !== r && !Array.isArray(r);
            }
            function Bf(r) {
              return r;
            }
            function wc(r, i) {
              const o = "color" === i.type,
                l = r.stops && "object" == typeof r.stops[0][0],
                h = l || !(l || void 0 !== r.property),
                m = r.type || (jh(i) ? "exponential" : "interval");
              if (
                (o &&
                  ((r = Vo({}, r)).stops &&
                    (r.stops = r.stops.map((T) => [T[0], di.parse(T[1])])),
                  (r.default = di.parse(r.default ? r.default : i.default))),
                r.colorSpace && "rgb" !== r.colorSpace && !Kt[r.colorSpace])
              )
                throw new Error(`Unknown color space: ${r.colorSpace}`);
              let _, x, E;
              if ("exponential" === m) _ = Ks;
              else if ("interval" === m) _ = Uh;
              else if ("categorical" === m) {
                (_ = Vf), (x = Object.create(null));
                for (const T of r.stops) x[T[0]] = T[1];
                E = typeof r.stops[0][0];
              } else {
                if ("identity" !== m)
                  throw new Error(`Unknown function type "${m}"`);
                _ = Ys;
              }
              if (l) {
                const T = {},
                  C = [];
                for (let O = 0; O < r.stops.length; O++) {
                  const F = r.stops[O],
                    V = F[0].zoom;
                  void 0 === T[V] &&
                    ((T[V] = {
                      zoom: V,
                      type: r.type,
                      property: r.property,
                      default: r.default,
                      stops: [],
                    }),
                    C.push(V)),
                    T[V].stops.push([F[0].value, F[1]]);
                }
                const A = [];
                for (const O of C) A.push([T[O].zoom, wc(T[O], i)]);
                const L = { name: "linear" };
                return {
                  kind: "composite",
                  interpolationType: L,
                  interpolationFactor: oo.interpolationFactor.bind(void 0, L),
                  zoomStops: A.map((O) => O[0]),
                  evaluate: ({ zoom: O }, F) =>
                    Ks({ stops: A, base: r.base }, i, O).evaluate(O, F),
                };
              }
              if (h) {
                const T =
                  "exponential" === m
                    ? {
                        name: "exponential",
                        base: void 0 !== r.base ? r.base : 1,
                      }
                    : null;
                return {
                  kind: "camera",
                  interpolationType: T,
                  interpolationFactor: oo.interpolationFactor.bind(void 0, T),
                  zoomStops: r.stops.map((C) => C[0]),
                  evaluate: ({ zoom: C }) => _(r, i, C, x, E),
                };
              }
              return {
                kind: "source",
                evaluate(T, C) {
                  const A =
                    C && C.properties ? C.properties[r.property] : void 0;
                  return void 0 === A
                    ? Xs(r.default, i.default)
                    : _(r, i, A, x, E);
                },
              };
            }
            function Xs(r, i, o) {
              return void 0 !== r
                ? r
                : void 0 !== i
                ? i
                : void 0 !== o
                ? o
                : void 0;
            }
            function Vf(r, i, o, l, h) {
              return Xs(typeof o === h ? l[o] : void 0, r.default, i.default);
            }
            function Uh(r, i, o) {
              if ("number" !== hn(o)) return Xs(r.default, i.default);
              const l = r.stops.length;
              if (1 === l || o <= r.stops[0][0]) return r.stops[0][1];
              if (o >= r.stops[l - 1][0]) return r.stops[l - 1][1];
              const h = yc(
                r.stops.map((m) => m[0]),
                o
              );
              return r.stops[h][1];
            }
            function Ks(r, i, o) {
              const l = void 0 !== r.base ? r.base : 1;
              if ("number" !== hn(o)) return Xs(r.default, i.default);
              const h = r.stops.length;
              if (1 === h || o <= r.stops[0][0]) return r.stops[0][1];
              if (o >= r.stops[h - 1][0]) return r.stops[h - 1][1];
              const m = yc(
                  r.stops.map((C) => C[0]),
                  o
                ),
                _ = (function (C, A, L, O) {
                  const F = O - L,
                    V = C - L;
                  return 0 === F
                    ? 0
                    : 1 === A
                    ? V / F
                    : (Math.pow(A, V) - 1) / (Math.pow(A, F) - 1);
                })(o, l, r.stops[m][0], r.stops[m + 1][0]),
                x = r.stops[m][1],
                E = r.stops[m + 1][1];
              let T = Mi[i.type] || Bf;
              if (r.colorSpace && "rgb" !== r.colorSpace) {
                const C = Kt[r.colorSpace];
                T = (A, L) =>
                  C.reverse(C.interpolate(C.forward(A), C.forward(L), _));
              }
              return "function" == typeof x.evaluate
                ? {
                    evaluate(...C) {
                      const A = x.evaluate.apply(void 0, C),
                        L = E.evaluate.apply(void 0, C);
                      if (void 0 !== A && void 0 !== L) return T(A, L, _);
                    },
                  }
                : T(x, E, _);
            }
            function Ys(r, i, o) {
              return (
                "color" === i.type
                  ? (o = di.parse(o))
                  : "formatted" === i.type
                  ? (o = Lr.fromString(o.toString()))
                  : "resolvedImage" === i.type
                  ? (o = go.fromString(o.toString()))
                  : hn(o) === i.type ||
                    ("enum" === i.type && i.values[o]) ||
                    (o = void 0),
                Xs(o, r.default, i.default)
              );
            }
            class Iu {
              constructor(i, o) {
                var l;
                (this.expression = i),
                  (this._warningHistory = {}),
                  (this._evaluator = new Cl()),
                  (this._defaultValue = o
                    ? "color" === (l = o).type &&
                      (Su(l.default) || Array.isArray(l.default))
                      ? new di(0, 0, 0, 0)
                      : "color" === l.type
                      ? di.parse(l.default) || null
                      : void 0 === l.default
                      ? null
                      : l.default
                    : null),
                  (this._enumValues = o && "enum" === o.type ? o.values : null);
              }
              evaluateWithoutErrorHandling(i, o, l, h, m, _, x, E) {
                return (
                  (this._evaluator.globals = i),
                  (this._evaluator.feature = o),
                  (this._evaluator.featureState = l),
                  (this._evaluator.canonical = h || null),
                  (this._evaluator.availableImages = m || null),
                  (this._evaluator.formattedSection = _),
                  (this._evaluator.featureTileCoord = x || null),
                  (this._evaluator.featureDistanceData = E || null),
                  this.expression.evaluate(this._evaluator)
                );
              }
              evaluate(i, o, l, h, m, _, x, E) {
                (this._evaluator.globals = i),
                  (this._evaluator.feature = o || null),
                  (this._evaluator.featureState = l || null),
                  (this._evaluator.canonical = h || null),
                  (this._evaluator.availableImages = m || null),
                  (this._evaluator.formattedSection = _ || null),
                  (this._evaluator.featureTileCoord = x || null),
                  (this._evaluator.featureDistanceData = E || null);
                try {
                  const T = this.expression.evaluate(this._evaluator);
                  if (null == T || ("number" == typeof T && T != T))
                    return this._defaultValue;
                  if (this._enumValues && !(T in this._enumValues))
                    throw new ir(
                      `Expected value to be one of ${Object.keys(
                        this._enumValues
                      )
                        .map((C) => JSON.stringify(C))
                        .join(", ")}, but found ${JSON.stringify(T)} instead.`
                    );
                  return T;
                } catch (T) {
                  return (
                    this._warningHistory[T.message] ||
                      ((this._warningHistory[T.message] = !0),
                      typeof console < "u" && console.warn(T.message)),
                    this._defaultValue
                  );
                }
              }
            }
            function Zo(r) {
              return (
                Array.isArray(r) &&
                r.length > 0 &&
                "string" == typeof r[0] &&
                r[0] in Du
              );
            }
            function Ba(r, i) {
              const o = new Oh(
                  Du,
                  [],
                  i
                    ? (function (h) {
                        const m = {
                          color: Ur,
                          string: _t,
                          number: it,
                          enum: _t,
                          boolean: Vt,
                          formatted: mu,
                          resolvedImage: rt,
                        };
                        return "array" === h.type
                          ? gr(m[h.value] || tt, h.length)
                          : m[h.type];
                      })(i)
                    : void 0
                ),
                l = o.parse(
                  r,
                  void 0,
                  void 0,
                  void 0,
                  i && "string" === i.type
                    ? { typeAnnotation: "coerce" }
                    : void 0
                );
              return l ? zf(new Iu(l, i)) : Ol(o.errors);
            }
            class $h {
              constructor(i, o) {
                (this.kind = i),
                  (this._styleExpression = o),
                  (this.isStateDependent =
                    "constant" !== i && !Ho(o.expression));
              }
              evaluateWithoutErrorHandling(i, o, l, h, m, _) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  i,
                  o,
                  l,
                  h,
                  m,
                  _
                );
              }
              evaluate(i, o, l, h, m, _) {
                return this._styleExpression.evaluate(i, o, l, h, m, _);
              }
            }
            class Ec {
              constructor(i, o, l, h) {
                (this.kind = i),
                  (this.zoomStops = l),
                  (this._styleExpression = o),
                  (this.isStateDependent = "camera" !== i && !Ho(o.expression)),
                  (this.interpolationType = h);
              }
              evaluateWithoutErrorHandling(i, o, l, h, m, _) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  i,
                  o,
                  l,
                  h,
                  m,
                  _
                );
              }
              evaluate(i, o, l, h, m, _) {
                return this._styleExpression.evaluate(i, o, l, h, m, _);
              }
              interpolationFactor(i, o, l) {
                return this.interpolationType
                  ? oo.interpolationFactor(this.interpolationType, i, o, l)
                  : 0;
              }
            }
            function Fl(r, i) {
              if ("error" === (r = Ba(r, i)).result) return r;
              const o = r.value.expression,
                l = Us(o);
              if (!l && !bc(i))
                return Ol([new jo("", "data expressions not supported")]);
              const h = _r(o, ["zoom", "pitch", "distance-from-center"]);
              if (!h && !Vh(i))
                return Ol([new jo("", "zoom expressions not supported")]);
              const m = Cu(o);
              return m || h
                ? m instanceof jo
                  ? Ol([m])
                  : m instanceof oo && !jh(i)
                  ? Ol([
                      new jo(
                        "",
                        '"interpolate" expressions cannot be used with this property'
                      ),
                    ])
                  : zf(
                      m
                        ? new Ec(
                            l ? "camera" : "composite",
                            r.value,
                            m.labels,
                            m instanceof oo ? m.interpolation : void 0
                          )
                        : new $h(l ? "constant" : "source", r.value)
                    )
                : Ol([
                    new jo(
                      "",
                      '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                    ),
                  ]);
            }
            class Tc {
              constructor(i, o) {
                (this._parameters = i),
                  (this._specification = o),
                  Vo(this, wc(this._parameters, this._specification));
              }
              static deserialize(i) {
                return new Tc(i._parameters, i._specification);
              }
              static serialize(i) {
                return {
                  _parameters: i._parameters,
                  _specification: i._specification,
                };
              }
            }
            function Cu(r) {
              let i = null;
              if (r instanceof Na) i = Cu(r.result);
              else if (r instanceof Ni) {
                for (const o of r.args) if (((i = Cu(o)), i)) break;
              } else
                (r instanceof Fh || r instanceof oo) &&
                  r.input instanceof Uo &&
                  "zoom" === r.input.name &&
                  (i = r);
              return (
                i instanceof jo ||
                  r.eachChild((o) => {
                    const l = Cu(o);
                    l instanceof jo
                      ? (i = l)
                      : !i && l
                      ? (i = new jo(
                          "",
                          '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'
                        ))
                      : i &&
                        l &&
                        i !== l &&
                        (i = new jo(
                          "",
                          'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'
                        ));
                  }),
                i
              );
            }
            class at {
              constructor(i, o, l, h) {
                (this.message = (i ? `${i}: ` : "") + l),
                  h && (this.identifier = h),
                  null != o && o.__line__ && (this.line = o.__line__);
              }
            }
            function To(r) {
              const i = r.key,
                o = r.value,
                l = r.valueSpec || {},
                h = r.objectElementValidators || {},
                m = r.style,
                _ = r.styleSpec;
              let x = [];
              const E = hn(o);
              if ("object" !== E)
                return [new at(i, o, `object expected, ${E} found`)];
              for (const T in o) {
                const C = T.split(".")[0];
                let A;
                h[C]
                  ? (A = h[C])
                  : l[C]
                  ? (A = fi)
                  : h["*"]
                  ? (A = h["*"])
                  : l["*"] && (A = fi),
                  A
                    ? (x = x.concat(
                        A(
                          {
                            key: (i && `${i}.`) + T,
                            value: o[T],
                            valueSpec: l[C] || l["*"],
                            style: m,
                            styleSpec: _,
                            object: o,
                            objectKey: T,
                          },
                          o
                        )
                      ))
                    : x.push(new at(i, o[T], `unknown property "${T}"`));
              }
              for (const T in l)
                h[T] ||
                  (l[T].required &&
                    void 0 === l[T].default &&
                    void 0 === o[T] &&
                    x.push(new at(i, o, `missing required property "${T}"`)));
              return x;
            }
            function Wr(r) {
              const i = r.value,
                o = r.valueSpec,
                l = r.style,
                h = r.styleSpec,
                m = r.key,
                _ = r.arrayElementValidator || fi;
              if ("array" !== hn(i))
                return [new at(m, i, `array expected, ${hn(i)} found`)];
              if (o.length && i.length !== o.length)
                return [
                  new at(
                    m,
                    i,
                    `array length ${o.length} expected, length ${i.length} found`
                  ),
                ];
              if (o["min-length"] && i.length < o["min-length"])
                return [
                  new at(
                    m,
                    i,
                    `array length at least ${o["min-length"]} expected, length ${i.length} found`
                  ),
                ];
              let x = {
                type: o.value,
                values: o.values,
                minimum: o.minimum,
                maximum: o.maximum,
                function: void 0,
              };
              h.$version < 7 && (x.function = o.function),
                "object" === hn(o.value) && (x = o.value);
              let E = [];
              for (let T = 0; T < i.length; T++)
                E = E.concat(
                  _({
                    array: i,
                    arrayIndex: T,
                    value: i[T],
                    valueSpec: x,
                    style: l,
                    styleSpec: h,
                    key: `${m}[${T}]`,
                  })
                );
              return E;
            }
            function Va(r) {
              const i = r.key,
                o = r.value,
                l = r.valueSpec;
              let h = hn(o);
              if (("number" === h && o != o && (h = "NaN"), "number" !== h))
                return [new at(i, o, `number expected, ${h} found`)];
              if ("minimum" in l) {
                let m = l.minimum;
                if (
                  ("array" === hn(l.minimum) && (m = l.minimum[r.arrayIndex]),
                  o < m)
                )
                  return [
                    new at(i, o, `${o} is less than the minimum value ${m}`),
                  ];
              }
              if ("maximum" in l) {
                let m = l.maximum;
                if (
                  ("array" === hn(l.maximum) && (m = l.maximum[r.arrayIndex]),
                  o > m)
                )
                  return [
                    new at(i, o, `${o} is greater than the maximum value ${m}`),
                  ];
              }
              return [];
            }
            function Dc(r) {
              const i = r.valueSpec,
                o = hi(r.value.type);
              let l,
                h,
                m,
                _ = {};
              const x = "categorical" !== o && void 0 === r.value.property,
                E = !x,
                T =
                  "array" === hn(r.value.stops) &&
                  "array" === hn(r.value.stops[0]) &&
                  "object" === hn(r.value.stops[0][0]),
                C = To({
                  key: r.key,
                  value: r.value,
                  valueSpec: r.styleSpec.function,
                  style: r.style,
                  styleSpec: r.styleSpec,
                  objectElementValidators: {
                    stops: function (O) {
                      if ("identity" === o)
                        return [
                          new at(
                            O.key,
                            O.value,
                            'identity function may not have a "stops" property'
                          ),
                        ];
                      let F = [];
                      const V = O.value;
                      return (
                        (F = F.concat(
                          Wr({
                            key: O.key,
                            value: V,
                            valueSpec: O.valueSpec,
                            style: O.style,
                            styleSpec: O.styleSpec,
                            arrayElementValidator: A,
                          })
                        )),
                        "array" === hn(V) &&
                          0 === V.length &&
                          F.push(
                            new at(
                              O.key,
                              V,
                              "array must have at least one stop"
                            )
                          ),
                        F
                      );
                    },
                    default: function (O) {
                      return fi({
                        key: O.key,
                        value: O.value,
                        valueSpec: i,
                        style: O.style,
                        styleSpec: O.styleSpec,
                      });
                    },
                  },
                });
              return (
                "identity" === o &&
                  x &&
                  C.push(
                    new at(
                      r.key,
                      r.value,
                      'missing required property "property"'
                    )
                  ),
                "identity" === o ||
                  r.value.stops ||
                  C.push(
                    new at(r.key, r.value, 'missing required property "stops"')
                  ),
                "exponential" === o &&
                  r.valueSpec.expression &&
                  !jh(r.valueSpec) &&
                  C.push(
                    new at(
                      r.key,
                      r.value,
                      "exponential functions not supported"
                    )
                  ),
                r.styleSpec.$version >= 8 &&
                  (E && !bc(r.valueSpec)
                    ? C.push(
                        new at(
                          r.key,
                          r.value,
                          "property functions not supported"
                        )
                      )
                    : x &&
                      !Vh(r.valueSpec) &&
                      C.push(
                        new at(r.key, r.value, "zoom functions not supported")
                      )),
                ("categorical" !== o && !T) ||
                  void 0 !== r.value.property ||
                  C.push(
                    new at(r.key, r.value, '"property" property is required')
                  ),
                C
              );
              function A(O) {
                let F = [];
                const V = O.value,
                  G = O.key;
                if ("array" !== hn(V))
                  return [new at(G, V, `array expected, ${hn(V)} found`)];
                if (2 !== V.length)
                  return [
                    new at(
                      G,
                      V,
                      `array length 2 expected, length ${V.length} found`
                    ),
                  ];
                if (T) {
                  if ("object" !== hn(V[0]))
                    return [new at(G, V, `object expected, ${hn(V[0])} found`)];
                  if (void 0 === V[0].zoom)
                    return [new at(G, V, "object stop key must have zoom")];
                  if (void 0 === V[0].value)
                    return [new at(G, V, "object stop key must have value")];
                  const K = hi(V[0].zoom);
                  if ("number" != typeof K)
                    return [
                      new at(G, V[0].zoom, "stop zoom values must be numbers"),
                    ];
                  if (m && m > K)
                    return [
                      new at(
                        G,
                        V[0].zoom,
                        "stop zoom values must appear in ascending order"
                      ),
                    ];
                  K !== m && ((m = K), (h = void 0), (_ = {})),
                    (F = F.concat(
                      To({
                        key: `${G}[0]`,
                        value: V[0],
                        valueSpec: { zoom: {} },
                        style: O.style,
                        styleSpec: O.styleSpec,
                        objectElementValidators: { zoom: Va, value: L },
                      })
                    ));
                } else F = F.concat(L({ key: `${G}[0]`, value: V[0], valueSpec: {}, style: O.style, styleSpec: O.styleSpec }, V));
                return Zo(Fi(V[1]))
                  ? F.concat([
                      new at(
                        `${G}[1]`,
                        V[1],
                        "expressions are not allowed in function stops."
                      ),
                    ])
                  : F.concat(
                      fi({
                        key: `${G}[1]`,
                        value: V[1],
                        valueSpec: i,
                        style: O.style,
                        styleSpec: O.styleSpec,
                      })
                    );
              }
              function L(O, F) {
                const V = hn(O.value),
                  G = hi(O.value),
                  K = null !== O.value ? O.value : F;
                if (l) {
                  if (V !== l)
                    return [
                      new at(
                        O.key,
                        K,
                        `${V} stop domain type must match previous stop domain type ${l}`
                      ),
                    ];
                } else l = V;
                if (
                  "number" !== V &&
                  "string" !== V &&
                  "boolean" !== V &&
                  "number" != typeof G &&
                  "string" != typeof G &&
                  "boolean" != typeof G
                )
                  return [
                    new at(
                      O.key,
                      K,
                      "stop domain value must be a number, string, or boolean"
                    ),
                  ];
                if ("number" !== V && "categorical" !== o) {
                  let oe = `number expected, ${V} found`;
                  return (
                    bc(i) &&
                      void 0 === o &&
                      (oe +=
                        '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                    [new at(O.key, K, oe)]
                  );
                }
                return "categorical" !== o ||
                  "number" !== V ||
                  ("number" == typeof G && isFinite(G) && Math.floor(G) === G)
                  ? "categorical" !== o &&
                    "number" === V &&
                    "number" == typeof G &&
                    "number" == typeof h &&
                    void 0 !== h &&
                    G < h
                    ? [
                        new at(
                          O.key,
                          K,
                          "stop domain values must appear in ascending order"
                        ),
                      ]
                    : ((h = G),
                      "categorical" === o && G in _
                        ? [
                            new at(
                              O.key,
                              K,
                              "stop domain values must be unique"
                            ),
                          ]
                        : ((_[G] = !0), []))
                  : [new at(O.key, K, `integer expected, found ${String(G)}`)];
              }
            }
            function Ei(r) {
              const i = ("property" === r.expressionContext ? Fl : Ba)(
                Fi(r.value),
                r.valueSpec
              );
              if ("error" === i.result)
                return i.value.map(
                  (l) => new at(`${r.key}${l.key}`, r.value, l.message)
                );
              const o =
                i.value.expression || i.value._styleExpression.expression;
              if (
                "property" === r.expressionContext &&
                "text-font" === r.propertyKey &&
                !o.outputDefined()
              )
                return [
                  new at(
                    r.key,
                    r.value,
                    `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`
                  ),
                ];
              if (
                "property" === r.expressionContext &&
                "layout" === r.propertyType &&
                !Ho(o)
              )
                return [
                  new at(
                    r.key,
                    r.value,
                    '"feature-state" data expressions are not supported with layout properties.'
                  ),
                ];
              if ("filter" === r.expressionContext) return Sc(o, r);
              if (
                r.expressionContext &&
                0 === r.expressionContext.indexOf("cluster")
              ) {
                if (!_r(o, ["zoom", "feature-state"]))
                  return [
                    new at(
                      r.key,
                      r.value,
                      '"zoom" and "feature-state" expressions are not supported with cluster properties.'
                    ),
                  ];
                if ("cluster-initial" === r.expressionContext && !Us(o))
                  return [
                    new at(
                      r.key,
                      r.value,
                      "Feature data expressions are not supported with initial expression part of cluster properties."
                    ),
                  ];
              }
              return [];
            }
            function Sc(r, i) {
              const o = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center",
              ]);
              if (i.valueSpec && i.valueSpec.expression)
                for (const h of i.valueSpec.expression.parameters) o.delete(h);
              if (0 === o.size) return [];
              const l = [];
              return r instanceof Uo && o.has(r.name)
                ? [
                    new at(
                      i.key,
                      i.value,
                      `["${r.name}"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`
                    ),
                  ]
                : (r.eachChild((h) => {
                    l.push(...Sc(h, i));
                  }),
                  l);
            }
            function Hh(r) {
              const i = r.key,
                o = r.value,
                l = r.valueSpec,
                h = [];
              return (
                Array.isArray(l.values)
                  ? -1 === l.values.indexOf(hi(o)) &&
                    h.push(
                      new at(
                        i,
                        o,
                        `expected one of [${l.values.join(
                          ", "
                        )}], ${JSON.stringify(o)} found`
                      )
                    )
                  : -1 === Object.keys(l.values).indexOf(hi(o)) &&
                    h.push(
                      new at(
                        i,
                        o,
                        `expected one of [${Object.keys(l.values).join(
                          ", "
                        )}], ${JSON.stringify(o)} found`
                      )
                    ),
                h
              );
            }
            function ti(r) {
              if (!0 === r || !1 === r) return !0;
              if (!Array.isArray(r) || 0 === r.length) return !1;
              switch (r[0]) {
                case "has":
                  return r.length >= 2 && "$id" !== r[1] && "$type" !== r[1];
                case "in":
                  return (
                    r.length >= 3 &&
                    ("string" != typeof r[1] || Array.isArray(r[2]))
                  );
                case "!in":
                case "!has":
                case "none":
                  return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                  return (
                    3 !== r.length || Array.isArray(r[1]) || Array.isArray(r[2])
                  );
                case "any":
                case "all":
                  for (const i of r.slice(1))
                    if (!ti(i) && "boolean" != typeof i) return !1;
                  return !0;
                default:
                  return !0;
              }
            }
            function Mu(r, i = "fill") {
              if (null == r)
                return { filter: () => !0, needGeometry: !1, needFeature: !1 };
              ti(r) || (r = Bi(r));
              const o = r;
              let l = !0;
              try {
                l = (function (T) {
                  if (!zi(T)) return T;
                  let C = Fi(T);
                  return ja(C), (C = jf(C)), C;
                })(o);
              } catch {
                console.warn(
                  `Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(
                    o,
                    null,
                    2
                  )}\n        `
                );
              }
              const h = Ae[`filter_${i}`],
                m = Ba(l, h);
              let _ = null;
              if ("error" === m.result)
                throw new Error(
                  m.value.map((T) => `${T.key}: ${T.message}`).join(", ")
                );
              _ = (T, C, A) => m.value.evaluate(T, C, {}, A);
              let x = null,
                E = null;
              if (l !== o) {
                const T = Ba(o, h);
                if ("error" === T.result)
                  throw new Error(
                    T.value.map((C) => `${C.key}: ${C.message}`).join(", ")
                  );
                (x = (C, A, L, O, F) =>
                  T.value.evaluate(C, A, {}, L, void 0, void 0, O, F)),
                  (E = !Us(T.value.expression));
              }
              return {
                filter: _,
                dynamicFilter: x || void 0,
                needGeometry: Ua(l),
                needFeature: !!E,
              };
            }
            function jf(r) {
              if (!Array.isArray(r)) return r;
              const i = (function (o) {
                if (Gh.has(o[0]))
                  for (let l = 1; l < o.length; l++) if (zi(o[l])) return !0;
                return o;
              })(r);
              return !0 === i ? i : i.map((o) => jf(o));
            }
            function ja(r) {
              let i = !1;
              const o = [];
              if ("case" === r[0]) {
                for (let l = 1; l < r.length - 1; l += 2)
                  (i = i || zi(r[l])), o.push(r[l + 1]);
                o.push(r[r.length - 1]);
              } else if ("match" === r[0]) {
                i = i || zi(r[1]);
                for (let l = 2; l < r.length - 1; l += 2) o.push(r[l + 1]);
                o.push(r[r.length - 1]);
              } else if ("step" === r[0]) {
                i = i || zi(r[1]);
                for (let l = 1; l < r.length - 1; l += 2) o.push(r[l + 1]);
              }
              i && ((r.length = 0), r.push("any", ...o));
              for (let l = 1; l < r.length; l++) ja(r[l]);
            }
            function zi(r) {
              if (!Array.isArray(r)) return !1;
              if ("pitch" === (i = r[0]) || "distance-from-center" === i)
                return !0;
              var i;
              for (let o = 1; o < r.length; o++) if (zi(r[o])) return !0;
              return !1;
            }
            const Gh = new Set([
              "in",
              "==",
              "!=",
              ">",
              ">=",
              "<",
              "<=",
              "to-boolean",
            ]);
            function qh(r, i) {
              return r < i ? -1 : r > i ? 1 : 0;
            }
            function Ua(r) {
              if (!Array.isArray(r)) return !1;
              if ("within" === r[0]) return !0;
              for (let i = 1; i < r.length; i++) if (Ua(r[i])) return !0;
              return !1;
            }
            function Bi(r) {
              if (!r) return !0;
              const i = r[0];
              return r.length <= 1
                ? "any" !== i
                : "==" === i
                ? Wh(r[1], r[2], "==")
                : "!=" === i
                ? Do(Wh(r[1], r[2], "=="))
                : "<" === i || ">" === i || "<=" === i || ">=" === i
                ? Wh(r[1], r[2], i)
                : "any" === i
                ? ((o = r.slice(1)), ["any"].concat(o.map(Bi)))
                : "all" === i
                ? ["all"].concat(r.slice(1).map(Bi))
                : "none" === i
                ? ["all"].concat(r.slice(1).map(Bi).map(Do))
                : "in" === i
                ? Nl(r[1], r.slice(2))
                : "!in" === i
                ? Do(Nl(r[1], r.slice(2)))
                : "has" === i
                ? Zh(r[1])
                : "!has" === i
                ? Do(Zh(r[1]))
                : "within" !== i || r;
              var o;
            }
            function Wh(r, i, o) {
              switch (r) {
                case "$type":
                  return [`filter-type-${o}`, i];
                case "$id":
                  return [`filter-id-${o}`, i];
                default:
                  return [`filter-${o}`, r, i];
              }
            }
            function Nl(r, i) {
              if (0 === i.length) return !1;
              switch (r) {
                case "$type":
                  return ["filter-type-in", ["literal", i]];
                case "$id":
                  return ["filter-id-in", ["literal", i]];
                default:
                  return i.length > 200 &&
                    !i.some((o) => typeof o != typeof i[0])
                    ? ["filter-in-large", r, ["literal", i.sort(qh)]]
                    : ["filter-in-small", r, ["literal", i]];
              }
            }
            function Zh(r) {
              switch (r) {
                case "$type":
                  return !0;
                case "$id":
                  return ["filter-has-id"];
                default:
                  return ["filter-has", r];
              }
            }
            function Do(r) {
              return ["!", r];
            }
            function zl(r) {
              return ti(Fi(r.value))
                ? Ei(
                    Vo({}, r, {
                      expressionContext: "filter",
                      valueSpec: r.styleSpec[`filter_${r.layerType || "fill"}`],
                    })
                  )
                : $a(r);
            }
            function $a(r) {
              const i = r.value,
                o = r.key;
              if ("array" !== hn(i))
                return [new at(o, i, `array expected, ${hn(i)} found`)];
              const l = r.styleSpec;
              let h,
                m = [];
              if (i.length < 1)
                return [
                  new at(o, i, "filter array must have at least 1 element"),
                ];
              switch (
                ((m = m.concat(
                  Hh({
                    key: `${o}[0]`,
                    value: i[0],
                    valueSpec: l.filter_operator,
                    style: r.style,
                    styleSpec: r.styleSpec,
                  })
                )),
                hi(i[0]))
              ) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                  i.length >= 2 &&
                    "$type" === hi(i[1]) &&
                    m.push(
                      new at(
                        o,
                        i,
                        `"$type" cannot be use with operator "${i[0]}"`
                      )
                    );
                case "==":
                case "!=":
                  3 !== i.length &&
                    m.push(
                      new at(
                        o,
                        i,
                        `filter array for operator "${i[0]}" must have 3 elements`
                      )
                    );
                case "in":
                case "!in":
                  i.length >= 2 &&
                    ((h = hn(i[1])),
                    "string" !== h &&
                      m.push(
                        new at(`${o}[1]`, i[1], `string expected, ${h} found`)
                      ));
                  for (let _ = 2; _ < i.length; _++)
                    (h = hn(i[_])),
                      "$type" === hi(i[1])
                        ? (m = m.concat(
                            Hh({
                              key: `${o}[${_}]`,
                              value: i[_],
                              valueSpec: l.geometry_type,
                              style: r.style,
                              styleSpec: r.styleSpec,
                            })
                          ))
                        : "string" !== h &&
                          "number" !== h &&
                          "boolean" !== h &&
                          m.push(
                            new at(
                              `${o}[${_}]`,
                              i[_],
                              `string, number, or boolean expected, ${h} found`
                            )
                          );
                  break;
                case "any":
                case "all":
                case "none":
                  for (let _ = 1; _ < i.length; _++)
                    m = m.concat(
                      $a({
                        key: `${o}[${_}]`,
                        value: i[_],
                        style: r.style,
                        styleSpec: r.styleSpec,
                      })
                    );
                  break;
                case "has":
                case "!has":
                  (h = hn(i[1])),
                    2 !== i.length
                      ? m.push(
                          new at(
                            o,
                            i,
                            `filter array for "${i[0]}" operator must have 2 elements`
                          )
                        )
                      : "string" !== h &&
                        m.push(
                          new at(`${o}[1]`, i[1], `string expected, ${h} found`)
                        );
                  break;
                case "within":
                  (h = hn(i[1])),
                    2 !== i.length
                      ? m.push(
                          new at(
                            o,
                            i,
                            `filter array for "${i[0]}" operator must have 2 elements`
                          )
                        )
                      : "object" !== h &&
                        m.push(
                          new at(`${o}[1]`, i[1], `object expected, ${h} found`)
                        );
              }
              return m;
            }
            function Ft(r, i) {
              const o = r.key,
                l = r.style,
                h = r.styleSpec,
                m = r.value,
                _ = r.objectKey,
                x = h[`${i}_${r.layerType}`];
              if (!x) return [];
              const E = _.match(/^(.*)-transition$/);
              if ("paint" === i && E && x[E[1]] && x[E[1]].transition)
                return fi({
                  key: o,
                  value: m,
                  valueSpec: h.transition,
                  style: l,
                  styleSpec: h,
                });
              const T = r.valueSpec || x[_];
              if (!T) return [new at(o, m, `unknown property "${_}"`)];
              let C;
              if (
                "string" === hn(m) &&
                bc(T) &&
                !T.tokens &&
                (C = /^{([^}]+)}$/.exec(m))
              ) {
                const L = `\`{ "type": "identity", "property": ${
                  C ? JSON.stringify(C[1]) : '"_"'
                } }\``;
                return [
                  new at(
                    o,
                    m,
                    `"${_}" does not support interpolation syntax\nUse an identity property function instead: ${L}.`
                  ),
                ];
              }
              const A = [];
              return (
                "symbol" === r.layerType &&
                  ("text-field" === _ &&
                    l &&
                    !l.glyphs &&
                    A.push(
                      new at(
                        o,
                        m,
                        'use of "text-field" requires a style "glyphs" property'
                      )
                    ),
                  "text-font" === _ &&
                    Su(Fi(m)) &&
                    "identity" === hi(m.type) &&
                    A.push(
                      new at(
                        o,
                        m,
                        '"text-font" does not support identity functions'
                      )
                    )),
                A.concat(
                  fi({
                    key: r.key,
                    value: m,
                    valueSpec: T,
                    style: l,
                    styleSpec: h,
                    expressionContext: "property",
                    propertyType: i,
                    propertyKey: _,
                  })
                )
              );
            }
            function Xh(r) {
              return Ft(r, "paint");
            }
            function mp(r) {
              return Ft(r, "layout");
            }
            function gp(r) {
              let i = [];
              const o = r.value,
                l = r.key,
                h = r.style,
                m = r.styleSpec;
              o.type ||
                o.ref ||
                i.push(new at(l, o, 'either "type" or "ref" is required'));
              let _ = hi(o.type);
              const x = hi(o.ref);
              if (o.id) {
                const E = hi(o.id);
                for (let T = 0; T < r.arrayIndex; T++) {
                  const C = h.layers[T];
                  hi(C.id) === E &&
                    i.push(
                      new at(
                        l,
                        o.id,
                        `duplicate layer id "${o.id}", previously used at line ${C.id.__line__}`
                      )
                    );
                }
              }
              if ("ref" in o) {
                let E;
                ["type", "source", "source-layer", "filter", "layout"].forEach(
                  (T) => {
                    T in o &&
                      i.push(
                        new at(l, o[T], `"${T}" is prohibited for ref layers`)
                      );
                  }
                ),
                  h.layers.forEach((T) => {
                    hi(T.id) === x && (E = T);
                  }),
                  E
                    ? E.ref
                      ? i.push(
                          new at(
                            l,
                            o.ref,
                            "ref cannot reference another ref layer"
                          )
                        )
                      : (_ = hi(E.type))
                    : "string" == typeof x &&
                      i.push(new at(l, o.ref, `ref layer "${x}" not found`));
              } else if ("background" !== _ && "sky" !== _)
                if (o.source) {
                  const E = h.sources && h.sources[o.source],
                    T = E && hi(E.type);
                  E
                    ? "vector" === T && "raster" === _
                      ? i.push(
                          new at(
                            l,
                            o.source,
                            `layer "${o.id}" requires a raster source`
                          )
                        )
                      : "raster" === T && "raster" !== _
                      ? i.push(
                          new at(
                            l,
                            o.source,
                            `layer "${o.id}" requires a vector source`
                          )
                        )
                      : "vector" !== T || o["source-layer"]
                      ? "raster-dem" === T && "hillshade" !== _
                        ? i.push(
                            new at(
                              l,
                              o.source,
                              "raster-dem source can only be used with layer type 'hillshade'."
                            )
                          )
                        : "line" !== _ ||
                          !o.paint ||
                          (!o.paint["line-gradient"] &&
                            !o.paint["line-trim-offset"]) ||
                          ("geojson" === T && E.lineMetrics) ||
                          i.push(
                            new at(
                              l,
                              o,
                              `layer "${o.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`
                            )
                          )
                      : i.push(
                          new at(
                            l,
                            o,
                            `layer "${o.id}" must specify a "source-layer"`
                          )
                        )
                    : i.push(
                        new at(l, o.source, `source "${o.source}" not found`)
                      );
                } else
                  i.push(new at(l, o, 'missing required property "source"'));
              return (
                (i = i.concat(
                  To({
                    key: l,
                    value: o,
                    valueSpec: m.layer,
                    style: r.style,
                    styleSpec: r.styleSpec,
                    objectElementValidators: {
                      "*": () => [],
                      type: () =>
                        fi({
                          key: `${l}.type`,
                          value: o.type,
                          valueSpec: m.layer.type,
                          style: r.style,
                          styleSpec: r.styleSpec,
                          object: o,
                          objectKey: "type",
                        }),
                      filter: (E) => zl(Vo({ layerType: _ }, E)),
                      layout: (E) =>
                        To({
                          layer: o,
                          key: E.key,
                          value: E.value,
                          valueSpec: {},
                          style: E.style,
                          styleSpec: E.styleSpec,
                          objectElementValidators: {
                            "*": (T) => mp(Vo({ layerType: _ }, T)),
                          },
                        }),
                      paint: (E) =>
                        To({
                          layer: o,
                          key: E.key,
                          value: E.value,
                          valueSpec: {},
                          style: E.style,
                          styleSpec: E.styleSpec,
                          objectElementValidators: {
                            "*": (T) => Xh(Vo({ layerType: _ }, T)),
                          },
                        }),
                    },
                  })
                )),
                i
              );
            }
            function Qs(r) {
              const i = r.value,
                o = r.key,
                l = hn(i);
              return "string" !== l
                ? [new at(o, i, `string expected, ${l} found`)]
                : [];
            }
            const _p = {
              promoteId: function ({ key: r, value: i }) {
                if ("string" === hn(i)) return Qs({ key: r, value: i });
                {
                  const o = [];
                  for (const l in i)
                    o.push(...Qs({ key: `${r}.${l}`, value: i[l] }));
                  return o;
                }
              },
            };
            function Kh(r) {
              const i = r.value,
                o = r.key,
                l = r.styleSpec,
                h = r.style;
              if (!i.type) return [new at(o, i, '"type" is required')];
              const m = hi(i.type);
              let _;
              switch (m) {
                case "vector":
                case "raster":
                case "raster-dem":
                  return (
                    (_ = To({
                      key: o,
                      value: i,
                      valueSpec: l[`source_${m.replace("-", "_")}`],
                      style: r.style,
                      styleSpec: l,
                      objectElementValidators: _p,
                    })),
                    _
                  );
                case "geojson":
                  if (
                    ((_ = To({
                      key: o,
                      value: i,
                      valueSpec: l.source_geojson,
                      style: h,
                      styleSpec: l,
                      objectElementValidators: _p,
                    })),
                    i.cluster)
                  )
                    for (const x in i.clusterProperties) {
                      const [E, T] = i.clusterProperties[x],
                        C =
                          "string" == typeof E
                            ? [E, ["accumulated"], ["get", x]]
                            : E;
                      _.push(
                        ...Ei({
                          key: `${o}.${x}.map`,
                          value: T,
                          expressionContext: "cluster-map",
                        })
                      ),
                        _.push(
                          ...Ei({
                            key: `${o}.${x}.reduce`,
                            value: C,
                            expressionContext: "cluster-reduce",
                          })
                        );
                    }
                  return _;
                case "video":
                  return To({
                    key: o,
                    value: i,
                    valueSpec: l.source_video,
                    style: h,
                    styleSpec: l,
                  });
                case "image":
                  return To({
                    key: o,
                    value: i,
                    valueSpec: l.source_image,
                    style: h,
                    styleSpec: l,
                  });
                case "canvas":
                  return [
                    new at(
                      o,
                      null,
                      "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
                      "source.canvas"
                    ),
                  ];
                default:
                  return Hh({
                    key: `${o}.type`,
                    value: i.type,
                    valueSpec: { values: Uf(l) },
                    style: h,
                    styleSpec: l,
                  });
              }
            }
            function Uf(r) {
              return r.source.reduce((i, o) => {
                const l = r[o];
                return (
                  "enum" === l.type.type &&
                    (i = i.concat(Object.keys(l.type.values))),
                  i
                );
              }, []);
            }
            function yp(r) {
              const i = r.value,
                o = r.styleSpec,
                l = o.light,
                h = r.style;
              let m = [];
              const _ = hn(i);
              if (void 0 === i) return m;
              if ("object" !== _)
                return (
                  (m = m.concat([
                    new at("light", i, `object expected, ${_} found`),
                  ])),
                  m
                );
              for (const x in i) {
                const E = x.match(/^(.*)-transition$/);
                m = m.concat(
                  E && l[E[1]] && l[E[1]].transition
                    ? fi({
                        key: x,
                        value: i[x],
                        valueSpec: o.transition,
                        style: h,
                        styleSpec: o,
                      })
                    : l[x]
                    ? fi({
                        key: x,
                        value: i[x],
                        valueSpec: l[x],
                        style: h,
                        styleSpec: o,
                      })
                    : [new at(x, i[x], `unknown property "${x}"`)]
                );
              }
              return m;
            }
            function Ze(r) {
              const i = r.value,
                o = r.key,
                l = r.style,
                h = r.styleSpec,
                m = h.terrain;
              let _ = [];
              const x = hn(i);
              if (void 0 === i) return _;
              if ("object" !== x)
                return (
                  (_ = _.concat([
                    new at("terrain", i, `object expected, ${x} found`),
                  ])),
                  _
                );
              for (const E in i) {
                const T = E.match(/^(.*)-transition$/);
                _ = _.concat(
                  T && m[T[1]] && m[T[1]].transition
                    ? fi({
                        key: E,
                        value: i[E],
                        valueSpec: h.transition,
                        style: l,
                        styleSpec: h,
                      })
                    : m[E]
                    ? fi({
                        key: E,
                        value: i[E],
                        valueSpec: m[E],
                        style: l,
                        styleSpec: h,
                      })
                    : [new at(E, i[E], `unknown property "${E}"`)]
                );
              }
              if (i.source) {
                const E = l.sources && l.sources[i.source],
                  T = E && hi(E.type);
                E
                  ? "raster-dem" !== T &&
                    _.push(
                      new at(
                        o,
                        i.source,
                        `terrain cannot be used with a source of type ${String(
                          T
                        )}, it only be used with a "raster-dem" source type`
                      )
                    )
                  : _.push(
                      new at(o, i.source, `source "${i.source}" not found`)
                    );
              } else _.push(new at(o, i, 'terrain is missing required property "source"'));
              return _;
            }
            function dn(r) {
              const i = r.value,
                o = r.style,
                l = r.styleSpec,
                h = l.fog;
              let m = [];
              const _ = hn(i);
              if (void 0 === i) return m;
              if ("object" !== _)
                return (
                  (m = m.concat([
                    new at("fog", i, `object expected, ${_} found`),
                  ])),
                  m
                );
              for (const x in i) {
                const E = x.match(/^(.*)-transition$/);
                m = m.concat(
                  E && h[E[1]] && h[E[1]].transition
                    ? fi({
                        key: x,
                        value: i[x],
                        valueSpec: l.transition,
                        style: o,
                        styleSpec: l,
                      })
                    : h[x]
                    ? fi({
                        key: x,
                        value: i[x],
                        valueSpec: h[x],
                        style: o,
                        styleSpec: l,
                      })
                    : [new at(x, i[x], `unknown property "${x}"`)]
                );
              }
              return m;
            }
            const Ha = {
              "*": () => [],
              array: Wr,
              boolean: function (r) {
                const i = r.value,
                  o = r.key,
                  l = hn(i);
                return "boolean" !== l
                  ? [new at(o, i, `boolean expected, ${l} found`)]
                  : [];
              },
              number: Va,
              color: function (r) {
                const i = r.key,
                  o = r.value,
                  l = hn(o);
                return "string" !== l
                  ? [new at(i, o, `color expected, ${l} found`)]
                  : null === Dl(o)
                  ? [new at(i, o, `color expected, "${o}" found`)]
                  : [];
              },
              enum: Hh,
              filter: zl,
              function: Dc,
              layer: gp,
              object: To,
              source: Kh,
              light: yp,
              terrain: Ze,
              fog: dn,
              string: Qs,
              formatted: function (r) {
                return 0 === Qs(r).length ? [] : Ei(r);
              },
              resolvedImage: function (r) {
                return 0 === Qs(r).length ? [] : Ei(r);
              },
              projection: function (r) {
                const i = r.value,
                  o = r.styleSpec,
                  l = o.projection,
                  h = r.style;
                let m = [];
                const _ = hn(i);
                if ("object" === _)
                  for (const x in i)
                    m = m.concat(
                      fi({
                        key: x,
                        value: i[x],
                        valueSpec: l[x],
                        style: h,
                        styleSpec: o,
                      })
                    );
                else
                  "string" !== _ &&
                    (m = m.concat([
                      new at(
                        "projection",
                        i,
                        `object or string expected, ${_} found`
                      ),
                    ]));
                return m;
              },
            };
            function fi(r) {
              const i = r.value,
                o = r.valueSpec,
                l = r.styleSpec;
              return o.expression && Su(hi(i))
                ? Dc(r)
                : o.expression && Zo(Fi(i))
                ? Ei(r)
                : o.type && Ha[o.type]
                ? Ha[o.type](r)
                : To(Vo({}, r, { valueSpec: o.type ? l[o.type] : o }));
            }
            function Pi(r) {
              const i = r.value,
                o = r.key,
                l = Qs(r);
              return (
                l.length ||
                  (-1 === i.indexOf("{fontstack}") &&
                    l.push(
                      new at(
                        o,
                        i,
                        '"glyphs" url must include a "{fontstack}" token'
                      )
                    ),
                  -1 === i.indexOf("{range}") &&
                    l.push(
                      new at(
                        o,
                        i,
                        '"glyphs" url must include a "{range}" token'
                      )
                    )),
                l
              );
            }
            function Yh(r, i = Ae) {
              return kr(
                fi({
                  key: "",
                  value: r,
                  valueSpec: i.$root,
                  styleSpec: i,
                  style: r,
                  objectElementValidators: { glyphs: Pi, "*": () => [] },
                })
              );
            }
            const Ic = (r) => kr(Xh(r)),
              Xo = (r) => kr(mp(r));
            function kr(r) {
              return r
                .slice()
                .sort((i, o) => (i.line && o.line ? i.line - o.line : 0));
            }
            function Au(r, i) {
              let o = !1;
              if (i && i.length)
                for (const l of i)
                  r.fire(new us(new Error(l.message))), (o = !0);
              return o;
            }
            var Ng = ms;
            function ms(r, i, o) {
              var l = (this.cells = []);
              if (r instanceof ArrayBuffer) {
                this.arrayBuffer = r;
                var h = new Int32Array(this.arrayBuffer);
                (r = h[0]), (this.d = (i = h[1]) + 2 * (o = h[2]));
                for (var m = 0; m < this.d * this.d; m++) {
                  var _ = h[3 + m],
                    x = h[3 + m + 1];
                  l.push(_ === x ? null : h.subarray(_, x));
                }
                var E = h[3 + l.length + 1];
                (this.keys = h.subarray(h[3 + l.length], E)),
                  (this.bboxes = h.subarray(E)),
                  (this.insert = this._insertReadonly);
              } else {
                this.d = i + 2 * o;
                for (var T = 0; T < this.d * this.d; T++) l.push([]);
                (this.keys = []), (this.bboxes = []);
              }
              (this.n = i),
                (this.extent = r),
                (this.padding = o),
                (this.scale = i / r),
                (this.uid = 0);
              var C = (o / i) * r;
              (this.min = -C), (this.max = r + C);
            }
            (ms.prototype.insert = function (r, i, o, l, h) {
              this._forEachCell(i, o, l, h, this._insertCell, this.uid++),
                this.keys.push(r),
                this.bboxes.push(i),
                this.bboxes.push(o),
                this.bboxes.push(l),
                this.bboxes.push(h);
            }),
              (ms.prototype._insertReadonly = function () {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
              }),
              (ms.prototype._insertCell = function (r, i, o, l, h, m) {
                this.cells[h].push(m);
              }),
              (ms.prototype.query = function (r, i, o, l, h) {
                var m = this.min,
                  _ = this.max;
                if (r <= m && i <= m && _ <= o && _ <= l && !h)
                  return Array.prototype.slice.call(this.keys);
                var x = [];
                return (
                  this._forEachCell(r, i, o, l, this._queryCell, x, {}, h), x
                );
              }),
              (ms.prototype._queryCell = function (r, i, o, l, h, m, _, x) {
                var E = this.cells[h];
                if (null !== E)
                  for (
                    var T = this.keys, C = this.bboxes, A = 0;
                    A < E.length;
                    A++
                  ) {
                    var L = E[A];
                    if (void 0 === _[L]) {
                      var O = 4 * L;
                      (
                        x
                          ? x(C[O + 0], C[O + 1], C[O + 2], C[O + 3])
                          : r <= C[O + 2] &&
                            i <= C[O + 3] &&
                            o >= C[O + 0] &&
                            l >= C[O + 1]
                      )
                        ? ((_[L] = !0), m.push(T[L]))
                        : (_[L] = !1);
                    }
                  }
              }),
              (ms.prototype._forEachCell = function (r, i, o, l, h, m, _, x) {
                for (
                  var E = this._convertToCellCoord(r),
                    T = this._convertToCellCoord(i),
                    C = this._convertToCellCoord(o),
                    A = this._convertToCellCoord(l),
                    L = E;
                  L <= C;
                  L++
                )
                  for (var O = T; O <= A; O++) {
                    var F = this.d * O + L;
                    if (
                      (!x ||
                        x(
                          this._convertFromCellCoord(L),
                          this._convertFromCellCoord(O),
                          this._convertFromCellCoord(L + 1),
                          this._convertFromCellCoord(O + 1)
                        )) &&
                      h.call(this, r, i, o, l, F, m, _, x)
                    )
                      return;
                  }
              }),
              (ms.prototype._convertFromCellCoord = function (r) {
                return (r - this.padding) / this.scale;
              }),
              (ms.prototype._convertToCellCoord = function (r) {
                return Math.max(
                  0,
                  Math.min(
                    this.d - 1,
                    Math.floor(r * this.scale) + this.padding
                  )
                );
              }),
              (ms.prototype.toArrayBuffer = function () {
                if (this.arrayBuffer) return this.arrayBuffer;
                for (
                  var r = this.cells,
                    i = 3 + this.cells.length + 1 + 1,
                    o = 0,
                    l = 0;
                  l < this.cells.length;
                  l++
                )
                  o += this.cells[l].length;
                var h = new Int32Array(
                  i + o + this.keys.length + this.bboxes.length
                );
                (h[0] = this.extent), (h[1] = this.n), (h[2] = this.padding);
                for (var m = i, _ = 0; _ < r.length; _++) {
                  var x = r[_];
                  (h[3 + _] = m), h.set(x, m), (m += x.length);
                }
                return (
                  (h[3 + r.length] = m),
                  h.set(this.keys, m),
                  (h[3 + r.length + 1] = m += this.keys.length),
                  h.set(this.bboxes, m),
                  (m += this.bboxes.length),
                  h.buffer
                );
              });
            var Js = Vr(Ng);
            const Vi = {};
            function st(r, i, o = {}) {
              Object.defineProperty(r, "_classRegistryKey", {
                value: i,
                writeable: !1,
              }),
                (Vi[i] = { klass: r, omit: o.omit || [] });
            }
            st(Object, "Object"),
              (Js.serialize = function (r, i) {
                const o = r.toArrayBuffer();
                return i && i.push(o), { buffer: o };
              }),
              (Js.deserialize = function (r) {
                return new Js(r.buffer);
              }),
              Object.defineProperty(Js, "name", { value: "Grid" }),
              st(Js, "Grid"),
              st(di, "Color"),
              st(Error, "Error"),
              st(Vs, "AJAXError"),
              st(go, "ResolvedImage"),
              st(Tc, "StylePropertyFunction"),
              st(Iu, "StyleExpression", { omit: ["_evaluator"] }),
              st(Ec, "ZoomDependentExpression"),
              st($h, "ZoomConstantExpression"),
              st(Uo, "CompoundExpression", { omit: ["_evaluate"] });
            for (const r in Du)
              Vi[Du[r]._classRegistryKey] || st(Du[r], `Expression${r}`);
            function Pu(r) {
              return (
                r &&
                typeof ArrayBuffer < "u" &&
                (r instanceof ArrayBuffer ||
                  (r.constructor && "ArrayBuffer" === r.constructor.name))
              );
            }
            function ea(r) {
              return Be.ImageBitmap && r instanceof Be.ImageBitmap;
            }
            function Rr(r, i) {
              if (
                null == r ||
                "boolean" == typeof r ||
                "number" == typeof r ||
                "string" == typeof r ||
                r instanceof Boolean ||
                r instanceof Number ||
                r instanceof String ||
                r instanceof Date ||
                r instanceof RegExp
              )
                return r;
              if (Pu(r) || ea(r)) return i && i.push(r), r;
              if (ArrayBuffer.isView(r)) {
                const o = r;
                return i && i.push(o.buffer), o;
              }
              if (r instanceof Be.ImageData)
                return i && i.push(r.data.buffer), r;
              if (Array.isArray(r)) {
                const o = [];
                for (const l of r) o.push(Rr(l, i));
                return o;
              }
              if ("object" == typeof r) {
                const o = r.constructor,
                  l = o._classRegistryKey;
                if (!l)
                  throw new Error(
                    `can't serialize object of unregistered class ${l}`
                  );
                const h = o.serialize ? o.serialize(r, i) : {};
                if (!o.serialize) {
                  for (const m in r)
                    r.hasOwnProperty(m) &&
                      (Vi[l].omit.indexOf(m) >= 0 || (h[m] = Rr(r[m], i)));
                  r instanceof Error && (h.message = r.message);
                }
                if (h.$name)
                  throw new Error(
                    "$name property is reserved for worker serialization logic."
                  );
                return "Object" !== l && (h.$name = l), h;
              }
              throw new Error("can't serialize object of type " + typeof r);
            }
            function Ga(r) {
              if (
                null == r ||
                "boolean" == typeof r ||
                "number" == typeof r ||
                "string" == typeof r ||
                r instanceof Boolean ||
                r instanceof Number ||
                r instanceof String ||
                r instanceof Date ||
                r instanceof RegExp ||
                Pu(r) ||
                ea(r) ||
                ArrayBuffer.isView(r) ||
                r instanceof Be.ImageData
              )
                return r;
              if (Array.isArray(r)) return r.map(Ga);
              if ("object" == typeof r) {
                const i = r.$name || "Object",
                  { klass: o } = Vi[i];
                if (!o)
                  throw new Error(`can't deserialize unregistered class ${i}`);
                if (o.deserialize) return o.deserialize(r);
                const l = Object.create(o.prototype);
                for (const h of Object.keys(r))
                  "$name" !== h && (l[h] = Ga(r[h]));
                return l;
              }
              throw new Error("can't deserialize object of type " + typeof r);
            }
            const ot_Latin_1_Supplement = (r) => r >= 128 && r <= 255,
              ot_Arabic = (r) => r >= 1536 && r <= 1791,
              ot_Arabic_Supplement = (r) => r >= 1872 && r <= 1919,
              ot_Arabic_Extended_A = (r) => r >= 2208 && r <= 2303,
              ot_Hangul_Jamo = (r) => r >= 4352 && r <= 4607,
              ot_Unified_Canadian_Aboriginal_Syllabics = (r) =>
                r >= 5120 && r <= 5759,
              ot_Khmer = (r) => r >= 6016 && r <= 6143,
              ot_Unified_Canadian_Aboriginal_Syllabics_Extended = (r) =>
                r >= 6320 && r <= 6399,
              ot_General_Punctuation = (r) => r >= 8192 && r <= 8303,
              ot_Letterlike_Symbols = (r) => r >= 8448 && r <= 8527,
              ot_Number_Forms = (r) => r >= 8528 && r <= 8591,
              ot_Miscellaneous_Technical = (r) => r >= 8960 && r <= 9215,
              ot_Control_Pictures = (r) => r >= 9216 && r <= 9279,
              ot_Optical_Character_Recognition = (r) => r >= 9280 && r <= 9311,
              ot_Enclosed_Alphanumerics = (r) => r >= 9312 && r <= 9471,
              ot_Geometric_Shapes = (r) => r >= 9632 && r <= 9727,
              ot_Miscellaneous_Symbols = (r) => r >= 9728 && r <= 9983,
              ot_Miscellaneous_Symbols_and_Arrows = (r) =>
                r >= 11008 && r <= 11263,
              ot_CJK_Radicals_Supplement = (r) => r >= 11904 && r <= 12031,
              ot_Kangxi_Radicals = (r) => r >= 12032 && r <= 12255,
              ot_Ideographic_Description_Characters = (r) =>
                r >= 12272 && r <= 12287,
              ot_CJK_Symbols_and_Punctuation = (r) => r >= 12288 && r <= 12351,
              ot_Hiragana = (r) => r >= 12352 && r <= 12447,
              ot_Katakana = (r) => r >= 12448 && r <= 12543,
              ot_Bopomofo = (r) => r >= 12544 && r <= 12591,
              ot_Hangul_Compatibility_Jamo = (r) => r >= 12592 && r <= 12687,
              ot_Kanbun = (r) => r >= 12688 && r <= 12703,
              ot_Bopomofo_Extended = (r) => r >= 12704 && r <= 12735,
              ot_CJK_Strokes = (r) => r >= 12736 && r <= 12783,
              ot_Katakana_Phonetic_Extensions = (r) => r >= 12784 && r <= 12799,
              ot_Enclosed_CJK_Letters_and_Months = (r) =>
                r >= 12800 && r <= 13055,
              ot_CJK_Compatibility = (r) => r >= 13056 && r <= 13311,
              ot_CJK_Unified_Ideographs_Extension_A = (r) =>
                r >= 13312 && r <= 19903,
              ot_Yijing_Hexagram_Symbols = (r) => r >= 19904 && r <= 19967,
              ot_CJK_Unified_Ideographs = (r) => r >= 19968 && r <= 40959,
              ot_Yi_Syllables = (r) => r >= 40960 && r <= 42127,
              ot_Yi_Radicals = (r) => r >= 42128 && r <= 42191,
              ot_Hangul_Jamo_Extended_A = (r) => r >= 43360 && r <= 43391,
              ot_Hangul_Syllables = (r) => r >= 44032 && r <= 55215,
              ot_Hangul_Jamo_Extended_B = (r) => r >= 55216 && r <= 55295,
              ot_Private_Use_Area = (r) => r >= 57344 && r <= 63743,
              ot_CJK_Compatibility_Ideographs = (r) => r >= 63744 && r <= 64255,
              ot_Arabic_Presentation_Forms_A = (r) => r >= 64336 && r <= 65023,
              ot_Vertical_Forms = (r) => r >= 65040 && r <= 65055,
              ot_CJK_Compatibility_Forms = (r) => r >= 65072 && r <= 65103,
              ot_Small_Form_Variants = (r) => r >= 65104 && r <= 65135,
              ot_Arabic_Presentation_Forms_B = (r) => r >= 65136 && r <= 65279,
              ot_Halfwidth_and_Fullwidth_Forms = (r) =>
                r >= 65280 && r <= 65519;
            function Qh(r) {
              for (const i of r) if (Cc(i.charCodeAt(0))) return !0;
              return !1;
            }
            function $f(r) {
              for (const i of r) if (!Lu(i.charCodeAt(0))) return !1;
              return !0;
            }
            function Lu(r) {
              return !(
                ot_Arabic(r) ||
                ot_Arabic_Supplement(r) ||
                ot_Arabic_Extended_A(r) ||
                ot_Arabic_Presentation_Forms_A(r) ||
                ot_Arabic_Presentation_Forms_B(r)
              );
            }
            function Cc(r) {
              return !(
                746 !== r &&
                747 !== r &&
                (r < 4352 ||
                  !(
                    ot_Bopomofo_Extended(r) ||
                    ot_Bopomofo(r) ||
                    (ot_CJK_Compatibility_Forms(r) &&
                      !(r >= 65097 && r <= 65103)) ||
                    ot_CJK_Compatibility_Ideographs(r) ||
                    ot_CJK_Compatibility(r) ||
                    ot_CJK_Radicals_Supplement(r) ||
                    ot_CJK_Strokes(r) ||
                    !(
                      !ot_CJK_Symbols_and_Punctuation(r) ||
                      (r >= 12296 && r <= 12305) ||
                      (r >= 12308 && r <= 12319) ||
                      12336 === r
                    ) ||
                    ot_CJK_Unified_Ideographs_Extension_A(r) ||
                    ot_CJK_Unified_Ideographs(r) ||
                    ot_Enclosed_CJK_Letters_and_Months(r) ||
                    ot_Hangul_Compatibility_Jamo(r) ||
                    ot_Hangul_Jamo_Extended_A(r) ||
                    ot_Hangul_Jamo_Extended_B(r) ||
                    ot_Hangul_Jamo(r) ||
                    ot_Hangul_Syllables(r) ||
                    ot_Hiragana(r) ||
                    ot_Ideographic_Description_Characters(r) ||
                    ot_Kanbun(r) ||
                    ot_Kangxi_Radicals(r) ||
                    ot_Katakana_Phonetic_Extensions(r) ||
                    (ot_Katakana(r) && 12540 !== r) ||
                    !(
                      !ot_Halfwidth_and_Fullwidth_Forms(r) ||
                      65288 === r ||
                      65289 === r ||
                      65293 === r ||
                      (r >= 65306 && r <= 65310) ||
                      65339 === r ||
                      65341 === r ||
                      65343 === r ||
                      (r >= 65371 && r <= 65503) ||
                      65507 === r ||
                      (r >= 65512 && r <= 65519)
                    ) ||
                    !(
                      !ot_Small_Form_Variants(r) ||
                      (r >= 65112 && r <= 65118) ||
                      (r >= 65123 && r <= 65126)
                    ) ||
                    ot_Unified_Canadian_Aboriginal_Syllabics(r) ||
                    ot_Unified_Canadian_Aboriginal_Syllabics_Extended(r) ||
                    ot_Vertical_Forms(r) ||
                    ot_Yijing_Hexagram_Symbols(r) ||
                    ot_Yi_Syllables(r) ||
                    ot_Yi_Radicals(r)
                  ))
              );
            }
            function Jh(r) {
              return !(
                Cc(r) ||
                ((i = r),
                (ot_Latin_1_Supplement(i) &&
                  (167 === i ||
                    169 === i ||
                    174 === i ||
                    177 === i ||
                    188 === i ||
                    189 === i ||
                    190 === i ||
                    215 === i ||
                    247 === i)) ||
                  (ot_General_Punctuation(i) &&
                    (8214 === i ||
                      8224 === i ||
                      8225 === i ||
                      8240 === i ||
                      8241 === i ||
                      8251 === i ||
                      8252 === i ||
                      8258 === i ||
                      8263 === i ||
                      8264 === i ||
                      8265 === i ||
                      8273 === i)) ||
                  ot_Letterlike_Symbols(i) ||
                  ot_Number_Forms(i) ||
                  (ot_Miscellaneous_Technical(i) &&
                    ((i >= 8960 && i <= 8967) ||
                      (i >= 8972 && i <= 8991) ||
                      (i >= 8996 && i <= 9e3) ||
                      9003 === i ||
                      (i >= 9085 && i <= 9114) ||
                      (i >= 9150 && i <= 9165) ||
                      9167 === i ||
                      (i >= 9169 && i <= 9179) ||
                      (i >= 9186 && i <= 9215))) ||
                  (ot_Control_Pictures(i) && 9251 !== i) ||
                  ot_Optical_Character_Recognition(i) ||
                  ot_Enclosed_Alphanumerics(i) ||
                  ot_Geometric_Shapes(i) ||
                  (ot_Miscellaneous_Symbols(i) && !(i >= 9754 && i <= 9759)) ||
                  (ot_Miscellaneous_Symbols_and_Arrows(i) &&
                    ((i >= 11026 && i <= 11055) ||
                      (i >= 11088 && i <= 11097) ||
                      (i >= 11192 && i <= 11243))) ||
                  ot_CJK_Symbols_and_Punctuation(i) ||
                  ot_Katakana(i) ||
                  ot_Private_Use_Area(i) ||
                  ot_CJK_Compatibility_Forms(i) ||
                  ot_Small_Form_Variants(i) ||
                  ot_Halfwidth_and_Fullwidth_Forms(i) ||
                  8734 === i ||
                  8756 === i ||
                  8757 === i ||
                  (i >= 9984 && i <= 10087) ||
                  (i >= 10102 && i <= 10131) ||
                  65532 === i ||
                  65533 === i)
              );
              var i;
            }
            function ku(r) {
              return (
                (r >= 1424 && r <= 2303) ||
                ot_Arabic_Presentation_Forms_A(r) ||
                ot_Arabic_Presentation_Forms_B(r)
              );
            }
            function Hf(r, i) {
              return !(
                (!i && ku(r)) ||
                (r >= 2304 && r <= 3583) ||
                (r >= 3840 && r <= 4255) ||
                ot_Khmer(r)
              );
            }
            function vp(r) {
              for (const i of r) if (ku(i.charCodeAt(0))) return !0;
              return !1;
            }
            const Mc = "deferred",
              Ru = "loading",
              Ou = "loaded";
            let qa = null,
              f = "unavailable",
              a = null;
            const u = function (r) {
              r &&
                "string" == typeof r &&
                r.indexOf("NetworkError") > -1 &&
                (f = "error"),
                qa && qa(r);
            };
            function g() {
              v.fire(
                new Ra("pluginStateChange", { pluginStatus: f, pluginURL: a })
              );
            }
            const v = new pc(),
              b = function () {
                return f;
              },
              D = function () {
                if (f !== Mc || !a)
                  throw new Error(
                    "rtl-text-plugin cannot be downloaded unless a pluginURL is specified"
                  );
                (f = Ru),
                  g(),
                  a &&
                    Tl({ url: a }, (r) => {
                      r ? u(r) : ((f = Ou), g());
                    });
              },
              I = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: () => f === Ou || null != I.applyArabicShaping,
                isLoading: () => f === Ru,
                setState(r) {
                  (f = r.pluginStatus), (a = r.pluginURL);
                },
                isParsed: () =>
                  null != I.applyArabicShaping &&
                  null != I.processBidirectionalText &&
                  null != I.processStyledBidirectionalText,
                getPluginURL: () => a,
              };
            class M {
              constructor(i, o) {
                (this.zoom = i),
                  o
                    ? ((this.now = o.now),
                      (this.fadeDuration = o.fadeDuration),
                      (this.transition = o.transition),
                      (this.pitch = o.pitch))
                    : ((this.now = 0),
                      (this.fadeDuration = 0),
                      (this.transition = {}),
                      (this.pitch = 0));
              }
              isSupportedScript(i) {
                return (function (o, l) {
                  for (const h of o) if (!Hf(h.charCodeAt(0), l)) return !1;
                  return !0;
                })(i, I.isLoaded());
              }
            }
            class R {
              constructor(i, o) {
                (this.property = i),
                  (this.value = o),
                  (this.expression = (function (l, h) {
                    if (Su(l)) return new Tc(l, h);
                    if (Zo(l)) {
                      const m = Fl(l, h);
                      if ("error" === m.result)
                        throw new Error(
                          m.value
                            .map((_) => `${_.key}: ${_.message}`)
                            .join(", ")
                        );
                      return m.value;
                    }
                    {
                      let m = l;
                      return (
                        "string" == typeof l &&
                          "color" === h.type &&
                          (m = di.parse(l)),
                        { kind: "constant", evaluate: () => m }
                      );
                    }
                  })(
                    void 0 === o ? i.specification.default : o,
                    i.specification
                  ));
              }
              isDataDriven() {
                return (
                  "source" === this.expression.kind ||
                  "composite" === this.expression.kind
                );
              }
              possiblyEvaluate(i, o, l) {
                return this.property.possiblyEvaluate(this, i, o, l);
              }
            }
            class k {
              constructor(i) {
                (this.property = i), (this.value = new R(i, void 0));
              }
              transitioned(i, o) {
                return new H(
                  this.property,
                  this.value,
                  o,
                  ci({}, i.transition, this.transition),
                  i.now
                );
              }
              untransitioned() {
                return new H(this.property, this.value, null, {}, 0);
              }
            }
            class z {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(
                    i.defaultTransitionablePropertyValues
                  ));
              }
              getValue(i) {
                return jr(this._values[i].value.value);
              }
              setValue(i, o) {
                this._values.hasOwnProperty(i) ||
                  (this._values[i] = new k(this._values[i].property)),
                  (this._values[i].value = new R(
                    this._values[i].property,
                    null === o ? void 0 : jr(o)
                  ));
              }
              getTransition(i) {
                return jr(this._values[i].transition);
              }
              setTransition(i, o) {
                this._values.hasOwnProperty(i) ||
                  (this._values[i] = new k(this._values[i].property)),
                  (this._values[i].transition = jr(o) || void 0);
              }
              serialize() {
                const i = {};
                for (const o of Object.keys(this._values)) {
                  const l = this.getValue(o);
                  void 0 !== l && (i[o] = l);
                  const h = this.getTransition(o);
                  void 0 !== h && (i[`${o}-transition`] = h);
                }
                return i;
              }
              transitioned(i, o) {
                const l = new q(this._properties);
                for (const h of Object.keys(this._values))
                  l._values[h] = this._values[h].transitioned(i, o._values[h]);
                return l;
              }
              untransitioned() {
                const i = new q(this._properties);
                for (const o of Object.keys(this._values))
                  i._values[o] = this._values[o].untransitioned();
                return i;
              }
            }
            class H {
              constructor(i, o, l, h, m) {
                const _ = h.delay || 0,
                  x = h.duration || 0;
                (m = m || 0),
                  (this.property = i),
                  (this.value = o),
                  (this.begin = m + _),
                  (this.end = this.begin + x),
                  i.specification.transition &&
                    (h.delay || h.duration) &&
                    (this.prior = l);
              }
              possiblyEvaluate(i, o, l) {
                const h = i.now || 0,
                  m = this.value.possiblyEvaluate(i, o, l),
                  _ = this.prior;
                if (_) {
                  if (h > this.end) return (this.prior = null), m;
                  if (this.value.isDataDriven()) return (this.prior = null), m;
                  if (h < this.begin) return _.possiblyEvaluate(i, o, l);
                  {
                    const x = (h - this.begin) / (this.end - this.begin);
                    return this.property.interpolate(
                      _.possiblyEvaluate(i, o, l),
                      m,
                      au(x)
                    );
                  }
                }
                return m;
              }
            }
            class q {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(
                    i.defaultTransitioningPropertyValues
                  ));
              }
              possiblyEvaluate(i, o, l) {
                const h = new Y(this._properties);
                for (const m of Object.keys(this._values))
                  h._values[m] = this._values[m].possiblyEvaluate(i, o, l);
                return h;
              }
              hasTransition() {
                for (const i of Object.keys(this._values))
                  if (this._values[i].prior) return !0;
                return !1;
              }
            }
            class X {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(i.defaultPropertyValues));
              }
              getValue(i) {
                return jr(this._values[i].value);
              }
              setValue(i, o) {
                this._values[i] = new R(
                  this._values[i].property,
                  null === o ? void 0 : jr(o)
                );
              }
              serialize() {
                const i = {};
                for (const o of Object.keys(this._values)) {
                  const l = this.getValue(o);
                  void 0 !== l && (i[o] = l);
                }
                return i;
              }
              possiblyEvaluate(i, o, l) {
                const h = new Y(this._properties);
                for (const m of Object.keys(this._values))
                  h._values[m] = this._values[m].possiblyEvaluate(i, o, l);
                return h;
              }
            }
            class Z {
              constructor(i, o, l) {
                (this.property = i), (this.value = o), (this.parameters = l);
              }
              isConstant() {
                return "constant" === this.value.kind;
              }
              constantOr(i) {
                return "constant" === this.value.kind ? this.value.value : i;
              }
              evaluate(i, o, l, h) {
                return this.property.evaluate(
                  this.value,
                  this.parameters,
                  i,
                  o,
                  l,
                  h
                );
              }
            }
            class Y {
              constructor(i) {
                (this._properties = i),
                  (this._values = Object.create(
                    i.defaultPossiblyEvaluatedValues
                  ));
              }
              get(i) {
                return this._values[i];
              }
            }
            class B {
              constructor(i) {
                this.specification = i;
              }
              possiblyEvaluate(i, o) {
                return i.expression.evaluate(o);
              }
              interpolate(i, o, l) {
                const h = Mi[this.specification.type];
                return h ? h(i, o, l) : i;
              }
            }
            class W {
              constructor(i, o) {
                (this.specification = i), (this.overrides = o);
              }
              possiblyEvaluate(i, o, l, h) {
                return new Z(
                  this,
                  "constant" === i.expression.kind ||
                  "camera" === i.expression.kind
                    ? {
                        kind: "constant",
                        value: i.expression.evaluate(o, null, {}, l, h),
                      }
                    : i.expression,
                  o
                );
              }
              interpolate(i, o, l) {
                if ("constant" !== i.value.kind || "constant" !== o.value.kind)
                  return i;
                if (void 0 === i.value.value || void 0 === o.value.value)
                  return new Z(
                    this,
                    { kind: "constant", value: void 0 },
                    i.parameters
                  );
                const h = Mi[this.specification.type];
                return h
                  ? new Z(
                      this,
                      {
                        kind: "constant",
                        value: h(i.value.value, o.value.value, l),
                      },
                      i.parameters
                    )
                  : i;
              }
              evaluate(i, o, l, h, m, _) {
                return "constant" === i.kind
                  ? i.value
                  : i.evaluate(o, l, h, m, _);
              }
            }
            class ee {
              constructor(i) {
                this.specification = i;
              }
              possiblyEvaluate(i, o, l, h) {
                return !!i.expression.evaluate(o, null, {}, l, h);
              }
              interpolate() {
                return !1;
              }
            }
            class te {
              constructor(i) {
                (this.properties = i),
                  (this.defaultPropertyValues = {}),
                  (this.defaultTransitionablePropertyValues = {}),
                  (this.defaultTransitioningPropertyValues = {}),
                  (this.defaultPossiblyEvaluatedValues = {}),
                  (this.overridableProperties = []);
                const o = new M(0, {});
                for (const l in i) {
                  const h = i[l];
                  h.specification.overridable &&
                    this.overridableProperties.push(l);
                  const m = (this.defaultPropertyValues[l] = new R(h, void 0)),
                    _ = (this.defaultTransitionablePropertyValues[l] = new k(
                      h
                    ));
                  (this.defaultTransitioningPropertyValues[l] =
                    _.untransitioned()),
                    (this.defaultPossiblyEvaluatedValues[l] =
                      m.possiblyEvaluate(o));
                }
              }
            }
            function he(r, i) {
              return (
                256 * (r = Qt(Math.floor(r), 0, 255)) +
                Qt(Math.floor(i), 0, 255)
              );
            }
            st(W, "DataDrivenProperty"),
              st(B, "DataConstantProperty"),
              st(ee, "ColorRampProperty");
            const de = {
              Int8: Int8Array,
              Uint8: Uint8Array,
              Int16: Int16Array,
              Uint16: Uint16Array,
              Int32: Int32Array,
              Uint32: Uint32Array,
              Float32: Float32Array,
            };
            class ue {
              constructor(i, o) {
                (this._structArray = i),
                  (this._pos1 = o * this.size),
                  (this._pos2 = this._pos1 / 2),
                  (this._pos4 = this._pos1 / 4),
                  (this._pos8 = this._pos1 / 8);
              }
            }
            class _e {
              constructor() {
                (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
              }
              static serialize(i, o) {
                return (
                  i._trim(),
                  o && ((i.isTransferred = !0), o.push(i.arrayBuffer)),
                  { length: i.length, arrayBuffer: i.arrayBuffer }
                );
              }
              static deserialize(i) {
                const o = Object.create(this.prototype);
                return (
                  (o.arrayBuffer = i.arrayBuffer),
                  (o.length = i.length),
                  (o.capacity = i.arrayBuffer.byteLength / o.bytesPerElement),
                  o._refreshViews(),
                  o
                );
              }
              _trim() {
                this.length !== this.capacity &&
                  ((this.capacity = this.length),
                  (this.arrayBuffer = this.arrayBuffer.slice(
                    0,
                    this.length * this.bytesPerElement
                  )),
                  this._refreshViews());
              }
              clear() {
                this.length = 0;
              }
              resize(i) {
                this.reserve(i), (this.length = i);
              }
              reserve(i) {
                if (i > this.capacity) {
                  (this.capacity = Math.max(
                    i,
                    Math.floor(5 * this.capacity),
                    128
                  )),
                    (this.arrayBuffer = new ArrayBuffer(
                      this.capacity * this.bytesPerElement
                    ));
                  const o = this.uint8;
                  this._refreshViews(), o && this.uint8.set(o);
                }
              }
              _refreshViews() {
                throw new Error(
                  "_refreshViews() must be implemented by each concrete StructArray layout"
                );
              }
              destroy() {
                (this.int8 =
                  this.uint8 =
                  this.int16 =
                  this.uint16 =
                  this.int32 =
                  this.uint32 =
                  this.float32 =
                    null),
                  (this.arrayBuffer = null);
              }
            }
            function ge(r, i = 1) {
              let o = 0,
                l = 0;
              return {
                members: r.map((h) => {
                  const m = de[h.type].BYTES_PER_ELEMENT,
                    _ = (o = Te(o, Math.max(i, m))),
                    x = h.components || 1;
                  return (
                    (l = Math.max(l, m)),
                    (o += m * x),
                    { name: h.name, type: h.type, components: x, offset: _ }
                  );
                }),
                size: Te(o, Math.max(l, i)),
                alignment: i,
              };
            }
            function Te(r, i) {
              return Math.ceil(r / i) * i;
            }
            class Ge extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o) {
                const l = this.length;
                return this.resize(l + 1), this.emplace(l, i, o);
              }
              emplace(i, o, l) {
                const h = 2 * i;
                return (this.int16[h + 0] = o), (this.int16[h + 1] = l), i;
              }
            }
            (Ge.prototype.bytesPerElement = 4), st(Ge, "StructArrayLayout2i4");
            class be extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, i, o, l);
              }
              emplace(i, o, l, h) {
                const m = 3 * i;
                return (
                  (this.int16[m + 0] = o),
                  (this.int16[m + 1] = l),
                  (this.int16[m + 2] = h),
                  i
                );
              }
            }
            (be.prototype.bytesPerElement = 6), st(be, "StructArrayLayout3i6");
            class Le extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 4 * i;
                return (
                  (this.int16[_ + 0] = o),
                  (this.int16[_ + 1] = l),
                  (this.int16[_ + 2] = h),
                  (this.int16[_ + 3] = m),
                  i
                );
              }
            }
            (Le.prototype.bytesPerElement = 8), st(Le, "StructArrayLayout4i8");
            class Ie extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x) {
                const E = this.length;
                return this.resize(E + 1), this.emplace(E, i, o, l, h, m, _, x);
              }
              emplace(i, o, l, h, m, _, x, E) {
                const T = 6 * i,
                  C = 12 * i,
                  A = 3 * i;
                return (
                  (this.int16[T + 0] = o),
                  (this.int16[T + 1] = l),
                  (this.uint8[C + 4] = h),
                  (this.uint8[C + 5] = m),
                  (this.uint8[C + 6] = _),
                  (this.uint8[C + 7] = x),
                  (this.float32[A + 2] = E),
                  i
                );
              }
            }
            (Ie.prototype.bytesPerElement = 12),
              st(Ie, "StructArrayLayout2i4ub1f12");
            class je extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 4 * i;
                return (
                  (this.float32[_ + 0] = o),
                  (this.float32[_ + 1] = l),
                  (this.float32[_ + 2] = h),
                  (this.float32[_ + 3] = m),
                  i
                );
              }
            }
            (je.prototype.bytesPerElement = 16),
              st(je, "StructArrayLayout4f16");
            class we extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, i, o, l, h, m);
              }
              emplace(i, o, l, h, m, _) {
                const x = 6 * i,
                  E = 3 * i;
                return (
                  (this.uint16[x + 0] = o),
                  (this.uint16[x + 1] = l),
                  (this.uint16[x + 2] = h),
                  (this.uint16[x + 3] = m),
                  (this.float32[E + 2] = _),
                  i
                );
              }
            }
            (we.prototype.bytesPerElement = 12),
              st(we, "StructArrayLayout4ui1f12");
            class ke extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 4 * i;
                return (
                  (this.uint16[_ + 0] = o),
                  (this.uint16[_ + 1] = l),
                  (this.uint16[_ + 2] = h),
                  (this.uint16[_ + 3] = m),
                  i
                );
              }
            }
            (ke.prototype.bytesPerElement = 8), st(ke, "StructArrayLayout4ui8");
            class He extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _) {
                const x = this.length;
                return this.resize(x + 1), this.emplace(x, i, o, l, h, m, _);
              }
              emplace(i, o, l, h, m, _, x) {
                const E = 6 * i;
                return (
                  (this.int16[E + 0] = o),
                  (this.int16[E + 1] = l),
                  (this.int16[E + 2] = h),
                  (this.int16[E + 3] = m),
                  (this.int16[E + 4] = _),
                  (this.int16[E + 5] = x),
                  i
                );
              }
            }
            (He.prototype.bytesPerElement = 12),
              st(He, "StructArrayLayout6i12");
            class Ne extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x, E, T, C, A, L) {
                const O = this.length;
                return (
                  this.resize(O + 1),
                  this.emplace(O, i, o, l, h, m, _, x, E, T, C, A, L)
                );
              }
              emplace(i, o, l, h, m, _, x, E, T, C, A, L, O) {
                const F = 12 * i;
                return (
                  (this.int16[F + 0] = o),
                  (this.int16[F + 1] = l),
                  (this.int16[F + 2] = h),
                  (this.int16[F + 3] = m),
                  (this.uint16[F + 4] = _),
                  (this.uint16[F + 5] = x),
                  (this.uint16[F + 6] = E),
                  (this.uint16[F + 7] = T),
                  (this.int16[F + 8] = C),
                  (this.int16[F + 9] = A),
                  (this.int16[F + 10] = L),
                  (this.int16[F + 11] = O),
                  i
                );
              }
            }
            (Ne.prototype.bytesPerElement = 24),
              st(Ne, "StructArrayLayout4i4ui4i24");
            class Xe extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _) {
                const x = this.length;
                return this.resize(x + 1), this.emplace(x, i, o, l, h, m, _);
              }
              emplace(i, o, l, h, m, _, x) {
                const E = 10 * i,
                  T = 5 * i;
                return (
                  (this.int16[E + 0] = o),
                  (this.int16[E + 1] = l),
                  (this.int16[E + 2] = h),
                  (this.float32[T + 2] = m),
                  (this.float32[T + 3] = _),
                  (this.float32[T + 4] = x),
                  i
                );
              }
            }
            (Xe.prototype.bytesPerElement = 20),
              st(Xe, "StructArrayLayout3i3f20");
            class dt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(i) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, i);
              }
              emplace(i, o) {
                return (this.uint32[1 * i + 0] = o), i;
              }
            }
            (dt.prototype.bytesPerElement = 4), st(dt, "StructArrayLayout1ul4");
            class Dt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x, E, T, C, A, L, O) {
                const F = this.length;
                return (
                  this.resize(F + 1),
                  this.emplace(F, i, o, l, h, m, _, x, E, T, C, A, L, O)
                );
              }
              emplace(i, o, l, h, m, _, x, E, T, C, A, L, O, F) {
                const V = 20 * i,
                  G = 10 * i;
                return (
                  (this.int16[V + 0] = o),
                  (this.int16[V + 1] = l),
                  (this.int16[V + 2] = h),
                  (this.int16[V + 3] = m),
                  (this.int16[V + 4] = _),
                  (this.float32[G + 3] = x),
                  (this.float32[G + 4] = E),
                  (this.float32[G + 5] = T),
                  (this.float32[G + 6] = C),
                  (this.int16[V + 14] = A),
                  (this.uint32[G + 8] = L),
                  (this.uint16[V + 18] = O),
                  (this.uint16[V + 19] = F),
                  i
                );
              }
            }
            (Dt.prototype.bytesPerElement = 40),
              st(Dt, "StructArrayLayout5i4f1i1ul2ui40");
            class ct extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m, _, x) {
                const E = this.length;
                return this.resize(E + 1), this.emplace(E, i, o, l, h, m, _, x);
              }
              emplace(i, o, l, h, m, _, x, E) {
                const T = 8 * i;
                return (
                  (this.int16[T + 0] = o),
                  (this.int16[T + 1] = l),
                  (this.int16[T + 2] = h),
                  (this.int16[T + 4] = m),
                  (this.int16[T + 5] = _),
                  (this.int16[T + 6] = x),
                  (this.int16[T + 7] = E),
                  i
                );
              }
            }
            (ct.prototype.bytesPerElement = 16),
              st(ct, "StructArrayLayout3i2i2i16");
            class wt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, i, o, l, h, m);
              }
              emplace(i, o, l, h, m, _) {
                const x = 4 * i,
                  E = 8 * i;
                return (
                  (this.float32[x + 0] = o),
                  (this.float32[x + 1] = l),
                  (this.float32[x + 2] = h),
                  (this.int16[E + 6] = m),
                  (this.int16[E + 7] = _),
                  i
                );
              }
            }
            (wt.prototype.bytesPerElement = 16),
              st(wt, "StructArrayLayout2f1f2i16");
            class Wt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 12 * i,
                  x = 3 * i;
                return (
                  (this.uint8[_ + 0] = o),
                  (this.uint8[_ + 1] = l),
                  (this.float32[x + 1] = h),
                  (this.float32[x + 2] = m),
                  i
                );
              }
            }
            (Wt.prototype.bytesPerElement = 12),
              st(Wt, "StructArrayLayout2ub2f12");
            class jt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, i, o, l);
              }
              emplace(i, o, l, h) {
                const m = 3 * i;
                return (
                  (this.float32[m + 0] = o),
                  (this.float32[m + 1] = l),
                  (this.float32[m + 2] = h),
                  i
                );
              }
            }
            (jt.prototype.bytesPerElement = 12),
              st(jt, "StructArrayLayout3f12");
            class ft extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, i, o, l);
              }
              emplace(i, o, l, h) {
                const m = 3 * i;
                return (
                  (this.uint16[m + 0] = o),
                  (this.uint16[m + 1] = l),
                  (this.uint16[m + 2] = h),
                  i
                );
              }
            }
            (ft.prototype.bytesPerElement = 6), st(ft, "StructArrayLayout3ui6");
            class Yt extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                C,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le
              ) {
                const ae = this.length;
                return (
                  this.resize(ae + 1),
                  this.emplace(
                    ae,
                    i,
                    o,
                    l,
                    h,
                    m,
                    _,
                    x,
                    E,
                    T,
                    C,
                    A,
                    L,
                    O,
                    F,
                    V,
                    G,
                    K,
                    oe,
                    J,
                    re,
                    le
                  )
                );
              }
              emplace(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                C,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le,
                ae
              ) {
                const De = 30 * i,
                  xe = 15 * i,
                  Pe = 60 * i;
                return (
                  (this.int16[De + 0] = o),
                  (this.int16[De + 1] = l),
                  (this.int16[De + 2] = h),
                  (this.float32[xe + 2] = m),
                  (this.float32[xe + 3] = _),
                  (this.uint16[De + 8] = x),
                  (this.uint16[De + 9] = E),
                  (this.uint32[xe + 5] = T),
                  (this.uint32[xe + 6] = C),
                  (this.uint32[xe + 7] = A),
                  (this.uint16[De + 16] = L),
                  (this.uint16[De + 17] = O),
                  (this.uint16[De + 18] = F),
                  (this.float32[xe + 10] = V),
                  (this.float32[xe + 11] = G),
                  (this.uint8[Pe + 48] = K),
                  (this.uint8[Pe + 49] = oe),
                  (this.uint8[Pe + 50] = J),
                  (this.uint32[xe + 13] = re),
                  (this.int16[De + 28] = le),
                  (this.uint8[Pe + 58] = ae),
                  i
                );
              }
            }
            (Yt.prototype.bytesPerElement = 60),
              st(Yt, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
            class kn extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer));
              }
              emplaceBack(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                C,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le,
                ae,
                De,
                xe,
                Pe,
                $e,
                Ce,
                Fe,
                Re,
                Ve
              ) {
                const qe = this.length;
                return (
                  this.resize(qe + 1),
                  this.emplace(
                    qe,
                    i,
                    o,
                    l,
                    h,
                    m,
                    _,
                    x,
                    E,
                    T,
                    C,
                    A,
                    L,
                    O,
                    F,
                    V,
                    G,
                    K,
                    oe,
                    J,
                    re,
                    le,
                    ae,
                    De,
                    xe,
                    Pe,
                    $e,
                    Ce,
                    Fe,
                    Re,
                    Ve
                  )
                );
              }
              emplace(
                i,
                o,
                l,
                h,
                m,
                _,
                x,
                E,
                T,
                C,
                A,
                L,
                O,
                F,
                V,
                G,
                K,
                oe,
                J,
                re,
                le,
                ae,
                De,
                xe,
                Pe,
                $e,
                Ce,
                Fe,
                Re,
                Ve,
                qe
              ) {
                const Me = 38 * i,
                  Je = 19 * i;
                return (
                  (this.int16[Me + 0] = o),
                  (this.int16[Me + 1] = l),
                  (this.int16[Me + 2] = h),
                  (this.float32[Je + 2] = m),
                  (this.float32[Je + 3] = _),
                  (this.int16[Me + 8] = x),
                  (this.int16[Me + 9] = E),
                  (this.int16[Me + 10] = T),
                  (this.int16[Me + 11] = C),
                  (this.int16[Me + 12] = A),
                  (this.int16[Me + 13] = L),
                  (this.uint16[Me + 14] = O),
                  (this.uint16[Me + 15] = F),
                  (this.uint16[Me + 16] = V),
                  (this.uint16[Me + 17] = G),
                  (this.uint16[Me + 18] = K),
                  (this.uint16[Me + 19] = oe),
                  (this.uint16[Me + 20] = J),
                  (this.uint16[Me + 21] = re),
                  (this.uint16[Me + 22] = le),
                  (this.uint16[Me + 23] = ae),
                  (this.uint16[Me + 24] = De),
                  (this.uint16[Me + 25] = xe),
                  (this.uint16[Me + 26] = Pe),
                  (this.uint16[Me + 27] = $e),
                  (this.uint16[Me + 28] = Ce),
                  (this.uint32[Je + 15] = Fe),
                  (this.float32[Je + 16] = Re),
                  (this.float32[Je + 17] = Ve),
                  (this.float32[Je + 18] = qe),
                  i
                );
              }
            }
            (kn.prototype.bytesPerElement = 76),
              st(kn, "StructArrayLayout3i2f6i15ui1ul3f76");
            class fn extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, i);
              }
              emplace(i, o) {
                return (this.float32[1 * i + 0] = o), i;
              }
            }
            (fn.prototype.bytesPerElement = 4), st(fn, "StructArrayLayout1f4");
            class Tn extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h, m) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, i, o, l, h, m);
              }
              emplace(i, o, l, h, m, _) {
                const x = 5 * i;
                return (
                  (this.float32[x + 0] = o),
                  (this.float32[x + 1] = l),
                  (this.float32[x + 2] = h),
                  (this.float32[x + 3] = m),
                  (this.float32[x + 4] = _),
                  i
                );
              }
            }
            (Tn.prototype.bytesPerElement = 20),
              st(Tn, "StructArrayLayout5f20");
            class ji extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o, l, h) {
                const m = this.length;
                return this.resize(m + 1), this.emplace(m, i, o, l, h);
              }
              emplace(i, o, l, h, m) {
                const _ = 6 * i;
                return (
                  (this.uint32[3 * i + 0] = o),
                  (this.uint16[_ + 2] = l),
                  (this.uint16[_ + 3] = h),
                  (this.uint16[_ + 4] = m),
                  i
                );
              }
            }
            (ji.prototype.bytesPerElement = 12),
              st(ji, "StructArrayLayout1ul3ui12");
            class mi extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i, o) {
                const l = this.length;
                return this.resize(l + 1), this.emplace(l, i, o);
              }
              emplace(i, o, l) {
                const h = 2 * i;
                return (this.uint16[h + 0] = o), (this.uint16[h + 1] = l), i;
              }
            }
            (mi.prototype.bytesPerElement = 4), st(mi, "StructArrayLayout2ui4");
            class br extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer));
              }
              emplaceBack(i) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, i);
              }
              emplace(i, o) {
                return (this.uint16[1 * i + 0] = o), i;
              }
            }
            (br.prototype.bytesPerElement = 2), st(br, "StructArrayLayout1ui2");
            class Ko extends _e {
              _refreshViews() {
                (this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer));
              }
              emplaceBack(i, o) {
                const l = this.length;
                return this.resize(l + 1), this.emplace(l, i, o);
              }
              emplace(i, o, l) {
                const h = 2 * i;
                return (this.float32[h + 0] = o), (this.float32[h + 1] = l), i;
              }
            }
            (Ko.prototype.bytesPerElement = 8), st(Ko, "StructArrayLayout2f8");
            class Un extends ue {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
              }
              get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get x1() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get y1() {
                return this._structArray.float32[this._pos4 + 4];
              }
              get x2() {
                return this._structArray.float32[this._pos4 + 5];
              }
              get y2() {
                return this._structArray.float32[this._pos4 + 6];
              }
              get padding() {
                return this._structArray.int16[this._pos2 + 14];
              }
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
            }
            Un.prototype.size = 40;
            class Cn extends Dt {
              get(i) {
                return new Un(this, i);
              }
            }
            st(Cn, "CollisionBoxArray");
            class ln extends ue {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
              }
              get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
              }
              get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
              }
              get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
              }
              get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
              }
              get segment() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
              }
              get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
              }
              get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
              }
              get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
              }
              set placedOrientation(i) {
                this._structArray.uint8[this._pos1 + 49] = i;
              }
              get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
              }
              set hidden(i) {
                this._structArray.uint8[this._pos1 + 50] = i;
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
              }
              set crossTileID(i) {
                this._structArray.uint32[this._pos4 + 13] = i;
              }
              get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
              }
              get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
              }
              set flipState(i) {
                this._structArray.uint8[this._pos1 + 58] = i;
              }
            }
            ln.prototype.size = 60;
            class ni extends Yt {
              get(i) {
                return new ln(this, i);
              }
            }
            st(ni, "PlacedSymbolArray");
            class wr extends ue {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
              }
              get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
              }
              get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
              }
              get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
              }
              get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
              }
              get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 13];
              }
              get key() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 15];
              }
              get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
              get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 20];
              }
              get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 21];
              }
              get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 22];
              }
              get featureIndex() {
                return this._structArray.uint16[this._pos2 + 23];
              }
              get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
              }
              get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 25];
              }
              get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
              }
              get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 27];
              }
              get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 28];
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 15];
              }
              set crossTileID(i) {
                this._structArray.uint32[this._pos4 + 15] = i;
              }
              get textOffset0() {
                return this._structArray.float32[this._pos4 + 16];
              }
              get textOffset1() {
                return this._structArray.float32[this._pos4 + 17];
              }
              get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 18];
              }
            }
            wr.prototype.size = 76;
            class Rn extends kn {
              get(i) {
                return new wr(this, i);
              }
            }
            st(Rn, "SymbolInstanceArray");
            class Ui extends fn {
              getoffsetX(i) {
                return this.float32[1 * i + 0];
              }
            }
            st(Ui, "GlyphOffsetArray");
            class Fu extends Ge {
              getx(i) {
                return this.int16[2 * i + 0];
              }
              gety(i) {
                return this.int16[2 * i + 1];
              }
            }
            st(Fu, "SymbolLineVertexArray");
            class ta extends ue {
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
              }
              get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
              }
            }
            ta.prototype.size = 12;
            class Bl extends ji {
              get(i) {
                return new ta(this, i);
              }
            }
            st(Bl, "FeatureIndexArray");
            class Or extends mi {
              geta_centroid_pos0(i) {
                return this.uint16[2 * i + 0];
              }
              geta_centroid_pos1(i) {
                return this.uint16[2 * i + 1];
              }
            }
            st(Or, "FillExtrusionCentroidArray");
            const na = ge([
                { name: "a_pattern", components: 4, type: "Uint16" },
                { name: "a_pixel_ratio", components: 1, type: "Float32" },
              ]),
              Wa = ge([{ name: "a_dash", components: 4, type: "Uint16" }]);
            var Vl = { exports: {} },
              Pc = function (r, i) {
                var o, l, h, m, _, x, E, T;
                for (
                  l = r.length - (o = 3 & r.length),
                    h = i,
                    _ = 3432918353,
                    x = 461845907,
                    T = 0;
                  T < l;

                )
                  (E =
                    (255 & r.charCodeAt(T)) |
                    ((255 & r.charCodeAt(++T)) << 8) |
                    ((255 & r.charCodeAt(++T)) << 16) |
                    ((255 & r.charCodeAt(++T)) << 24)),
                    ++T,
                    (h =
                      27492 +
                      (65535 &
                        (m =
                          (5 *
                            (65535 &
                              (h =
                                ((h ^= E =
                                  ((65535 &
                                    (E =
                                      ((E =
                                        ((65535 & E) * _ +
                                          ((((E >>> 16) * _) & 65535) << 16)) &
                                        4294967295) <<
                                        15) |
                                      (E >>> 17))) *
                                    x +
                                    ((((E >>> 16) * x) & 65535) << 16)) &
                                  4294967295) <<
                                  13) |
                                (h >>> 19))) +
                            (((5 * (h >>> 16)) & 65535) << 16)) &
                          4294967295)) +
                      (((58964 + (m >>> 16)) & 65535) << 16));
                switch (((E = 0), o)) {
                  case 3:
                    E ^= (255 & r.charCodeAt(T + 2)) << 16;
                  case 2:
                    E ^= (255 & r.charCodeAt(T + 1)) << 8;
                  case 1:
                    h ^= E =
                      ((65535 &
                        (E =
                          ((E =
                            ((65535 & (E ^= 255 & r.charCodeAt(T))) * _ +
                              ((((E >>> 16) * _) & 65535) << 16)) &
                            4294967295) <<
                            15) |
                          (E >>> 17))) *
                        x +
                        ((((E >>> 16) * x) & 65535) << 16)) &
                      4294967295;
                }
                return (
                  (h ^= r.length),
                  (h =
                    (2246822507 * (65535 & (h ^= h >>> 16)) +
                      (((2246822507 * (h >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (h =
                    (3266489909 * (65535 & (h ^= h >>> 13)) +
                      (((3266489909 * (h >>> 16)) & 65535) << 16)) &
                    4294967295),
                  (h ^= h >>> 16) >>> 0
                );
              },
              zu = function (r, i) {
                for (var o, l = r.length, h = i ^ l, m = 0; l >= 4; )
                  (o =
                    1540483477 *
                      (65535 &
                        (o =
                          (255 & r.charCodeAt(m)) |
                          ((255 & r.charCodeAt(++m)) << 8) |
                          ((255 & r.charCodeAt(++m)) << 16) |
                          ((255 & r.charCodeAt(++m)) << 24))) +
                    (((1540483477 * (o >>> 16)) & 65535) << 16)),
                    (h =
                      (1540483477 * (65535 & h) +
                        (((1540483477 * (h >>> 16)) & 65535) << 16)) ^
                      (o =
                        1540483477 * (65535 & (o ^= o >>> 24)) +
                        (((1540483477 * (o >>> 16)) & 65535) << 16))),
                    (l -= 4),
                    ++m;
                switch (l) {
                  case 3:
                    h ^= (255 & r.charCodeAt(m + 2)) << 16;
                  case 2:
                    h ^= (255 & r.charCodeAt(m + 1)) << 8;
                  case 1:
                    h =
                      1540483477 * (65535 & (h ^= 255 & r.charCodeAt(m))) +
                      (((1540483477 * (h >>> 16)) & 65535) << 16);
                }
                return (
                  (h =
                    1540483477 * (65535 & (h ^= h >>> 13)) +
                    (((1540483477 * (h >>> 16)) & 65535) << 16)),
                  (h ^= h >>> 15) >>> 0
                );
              };
            (Vl.exports = Pc),
              (Vl.exports.murmur3 = Pc),
              (Vl.exports.murmur2 = zu);
            var jl = Vr(Vl.exports);
            class ed {
              constructor() {
                (this.ids = []), (this.positions = []), (this.indexed = !1);
              }
              add(i, o, l, h) {
                this.ids.push(bp(i)), this.positions.push(o, l, h);
              }
              getPositions(i) {
                const o = bp(i);
                let l = 0,
                  h = this.ids.length - 1;
                for (; l < h; ) {
                  const _ = (l + h) >> 1;
                  this.ids[_] >= o ? (h = _) : (l = _ + 1);
                }
                const m = [];
                for (; this.ids[l] === o; )
                  m.push({
                    index: this.positions[3 * l],
                    start: this.positions[3 * l + 1],
                    end: this.positions[3 * l + 2],
                  }),
                    l++;
                return m;
              }
              static serialize(i, o) {
                const l = new Float64Array(i.ids),
                  h = new Uint32Array(i.positions);
                return (
                  Ul(l, h, 0, l.length - 1),
                  o && o.push(l.buffer, h.buffer),
                  { ids: l, positions: h }
                );
              }
              static deserialize(i) {
                const o = new ed();
                return (
                  (o.ids = i.ids),
                  (o.positions = i.positions),
                  (o.indexed = !0),
                  o
                );
              }
            }
            function bp(r) {
              const i = +r;
              return !isNaN(i) &&
                Number.MIN_SAFE_INTEGER <= i &&
                i <= Number.MAX_SAFE_INTEGER
                ? i
                : jl(String(r));
            }
            function Ul(r, i, o, l) {
              for (; o < l; ) {
                const h = r[(o + l) >> 1];
                let m = o - 1,
                  _ = l + 1;
                for (;;) {
                  do {
                    m++;
                  } while (r[m] < h);
                  do {
                    _--;
                  } while (r[_] > h);
                  if (m >= _) break;
                  Gf(r, m, _),
                    Gf(i, 3 * m, 3 * _),
                    Gf(i, 3 * m + 1, 3 * _ + 1),
                    Gf(i, 3 * m + 2, 3 * _ + 2);
                }
                _ - o < l - _
                  ? (Ul(r, i, o, _), (o = _ + 1))
                  : (Ul(r, i, _ + 1, l), (l = _));
              }
            }
            function Gf(r, i, o) {
              const l = r[i];
              (r[i] = r[o]), (r[o] = l);
            }
            st(ed, "FeaturePositionMap");
            class Za {
              constructor(i) {
                (this.gl = i.gl), (this.initialized = !1);
              }
              fetchUniformLocation(i, o) {
                return (
                  this.location ||
                    this.initialized ||
                    ((this.location = this.gl.getUniformLocation(i, o)),
                    (this.initialized = !0)),
                  !!this.location
                );
              }
            }
            class nn extends Za {
              constructor(i) {
                super(i), (this.current = 0);
              }
              set(i, o, l) {
                this.fetchUniformLocation(i, o) &&
                  this.current !== l &&
                  ((this.current = l), this.gl.uniform1f(this.location, l));
              }
            }
            class fv extends Za {
              constructor(i) {
                super(i), (this.current = [0, 0, 0, 0]);
              }
              set(i, o, l) {
                this.fetchUniformLocation(i, o) &&
                  ((l[0] === this.current[0] &&
                    l[1] === this.current[1] &&
                    l[2] === this.current[2] &&
                    l[3] === this.current[3]) ||
                    ((this.current = l),
                    this.gl.uniform4f(this.location, l[0], l[1], l[2], l[3])));
              }
            }
            class mv extends Za {
              constructor(i) {
                super(i), (this.current = di.transparent);
              }
              set(i, o, l) {
                this.fetchUniformLocation(i, o) &&
                  ((l.r === this.current.r &&
                    l.g === this.current.g &&
                    l.b === this.current.b &&
                    l.a === this.current.a) ||
                    ((this.current = l),
                    this.gl.uniform4f(this.location, l.r, l.g, l.b, l.a)));
              }
            }
            const mb = new Float32Array(16),
              gb = new Float32Array(9),
              _b = new Float32Array(4);
            function zg(r) {
              return [he(255 * r.r, 255 * r.g), he(255 * r.b, 255 * r.a)];
            }
            class wp {
              constructor(i, o, l) {
                (this.value = i),
                  (this.uniformNames = o.map((h) => `u_${h}`)),
                  (this.type = l);
              }
              setUniform(i, o, l, h, m) {
                o.set(i, m, h.constantOr(this.value));
              }
              getBinding(i, o) {
                return "color" === this.type ? new mv(i) : new nn(i);
              }
            }
            class ia {
              constructor(i, o) {
                (this.uniformNames = o.map((l) => `u_${l}`)),
                  (this.pattern = null),
                  (this.pixelRatio = 1);
              }
              setConstantPatternPositions(i) {
                (this.pixelRatio = i.pixelRatio || 1),
                  (this.pattern = i.tl.concat(i.br));
              }
              setUniform(i, o, l, h, m) {
                const _ =
                  "u_pattern" === m || "u_dash" === m
                    ? this.pattern
                    : "u_pixel_ratio" === m
                    ? this.pixelRatio
                    : null;
                _ && o.set(i, m, _);
              }
              getBinding(i, o) {
                return "u_pattern" === o || "u_dash" === o
                  ? new fv(i)
                  : new nn(i);
              }
            }
            class $l {
              constructor(i, o, l, h) {
                (this.expression = i),
                  (this.type = l),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = o.map((m) => ({
                    name: `a_${m}`,
                    type: "Float32",
                    components: "color" === l ? 2 : 1,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new h());
              }
              populatePaintArray(i, o, l, h, m, _) {
                const x = this.paintVertexArray.length,
                  E = this.expression.evaluate(new M(0), o, {}, m, h, _);
                this.paintVertexArray.resize(i), this._setPaintValue(x, i, E);
              }
              updatePaintArray(i, o, l, h, m) {
                const _ = this.expression.evaluate(
                  { zoom: 0 },
                  l,
                  h,
                  void 0,
                  m
                );
                this._setPaintValue(i, o, _);
              }
              _setPaintValue(i, o, l) {
                if ("color" === this.type) {
                  const h = zg(l);
                  for (let m = i; m < o; m++)
                    this.paintVertexArray.emplace(m, h[0], h[1]);
                } else {
                  for (let h = i; h < o; h++)
                    this.paintVertexArray.emplace(h, l);
                  this.maxValue = Math.max(this.maxValue, Math.abs(l));
                }
              }
              upload(i) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = i.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class ra {
              constructor(i, o, l, h, m, _) {
                (this.expression = i),
                  (this.uniformNames = o.map((x) => `u_${x}_t`)),
                  (this.type = l),
                  (this.useIntegerZoom = h),
                  (this.zoom = m),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = o.map((x) => ({
                    name: `a_${x}`,
                    type: "Float32",
                    components: "color" === l ? 4 : 2,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new _());
              }
              populatePaintArray(i, o, l, h, m, _) {
                const x = this.expression.evaluate(
                    new M(this.zoom),
                    o,
                    {},
                    m,
                    h,
                    _
                  ),
                  E = this.expression.evaluate(
                    new M(this.zoom + 1),
                    o,
                    {},
                    m,
                    h,
                    _
                  ),
                  T = this.paintVertexArray.length;
                this.paintVertexArray.resize(i),
                  this._setPaintValue(T, i, x, E);
              }
              updatePaintArray(i, o, l, h, m) {
                const _ = this.expression.evaluate(
                    { zoom: this.zoom },
                    l,
                    h,
                    void 0,
                    m
                  ),
                  x = this.expression.evaluate(
                    { zoom: this.zoom + 1 },
                    l,
                    h,
                    void 0,
                    m
                  );
                this._setPaintValue(i, o, _, x);
              }
              _setPaintValue(i, o, l, h) {
                if ("color" === this.type) {
                  const m = zg(l),
                    _ = zg(h);
                  for (let x = i; x < o; x++)
                    this.paintVertexArray.emplace(x, m[0], m[1], _[0], _[1]);
                } else {
                  for (let m = i; m < o; m++)
                    this.paintVertexArray.emplace(m, l, h);
                  this.maxValue = Math.max(
                    this.maxValue,
                    Math.abs(l),
                    Math.abs(h)
                  );
                }
              }
              upload(i) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = i.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
              setUniform(i, o, l, h, m) {
                const _ = this.useIntegerZoom ? Math.floor(l.zoom) : l.zoom,
                  x = Qt(
                    this.expression.interpolationFactor(
                      _,
                      this.zoom,
                      this.zoom + 1
                    ),
                    0,
                    1
                  );
                o.set(i, m, x);
              }
              getBinding(i, o) {
                return new nn(i);
              }
            }
            class Zn {
              constructor(i, o, l, h, m) {
                (this.expression = i),
                  (this.layerId = m),
                  (this.paintVertexAttributes = (
                    "array" === l ? Wa : na
                  ).members);
                for (let _ = 0; _ < o.length; ++_);
                this.paintVertexArray = new h();
              }
              populatePaintArray(i, o, l) {
                const h = this.paintVertexArray.length;
                this.paintVertexArray.resize(i),
                  this._setPaintValues(
                    h,
                    i,
                    o.patterns && o.patterns[this.layerId],
                    l
                  );
              }
              updatePaintArray(i, o, l, h, m, _) {
                this._setPaintValues(
                  i,
                  o,
                  l.patterns && l.patterns[this.layerId],
                  _
                );
              }
              _setPaintValues(i, o, l, h) {
                if (!h || !l) return;
                const m = h[l];
                if (!m) return;
                const { tl: _, br: x, pixelRatio: E } = m;
                for (let T = i; T < o; T++)
                  this.paintVertexArray.emplace(T, _[0], _[1], x[0], x[1], E);
              }
              upload(i) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer = i.createVertexBuffer(
                    this.paintVertexArray,
                    this.paintVertexAttributes,
                    this.expression.isStateDependent
                  ));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class oa {
              constructor(i, o, l = () => !0) {
                (this.binders = {}), (this._buffers = []);
                const h = [];
                for (const m in i.paint._values) {
                  if (!l(m)) continue;
                  const _ = i.paint.get(m);
                  if (!(_ instanceof Z && bc(_.property.specification)))
                    continue;
                  const x = gv(m, i.type),
                    E = _.value,
                    T = _.property.specification.type,
                    C = !!_.property.useIntegerZoom,
                    A = "line-dasharray" === m || m.endsWith("pattern"),
                    L =
                      "line-dasharray" === m &&
                      "constant" !== i.layout.get("line-cap").value.kind;
                  if ("constant" !== E.kind || L)
                    if ("source" === E.kind || L || A) {
                      const O = qf(m, T, "source");
                      (this.binders[m] = A
                        ? new Zn(E, x, T, O, i.id)
                        : new $l(E, x, T, O)),
                        h.push(`/a_${m}`);
                    } else {
                      const O = qf(m, T, "composite");
                      (this.binders[m] = new ra(E, x, T, C, o, O)),
                        h.push(`/z_${m}`);
                    }
                  else
                    (this.binders[m] = A
                      ? new ia(E.value, x)
                      : new wp(E.value, x, T)),
                      h.push(`/u_${m}`);
                }
                this.cacheKey = h.sort().join("");
              }
              getMaxValue(i) {
                const o = this.binders[i];
                return o instanceof $l || o instanceof ra ? o.maxValue : 0;
              }
              populatePaintArrays(i, o, l, h, m, _) {
                for (const x in this.binders) {
                  const E = this.binders[x];
                  (E instanceof $l || E instanceof ra || E instanceof Zn) &&
                    E.populatePaintArray(i, o, l, h, m, _);
                }
              }
              setConstantPatternPositions(i) {
                for (const o in this.binders) {
                  const l = this.binders[o];
                  l instanceof ia && l.setConstantPatternPositions(i);
                }
              }
              updatePaintArrays(i, o, l, h, m, _) {
                let x = !1;
                for (const E in i) {
                  const T = o.getPositions(E);
                  for (const C of T) {
                    const A = l.feature(C.index);
                    for (const L in this.binders) {
                      const O = this.binders[L];
                      if (
                        (O instanceof $l ||
                          O instanceof ra ||
                          O instanceof Zn) &&
                        !0 === O.expression.isStateDependent
                      ) {
                        const F = h.paint.get(L);
                        (O.expression = F.value),
                          O.updatePaintArray(C.start, C.end, A, i[E], m, _),
                          (x = !0);
                      }
                    }
                  }
                }
                return x;
              }
              defines() {
                const i = [];
                for (const o in this.binders) {
                  const l = this.binders[o];
                  (l instanceof wp || l instanceof ia) &&
                    i.push(
                      ...l.uniformNames.map((h) => `#define HAS_UNIFORM_${h}`)
                    );
                }
                return i;
              }
              getBinderAttributes() {
                const i = [];
                for (const o in this.binders) {
                  const l = this.binders[o];
                  if (l instanceof $l || l instanceof ra || l instanceof Zn)
                    for (let h = 0; h < l.paintVertexAttributes.length; h++)
                      i.push(l.paintVertexAttributes[h].name);
                }
                return i;
              }
              getBinderUniforms() {
                const i = [];
                for (const o in this.binders) {
                  const l = this.binders[o];
                  if (l instanceof wp || l instanceof ia || l instanceof ra)
                    for (const h of l.uniformNames) i.push(h);
                }
                return i;
              }
              getPaintVertexBuffers() {
                return this._buffers;
              }
              getUniforms(i) {
                const o = [];
                for (const l in this.binders) {
                  const h = this.binders[l];
                  if (h instanceof wp || h instanceof ia || h instanceof ra)
                    for (const m of h.uniformNames)
                      o.push({
                        name: m,
                        property: l,
                        binding: h.getBinding(i, m),
                      });
                }
                return o;
              }
              setUniforms(i, o, l, h, m) {
                for (const { name: _, property: x, binding: E } of l)
                  this.binders[x].setUniform(i, E, m, h.get(x), _);
              }
              updatePaintBuffers() {
                this._buffers = [];
                for (const i in this.binders) {
                  const o = this.binders[i];
                  (o instanceof $l || o instanceof ra || o instanceof Zn) &&
                    o.paintVertexBuffer &&
                    this._buffers.push(o.paintVertexBuffer);
                }
              }
              upload(i) {
                for (const o in this.binders) {
                  const l = this.binders[o];
                  (l instanceof $l || l instanceof ra || l instanceof Zn) &&
                    l.upload(i);
                }
                this.updatePaintBuffers();
              }
              destroy() {
                for (const i in this.binders) {
                  const o = this.binders[i];
                  (o instanceof $l || o instanceof ra || o instanceof Zn) &&
                    o.destroy();
                }
              }
            }
            class gs {
              constructor(i, o, l = () => !0) {
                this.programConfigurations = {};
                for (const h of i)
                  this.programConfigurations[h.id] = new oa(h, o, l);
                (this.needsUpload = !1),
                  (this._featureMap = new ed()),
                  (this._bufferOffset = 0);
              }
              populatePaintArrays(i, o, l, h, m, _, x) {
                for (const E in this.programConfigurations)
                  this.programConfigurations[E].populatePaintArrays(
                    i,
                    o,
                    h,
                    m,
                    _,
                    x
                  );
                void 0 !== o.id &&
                  this._featureMap.add(o.id, l, this._bufferOffset, i),
                  (this._bufferOffset = i),
                  (this.needsUpload = !0);
              }
              updatePaintArrays(i, o, l, h, m) {
                for (const _ of l)
                  this.needsUpload =
                    this.programConfigurations[_.id].updatePaintArrays(
                      i,
                      this._featureMap,
                      o,
                      _,
                      h,
                      m
                    ) || this.needsUpload;
              }
              get(i) {
                return this.programConfigurations[i];
              }
              upload(i) {
                if (this.needsUpload) {
                  for (const o in this.programConfigurations)
                    this.programConfigurations[o].upload(i);
                  this.needsUpload = !1;
                }
              }
              destroy() {
                for (const i in this.programConfigurations)
                  this.programConfigurations[i].destroy();
              }
            }
            const yb = {
              "text-opacity": ["opacity"],
              "icon-opacity": ["opacity"],
              "text-color": ["fill_color"],
              "icon-color": ["fill_color"],
              "text-halo-color": ["halo_color"],
              "icon-halo-color": ["halo_color"],
              "text-halo-blur": ["halo_blur"],
              "icon-halo-blur": ["halo_blur"],
              "text-halo-width": ["halo_width"],
              "icon-halo-width": ["halo_width"],
              "line-gap-width": ["gapwidth"],
              "line-pattern": ["pattern", "pixel_ratio"],
              "fill-pattern": ["pattern", "pixel_ratio"],
              "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
              "line-dasharray": ["dash"],
            };
            function gv(r, i) {
              return yb[r] || [r.replace(`${i}-`, "").replace(/-/g, "_")];
            }
            const Io = {
                "line-pattern": { source: we, composite: we },
                "fill-pattern": { source: we, composite: we },
                "fill-extrusion-pattern": { source: we, composite: we },
                "line-dasharray": { source: ke, composite: ke },
              },
              Xa = {
                color: { source: Ko, composite: je },
                number: { source: fn, composite: Ko },
              };
            function qf(r, i, o) {
              const l = Io[r];
              return (l && l[o]) || Xa[i][o];
            }
            st(wp, "ConstantBinder"),
              st(ia, "PatternConstantBinder"),
              st($l, "SourceExpressionBinder"),
              st(Zn, "PatternCompositeBinder"),
              st(ra, "CompositeExpressionBinder"),
              st(oa, "ProgramConfiguration", { omit: ["_buffers"] }),
              st(gs, "ProgramConfigurationSet");
            const td = "-transition";
            class Zr extends pc {
              constructor(i, o) {
                if (
                  (super(),
                  (this.id = i.id),
                  (this.type = i.type),
                  (this._featureFilter = {
                    filter: () => !0,
                    needGeometry: !1,
                    needFeature: !1,
                  }),
                  (this._filterCompiled = !1),
                  "custom" !== i.type &&
                    ((this.metadata = i.metadata),
                    (this.minzoom = i.minzoom),
                    (this.maxzoom = i.maxzoom),
                    "background" !== i.type &&
                      "sky" !== i.type &&
                      ((this.source = i.source),
                      (this.sourceLayer = i["source-layer"]),
                      (this.filter = i.filter)),
                    o.layout && (this._unevaluatedLayout = new X(o.layout)),
                    o.paint))
                ) {
                  this._transitionablePaint = new z(o.paint);
                  for (const l in i.paint)
                    this.setPaintProperty(l, i.paint[l], { validate: !1 });
                  for (const l in i.layout)
                    this.setLayoutProperty(l, i.layout[l], { validate: !1 });
                  (this._transitioningPaint =
                    this._transitionablePaint.untransitioned()),
                    (this.paint = new Y(o.paint));
                }
              }
              getLayoutProperty(i) {
                return "visibility" === i
                  ? this.visibility
                  : this._unevaluatedLayout.getValue(i);
              }
              setLayoutProperty(i, o, l = {}) {
                (null != o &&
                  this._validate(
                    Xo,
                    `layers.${this.id}.layout.${i}`,
                    i,
                    o,
                    l
                  )) ||
                  ("visibility" !== i
                    ? this._unevaluatedLayout.setValue(i, o)
                    : (this.visibility = o));
              }
              getPaintProperty(i) {
                return xl(i, td)
                  ? this._transitionablePaint.getTransition(i.slice(0, -11))
                  : this._transitionablePaint.getValue(i);
              }
              setPaintProperty(i, o, l = {}) {
                if (
                  null != o &&
                  this._validate(Ic, `layers.${this.id}.paint.${i}`, i, o, l)
                )
                  return !1;
                if (xl(i, td))
                  return (
                    this._transitionablePaint.setTransition(
                      i.slice(0, -11),
                      o || void 0
                    ),
                    !1
                  );
                {
                  const h = this._transitionablePaint._values[i],
                    m = h.value.isDataDriven(),
                    _ = h.value;
                  this._transitionablePaint.setValue(i, o),
                    this._handleSpecialPaintPropertyUpdate(i);
                  const x = this._transitionablePaint._values[i].value,
                    E = x.isDataDriven(),
                    T = xl(i, "pattern") || "line-dasharray" === i;
                  return (
                    E ||
                    m ||
                    T ||
                    this._handleOverridablePaintPropertyUpdate(i, _, x)
                  );
                }
              }
              _handleSpecialPaintPropertyUpdate(i) {}
              getProgramIds() {
                return null;
              }
              getProgramConfiguration(i) {
                return null;
              }
              _handleOverridablePaintPropertyUpdate(i, o, l) {
                return !1;
              }
              isHidden(i) {
                return (
                  !!(this.minzoom && i < this.minzoom) ||
                  !!(this.maxzoom && i >= this.maxzoom) ||
                  "none" === this.visibility
                );
              }
              updateTransitions(i) {
                this._transitioningPaint =
                  this._transitionablePaint.transitioned(
                    i,
                    this._transitioningPaint
                  );
              }
              hasTransition() {
                return this._transitioningPaint.hasTransition();
              }
              recalculate(i, o) {
                this._unevaluatedLayout &&
                  (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                    i,
                    void 0,
                    o
                  )),
                  (this.paint = this._transitioningPaint.possiblyEvaluate(
                    i,
                    void 0,
                    o
                  ));
              }
              serialize() {
                const i = {
                  id: this.id,
                  type: this.type,
                  source: this.source,
                  "source-layer": this.sourceLayer,
                  metadata: this.metadata,
                  minzoom: this.minzoom,
                  maxzoom: this.maxzoom,
                  filter: this.filter,
                  layout:
                    this._unevaluatedLayout &&
                    this._unevaluatedLayout.serialize(),
                  paint:
                    this._transitionablePaint &&
                    this._transitionablePaint.serialize(),
                };
                return (
                  this.visibility &&
                    ((i.layout = i.layout || {}),
                    (i.layout.visibility = this.visibility)),
                  Ns(
                    i,
                    (o, l) =>
                      !(
                        void 0 === o ||
                        ("layout" === l && !Object.keys(o).length) ||
                        ("paint" === l && !Object.keys(o).length)
                      )
                  )
                );
              }
              _validate(i, o, l, h, m = {}) {
                return (
                  (!m || !1 !== m.validate) &&
                  Au(
                    this,
                    i.call(Yh, {
                      key: o,
                      layerType: this.type,
                      objectKey: l,
                      value: h,
                      styleSpec: Ae,
                      style: { glyphs: !0, sprite: !0 },
                    })
                  )
                );
              }
              is3D() {
                return !1;
              }
              isSky() {
                return !1;
              }
              isTileClipped() {
                return !1;
              }
              hasOffscreenPass() {
                return !1;
              }
              resize() {}
              isStateDependent() {
                for (const i in this.paint._values) {
                  const o = this.paint.get(i);
                  if (
                    o instanceof Z &&
                    bc(o.property.specification) &&
                    ("source" === o.value.kind ||
                      "composite" === o.value.kind) &&
                    o.value.isStateDependent
                  )
                    return !0;
                }
                return !1;
              }
              compileFilter() {
                this._filterCompiled ||
                  ((this._featureFilter = Mu(this.filter)),
                  (this._filterCompiled = !0));
              }
              invalidateCompiledFilter() {
                this._filterCompiled = !1;
              }
              dynamicFilter() {
                return this._featureFilter.dynamicFilter;
              }
              dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
              }
            }
            const Bg = ge([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              _v = ge([
                { name: "a_pos_3", components: 3, type: "Int16" },
                { name: "a_pos_normal_3", components: 3, type: "Int16" },
              ]);
            class gi {
              constructor(i = []) {
                this.segments = i;
              }
              prepareSegment(i, o, l, h) {
                let m = this.segments[this.segments.length - 1];
                return (
                  i > gi.MAX_VERTEX_ARRAY_LENGTH &&
                    Hn(
                      `Max vertices per segment is ${gi.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${i}`
                    ),
                  (!m ||
                    m.vertexLength + i > gi.MAX_VERTEX_ARRAY_LENGTH ||
                    m.sortKey !== h) &&
                    ((m = {
                      vertexOffset: o.length,
                      primitiveOffset: l.length,
                      vertexLength: 0,
                      primitiveLength: 0,
                    }),
                    void 0 !== h && (m.sortKey = h),
                    this.segments.push(m)),
                  m
                );
              }
              get() {
                return this.segments;
              }
              destroy() {
                for (const i of this.segments)
                  for (const o in i.vaos) i.vaos[o].destroy();
              }
              static simpleSegment(i, o, l, h) {
                return new gi([
                  {
                    vertexOffset: i,
                    primitiveOffset: o,
                    vertexLength: l,
                    primitiveLength: h,
                    vaos: {},
                    sortKey: 0,
                  },
                ]);
              }
            }
            (gi.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
              st(gi, "SegmentVector");
            var vt = 8192;
            class Lc {
              constructor(i, o) {
                i &&
                  (o
                    ? this.setSouthWest(i).setNorthEast(o)
                    : 4 === i.length
                    ? this.setSouthWest([i[0], i[1]]).setNorthEast([i[2], i[3]])
                    : this.setSouthWest(i[0]).setNorthEast(i[1]));
              }
              setNorthEast(i) {
                return (
                  (this._ne =
                    i instanceof Mn ? new Mn(i.lng, i.lat) : Mn.convert(i)),
                  this
                );
              }
              setSouthWest(i) {
                return (
                  (this._sw =
                    i instanceof Mn ? new Mn(i.lng, i.lat) : Mn.convert(i)),
                  this
                );
              }
              extend(i) {
                const o = this._sw,
                  l = this._ne;
                let h, m;
                if (i instanceof Mn) (h = i), (m = i);
                else {
                  if (!(i instanceof Lc))
                    return Array.isArray(i)
                      ? 4 === i.length || i.every(Array.isArray)
                        ? this.extend(Lc.convert(i))
                        : this.extend(Mn.convert(i))
                      : "object" == typeof i &&
                        null !== i &&
                        i.hasOwnProperty("lat") &&
                        (i.hasOwnProperty("lon") || i.hasOwnProperty("lng"))
                      ? this.extend(Mn.convert(i))
                      : this;
                  if (((h = i._sw), (m = i._ne), !h || !m)) return this;
                }
                return (
                  o || l
                    ? ((o.lng = Math.min(h.lng, o.lng)),
                      (o.lat = Math.min(h.lat, o.lat)),
                      (l.lng = Math.max(m.lng, l.lng)),
                      (l.lat = Math.max(m.lat, l.lat)))
                    : ((this._sw = new Mn(h.lng, h.lat)),
                      (this._ne = new Mn(m.lng, m.lat))),
                  this
                );
              }
              getCenter() {
                return new Mn(
                  (this._sw.lng + this._ne.lng) / 2,
                  (this._sw.lat + this._ne.lat) / 2
                );
              }
              getSouthWest() {
                return this._sw;
              }
              getNorthEast() {
                return this._ne;
              }
              getNorthWest() {
                return new Mn(this.getWest(), this.getNorth());
              }
              getSouthEast() {
                return new Mn(this.getEast(), this.getSouth());
              }
              getWest() {
                return this._sw.lng;
              }
              getSouth() {
                return this._sw.lat;
              }
              getEast() {
                return this._ne.lng;
              }
              getNorth() {
                return this._ne.lat;
              }
              toArray() {
                return [this._sw.toArray(), this._ne.toArray()];
              }
              toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
              }
              isEmpty() {
                return !(this._sw && this._ne);
              }
              contains(i) {
                const { lng: o, lat: l } = Mn.convert(i);
                let h = this._sw.lng <= o && o <= this._ne.lng;
                return (
                  this._sw.lng > this._ne.lng &&
                    (h = this._sw.lng >= o && o >= this._ne.lng),
                  this._sw.lat <= l && l <= this._ne.lat && h
                );
              }
              static convert(i) {
                return !i || i instanceof Lc ? i : new Lc(i);
              }
            }
            var nd = 1e-6,
              Xn = typeof Float32Array < "u" ? Float32Array : Array;
            function Ep() {
              var r = new Xn(9);
              return (
                Xn != Float32Array &&
                  ((r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[5] = 0),
                  (r[6] = 0),
                  (r[7] = 0)),
                (r[0] = 1),
                (r[4] = 1),
                (r[8] = 1),
                r
              );
            }
            function kc(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = i[4],
                E = i[5],
                T = i[6],
                C = i[7],
                A = i[8],
                L = o[0],
                O = o[1],
                F = o[2],
                V = o[3],
                G = o[4],
                K = o[5],
                oe = o[6],
                J = o[7],
                re = o[8];
              return (
                (r[0] = L * l + O * _ + F * T),
                (r[1] = L * h + O * x + F * C),
                (r[2] = L * m + O * E + F * A),
                (r[3] = V * l + G * _ + K * T),
                (r[4] = V * h + G * x + K * C),
                (r[5] = V * m + G * E + K * A),
                (r[6] = oe * l + J * _ + re * T),
                (r[7] = oe * h + J * x + re * C),
                (r[8] = oe * m + J * E + re * A),
                r
              );
            }
            function sa(r) {
              return (
                (r[0] = 1),
                (r[1] = 0),
                (r[2] = 0),
                (r[3] = 0),
                (r[4] = 0),
                (r[5] = 1),
                (r[6] = 0),
                (r[7] = 0),
                (r[8] = 0),
                (r[9] = 0),
                (r[10] = 1),
                (r[11] = 0),
                (r[12] = 0),
                (r[13] = 0),
                (r[14] = 0),
                (r[15] = 1),
                r
              );
            }
            function Tp(r, i) {
              var o = i[0],
                l = i[1],
                h = i[2],
                m = i[3],
                _ = i[4],
                x = i[5],
                E = i[6],
                T = i[7],
                C = i[8],
                A = i[9],
                L = i[10],
                O = i[11],
                F = i[12],
                V = i[13],
                G = i[14],
                K = i[15],
                oe = o * x - l * _,
                J = o * E - h * _,
                re = o * T - m * _,
                le = l * E - h * x,
                ae = l * T - m * x,
                De = h * T - m * E,
                xe = C * V - A * F,
                Pe = C * G - L * F,
                $e = C * K - O * F,
                Ce = A * G - L * V,
                Fe = A * K - O * V,
                Re = L * K - O * G,
                Ve = oe * Re - J * Fe + re * Ce + le * $e - ae * Pe + De * xe;
              return Ve
                ? ((r[0] = (x * Re - E * Fe + T * Ce) * (Ve = 1 / Ve)),
                  (r[1] = (h * Fe - l * Re - m * Ce) * Ve),
                  (r[2] = (V * De - G * ae + K * le) * Ve),
                  (r[3] = (L * ae - A * De - O * le) * Ve),
                  (r[4] = (E * $e - _ * Re - T * Pe) * Ve),
                  (r[5] = (o * Re - h * $e + m * Pe) * Ve),
                  (r[6] = (G * re - F * De - K * J) * Ve),
                  (r[7] = (C * De - L * re + O * J) * Ve),
                  (r[8] = (_ * Fe - x * $e + T * xe) * Ve),
                  (r[9] = (l * $e - o * Fe - m * xe) * Ve),
                  (r[10] = (F * ae - V * re + K * oe) * Ve),
                  (r[11] = (A * re - C * ae - O * oe) * Ve),
                  (r[12] = (x * Pe - _ * Ce - E * xe) * Ve),
                  (r[13] = (o * Ce - l * Pe + h * xe) * Ve),
                  (r[14] = (V * J - F * le - G * oe) * Ve),
                  (r[15] = (C * le - A * J + L * oe) * Ve),
                  r)
                : null;
            }
            function Rc(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = i[4],
                E = i[5],
                T = i[6],
                C = i[7],
                A = i[8],
                L = i[9],
                O = i[10],
                F = i[11],
                V = i[12],
                G = i[13],
                K = i[14],
                oe = i[15],
                J = o[0],
                re = o[1],
                le = o[2],
                ae = o[3];
              return (
                (r[0] = J * l + re * x + le * A + ae * V),
                (r[1] = J * h + re * E + le * L + ae * G),
                (r[2] = J * m + re * T + le * O + ae * K),
                (r[3] = J * _ + re * C + le * F + ae * oe),
                (r[4] =
                  (J = o[4]) * l +
                  (re = o[5]) * x +
                  (le = o[6]) * A +
                  (ae = o[7]) * V),
                (r[5] = J * h + re * E + le * L + ae * G),
                (r[6] = J * m + re * T + le * O + ae * K),
                (r[7] = J * _ + re * C + le * F + ae * oe),
                (r[8] =
                  (J = o[8]) * l +
                  (re = o[9]) * x +
                  (le = o[10]) * A +
                  (ae = o[11]) * V),
                (r[9] = J * h + re * E + le * L + ae * G),
                (r[10] = J * m + re * T + le * O + ae * K),
                (r[11] = J * _ + re * C + le * F + ae * oe),
                (r[12] =
                  (J = o[12]) * l +
                  (re = o[13]) * x +
                  (le = o[14]) * A +
                  (ae = o[15]) * V),
                (r[13] = J * h + re * E + le * L + ae * G),
                (r[14] = J * m + re * T + le * O + ae * K),
                (r[15] = J * _ + re * C + le * F + ae * oe),
                r
              );
            }
            function id(r, i, o) {
              var l,
                h,
                m,
                _,
                x,
                E,
                T,
                C,
                A,
                L,
                O,
                F,
                V = o[0],
                G = o[1],
                K = o[2];
              return (
                i === r
                  ? ((r[12] = i[0] * V + i[4] * G + i[8] * K + i[12]),
                    (r[13] = i[1] * V + i[5] * G + i[9] * K + i[13]),
                    (r[14] = i[2] * V + i[6] * G + i[10] * K + i[14]),
                    (r[15] = i[3] * V + i[7] * G + i[11] * K + i[15]))
                  : ((h = i[1]),
                    (m = i[2]),
                    (_ = i[3]),
                    (x = i[4]),
                    (E = i[5]),
                    (T = i[6]),
                    (C = i[7]),
                    (A = i[8]),
                    (L = i[9]),
                    (O = i[10]),
                    (F = i[11]),
                    (r[0] = l = i[0]),
                    (r[1] = h),
                    (r[2] = m),
                    (r[3] = _),
                    (r[4] = x),
                    (r[5] = E),
                    (r[6] = T),
                    (r[7] = C),
                    (r[8] = A),
                    (r[9] = L),
                    (r[10] = O),
                    (r[11] = F),
                    (r[12] = l * V + x * G + A * K + i[12]),
                    (r[13] = h * V + E * G + L * K + i[13]),
                    (r[14] = m * V + T * G + O * K + i[14]),
                    (r[15] = _ * V + C * G + F * K + i[15])),
                r
              );
            }
            function Oc(r, i, o) {
              var l = o[0],
                h = o[1],
                m = o[2];
              return (
                (r[0] = i[0] * l),
                (r[1] = i[1] * l),
                (r[2] = i[2] * l),
                (r[3] = i[3] * l),
                (r[4] = i[4] * h),
                (r[5] = i[5] * h),
                (r[6] = i[6] * h),
                (r[7] = i[7] * h),
                (r[8] = i[8] * m),
                (r[9] = i[9] * m),
                (r[10] = i[10] * m),
                (r[11] = i[11] * m),
                (r[12] = i[12]),
                (r[13] = i[13]),
                (r[14] = i[14]),
                (r[15] = i[15]),
                r
              );
            }
            function Wf(r, i, o) {
              var l = Math.sin(o),
                h = Math.cos(o),
                m = i[4],
                _ = i[5],
                x = i[6],
                E = i[7],
                T = i[8],
                C = i[9],
                A = i[10],
                L = i[11];
              return (
                i !== r &&
                  ((r[0] = i[0]),
                  (r[1] = i[1]),
                  (r[2] = i[2]),
                  (r[3] = i[3]),
                  (r[12] = i[12]),
                  (r[13] = i[13]),
                  (r[14] = i[14]),
                  (r[15] = i[15])),
                (r[4] = m * h + T * l),
                (r[5] = _ * h + C * l),
                (r[6] = x * h + A * l),
                (r[7] = E * h + L * l),
                (r[8] = T * h - m * l),
                (r[9] = C * h - _ * l),
                (r[10] = A * h - x * l),
                (r[11] = L * h - E * l),
                r
              );
            }
            function Dp(r, i, o) {
              var l = Math.sin(o),
                h = Math.cos(o),
                m = i[0],
                _ = i[1],
                x = i[2],
                E = i[3],
                T = i[8],
                C = i[9],
                A = i[10],
                L = i[11];
              return (
                i !== r &&
                  ((r[4] = i[4]),
                  (r[5] = i[5]),
                  (r[6] = i[6]),
                  (r[7] = i[7]),
                  (r[12] = i[12]),
                  (r[13] = i[13]),
                  (r[14] = i[14]),
                  (r[15] = i[15])),
                (r[0] = m * h - T * l),
                (r[1] = _ * h - C * l),
                (r[2] = x * h - A * l),
                (r[3] = E * h - L * l),
                (r[8] = m * l + T * h),
                (r[9] = _ * l + C * h),
                (r[10] = x * l + A * h),
                (r[11] = E * l + L * h),
                r
              );
            }
            function Vg(r, i) {
              return (
                (r[0] = i[0]),
                (r[1] = 0),
                (r[2] = 0),
                (r[3] = 0),
                (r[4] = 0),
                (r[5] = i[1]),
                (r[6] = 0),
                (r[7] = 0),
                (r[8] = 0),
                (r[9] = 0),
                (r[10] = i[2]),
                (r[11] = 0),
                (r[12] = 0),
                (r[13] = 0),
                (r[14] = 0),
                (r[15] = 1),
                r
              );
            }
            function Sp(r, i, o) {
              var l,
                h,
                m,
                _ = o[0],
                x = o[1],
                E = o[2],
                T = Math.hypot(_, x, E);
              return T < nd
                ? null
                : ((_ *= T = 1 / T),
                  (x *= T),
                  (E *= T),
                  (l = Math.sin(i)),
                  (h = Math.cos(i)),
                  (r[0] = _ * _ * (m = 1 - h) + h),
                  (r[1] = x * _ * m + E * l),
                  (r[2] = E * _ * m - x * l),
                  (r[3] = 0),
                  (r[4] = _ * x * m - E * l),
                  (r[5] = x * x * m + h),
                  (r[6] = E * x * m + _ * l),
                  (r[7] = 0),
                  (r[8] = _ * E * m + x * l),
                  (r[9] = x * E * m - _ * l),
                  (r[10] = E * E * m + h),
                  (r[11] = 0),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[14] = 0),
                  (r[15] = 1),
                  r);
            }
            Math.hypot ||
              (Math.hypot = function () {
                for (var r = 0, i = arguments.length; i--; )
                  r += arguments[i] * arguments[i];
                return Math.sqrt(r);
              });
            var Ip = Rc;
            function jg() {
              var r = new Xn(3);
              return (
                Xn != Float32Array && ((r[0] = 0), (r[1] = 0), (r[2] = 0)), r
              );
            }
            function Bu(r) {
              var i = new Xn(3);
              return (i[0] = r[0]), (i[1] = r[1]), (i[2] = r[2]), i;
            }
            function Fc(r) {
              return Math.hypot(r[0], r[1], r[2]);
            }
            function Ka(r, i, o) {
              var l = new Xn(3);
              return (l[0] = r), (l[1] = i), (l[2] = o), l;
            }
            function Ya(r, i, o) {
              return (
                (r[0] = i[0] + o[0]),
                (r[1] = i[1] + o[1]),
                (r[2] = i[2] + o[2]),
                r
              );
            }
            function Zf(r, i, o) {
              return (
                (r[0] = i[0] - o[0]),
                (r[1] = i[1] - o[1]),
                (r[2] = i[2] - o[2]),
                r
              );
            }
            function Ug(r, i, o) {
              return (
                (r[0] = i[0] * o[0]),
                (r[1] = i[1] * o[1]),
                (r[2] = i[2] * o[2]),
                r
              );
            }
            function Vu(r, i, o) {
              return (
                (r[0] = Math.min(i[0], o[0])),
                (r[1] = Math.min(i[1], o[1])),
                (r[2] = Math.min(i[2], o[2])),
                r
              );
            }
            function Qa(r, i, o) {
              return (
                (r[0] = Math.max(i[0], o[0])),
                (r[1] = Math.max(i[1], o[1])),
                (r[2] = Math.max(i[2], o[2])),
                r
              );
            }
            function lr(r, i, o) {
              return (r[0] = i[0] * o), (r[1] = i[1] * o), (r[2] = i[2] * o), r;
            }
            function rd(r, i, o, l) {
              return (
                (r[0] = i[0] + o[0] * l),
                (r[1] = i[1] + o[1] * l),
                (r[2] = i[2] + o[2] * l),
                r
              );
            }
            function St(r, i) {
              var o = i[0],
                l = i[1],
                h = i[2],
                m = o * o + l * l + h * h;
              return (
                m > 0 && (m = 1 / Math.sqrt(m)),
                (r[0] = i[0] * m),
                (r[1] = i[1] * m),
                (r[2] = i[2] * m),
                r
              );
            }
            function Co(r, i) {
              return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
            }
            function Xf(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = o[0],
                x = o[1],
                E = o[2];
              return (
                (r[0] = h * E - m * x),
                (r[1] = m * _ - l * E),
                (r[2] = l * x - h * _),
                r
              );
            }
            function Kn(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = o[3] * l + o[7] * h + o[11] * m + o[15];
              return (
                (r[0] =
                  (o[0] * l + o[4] * h + o[8] * m + o[12]) / (_ = _ || 1)),
                (r[1] = (o[1] * l + o[5] * h + o[9] * m + o[13]) / _),
                (r[2] = (o[2] * l + o[6] * h + o[10] * m + o[14]) / _),
                r
              );
            }
            function ju(r, i, o) {
              var l = o[0],
                h = o[1],
                m = o[2],
                _ = i[0],
                x = i[1],
                E = i[2],
                T = h * E - m * x,
                C = m * _ - l * E,
                A = l * x - h * _,
                L = h * A - m * C,
                O = m * T - l * A,
                F = l * C - h * T,
                V = 2 * o[3];
              return (
                (C *= V),
                (A *= V),
                (O *= 2),
                (F *= 2),
                (r[0] = _ + (T *= V) + (L *= 2)),
                (r[1] = x + C + O),
                (r[2] = E + A + F),
                r
              );
            }
            var od,
              _s = Zf,
              yv = Ug,
              Kf = Fc;
            function sd(r, i, o) {
              return (
                (r[0] = i[0] * o),
                (r[1] = i[1] * o),
                (r[2] = i[2] * o),
                (r[3] = i[3] * o),
                r
              );
            }
            function Yf(r, i) {
              var o = i[0],
                l = i[1],
                h = i[2],
                m = i[3],
                _ = o * o + l * l + h * h + m * m;
              return (
                _ > 0 && (_ = 1 / Math.sqrt(_)),
                (r[0] = o * _),
                (r[1] = l * _),
                (r[2] = h * _),
                (r[3] = m * _),
                r
              );
            }
            function aa(r, i, o) {
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3];
              return (
                (r[0] = o[0] * l + o[4] * h + o[8] * m + o[12] * _),
                (r[1] = o[1] * l + o[5] * h + o[9] * m + o[13] * _),
                (r[2] = o[2] * l + o[6] * h + o[10] * m + o[14] * _),
                (r[3] = o[3] * l + o[7] * h + o[11] * m + o[15] * _),
                r
              );
            }
            function $g() {
              var r = new Xn(4);
              return (
                Xn != Float32Array && ((r[0] = 0), (r[1] = 0), (r[2] = 0)),
                (r[3] = 1),
                r
              );
            }
            function Qf(r) {
              return (r[0] = 0), (r[1] = 0), (r[2] = 0), (r[3] = 1), r;
            }
            function Uu(r, i, o) {
              o *= 0.5;
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = Math.sin(o),
                E = Math.cos(o);
              return (
                (r[0] = l * E + _ * x),
                (r[1] = h * E + m * x),
                (r[2] = m * E - h * x),
                (r[3] = _ * E - l * x),
                r
              );
            }
            function ad(r, i, o) {
              o *= 0.5;
              var l = i[0],
                h = i[1],
                m = i[2],
                _ = i[3],
                x = Math.sin(o),
                E = Math.cos(o);
              return (
                (r[0] = l * E - m * x),
                (r[1] = h * E + _ * x),
                (r[2] = m * E + l * x),
                (r[3] = _ * E - h * x),
                r
              );
            }
            jg(),
              (od = new Xn(4)),
              Xn != Float32Array &&
                ((od[0] = 0), (od[1] = 0), (od[2] = 0), (od[3] = 0));
            var Hg = Yf;
            jg(), Ka(1, 0, 0), Ka(0, 1, 0), $g(), $g(), Ep();
            const vv = ge([
                { type: "Float32", name: "a_globe_pos", components: 3 },
                { type: "Float32", name: "a_uv", components: 2 },
              ]),
              { members: Gg } = vv,
              Nc = ge([{ name: "a_pos_3", components: 3, type: "Int16" }]);
            var Ja = ge([{ name: "a_pos", type: "Int16", components: 2 }]);
            class Jf {
              constructor(i, o) {
                (this.pos = i), (this.dir = o);
              }
              intersectsPlane(i, o, l) {
                const h = Co(o, this.dir);
                if (Math.abs(h) < 1e-6) return !1;
                const m =
                  ((i[0] - this.pos[0]) * o[0] +
                    (i[1] - this.pos[1]) * o[1] +
                    (i[2] - this.pos[2]) * o[2]) /
                  h;
                return (
                  (l[0] = this.pos[0] + this.dir[0] * m),
                  (l[1] = this.pos[1] + this.dir[1] * m),
                  (l[2] = this.pos[2] + this.dir[2] * m),
                  !0
                );
              }
              closestPointOnSphere(i, o, l) {
                if (
                  ((V = (O = this.pos)[0]),
                  (G = O[1]),
                  (K = O[2]),
                  (oe = (F = i)[0]),
                  (J = F[1]),
                  (re = F[2]),
                  (Math.abs(V - oe) <=
                    nd * Math.max(1, Math.abs(V), Math.abs(oe)) &&
                    Math.abs(G - J) <=
                      nd * Math.max(1, Math.abs(G), Math.abs(J)) &&
                    Math.abs(K - re) <=
                      nd * Math.max(1, Math.abs(K), Math.abs(re))) ||
                    0 === o)
                )
                  return (l[0] = l[1] = l[2] = 0), !1;
                var O, F, V, G, K, oe, J, re;
                const [h, m, _] = this.dir,
                  x = this.pos[0] - i[0],
                  E = this.pos[1] - i[1],
                  T = this.pos[2] - i[2],
                  C = h * h + m * m + _ * _,
                  A = 2 * (x * h + E * m + T * _),
                  L = A * A - 4 * C * (x * x + E * E + T * T - o * o);
                if (L < 0) {
                  const O = Math.max(-A / 2, 0),
                    F = x + h * O,
                    V = E + m * O,
                    G = T + _ * O,
                    K = Math.hypot(F, V, G);
                  return (
                    (l[0] = (F * o) / K),
                    (l[1] = (V * o) / K),
                    (l[2] = (G * o) / K),
                    !1
                  );
                }
                {
                  const O = (-A - Math.sqrt(L)) / (2 * C);
                  if (O < 0) {
                    const F = Math.hypot(x, E, T);
                    return (
                      (l[0] = (x * o) / F),
                      (l[1] = (E * o) / F),
                      (l[2] = (T * o) / F),
                      !1
                    );
                  }
                  return (
                    (l[0] = x + h * O),
                    (l[1] = E + m * O),
                    (l[2] = T + _ * O),
                    !0
                  );
                }
              }
            }
            class qg {
              constructor(i, o, l, h, m) {
                (this.TL = i),
                  (this.TR = o),
                  (this.BR = l),
                  (this.BL = h),
                  (this.horizon = m);
              }
              static fromInvProjectionMatrix(i, o, l) {
                const h = [-1, 1, 1],
                  m = [1, 1, 1],
                  _ = [1, -1, 1],
                  x = [-1, -1, 1],
                  E = Kn(h, h, i),
                  T = Kn(m, m, i),
                  C = Kn(_, _, i),
                  A = Kn(x, x, i);
                return new qg(E, T, C, A, o / l);
              }
            }
            class Cp {
              constructor(i, o) {
                (this.points = i), (this.planes = o);
              }
              static fromInvProjectionMatrix(i, o, l, h) {
                const m = Math.pow(2, l),
                  _ = [
                    [-1, 1, -1, 1],
                    [1, 1, -1, 1],
                    [1, -1, -1, 1],
                    [-1, -1, -1, 1],
                    [-1, 1, 1, 1],
                    [1, 1, 1, 1],
                    [1, -1, 1, 1],
                    [-1, -1, 1, 1],
                  ].map((E) => {
                    const T = aa([], E, i),
                      C = (1 / T[3] / o) * m;
                    return (
                      ((A = T)[0] =
                        (L = T)[0] * (O = [C, C, h ? 1 / T[3] : C, C])[0]),
                      (A[1] = L[1] * O[1]),
                      (A[2] = L[2] * O[2]),
                      (A[3] = L[3] * O[3]),
                      A
                    );
                    var A, L, O;
                  }),
                  x = [
                    [0, 1, 2],
                    [6, 5, 4],
                    [0, 3, 7],
                    [2, 1, 5],
                    [3, 2, 6],
                    [0, 4, 5],
                  ].map((E) => {
                    const T = St(
                        [],
                        Xf(
                          [],
                          _s([], _[E[0]], _[E[1]]),
                          _s([], _[E[2]], _[E[1]])
                        )
                      ),
                      C = -Co(T, _[E[1]]);
                    return T.concat(C);
                  });
                return new Cp(_, x);
              }
            }
            class Fr {
              static fromPoints(i) {
                const o = [1 / 0, 1 / 0, 1 / 0],
                  l = [-1 / 0, -1 / 0, -1 / 0];
                for (const h of i) Vu(o, o, h), Qa(l, l, h);
                return new Fr(o, l);
              }
              static applyTransform(i, o) {
                const l = i.getCorners();
                for (let h = 0; h < l.length; ++h) Kn(l[h], l[h], o);
                return Fr.fromPoints(l);
              }
              constructor(i, o) {
                (this.min = i),
                  (this.max = o),
                  (this.center = lr([], Ya([], this.min, this.max), 0.5));
              }
              quadrant(i) {
                const o = [i % 2 == 0, i < 2],
                  l = Bu(this.min),
                  h = Bu(this.max);
                for (let m = 0; m < o.length; m++)
                  (l[m] = o[m] ? this.min[m] : this.center[m]),
                    (h[m] = o[m] ? this.center[m] : this.max[m]);
                return (h[2] = this.max[2]), new Fr(l, h);
              }
              distanceX(i) {
                return (
                  Math.max(Math.min(this.max[0], i[0]), this.min[0]) - i[0]
                );
              }
              distanceY(i) {
                return (
                  Math.max(Math.min(this.max[1], i[1]), this.min[1]) - i[1]
                );
              }
              distanceZ(i) {
                return (
                  Math.max(Math.min(this.max[2], i[2]), this.min[2]) - i[2]
                );
              }
              getCorners() {
                const i = this.min,
                  o = this.max;
                return [
                  [i[0], i[1], i[2]],
                  [o[0], i[1], i[2]],
                  [o[0], o[1], i[2]],
                  [i[0], o[1], i[2]],
                  [i[0], i[1], o[2]],
                  [o[0], i[1], o[2]],
                  [o[0], o[1], o[2]],
                  [i[0], o[1], o[2]],
                ];
              }
              intersects(i) {
                const o = this.getCorners();
                let l = !0;
                for (let h = 0; h < i.planes.length; h++) {
                  const m = i.planes[h];
                  let _ = 0;
                  for (let x = 0; x < o.length; x++)
                    _ += Co(m, o[x]) + m[3] >= 0;
                  if (0 === _) return 0;
                  _ !== o.length && (l = !1);
                }
                if (l) return 2;
                for (let h = 0; h < 3; h++) {
                  let m = Number.MAX_VALUE,
                    _ = -Number.MAX_VALUE;
                  for (let x = 0; x < i.points.length; x++) {
                    const E = i.points[x][h] - this.min[h];
                    (m = Math.min(m, E)), (_ = Math.max(_, E));
                  }
                  if (_ < 0 || m > this.max[h] - this.min[h]) return 0;
                }
                return 1;
              }
            }
            const la = vt / Math.PI / 2,
              $u = [64, 32, 16],
              Yo = -la,
              Mo = la,
              vb = [
                new Fr([Yo, Yo, Yo], [Mo, Mo, Mo]),
                new Fr([Yo, Yo, Yo], [0, 0, Mo]),
                new Fr([0, Yo, Yo], [Mo, 0, Mo]),
                new Fr([Yo, 0, Yo], [0, Mo, Mo]),
                new Fr([0, 0, Yo], [Mo, Mo, Mo]),
              ];
            function ld(r) {
              return (r * la) / pd;
            }
            function bv(r, i, o, l = !0) {
              const h = lr([], r._camera.position, r.worldSize),
                m = [i, o, 1, 1];
              aa(m, m, r.pixelMatrixInverse), sd(m, m, 1 / m[3]);
              const _ = St([], _s([], m, h)),
                x = r.globeMatrix,
                E = [x[12], x[13], x[14]],
                T = _s([], E, h),
                C = Fc(T),
                A = St([], T),
                L = r.worldSize / (2 * Math.PI),
                O = Co(A, _),
                F = Math.asin(L / C);
              if (F < Math.acos(O)) {
                if (!l) return null;
                const $e = [],
                  Ce = [];
                lr($e, _, C / O),
                  St(Ce, _s(Ce, $e, T)),
                  St(_, Ya(_, T, lr(_, Ce, Math.tan(F) * C)));
              }
              const V = [];
              new Jf(h, _).closestPointOnSphere(E, L, V);
              const G = St([], as(x, 0)),
                K = St([], as(x, 1)),
                oe = St([], as(x, 2)),
                J = Co(G, V),
                re = Co(K, V),
                le = Co(oe, V),
                ae = Oi(Math.asin(-re / L));
              let De = Oi(Math.atan2(J, le));
              De =
                r.center.lng +
                (function ($e, Ce) {
                  const Fe = ((Ce - $e + 180) % 360) - 180;
                  return Fe < -180 ? Fe + 360 : Fe;
                })(r.center.lng, De);
              const xe = ua(De),
                Pe = Qt(ii(ae), 0, 1);
              return new qu(xe, Pe);
            }
            class wv {
              constructor(i, o, l) {
                (this.a = _s([], i, l)),
                  (this.b = _s([], o, l)),
                  (this.center = l);
                const h = St([], this.a),
                  m = St([], this.b);
                this.angle = Math.acos(Co(h, m));
              }
            }
            function em(r, i) {
              if (0 === r.angle) return null;
              let o;
              return (
                (o =
                  0 === r.a[i]
                    ? (1 / r.angle) * 0.5 * Math.PI
                    : (1 / r.angle) *
                      Math.atan(
                        r.b[i] / r.a[i] / Math.sin(r.angle) -
                          1 / Math.tan(r.angle)
                      )),
                o < 0 || o > 1
                  ? null
                  : (function (l, h, m, _) {
                      const x = Math.sin(m);
                      return (
                        l * (Math.sin((1 - _) * m) / x) +
                        h * (Math.sin(_ * m) / x)
                      );
                    })(r.a[i], r.b[i], r.angle, Qt(o, 0, 1)) + r.center[i]
              );
            }
            function Qo(r) {
              if (r.z <= 1) return vb[r.z + 2 * r.y + r.x];
              const i = Xg(tm(r));
              return Fr.fromPoints(i);
            }
            function Hu(r, i, o) {
              return lr(r, r, 1 - o), rd(r, r, i, o);
            }
            function Ev(r, i) {
              const o = Yi(i.zoom);
              if (0 === o) return Qo(r);
              const l = tm(r),
                h = Xg(l),
                m = ua(l.getWest()) * i.worldSize,
                _ = ua(l.getEast()) * i.worldSize,
                x = ii(l.getNorth()) * i.worldSize,
                E = ii(l.getSouth()) * i.worldSize,
                T = [m, x, 0],
                C = [_, x, 0],
                A = [m, E, 0],
                L = [_, E, 0],
                O = Tp([], i.globeMatrix);
              return (
                Kn(T, T, O),
                Kn(C, C, O),
                Kn(A, A, O),
                Kn(L, L, O),
                (h[0] = Hu(h[0], A, o)),
                (h[1] = Hu(h[1], L, o)),
                (h[2] = Hu(h[2], C, o)),
                (h[3] = Hu(h[3], T, o)),
                Fr.fromPoints(h)
              );
            }
            function Mp(r, i, o) {
              for (const l of r) Kn(l, l, i), lr(l, l, o);
            }
            function tm({ x: r, y: i, z: o }) {
              const l = 1 / (1 << o),
                h = new Mn(so(r * l), $i((i + 1) * l)),
                m = new Mn(so((r + 1) * l), $i(i * l));
              return new Lc(h, m);
            }
            function Xg(r) {
              const i = Xt(r.getNorth()),
                o = Xt(r.getSouth()),
                l = Math.cos(i),
                h = Math.cos(o),
                m = Math.sin(i),
                _ = Math.sin(o),
                x = r.getWest(),
                E = r.getEast();
              return [cd(h, _, x), cd(h, _, E), cd(l, m, E), cd(l, m, x)];
            }
            function cd(r, i, o, l = la) {
              return (
                (o = Xt(o)), [r * Math.sin(o) * l, -i * l, r * Math.cos(o) * l]
              );
            }
            function ud(r, i, o) {
              return cd(Math.cos(Xt(r)), Math.sin(Xt(r)), i, o);
            }
            function hd(r, i, o, l) {
              const h = 1 << o.z,
                m = (r / vt + o.x) / h;
              return ud($i((i / vt + o.y) / h), so(m), l);
            }
            function dd({ min: r, max: i }) {
              return 16383 / Math.max(i[0] - r[0], i[1] - r[1], i[2] - r[2]);
            }
            const Ap = new Float64Array(16);
            function Gu(r) {
              const i = dd(r),
                o = Vg(Ap, [i, i, i]);
              return id(
                o,
                o,
                (((l = [])[0] = -(h = r.min)[0]),
                (l[1] = -h[1]),
                (l[2] = -h[2]),
                l)
              );
              var l, h;
            }
            function Pp(r) {
              const i =
                ((l = r.min),
                ((o = Ap)[0] = 1),
                (o[1] = 0),
                (o[2] = 0),
                (o[3] = 0),
                (o[4] = 0),
                (o[5] = 1),
                (o[6] = 0),
                (o[7] = 0),
                (o[8] = 0),
                (o[9] = 0),
                (o[10] = 1),
                (o[11] = 0),
                (o[12] = l[0]),
                (o[13] = l[1]),
                (o[14] = l[2]),
                (o[15] = 1),
                o);
              var o, l;
              const h = 1 / dd(r);
              return Oc(i, i, [h, h, h]);
            }
            function nm(r, i, o, l, h) {
              const m = (function (E) {
                  const T = vt / (2 * Math.PI);
                  return E / (2 * Math.PI) / T;
                })(o),
                _ = [r, i, -o / (2 * Math.PI)],
                x = sa(new Float64Array(16));
              return (
                id(x, x, _),
                Oc(x, x, [m, m, m]),
                Wf(x, x, Xt(-h)),
                Dp(x, x, Xt(-l)),
                x
              );
            }
            function Yi(r) {
              return Ma(5, 6, r);
            }
            function Kg(r, i) {
              const o = ud(i.lat, i.lng);
              return (
                (_ = (h = Zf(
                  [],
                  (function (F) {
                    const V = ud(F._center.lat, F._center.lng);
                    let G = Xf([], Ka(0, 1, 0), V);
                    const K = Sp([], -F.angle, V);
                    (G = Kn(G, G, K)), Sp(K, -F._pitch, G);
                    const oe = St([], V);
                    return (
                      lr(
                        oe,
                        oe,
                        ld(F.cameraToCenterDistance / F.pixelsPerMeter)
                      ),
                      Kn(oe, oe, K),
                      Ya([], V, oe)
                    );
                  })(r),
                  o
                ))[0]),
                (x = h[1]),
                (E = h[2]),
                (T = (m = o)[0]),
                (C = m[1]),
                (A = m[2]),
                (O =
                  (L =
                    Math.sqrt(_ * _ + x * x + E * E) *
                    Math.sqrt(T * T + C * C + A * A)) && Co(h, m) / L),
                Math.acos(Math.min(Math.max(O, -1), 1))
              );
              var h, m, _, x, E, T, C, A, L, O;
            }
            function im(r, i) {
              return Kg(r, i) > (Math.PI / 2) * 1.01;
            }
            const Yg = Xt(85),
              Qg = Math.cos(Yg),
              rm = Math.sin(Yg),
              pd = 6371008.8,
              Jg = 2 * Math.PI * pd;
            class Hl {
              constructor(i, o) {
                if (isNaN(i) || isNaN(o))
                  throw new Error(`Invalid LngLat object: (${i}, ${o})`);
                if (
                  ((this.lng = +i),
                  (this.lat = +o),
                  this.lat > 90 || this.lat < -90)
                )
                  throw new Error(
                    "Invalid LngLat latitude value: must be between -90 and 90"
                  );
              }
              wrap() {
                return new Hl(bn(this.lng, -180, 180), this.lat);
              }
              toArray() {
                return [this.lng, this.lat];
              }
              toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
              }
              distanceTo(i) {
                const o = Math.PI / 180,
                  l = this.lat * o,
                  h = i.lat * o,
                  m =
                    Math.sin(l) * Math.sin(h) +
                    Math.cos(l) *
                      Math.cos(h) *
                      Math.cos((i.lng - this.lng) * o);
                return pd * Math.acos(Math.min(m, 1));
              }
              toBounds(i = 0) {
                const o = (360 * i) / 40075017,
                  l = o / Math.cos((Math.PI / 180) * this.lat);
                return new Lc(
                  new Hl(this.lng - l, this.lat - o),
                  new Hl(this.lng + l, this.lat + o)
                );
              }
              toEcef(i) {
                const o = ld(i);
                return ud(this.lat, this.lng, la + o);
              }
              static convert(i) {
                if (i instanceof Hl) return i;
                if (Array.isArray(i) && (2 === i.length || 3 === i.length))
                  return new Hl(Number(i[0]), Number(i[1]));
                if (!Array.isArray(i) && "object" == typeof i && null !== i)
                  return new Hl(
                    Number("lng" in i ? i.lng : i.lon),
                    Number(i.lat)
                  );
                throw new Error(
                  "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]"
                );
              }
            }
            var Mn = Hl;
            function om(r) {
              return Jg * Math.cos((r * Math.PI) / 180);
            }
            function ua(r) {
              return (180 + r) / 360;
            }
            function ii(r) {
              return (
                (180 -
                  (180 / Math.PI) *
                    Math.log(Math.tan(Math.PI / 4 + (r * Math.PI) / 360))) /
                360
              );
            }
            function Ao(r, i) {
              return r / om(i);
            }
            function so(r) {
              return 360 * r - 180;
            }
            function $i(r) {
              return (
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * r) * Math.PI) / 180)) -
                90
              );
            }
            function Er(r, i) {
              return r * om($i(i));
            }
            const Ti = 85.051129;
            function sm(r) {
              return 1 / Math.cos((r * Math.PI) / 180);
            }
            class qu {
              constructor(i, o, l = 0) {
                (this.x = +i), (this.y = +o), (this.z = +l);
              }
              static fromLngLat(i, o = 0) {
                const l = Mn.convert(i);
                return new qu(ua(l.lng), ii(l.lat), Ao(o, l.lat));
              }
              toLngLat() {
                return new Mn(so(this.x), $i(this.y));
              }
              toAltitude() {
                return Er(this.z, this.y);
              }
              meterInMercatorCoordinateUnits() {
                return (1 / Jg) * sm($i(this.y));
              }
            }
            function am(r, i, o, l, h, m, _, x, E) {
              const T = (i + l) / 2,
                C = (o + h) / 2,
                A = new et(T, C);
              x(A),
                (function (L, O, F, V, G, K) {
                  const oe = F - G,
                    J = V - K;
                  return (
                    Math.abs((V - O) * oe - (F - L) * J) / Math.hypot(oe, J)
                  );
                })(A.x, A.y, m.x, m.y, _.x, _.y) >= E
                  ? (am(r, i, o, T, C, m, A, x, E),
                    am(r, T, C, l, h, A, _, x, E))
                  : r.push(_);
            }
            function lm(r, i, o) {
              let l = r[0],
                h = l.x,
                m = l.y;
              i(l);
              const _ = [l];
              for (let x = 1; x < r.length; x++) {
                const E = r[x],
                  { x: T, y: C } = E;
                i(E), am(_, h, m, T, C, l, E, i, o), (h = T), (m = C), (l = E);
              }
              return _;
            }
            function cm(r, i, o, l) {
              if (l(i, o)) {
                const h = i.add(o)._mult(0.5);
                cm(r, i, h, l), cm(r, h, o, l);
              } else r.push(o);
            }
            function e_(r, i) {
              let o = r[0];
              const l = [o];
              for (let h = 1; h < r.length; h++) {
                const m = r[h];
                cm(l, o, m, i), (o = m);
              }
              return l;
            }
            const um = Math.pow(2, 14) - 1,
              hm = -um - 1;
            function Tv(r, i) {
              const o = Math.round(r.x * i),
                l = Math.round(r.y * i);
              return (
                (r.x = Qt(o, hm, um)),
                (r.y = Qt(l, hm, um)),
                (o < r.x || o > r.x + 1 || l < r.y || l > r.y + 1) &&
                  Hn(
                    "Geometry exceeds allowed extent, reduce your vector tile buffer size"
                  ),
                r
              );
            }
            function el(r, i, o) {
              const l = r.loadGeometry(),
                h = r.extent,
                m = vt / h;
              if (i && o && o.projection.isReprojectedInTileSpace) {
                const _ = 1 << i.z,
                  { scale: x, x: E, y: T, projection: C } = o,
                  A = (L) => {
                    const O = so((i.x + L.x / h) / _),
                      F = $i((i.y + L.y / h) / _),
                      V = C.project(O, F);
                    (L.x = (V.x * x - E) * h), (L.y = (V.y * x - T) * h);
                  };
                for (let L = 0; L < l.length; L++)
                  if (1 !== r.type) l[L] = lm(l[L], A, 1);
                  else {
                    const O = [];
                    for (const F of l[L])
                      F.x < 0 ||
                        F.x >= h ||
                        F.y < 0 ||
                        F.y >= h ||
                        (A(F), O.push(F));
                    l[L] = O;
                  }
              }
              for (const _ of l) for (const x of _) Tv(x, m);
              return l;
            }
            function tl(r, i) {
              return {
                type: r.type,
                id: r.id,
                properties: r.properties,
                geometry: i ? el(r) : [],
              };
            }
            function Wu(r, i, o, l, h) {
              r.emplaceBack(2 * i + (l + 1) / 2, 2 * o + (h + 1) / 2);
            }
            function Lp(r, i, o) {
              r.emplaceBack(
                i.x,
                i.y,
                i.z,
                16384 * o[0],
                16384 * o[1],
                16384 * o[2]
              );
            }
            class kp {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.hasPattern = !1),
                  (this.projection = i.projection),
                  (this.layoutVertexArray = new Ge()),
                  (this.indexArray = new ft()),
                  (this.segments = new gi()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id));
              }
              populate(i, o, l, h) {
                const m = this.layers[0],
                  _ = [];
                let x = null;
                "circle" === m.type && (x = m.layout.get("circle-sort-key"));
                for (const {
                  feature: T,
                  id: C,
                  index: A,
                  sourceLayerIndex: L,
                } of i) {
                  const O = this.layers[0]._featureFilter.needGeometry,
                    F = tl(T, O);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      F,
                      l
                    )
                  )
                    continue;
                  const V = x ? x.evaluate(F, {}, l) : void 0,
                    G = {
                      id: C,
                      properties: T.properties,
                      type: T.type,
                      sourceLayerIndex: L,
                      index: A,
                      geometry: O ? F.geometry : el(T, l, h),
                      patterns: {},
                      sortKey: V,
                    };
                  _.push(G);
                }
                x && _.sort((T, C) => T.sortKey - C.sortKey);
                let E = null;
                "globe" === h.projection.name &&
                  ((this.globeExtVertexArray = new He()), (E = h.projection));
                for (const T of _) {
                  const { geometry: C, index: A, sourceLayerIndex: L } = T,
                    O = i[A].feature;
                  this.addFeature(T, C, A, o.availableImages, l, E),
                    o.featureIndex.insert(O, C, A, L, this.index);
                }
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    Bg.members
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  this.globeExtVertexArray &&
                    (this.globeExtVertexBuffer = i.createVertexBuffer(
                      this.globeExtVertexArray,
                      _v.members
                    ))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy());
              }
              addFeature(i, o, l, h, m, _) {
                for (const x of o)
                  for (const E of x) {
                    const T = E.x,
                      C = E.y;
                    if (T < 0 || T >= vt || C < 0 || C >= vt) continue;
                    if (_) {
                      const O = _.projectTilePoint(T, C, m),
                        F = _.upVector(m, T, C),
                        V = this.globeExtVertexArray;
                      Lp(V, O, F), Lp(V, O, F), Lp(V, O, F), Lp(V, O, F);
                    }
                    const A = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                        i.sortKey
                      ),
                      L = A.vertexLength;
                    Wu(this.layoutVertexArray, T, C, -1, -1),
                      Wu(this.layoutVertexArray, T, C, 1, -1),
                      Wu(this.layoutVertexArray, T, C, 1, 1),
                      Wu(this.layoutVertexArray, T, C, -1, 1),
                      this.indexArray.emplaceBack(L, L + 1, L + 2),
                      this.indexArray.emplaceBack(L, L + 2, L + 3),
                      (A.vertexLength += 4),
                      (A.primitiveLength += 2);
                  }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  {},
                  h,
                  m
                );
              }
            }
            function t_(r, i) {
              for (let o = 0; o < r.length; o++) if (nl(i, r[o])) return !0;
              for (let o = 0; o < i.length; o++) if (nl(r, i[o])) return !0;
              return !!md(r, i);
            }
            function fd(r, i, o) {
              return !!nl(r, i) || !!Rp(i, r, o);
            }
            function n_(r, i) {
              if (1 === r.length) return zc(i, r[0]);
              for (let o = 0; o < i.length; o++) {
                const l = i[o];
                for (let h = 0; h < l.length; h++) if (nl(r, l[h])) return !0;
              }
              for (let o = 0; o < r.length; o++) if (zc(i, r[o])) return !0;
              for (let o = 0; o < i.length; o++) if (md(r, i[o])) return !0;
              return !1;
            }
            function Dv(r, i, o) {
              if (r.length > 1) {
                if (md(r, i)) return !0;
                for (let l = 0; l < i.length; l++)
                  if (Rp(i[l], r, o)) return !0;
              }
              for (let l = 0; l < r.length; l++) if (Rp(r[l], i, o)) return !0;
              return !1;
            }
            function md(r, i) {
              if (0 === r.length || 0 === i.length) return !1;
              for (let o = 0; o < r.length - 1; o++) {
                const l = r[o],
                  h = r[o + 1];
                for (let m = 0; m < i.length - 1; m++)
                  if (dm(l, h, i[m], i[m + 1])) return !0;
              }
              return !1;
            }
            function dm(r, i, o, l) {
              return to(r, o, l) !== to(i, o, l) && to(r, i, o) !== to(r, i, l);
            }
            function Rp(r, i, o) {
              const l = o * o;
              if (1 === i.length) return r.distSqr(i[0]) < l;
              for (let h = 1; h < i.length; h++)
                if (Sv(r, i[h - 1], i[h]) < l) return !0;
              return !1;
            }
            function Sv(r, i, o) {
              const l = i.distSqr(o);
              if (0 === l) return r.distSqr(i);
              const h =
                ((r.x - i.x) * (o.x - i.x) + (r.y - i.y) * (o.y - i.y)) / l;
              return r.distSqr(
                h < 0 ? i : h > 1 ? o : o.sub(i)._mult(h)._add(i)
              );
            }
            function zc(r, i) {
              let o,
                l,
                h,
                m = !1;
              for (let _ = 0; _ < r.length; _++) {
                o = r[_];
                for (let x = 0, E = o.length - 1; x < o.length; E = x++)
                  (l = o[x]),
                    (h = o[E]),
                    l.y > i.y != h.y > i.y &&
                      i.x < ((h.x - l.x) * (i.y - l.y)) / (h.y - l.y) + l.x &&
                      (m = !m);
              }
              return m;
            }
            function nl(r, i) {
              let o = !1;
              for (let l = 0, h = r.length - 1; l < r.length; h = l++) {
                const m = r[l],
                  _ = r[h];
                m.y > i.y != _.y > i.y &&
                  i.x < ((_.x - m.x) * (i.y - m.y)) / (_.y - m.y) + m.x &&
                  (o = !o);
              }
              return o;
            }
            function pm(r, i, o, l, h) {
              for (const _ of r)
                if (i <= _.x && o <= _.y && l >= _.x && h >= _.y) return !0;
              const m = [
                new et(i, o),
                new et(i, h),
                new et(l, h),
                new et(l, o),
              ];
              if (r.length > 2) for (const _ of m) if (nl(r, _)) return !0;
              for (let _ = 0; _ < r.length - 1; _++)
                if (Iv(r[_], r[_ + 1], m)) return !0;
              return !1;
            }
            function Iv(r, i, o) {
              const l = o[0],
                h = o[2];
              if (
                (r.x < l.x && i.x < l.x) ||
                (r.x > h.x && i.x > h.x) ||
                (r.y < l.y && i.y < l.y) ||
                (r.y > h.y && i.y > h.y)
              )
                return !1;
              const m = to(r, i, o[0]);
              return (
                m !== to(r, i, o[1]) ||
                m !== to(r, i, o[2]) ||
                m !== to(r, i, o[3])
              );
            }
            function Gl(r, i, o) {
              const l = i.paint.get(r).value;
              return "constant" === l.kind
                ? l.value
                : o.programConfigurations.get(i.id).getMaxValue(r);
            }
            function Op(r) {
              return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
            }
            function i_(r, i, o, l, h) {
              if (!i[0] && !i[1]) return r;
              const m = et.convert(i)._mult(h);
              "viewport" === o && m._rotate(-l);
              const _ = [];
              for (let x = 0; x < r.length; x++) _.push(r[x].sub(m));
              return _;
            }
            function r_(r, i, o, l) {
              const h = et.convert(r)._mult(l);
              return "viewport" === i && h._rotate(-o), h;
            }
            st(kp, "CircleBucket", { omit: ["layers"] });
            const Cv = new te({
              "circle-sort-key": new W(Ae.layout_circle["circle-sort-key"]),
            });
            var Mv = {
              paint: new te({
                "circle-radius": new W(Ae.paint_circle["circle-radius"]),
                "circle-color": new W(Ae.paint_circle["circle-color"]),
                "circle-blur": new W(Ae.paint_circle["circle-blur"]),
                "circle-opacity": new W(Ae.paint_circle["circle-opacity"]),
                "circle-translate": new B(Ae.paint_circle["circle-translate"]),
                "circle-translate-anchor": new B(
                  Ae.paint_circle["circle-translate-anchor"]
                ),
                "circle-pitch-scale": new B(
                  Ae.paint_circle["circle-pitch-scale"]
                ),
                "circle-pitch-alignment": new B(
                  Ae.paint_circle["circle-pitch-alignment"]
                ),
                "circle-stroke-width": new W(
                  Ae.paint_circle["circle-stroke-width"]
                ),
                "circle-stroke-color": new W(
                  Ae.paint_circle["circle-stroke-color"]
                ),
                "circle-stroke-opacity": new W(
                  Ae.paint_circle["circle-stroke-opacity"]
                ),
              }),
              layout: Cv,
            };
            function o_(r, i, o, l, h, m, _, x, E) {
              if (m && r.queryGeometry.isAboveHorizon) return !1;
              m && (E *= r.pixelToTileUnitsFactor);
              const T = r.tileID.canonical,
                C = o.projection.upVectorScale(
                  T,
                  o.center.lat,
                  o.worldSize
                ).metersToTile;
              for (const A of i)
                for (const L of A) {
                  const O = L.add(x),
                    F =
                      h && o.elevation
                        ? o.elevation.exaggeration() *
                          h.getElevationAt(O.x, O.y, !0)
                        : 0,
                    V = o.projection.projectTilePoint(O.x, O.y, T);
                  if (F > 0) {
                    const J = o.projection.upVector(T, O.x, O.y);
                    (V.x += J[0] * C * F),
                      (V.y += J[1] * C * F),
                      (V.z += J[2] * C * F);
                  }
                  const G = m ? O : s_(V.x, V.y, V.z, l),
                    K = m
                      ? r.tilespaceRays.map((J) => fm(J, F))
                      : r.queryGeometry.screenGeometry,
                    oe = aa([], [V.x, V.y, V.z, 1], l);
                  if (
                    (!_ && m
                      ? (E *= oe[3] / o.cameraToCenterDistance)
                      : _ && !m && (E *= o.cameraToCenterDistance / oe[3]),
                    m)
                  ) {
                    const J = $i((L.y / vt + T.y) / (1 << T.z));
                    E /= o.projection.pixelsPerMeter(J, 1) / Ao(1, J);
                  }
                  if (fd(K, G, E)) return !0;
                }
              return !1;
            }
            function s_(r, i, o, l) {
              const h = aa([], [r, i, o, 1], l);
              return new et(h[0] / h[3], h[1] / h[3]);
            }
            const Fp = Ka(0, 0, 0),
              a_ = Ka(0, 0, 1);
            function fm(r, i) {
              const o = jg();
              return (
                (Fp[2] = i), r.intersectsPlane(Fp, a_, o), new et(o[0], o[1])
              );
            }
            class l_ extends kp {}
            function c_(r, { width: i, height: o }, l, h) {
              if (h) {
                if (h instanceof Uint8ClampedArray)
                  h = new Uint8Array(h.buffer);
                else if (h.length !== i * o * l)
                  throw new RangeError("mismatched image size");
              } else h = new Uint8Array(i * o * l);
              return (r.width = i), (r.height = o), (r.data = h), r;
            }
            function mm(r, i, o) {
              const { width: l, height: h } = i;
              (l === r.width && h === r.height) ||
                (Np(
                  r,
                  i,
                  { x: 0, y: 0 },
                  { x: 0, y: 0 },
                  {
                    width: Math.min(r.width, l),
                    height: Math.min(r.height, h),
                  },
                  o
                ),
                (r.width = l),
                (r.height = h),
                (r.data = i.data));
            }
            function Np(r, i, o, l, h, m) {
              if (0 === h.width || 0 === h.height) return i;
              if (
                h.width > r.width ||
                h.height > r.height ||
                o.x > r.width - h.width ||
                o.y > r.height - h.height
              )
                throw new RangeError(
                  "out of range source coordinates for image copy"
                );
              if (
                h.width > i.width ||
                h.height > i.height ||
                l.x > i.width - h.width ||
                l.y > i.height - h.height
              )
                throw new RangeError(
                  "out of range destination coordinates for image copy"
                );
              const _ = r.data,
                x = i.data;
              for (let E = 0; E < h.height; E++) {
                const T = ((o.y + E) * r.width + o.x) * m,
                  C = ((l.y + E) * i.width + l.x) * m;
                for (let A = 0; A < h.width * m; A++) x[C + A] = _[T + A];
              }
              return i;
            }
            st(l_, "HeatmapBucket", { omit: ["layers"] });
            class Xr {
              constructor(i, o) {
                c_(this, i, 1, o);
              }
              resize(i) {
                mm(this, new Xr(i), 1);
              }
              clone() {
                return new Xr(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(i, o, l, h, m) {
                Np(i, o, l, h, m, 1);
              }
            }
            class Kr {
              constructor(i, o) {
                c_(this, i, 4, o);
              }
              resize(i) {
                mm(this, new Kr(i), 4);
              }
              replace(i, o) {
                o
                  ? this.data.set(i)
                  : (this.data =
                      i instanceof Uint8ClampedArray
                        ? new Uint8Array(i.buffer)
                        : i);
              }
              clone() {
                return new Kr(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data)
                );
              }
              static copy(i, o, l, h, m) {
                Np(i, o, l, h, m, 4);
              }
            }
            st(Xr, "AlphaImage"), st(Kr, "RGBAImage");
            var u_ = {
              paint: new te({
                "heatmap-radius": new W(Ae.paint_heatmap["heatmap-radius"]),
                "heatmap-weight": new W(Ae.paint_heatmap["heatmap-weight"]),
                "heatmap-intensity": new B(
                  Ae.paint_heatmap["heatmap-intensity"]
                ),
                "heatmap-color": new ee(Ae.paint_heatmap["heatmap-color"]),
                "heatmap-opacity": new B(Ae.paint_heatmap["heatmap-opacity"]),
              }),
            };
            function gm(r) {
              const i = {},
                o = r.resolution || 256,
                l = r.clips ? r.clips.length : 1,
                h = r.image || new Kr({ width: o, height: l }),
                m = (_, x, E) => {
                  i[r.evaluationKey] = E;
                  const T = r.expression.evaluate(i);
                  (h.data[_ + x + 0] = Math.floor((255 * T.r) / T.a)),
                    (h.data[_ + x + 1] = Math.floor((255 * T.g) / T.a)),
                    (h.data[_ + x + 2] = Math.floor((255 * T.b) / T.a)),
                    (h.data[_ + x + 3] = Math.floor(255 * T.a));
                };
              if (r.clips)
                for (let _ = 0, x = 0; _ < l; ++_, x += 4 * o)
                  for (let E = 0, T = 0; E < o; E++, T += 4) {
                    const C = E / (o - 1),
                      { start: A, end: L } = r.clips[_];
                    m(x, T, A * (1 - C) + L * C);
                  }
              else
                for (let _ = 0, x = 0; _ < o; _++, x += 4) m(0, x, _ / (o - 1));
              return h;
            }
            var bb = {
              paint: new te({
                "hillshade-illumination-direction": new B(
                  Ae.paint_hillshade["hillshade-illumination-direction"]
                ),
                "hillshade-illumination-anchor": new B(
                  Ae.paint_hillshade["hillshade-illumination-anchor"]
                ),
                "hillshade-exaggeration": new B(
                  Ae.paint_hillshade["hillshade-exaggeration"]
                ),
                "hillshade-shadow-color": new B(
                  Ae.paint_hillshade["hillshade-shadow-color"]
                ),
                "hillshade-highlight-color": new B(
                  Ae.paint_hillshade["hillshade-highlight-color"]
                ),
                "hillshade-accent-color": new B(
                  Ae.paint_hillshade["hillshade-accent-color"]
                ),
              }),
            };
            const zp = ge([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              { members: Av } = zp;
            var Bp = { exports: {} };
            function gd(r, i, o) {
              o = o || 2;
              var l,
                h,
                m,
                _,
                x,
                E,
                T,
                C = i && i.length,
                A = C ? i[0] * o : r.length,
                L = _m(r, 0, A, o, !0),
                O = [];
              if (!L || L.next === L.prev) return O;
              if (
                (C &&
                  (L = (function (V, G, K, oe) {
                    var J,
                      re,
                      le,
                      ae = [];
                    for (J = 0, re = G.length; J < re; J++)
                      (le = _m(
                        V,
                        G[J] * oe,
                        J < re - 1 ? G[J + 1] * oe : V.length,
                        oe,
                        !1
                      )) === le.next && (le.steiner = !0),
                        ae.push(d_(le));
                    for (ae.sort(vm), J = 0; J < ae.length; J++)
                      K = xm(ae[J], K);
                    return K;
                  })(r, i, L, o)),
                r.length > 80 * o)
              ) {
                (l = m = r[0]), (h = _ = r[1]);
                for (var F = o; F < A; F += o)
                  (x = r[F]) < l && (l = x),
                    (E = r[F + 1]) < h && (h = E),
                    x > m && (m = x),
                    E > _ && (_ = E);
                T = 0 !== (T = Math.max(m - l, _ - h)) ? 32767 / T : 0;
              }
              return Zu(L, O, o, l, h, T, 0), O;
            }
            function _m(r, i, o, l, h) {
              var m, _;
              if (h === wm(r, i, o, l) > 0)
                for (m = i; m < o; m += l) _ = Lv(m, r[m], r[m + 1], _);
              else for (m = o - l; m >= i; m -= l) _ = Lv(m, r[m], r[m + 1], _);
              return _ && Ku(_, _.next) && (xd(_), (_ = _.next)), _;
            }
            function il(r, i) {
              if (!r) return r;
              i || (i = r);
              var o,
                l = r;
              do {
                if (
                  ((o = !1),
                  l.steiner || (!Ku(l, l.next) && 0 !== ri(l.prev, l, l.next)))
                )
                  l = l.next;
                else {
                  if ((xd(l), (l = i = l.prev) === l.next)) break;
                  o = !0;
                }
              } while (o || l !== i);
              return i;
            }
            function Zu(r, i, o, l, h, m, _) {
              if (r) {
                !_ &&
                  m &&
                  (function (C, A, L, O) {
                    var F = C;
                    do {
                      0 === F.z && (F.z = bm(F.x, F.y, A, L, O)),
                        (F.prevZ = F.prev),
                        (F.nextZ = F.next),
                        (F = F.next);
                    } while (F !== C);
                    (F.prevZ.nextZ = null),
                      (F.prevZ = null),
                      (function (V) {
                        var G,
                          K,
                          oe,
                          J,
                          re,
                          le,
                          ae,
                          De,
                          xe = 1;
                        do {
                          for (K = V, V = null, re = null, le = 0; K; ) {
                            for (
                              le++, oe = K, ae = 0, G = 0;
                              G < xe && (ae++, (oe = oe.nextZ));
                              G++
                            );
                            for (De = xe; ae > 0 || (De > 0 && oe); )
                              0 !== ae && (0 === De || !oe || K.z <= oe.z)
                                ? ((J = K), (K = K.nextZ), ae--)
                                : ((J = oe), (oe = oe.nextZ), De--),
                                re ? (re.nextZ = J) : (V = J),
                                (J.prevZ = re),
                                (re = J);
                            K = oe;
                          }
                          (re.nextZ = null), (xe *= 2);
                        } while (le > 1);
                      })(F);
                  })(r, l, h, m);
                for (var x, E, T = r; r.prev !== r.next; )
                  if (((x = r.prev), (E = r.next), m ? jp(r, l, h, m) : Vp(r)))
                    i.push((x.i / o) | 0),
                      i.push((r.i / o) | 0),
                      i.push((E.i / o) | 0),
                      xd(r),
                      (r = E.next),
                      (T = E.next);
                  else if ((r = E) === T) {
                    _
                      ? 1 === _
                        ? Zu((r = h_(il(r), i, o)), i, o, l, h, m, 2)
                        : 2 === _ && ym(r, i, o, l, h, m)
                      : Zu(il(r), i, o, l, h, m, 1);
                    break;
                  }
              }
            }
            function Vp(r) {
              var i = r.prev,
                o = r,
                l = r.next;
              if (ri(i, o, l) >= 0) return !1;
              for (
                var h = i.x,
                  m = o.x,
                  _ = l.x,
                  x = i.y,
                  E = o.y,
                  T = l.y,
                  C = h < m ? (h < _ ? h : _) : m < _ ? m : _,
                  A = x < E ? (x < T ? x : T) : E < T ? E : T,
                  L = h > m ? (h > _ ? h : _) : m > _ ? m : _,
                  O = x > E ? (x > T ? x : T) : E > T ? E : T,
                  F = l.next;
                F !== i;

              ) {
                if (
                  F.x >= C &&
                  F.x <= L &&
                  F.y >= A &&
                  F.y <= O &&
                  Xu(h, x, m, E, _, T, F.x, F.y) &&
                  ri(F.prev, F, F.next) >= 0
                )
                  return !1;
                F = F.next;
              }
              return !0;
            }
            function jp(r, i, o, l) {
              var h = r.prev,
                m = r,
                _ = r.next;
              if (ri(h, m, _) >= 0) return !1;
              for (
                var x = h.x,
                  E = m.x,
                  T = _.x,
                  C = h.y,
                  A = m.y,
                  L = _.y,
                  O = x < E ? (x < T ? x : T) : E < T ? E : T,
                  F = C < A ? (C < L ? C : L) : A < L ? A : L,
                  V = x > E ? (x > T ? x : T) : E > T ? E : T,
                  G = C > A ? (C > L ? C : L) : A > L ? A : L,
                  K = bm(O, F, i, o, l),
                  oe = bm(V, G, i, o, l),
                  J = r.prevZ,
                  re = r.nextZ;
                J && J.z >= K && re && re.z <= oe;

              ) {
                if (
                  (J.x >= O &&
                    J.x <= V &&
                    J.y >= F &&
                    J.y <= G &&
                    J !== h &&
                    J !== _ &&
                    Xu(x, C, E, A, T, L, J.x, J.y) &&
                    ri(J.prev, J, J.next) >= 0) ||
                  ((J = J.prevZ),
                  re.x >= O &&
                    re.x <= V &&
                    re.y >= F &&
                    re.y <= G &&
                    re !== h &&
                    re !== _ &&
                    Xu(x, C, E, A, T, L, re.x, re.y) &&
                    ri(re.prev, re, re.next) >= 0)
                )
                  return !1;
                re = re.nextZ;
              }
              for (; J && J.z >= K; ) {
                if (
                  J.x >= O &&
                  J.x <= V &&
                  J.y >= F &&
                  J.y <= G &&
                  J !== h &&
                  J !== _ &&
                  Xu(x, C, E, A, T, L, J.x, J.y) &&
                  ri(J.prev, J, J.next) >= 0
                )
                  return !1;
                J = J.prevZ;
              }
              for (; re && re.z <= oe; ) {
                if (
                  re.x >= O &&
                  re.x <= V &&
                  re.y >= F &&
                  re.y <= G &&
                  re !== h &&
                  re !== _ &&
                  Xu(x, C, E, A, T, L, re.x, re.y) &&
                  ri(re.prev, re, re.next) >= 0
                )
                  return !1;
                re = re.nextZ;
              }
              return !0;
            }
            function h_(r, i, o) {
              var l = r;
              do {
                var h = l.prev,
                  m = l.next.next;
                !Ku(h, m) &&
                  yd(h, l, l.next, m) &&
                  vd(h, m) &&
                  vd(m, h) &&
                  (i.push((h.i / o) | 0),
                  i.push((l.i / o) | 0),
                  i.push((m.i / o) | 0),
                  xd(l),
                  xd(l.next),
                  (l = r = m)),
                  (l = l.next);
              } while (l !== r);
              return il(l);
            }
            function ym(r, i, o, l, h, m) {
              var _ = r;
              do {
                for (var x = _.next.next; x !== _.prev; ) {
                  if (_.i !== x.i && Pv(_, x)) {
                    var E = p_(_, x);
                    return (
                      (_ = il(_, _.next)),
                      (E = il(E, E.next)),
                      Zu(_, i, o, l, h, m, 0),
                      void Zu(E, i, o, l, h, m, 0)
                    );
                  }
                  x = x.next;
                }
                _ = _.next;
              } while (_ !== r);
            }
            function vm(r, i) {
              return r.x - i.x;
            }
            function xm(r, i) {
              var o = (function (h, m) {
                var _,
                  x = m,
                  E = h.x,
                  T = h.y,
                  C = -1 / 0;
                do {
                  if (T <= x.y && T >= x.next.y && x.next.y !== x.y) {
                    var A =
                      x.x + ((T - x.y) * (x.next.x - x.x)) / (x.next.y - x.y);
                    if (
                      A <= E &&
                      A > C &&
                      ((C = A), (_ = x.x < x.next.x ? x : x.next), A === E)
                    )
                      return _;
                  }
                  x = x.next;
                } while (x !== m);
                if (!_) return null;
                var L,
                  O = _,
                  F = _.x,
                  V = _.y,
                  G = 1 / 0;
                x = _;
                do {
                  E >= x.x &&
                    x.x >= F &&
                    E !== x.x &&
                    Xu(T < V ? E : C, T, F, V, T < V ? C : E, T, x.x, x.y) &&
                    ((L = Math.abs(T - x.y) / (E - x.x)),
                    vd(x, h) &&
                      (L < G ||
                        (L === G &&
                          (x.x > _.x || (x.x === _.x && _d(_, x))))) &&
                      ((_ = x), (G = L))),
                    (x = x.next);
                } while (x !== O);
                return _;
              })(r, i);
              if (!o) return i;
              var l = p_(o, r);
              return il(l, l.next), il(o, o.next);
            }
            function _d(r, i) {
              return ri(r.prev, r, i.prev) < 0 && ri(i.next, r, r.next) < 0;
            }
            function bm(r, i, o, l, h) {
              return (
                (r =
                  1431655765 &
                  ((r =
                    858993459 &
                    ((r =
                      252645135 &
                      ((r = 16711935 & ((r = ((r - o) * h) | 0) | (r << 8))) |
                        (r << 4))) |
                      (r << 2))) |
                    (r << 1))) |
                ((i =
                  1431655765 &
                  ((i =
                    858993459 &
                    ((i =
                      252645135 &
                      ((i = 16711935 & ((i = ((i - l) * h) | 0) | (i << 8))) |
                        (i << 4))) |
                      (i << 2))) |
                    (i << 1))) <<
                  1)
              );
            }
            function d_(r) {
              var i = r,
                o = r;
              do {
                (i.x < o.x || (i.x === o.x && i.y < o.y)) && (o = i),
                  (i = i.next);
              } while (i !== r);
              return o;
            }
            function Xu(r, i, o, l, h, m, _, x) {
              return (
                (h - _) * (i - x) >= (r - _) * (m - x) &&
                (r - _) * (l - x) >= (o - _) * (i - x) &&
                (o - _) * (m - x) >= (h - _) * (l - x)
              );
            }
            function Pv(r, i) {
              return (
                r.next.i !== i.i &&
                r.prev.i !== i.i &&
                !(function (o, l) {
                  var h = o;
                  do {
                    if (
                      h.i !== o.i &&
                      h.next.i !== o.i &&
                      h.i !== l.i &&
                      h.next.i !== l.i &&
                      yd(h, h.next, o, l)
                    )
                      return !0;
                    h = h.next;
                  } while (h !== o);
                  return !1;
                })(r, i) &&
                ((vd(r, i) &&
                  vd(i, r) &&
                  (function (o, l) {
                    var h = o,
                      m = !1,
                      _ = (o.x + l.x) / 2,
                      x = (o.y + l.y) / 2;
                    do {
                      h.y > x != h.next.y > x &&
                        h.next.y !== h.y &&
                        _ <
                          ((h.next.x - h.x) * (x - h.y)) / (h.next.y - h.y) +
                            h.x &&
                        (m = !m),
                        (h = h.next);
                    } while (h !== o);
                    return m;
                  })(r, i) &&
                  (ri(r.prev, r, i.prev) || ri(r, i.prev, i))) ||
                  (Ku(r, i) &&
                    ri(r.prev, r, r.next) > 0 &&
                    ri(i.prev, i, i.next) > 0))
              );
            }
            function ri(r, i, o) {
              return (i.y - r.y) * (o.x - i.x) - (i.x - r.x) * (o.y - i.y);
            }
            function Ku(r, i) {
              return r.x === i.x && r.y === i.y;
            }
            function yd(r, i, o, l) {
              var h = ha(ri(r, i, o)),
                m = ha(ri(r, i, l)),
                _ = ha(ri(o, l, r)),
                x = ha(ri(o, l, i));
              return (
                (h !== m && _ !== x) ||
                !(0 !== h || !Yu(r, o, i)) ||
                !(0 !== m || !Yu(r, l, i)) ||
                !(0 !== _ || !Yu(o, r, l)) ||
                !(0 !== x || !Yu(o, i, l))
              );
            }
            function Yu(r, i, o) {
              return (
                i.x <= Math.max(r.x, o.x) &&
                i.x >= Math.min(r.x, o.x) &&
                i.y <= Math.max(r.y, o.y) &&
                i.y >= Math.min(r.y, o.y)
              );
            }
            function ha(r) {
              return r > 0 ? 1 : r < 0 ? -1 : 0;
            }
            function vd(r, i) {
              return ri(r.prev, r, r.next) < 0
                ? ri(r, i, r.next) >= 0 && ri(r, r.prev, i) >= 0
                : ri(r, i, r.prev) < 0 || ri(r, r.next, i) < 0;
            }
            function p_(r, i) {
              var o = new bd(r.i, r.x, r.y),
                l = new bd(i.i, i.x, i.y),
                h = r.next,
                m = i.prev;
              return (
                (r.next = i),
                (i.prev = r),
                (o.next = h),
                (h.prev = o),
                (l.next = o),
                (o.prev = l),
                (m.next = l),
                (l.prev = m),
                l
              );
            }
            function Lv(r, i, o, l) {
              var h = new bd(r, i, o);
              return (
                l
                  ? ((h.next = l.next),
                    (h.prev = l),
                    (l.next.prev = h),
                    (l.next = h))
                  : ((h.prev = h), (h.next = h)),
                h
              );
            }
            function xd(r) {
              (r.next.prev = r.prev),
                (r.prev.next = r.next),
                r.prevZ && (r.prevZ.nextZ = r.nextZ),
                r.nextZ && (r.nextZ.prevZ = r.prevZ);
            }
            function bd(r, i, o) {
              (this.i = r),
                (this.x = i),
                (this.y = o),
                (this.prev = null),
                (this.next = null),
                (this.z = 0),
                (this.prevZ = null),
                (this.nextZ = null),
                (this.steiner = !1);
            }
            function wm(r, i, o, l) {
              for (var h = 0, m = i, _ = o - l; m < o; m += l)
                (h += (r[_] - r[m]) * (r[m + 1] + r[_ + 1])), (_ = m);
              return h;
            }
            (Bp.exports = gd),
              (Bp.exports.default = gd),
              (gd.deviation = function (r, i, o, l) {
                var h = i && i.length,
                  m = Math.abs(wm(r, 0, h ? i[0] * o : r.length, o));
                if (h)
                  for (var _ = 0, x = i.length; _ < x; _++)
                    m -= Math.abs(
                      wm(r, i[_] * o, _ < x - 1 ? i[_ + 1] * o : r.length, o)
                    );
                var E = 0;
                for (_ = 0; _ < l.length; _ += 3) {
                  var T = l[_] * o,
                    C = l[_ + 1] * o,
                    A = l[_ + 2] * o;
                  E += Math.abs(
                    (r[T] - r[A]) * (r[C + 1] - r[T + 1]) -
                      (r[T] - r[C]) * (r[A + 1] - r[T + 1])
                  );
                }
                return 0 === m && 0 === E ? 0 : Math.abs((E - m) / m);
              }),
              (gd.flatten = function (r) {
                for (
                  var i = r[0][0].length,
                    o = { vertices: [], holes: [], dimensions: i },
                    l = 0,
                    h = 0;
                  h < r.length;
                  h++
                ) {
                  for (var m = 0; m < r[h].length; m++)
                    for (var _ = 0; _ < i; _++) o.vertices.push(r[h][m][_]);
                  h > 0 && o.holes.push((l += r[h - 1].length));
                }
                return o;
              });
            var Up = Vr(Bp.exports);
            function $p(r, i, o, l, h) {
              Hp(r, i, o || 0, l || r.length - 1, h || f_);
            }
            function Hp(r, i, o, l, h) {
              for (; l > o; ) {
                if (l - o > 600) {
                  var m = l - o + 1,
                    _ = i - o + 1,
                    x = Math.log(m),
                    E = 0.5 * Math.exp((2 * x) / 3),
                    T =
                      0.5 *
                      Math.sqrt((x * E * (m - E)) / m) *
                      (_ - m / 2 < 0 ? -1 : 1);
                  Hp(
                    r,
                    i,
                    Math.max(o, Math.floor(i - (_ * E) / m + T)),
                    Math.min(l, Math.floor(i + ((m - _) * E) / m + T)),
                    h
                  );
                }
                var C = r[i],
                  A = o,
                  L = l;
                for (Qu(r, o, i), h(r[l], C) > 0 && Qu(r, o, l); A < L; ) {
                  for (Qu(r, A, L), A++, L--; h(r[A], C) < 0; ) A++;
                  for (; h(r[L], C) > 0; ) L--;
                }
                0 === h(r[o], C) ? Qu(r, o, L) : Qu(r, ++L, l),
                  L <= i && (o = L + 1),
                  i <= L && (l = L - 1);
              }
            }
            function Qu(r, i, o) {
              var l = r[i];
              (r[i] = r[o]), (r[o] = l);
            }
            function f_(r, i) {
              return r < i ? -1 : r > i ? 1 : 0;
            }
            function Gp(r, i) {
              const o = r.length;
              if (o <= 1) return [r];
              const l = [];
              let h, m;
              for (let _ = 0; _ < o; _++) {
                const x = lu(r[_]);
                0 !== x &&
                  ((r[_].area = Math.abs(x)),
                  void 0 === m && (m = x < 0),
                  m === x < 0 ? (h && l.push(h), (h = [r[_]])) : h.push(r[_]));
              }
              if ((h && l.push(h), i > 1))
                for (let _ = 0; _ < l.length; _++)
                  l[_].length <= i ||
                    ($p(l[_], i, 1, l[_].length - 1, m_),
                    (l[_] = l[_].slice(0, i)));
              return l;
            }
            function m_(r, i) {
              return i.area - r.area;
            }
            function Em(r, i, o) {
              const l = o.patternDependencies;
              let h = !1;
              for (const m of i) {
                const _ = m.paint.get(`${r}-pattern`);
                _.isConstant() || (h = !0);
                const x = _.constantOr(null);
                x && ((h = !0), (l[x] = !0));
              }
              return h;
            }
            function Tm(r, i, o, l, h) {
              const m = h.patternDependencies;
              for (const _ of i) {
                const x = _.paint.get(`${r}-pattern`).value;
                if ("constant" !== x.kind) {
                  let E = x.evaluate({ zoom: l }, o, {}, h.availableImages);
                  (E = E && E.name ? E.name : E),
                    (m[E] = !0),
                    (o.patterns[_.id] = E);
                }
              }
              return o;
            }
            class qp {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.layoutVertexArray = new Ge()),
                  (this.indexArray = new ft()),
                  (this.indexArray2 = new mi()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.segments = new gi()),
                  (this.segments2 = new gi()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id)),
                  (this.projection = i.projection);
              }
              populate(i, o, l, h) {
                this.hasPattern = Em("fill", this.layers, o);
                const m = this.layers[0].layout.get("fill-sort-key"),
                  _ = [];
                for (const {
                  feature: x,
                  id: E,
                  index: T,
                  sourceLayerIndex: C,
                } of i) {
                  const A = this.layers[0]._featureFilter.needGeometry,
                    L = tl(x, A);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      L,
                      l
                    )
                  )
                    continue;
                  const O = m
                      ? m.evaluate(L, {}, l, o.availableImages)
                      : void 0,
                    F = {
                      id: E,
                      properties: x.properties,
                      type: x.type,
                      sourceLayerIndex: C,
                      index: T,
                      geometry: A ? L.geometry : el(x, l, h),
                      patterns: {},
                      sortKey: O,
                    };
                  _.push(F);
                }
                m && _.sort((x, E) => x.sortKey - E.sortKey);
                for (const x of _) {
                  const { geometry: E, index: T, sourceLayerIndex: C } = x;
                  if (this.hasPattern) {
                    const A = Tm("fill", this.layers, x, this.zoom, o);
                    this.patternFeatures.push(A);
                  } else this.addFeature(x, E, T, l, {}, o.availableImages);
                  o.featureIndex.insert(i[T].feature, E, T, C, this.index);
                }
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              addFeatures(i, o, l, h, m) {
                for (const _ of this.patternFeatures)
                  this.addFeature(_, _.geometry, _.index, o, l, h);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    Av
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  (this.indexBuffer2 = i.createIndexBuffer(this.indexArray2))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.indexBuffer2.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.segments2.destroy());
              }
              addFeature(i, o, l, h, m, _ = []) {
                for (const x of Gp(o, 500)) {
                  let E = 0;
                  for (const F of x) E += F.length;
                  const T = this.segments.prepareSegment(
                      E,
                      this.layoutVertexArray,
                      this.indexArray
                    ),
                    C = T.vertexLength,
                    A = [],
                    L = [];
                  for (const F of x) {
                    if (0 === F.length) continue;
                    F !== x[0] && L.push(A.length / 2);
                    const V = this.segments2.prepareSegment(
                        F.length,
                        this.layoutVertexArray,
                        this.indexArray2
                      ),
                      G = V.vertexLength;
                    this.layoutVertexArray.emplaceBack(F[0].x, F[0].y),
                      this.indexArray2.emplaceBack(G + F.length - 1, G),
                      A.push(F[0].x),
                      A.push(F[0].y);
                    for (let K = 1; K < F.length; K++)
                      this.layoutVertexArray.emplaceBack(F[K].x, F[K].y),
                        this.indexArray2.emplaceBack(G + K - 1, G + K),
                        A.push(F[K].x),
                        A.push(F[K].y);
                    (V.vertexLength += F.length),
                      (V.primitiveLength += F.length);
                  }
                  const O = Up(A, L);
                  for (let F = 0; F < O.length; F += 3)
                    this.indexArray.emplaceBack(
                      C + O[F],
                      C + O[F + 1],
                      C + O[F + 2]
                    );
                  (T.vertexLength += E), (T.primitiveLength += O.length / 3);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  m,
                  _,
                  h
                );
              }
            }
            st(qp, "FillBucket", { omit: ["layers", "patternFeatures"] });
            const kv = new te({
              "fill-sort-key": new W(Ae.layout_fill["fill-sort-key"]),
            });
            var Rv = {
              paint: new te({
                "fill-antialias": new B(Ae.paint_fill["fill-antialias"]),
                "fill-opacity": new W(Ae.paint_fill["fill-opacity"]),
                "fill-color": new W(Ae.paint_fill["fill-color"]),
                "fill-outline-color": new W(
                  Ae.paint_fill["fill-outline-color"]
                ),
                "fill-translate": new B(Ae.paint_fill["fill-translate"]),
                "fill-translate-anchor": new B(
                  Ae.paint_fill["fill-translate-anchor"]
                ),
                "fill-pattern": new W(Ae.paint_fill["fill-pattern"]),
              }),
              layout: kv,
            };
            const ql = ge([
                { name: "a_pos_normal_ed", components: 4, type: "Int16" },
              ]),
              wd = ge([
                { name: "a_centroid_pos", components: 2, type: "Uint16" },
              ]),
              Ov = ge([
                { name: "a_pos_3", components: 3, type: "Int16" },
                { name: "a_pos_normal_3", components: 3, type: "Int16" },
              ]),
              { members: wb } = ql;
            var Dm = {},
              Eb = is,
              Fv = Ed;
            function Ed(r, i, o, l, h) {
              (this.properties = {}),
                (this.extent = o),
                (this.type = 0),
                (this._pbf = r),
                (this._geometry = -1),
                (this._keys = l),
                (this._values = h),
                r.readFields(g_, this, i);
            }
            function g_(r, i, o) {
              1 == r
                ? (i.id = o.readVarint())
                : 2 == r
                ? (function (l, h) {
                    for (var m = l.readVarint() + l.pos; l.pos < m; ) {
                      var _ = h._keys[l.readVarint()],
                        x = h._values[l.readVarint()];
                      h.properties[_] = x;
                    }
                  })(o, i)
                : 3 == r
                ? (i.type = o.readVarint())
                : 4 == r && (i._geometry = o.pos);
            }
            function Nv(r) {
              for (
                var i, o, l = 0, h = 0, m = r.length, _ = m - 1;
                h < m;
                _ = h++
              )
                l += ((o = r[_]).x - (i = r[h]).x) * (i.y + o.y);
              return l;
            }
            (Ed.types = ["Unknown", "Point", "LineString", "Polygon"]),
              (Ed.prototype.loadGeometry = function () {
                var r = this._pbf;
                r.pos = this._geometry;
                for (
                  var i,
                    o = r.readVarint() + r.pos,
                    l = 1,
                    h = 0,
                    m = 0,
                    _ = 0,
                    x = [];
                  r.pos < o;

                ) {
                  if (h <= 0) {
                    var E = r.readVarint();
                    (l = 7 & E), (h = E >> 3);
                  }
                  if ((h--, 1 === l || 2 === l))
                    (m += r.readSVarint()),
                      (_ += r.readSVarint()),
                      1 === l && (i && x.push(i), (i = [])),
                      i.push(new Eb(m, _));
                  else {
                    if (7 !== l) throw new Error("unknown command " + l);
                    i && i.push(i[0].clone());
                  }
                }
                return i && x.push(i), x;
              }),
              (Ed.prototype.bbox = function () {
                var r = this._pbf;
                r.pos = this._geometry;
                for (
                  var i = r.readVarint() + r.pos,
                    o = 1,
                    l = 0,
                    h = 0,
                    m = 0,
                    _ = 1 / 0,
                    x = -1 / 0,
                    E = 1 / 0,
                    T = -1 / 0;
                  r.pos < i;

                ) {
                  if (l <= 0) {
                    var C = r.readVarint();
                    (o = 7 & C), (l = C >> 3);
                  }
                  if ((l--, 1 === o || 2 === o))
                    (h += r.readSVarint()) < _ && (_ = h),
                      h > x && (x = h),
                      (m += r.readSVarint()) < E && (E = m),
                      m > T && (T = m);
                  else if (7 !== o) throw new Error("unknown command " + o);
                }
                return [_, E, x, T];
              }),
              (Ed.prototype.toGeoJSON = function (r, i, o) {
                var l,
                  h,
                  m = this.extent * Math.pow(2, o),
                  _ = this.extent * r,
                  x = this.extent * i,
                  E = this.loadGeometry(),
                  T = Ed.types[this.type];
                function C(O) {
                  for (var F = 0; F < O.length; F++) {
                    var V = O[F];
                    O[F] = [
                      (360 * (V.x + _)) / m - 180,
                      (360 / Math.PI) *
                        Math.atan(
                          Math.exp(
                            ((180 - (360 * (V.y + x)) / m) * Math.PI) / 180
                          )
                        ) -
                        90,
                    ];
                  }
                }
                switch (this.type) {
                  case 1:
                    var A = [];
                    for (l = 0; l < E.length; l++) A[l] = E[l][0];
                    C((E = A));
                    break;
                  case 2:
                    for (l = 0; l < E.length; l++) C(E[l]);
                    break;
                  case 3:
                    for (
                      E = (function (O) {
                        var F = O.length;
                        if (F <= 1) return [O];
                        for (var V, G, K = [], oe = 0; oe < F; oe++) {
                          var J = Nv(O[oe]);
                          0 !== J &&
                            (void 0 === G && (G = J < 0),
                            G === J < 0
                              ? (V && K.push(V), (V = [O[oe]]))
                              : V.push(O[oe]));
                        }
                        return V && K.push(V), K;
                      })(E),
                        l = 0;
                      l < E.length;
                      l++
                    )
                      for (h = 0; h < E[l].length; h++) C(E[l][h]);
                }
                1 === E.length ? (E = E[0]) : (T = "Multi" + T);
                var L = {
                  type: "Feature",
                  geometry: { type: T, coordinates: E },
                  properties: this.properties,
                };
                return "id" in this && (L.id = this.id), L;
              });
            var zv = Fv,
              __ = y_;
            function y_(r, i) {
              (this.version = 1),
                (this.name = null),
                (this.extent = 4096),
                (this.length = 0),
                (this._pbf = r),
                (this._keys = []),
                (this._values = []),
                (this._features = []),
                r.readFields(Sm, this, i),
                (this.length = this._features.length);
            }
            function Sm(r, i, o) {
              15 === r
                ? (i.version = o.readVarint())
                : 1 === r
                ? (i.name = o.readString())
                : 5 === r
                ? (i.extent = o.readVarint())
                : 2 === r
                ? i._features.push(o.pos)
                : 3 === r
                ? i._keys.push(o.readString())
                : 4 === r &&
                  i._values.push(
                    (function (l) {
                      for (
                        var h = null, m = l.readVarint() + l.pos;
                        l.pos < m;

                      ) {
                        var _ = l.readVarint() >> 3;
                        h =
                          1 === _
                            ? l.readString()
                            : 2 === _
                            ? l.readFloat()
                            : 3 === _
                            ? l.readDouble()
                            : 4 === _
                            ? l.readVarint64()
                            : 5 === _
                            ? l.readVarint()
                            : 6 === _
                            ? l.readSVarint()
                            : 7 === _
                            ? l.readBoolean()
                            : null;
                      }
                      return h;
                    })(o)
                  );
            }
            y_.prototype.feature = function (r) {
              if (r < 0 || r >= this._features.length)
                throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[r];
              var i = this._pbf.readVarint() + this._pbf.pos;
              return new zv(
                this._pbf,
                i,
                this.extent,
                this._keys,
                this._values
              );
            };
            var rl = __;
            function Td(r, i, o) {
              if (3 === r) {
                var l = new rl(o, o.readVarint() + o.pos);
                l.length && (i[l.name] = l);
              }
            }
            var Wp = (Dm.VectorTile = function (r, i) {
                this.layers = r.readFields(Td, {}, i);
              }),
              Dd = (Dm.VectorTileFeature = Fv);
            function Sd(r, i, o, l) {
              const h = [],
                m =
                  0 === l
                    ? (_, x, E, T, C, A) => {
                        _.push(new et(A, E + ((A - x) / (T - x)) * (C - E)));
                      }
                    : (_, x, E, T, C, A) => {
                        _.push(new et(x + ((A - E) / (C - E)) * (T - x), A));
                      };
              for (const _ of r) {
                const x = [];
                for (const E of _) {
                  if (E.length <= 2) continue;
                  const T = [];
                  for (let L = 0; L < E.length - 1; L++) {
                    const O = E[L].x,
                      F = E[L].y,
                      V = E[L + 1].x,
                      G = E[L + 1].y,
                      K = 0 === l ? O : F,
                      oe = 0 === l ? V : G;
                    K < i
                      ? oe > i && m(T, O, F, V, G, i)
                      : K > o
                      ? oe < o && m(T, O, F, V, G, o)
                      : T.push(E[L]),
                      oe < i && K >= i && m(T, O, F, V, G, i),
                      oe > o && K <= o && m(T, O, F, V, G, o);
                  }
                  let C = E[E.length - 1];
                  const A = 0 === l ? C.x : C.y;
                  A >= i && A <= o && T.push(C),
                    T.length &&
                      ((C = T[T.length - 1]),
                      (T[0].x === C.x && T[0].y === C.y) || T.push(T[0]),
                      x.push(T));
                }
                x.length && h.push(x);
              }
              return h;
            }
            Dm.VectorTileLayer = __;
            const Tb = Dd.types,
              Db = Math.pow(2, 13);
            function Zp(r, i, o, l, h, m, _, x) {
              r.emplaceBack(
                (i << 1) + _,
                (o << 1) + m,
                (Math.floor(l * Db) << 1) + h,
                Math.round(x)
              );
            }
            function Bc(r, i, o) {
              r.emplaceBack(
                i.x,
                i.y,
                i.z,
                16384 * o[0],
                16384 * o[1],
                16384 * o[2]
              );
            }
            class Xp {
              constructor() {
                (this.acc = new et(0, 0)), (this.polyCount = []);
              }
              startRing(i) {
                (this.currentPolyCount = { edges: 0, top: 0 }),
                  this.polyCount.push(this.currentPolyCount),
                  this.min ||
                    ((this.min = new et(i.x, i.y)),
                    (this.max = new et(i.x, i.y)));
              }
              append(i, o) {
                this.currentPolyCount.edges++, this.acc._add(i);
                const l = this.min,
                  h = this.max;
                i.x < l.x ? (l.x = i.x) : i.x > h.x && (h.x = i.x),
                  i.y < l.y ? (l.y = i.y) : i.y > h.y && (h.y = i.y),
                  ((0 === i.x || i.x === vt) && i.x === o.x) !=
                    ((0 === i.y || i.y === vt) && i.y === o.y) &&
                    this.processBorderOverlap(i, o),
                  o.x < 0 != i.x < 0 &&
                    this.addBorderIntersection(
                      0,
                      rn(o.y, i.y, (0 - o.x) / (i.x - o.x))
                    ),
                  o.x > vt != i.x > vt &&
                    this.addBorderIntersection(
                      1,
                      rn(o.y, i.y, (vt - o.x) / (i.x - o.x))
                    ),
                  o.y < 0 != i.y < 0 &&
                    this.addBorderIntersection(
                      2,
                      rn(o.x, i.x, (0 - o.y) / (i.y - o.y))
                    ),
                  o.y > vt != i.y > vt &&
                    this.addBorderIntersection(
                      3,
                      rn(o.x, i.x, (vt - o.y) / (i.y - o.y))
                    );
              }
              addBorderIntersection(i, o) {
                this.borders ||
                  (this.borders = [
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                  ]);
                const l = this.borders[i];
                o < l[0] && (l[0] = o), o > l[1] && (l[1] = o);
              }
              processBorderOverlap(i, o) {
                if (i.x === o.x) {
                  if (i.y === o.y) return;
                  const l = 0 === i.x ? 0 : 1;
                  this.addBorderIntersection(l, o.y),
                    this.addBorderIntersection(l, i.y);
                } else {
                  const l = 0 === i.y ? 2 : 3;
                  this.addBorderIntersection(l, o.x),
                    this.addBorderIntersection(l, i.x);
                }
              }
              centroid() {
                const i = this.polyCount.reduce((o, l) => o + l.edges, 0);
                return 0 !== i ? this.acc.div(i)._round() : new et(0, 0);
              }
              span() {
                return new et(this.max.x - this.min.x, this.max.y - this.min.y);
              }
              intersectsCount() {
                return this.borders.reduce(
                  (i, o) => i + +(o[0] !== Number.MAX_VALUE),
                  0
                );
              }
            }
            class Kp {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.canonical = i.canonical),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.hasPattern = !1),
                  (this.edgeRadius = 0),
                  (this.projection = i.projection),
                  (this.layoutVertexArray = new Le()),
                  (this.centroidVertexArray = new Or()),
                  (this.indexArray = new ft()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.segments = new gi()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id)),
                  (this.enableTerrain = i.enableTerrain);
              }
              populate(i, o, l, h) {
                (this.features = []),
                  (this.hasPattern = Em("fill-extrusion", this.layers, o)),
                  (this.featuresOnBorder = []),
                  (this.borders = [[], [], [], []]),
                  (this.borderDoneWithNeighborZ = [-1, -1, -1, -1]),
                  (this.tileToMeter = (function (m) {
                    const _ = Math.exp(Math.PI * (1 - (m.y / (1 << m.z)) * 2));
                    return (80150034 * _) / (_ * _ + 1) / vt / (1 << m.z);
                  })(l)),
                  (this.edgeRadius =
                    this.layers[0].layout.get("fill-extrusion-edge-radius") /
                    this.tileToMeter);
                for (const {
                  feature: m,
                  id: _,
                  index: x,
                  sourceLayerIndex: E,
                } of i) {
                  const T = this.layers[0]._featureFilter.needGeometry,
                    C = tl(m, T);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      C,
                      l
                    )
                  )
                    continue;
                  const A = {
                      id: _,
                      sourceLayerIndex: E,
                      index: x,
                      geometry: T ? C.geometry : el(m, l, h),
                      properties: m.properties,
                      type: m.type,
                      patterns: {},
                    },
                    L = this.layoutVertexArray.length;
                  this.hasPattern
                    ? this.features.push(
                        Tm("fill-extrusion", this.layers, A, this.zoom, o)
                      )
                    : this.addFeature(
                        A,
                        A.geometry,
                        x,
                        l,
                        {},
                        o.availableImages,
                        h
                      ),
                    o.featureIndex.insert(m, A.geometry, x, E, this.index, L);
                }
                this.sortBorders();
              }
              addFeatures(i, o, l, h, m) {
                for (const _ of this.features) {
                  const { geometry: x } = _;
                  this.addFeature(_, x, _.index, o, l, h, m);
                }
                this.sortBorders();
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  ((this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    wb
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  this.layoutVertexExtArray &&
                    (this.layoutVertexExtBuffer = i.createVertexBuffer(
                      this.layoutVertexExtArray,
                      Ov.members,
                      !0
                    ))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              uploadCentroid(i) {
                0 !== this.centroidVertexArray.length &&
                  (this.centroidVertexBuffer
                    ? this.needsCentroidUpdate &&
                      this.centroidVertexBuffer.updateData(
                        this.centroidVertexArray
                      )
                    : (this.centroidVertexBuffer = i.createVertexBuffer(
                        this.centroidVertexArray,
                        wd.members,
                        !0
                      )),
                  (this.needsCentroidUpdate = !1));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.centroidVertexBuffer &&
                    this.centroidVertexBuffer.destroy(),
                  this.layoutVertexExtBuffer &&
                    this.layoutVertexExtBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              addFeature(i, o, l, h, m, _, x) {
                const E = [new et(0, 0), new et(vt, vt)],
                  T = x.projection,
                  C = "globe" === T.name,
                  A = this.enableTerrain && !C ? new Xp() : null,
                  L = "Polygon" === Tb[i.type];
                C &&
                  !this.layoutVertexExtArray &&
                  (this.layoutVertexExtArray = new He());
                const O = Gp(o, 500);
                for (let K = O.length - 1; K >= 0; K--) {
                  const oe = O[K];
                  (0 === oe.length ||
                    (F = oe[0]).every((J) => J.x <= 0) ||
                    F.every((J) => J.x >= vt) ||
                    F.every((J) => J.y <= 0) ||
                    F.every((J) => J.y >= vt)) &&
                    O.splice(K, 1);
                }
                var F;
                let V;
                if (C) V = Id(O, E, h);
                else {
                  V = [];
                  for (const K of O) V.push({ polygon: K, bounds: E });
                }
                const G = L ? this.edgeRadius : 0;
                for (const { polygon: K, bounds: oe } of V) {
                  let J = 0,
                    re = 0;
                  for (const ae of K)
                    L && !ae[0].equals(ae[ae.length - 1]) && ae.push(ae[0]),
                      (re += L ? ae.length - 1 : ae.length);
                  const le = this.segments.prepareSegment(
                    (L ? 5 : 4) * re,
                    this.layoutVertexArray,
                    this.indexArray
                  );
                  if (L) {
                    const ae = [],
                      De = [];
                    J = le.vertexLength;
                    for (const Pe of K) {
                      let $e, Ce;
                      Pe.length && Pe !== K[0] && De.push(ae.length / 2),
                        ($e = Pe[1].sub(Pe[0])._perp()._unit());
                      for (let Fe = 1; Fe < Pe.length; Fe++) {
                        const Re = Pe[Fe],
                          Ve = Pe[Fe === Pe.length - 1 ? 1 : Fe + 1];
                        let { x: qe, y: Me } = Re;
                        if (G) {
                          Ce = Ve.sub(Re)._perp()._unit();
                          const Je = $e.add(Ce)._unit(),
                            ut =
                              G * Math.min(4, 1 / ($e.x * Je.x + $e.y * Je.y));
                          (qe += ut * Je.x), (Me += ut * Je.y), ($e = Ce);
                        }
                        Zp(this.layoutVertexArray, qe, Me, 0, 0, 1, 1, 0),
                          le.vertexLength++,
                          ae.push(Re.x, Re.y),
                          C &&
                            Bc(
                              this.layoutVertexExtArray,
                              T.projectTilePoint(qe, Me, h),
                              T.upVector(h, qe, Me)
                            );
                      }
                    }
                    const xe = Up(ae, De);
                    for (let Pe = 0; Pe < xe.length; Pe += 3)
                      this.indexArray.emplaceBack(
                        J + xe[Pe],
                        J + xe[Pe + 2],
                        J + xe[Pe + 1]
                      ),
                        le.primitiveLength++;
                  }
                  for (const ae of K) {
                    A && ae.length && A.startRing(ae[0]);
                    let De,
                      xe,
                      Pe,
                      $e = ae.length > 4 && w_(ae[ae.length - 2], ae[0], ae[1]),
                      Ce = G ? v_(ae[ae.length - 2], ae[0], ae[1], G) : 0;
                    xe = ae[1].sub(ae[0])._perp()._unit();
                    let Fe = !0;
                    for (let Re = 1, Ve = 0; Re < ae.length; Re++) {
                      let qe = ae[Re - 1],
                        Me = ae[Re];
                      const Je = ae[Re === ae.length - 1 ? 1 : Re + 1];
                      if (
                        (A && L && A.currentPolyCount.top++, b_(Me, qe, oe))
                      ) {
                        G && ((xe = Je.sub(Me)._perp()._unit()), (Fe = !Fe));
                        continue;
                      }
                      A && A.append(Me, qe);
                      const ut = Me.sub(qe)._perp(),
                        nt = ut.x / (Math.abs(ut.x) + Math.abs(ut.y)),
                        Mt = ut.y > 0 ? 1 : 0,
                        Ke = qe.dist(Me);
                      if ((Ve + Ke > 32768 && (Ve = 0), G)) {
                        Pe = Je.sub(Me)._perp()._unit();
                        let It = x_(qe, Me, Je, Bv(xe, Pe), G);
                        isNaN(It) && (It = 0);
                        const xt = Me.sub(qe)._unit();
                        (qe = qe.add(xt.mult(Ce))._round()),
                          (Me = Me.add(xt.mult(-It))._round()),
                          (Ce = It),
                          (xe = Pe);
                      }
                      const yt = le.vertexLength,
                        Ct = ae.length > 4 && w_(qe, Me, Je);
                      let Zt = E_(Ve, $e, Fe);
                      if (
                        (Zp(
                          this.layoutVertexArray,
                          qe.x,
                          qe.y,
                          nt,
                          Mt,
                          0,
                          0,
                          Zt
                        ),
                        Zp(
                          this.layoutVertexArray,
                          qe.x,
                          qe.y,
                          nt,
                          Mt,
                          0,
                          1,
                          Zt
                        ),
                        (Ve += Ke),
                        (Zt = E_(Ve, Ct, !Fe)),
                        ($e = Ct),
                        Zp(
                          this.layoutVertexArray,
                          Me.x,
                          Me.y,
                          nt,
                          Mt,
                          0,
                          0,
                          Zt
                        ),
                        Zp(
                          this.layoutVertexArray,
                          Me.x,
                          Me.y,
                          nt,
                          Mt,
                          0,
                          1,
                          Zt
                        ),
                        (le.vertexLength += 4),
                        this.indexArray.emplaceBack(yt + 0, yt + 1, yt + 2),
                        this.indexArray.emplaceBack(yt + 1, yt + 3, yt + 2),
                        (le.primitiveLength += 2),
                        G)
                      ) {
                        const It = J + (1 === Re ? ae.length - 2 : Re - 2),
                          xt = 1 === Re ? J : It + 1;
                        if (
                          (this.indexArray.emplaceBack(yt + 1, It, yt + 3),
                          this.indexArray.emplaceBack(It, xt, yt + 3),
                          (le.primitiveLength += 2),
                          void 0 === De && (De = yt),
                          !b_(Je, ae[Re], oe))
                        ) {
                          const Dn =
                            Re === ae.length - 1 ? De : le.vertexLength;
                          this.indexArray.emplaceBack(yt + 2, yt + 3, Dn),
                            this.indexArray.emplaceBack(yt + 3, Dn + 1, Dn),
                            this.indexArray.emplaceBack(yt + 3, xt, Dn + 1),
                            (le.primitiveLength += 3);
                        }
                        Fe = !Fe;
                      }
                      if (C) {
                        const It = this.layoutVertexExtArray,
                          xt = T.projectTilePoint(qe.x, qe.y, h),
                          Dn = T.projectTilePoint(Me.x, Me.y, h),
                          Rt = T.upVector(h, qe.x, qe.y),
                          At = T.upVector(h, Me.x, Me.y);
                        Bc(It, xt, Rt),
                          Bc(It, xt, Rt),
                          Bc(It, Dn, At),
                          Bc(It, Dn, At);
                      }
                    }
                    L && (J += ae.length - 1);
                  }
                }
                if (A && A.polyCount.length > 0) {
                  if (A.borders) {
                    A.vertexArrayOffset = this.centroidVertexArray.length;
                    const K = A.borders,
                      oe = this.featuresOnBorder.push(A) - 1;
                    for (let J = 0; J < 4; J++)
                      K[J][0] !== Number.MAX_VALUE && this.borders[J].push(oe);
                  }
                  this.encodeCentroid(A.borders ? void 0 : A.centroid(), A);
                }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  m,
                  _,
                  h
                );
              }
              sortBorders() {
                for (let i = 0; i < 4; i++)
                  this.borders[i].sort(
                    (o, l) =>
                      this.featuresOnBorder[o].borders[i][0] -
                      this.featuresOnBorder[l].borders[i][0]
                  );
              }
              encodeCentroid(i, o, l = !0) {
                let h, m;
                if (i)
                  if (0 !== i.y) {
                    const x = o.span()._mult(this.tileToMeter);
                    (h =
                      (Math.max(i.x, 1) << 3) +
                      Math.min(7, Math.round(x.x / 10))),
                      (m =
                        (Math.max(i.y, 1) << 3) +
                        Math.min(7, Math.round(x.y / 10)));
                  } else (h = Math.ceil(7 * (i.x + 450))), (m = 0);
                else (h = 0), (m = +l);
                let _ = l
                  ? this.centroidVertexArray.length
                  : o.vertexArrayOffset;
                for (const x of o.polyCount) {
                  l &&
                    this.centroidVertexArray.resize(
                      this.centroidVertexArray.length + 4 * x.edges + x.top
                    );
                  for (let E = 0; E < x.top; E++)
                    this.centroidVertexArray.emplace(_++, h, m);
                  for (let E = 0; E < 2 * x.edges; E++)
                    this.centroidVertexArray.emplace(_++, 0, m),
                      this.centroidVertexArray.emplace(_++, h, m);
                }
              }
            }
            function Bv(r, i) {
              const o = r.add(i)._unit();
              return r.x * o.x + r.y * o.y;
            }
            function v_(r, i, o, l) {
              const h = i.sub(r)._perp()._unit(),
                m = o.sub(i)._perp()._unit();
              return x_(r, i, o, Bv(h, m), l);
            }
            function x_(r, i, o, l, h) {
              const m = Math.sqrt(1 - l * l);
              return Math.min(r.dist(i) / 3, i.dist(o) / 3, (h * m) / l);
            }
            function b_(r, i, o) {
              return (
                (r.x < o[0].x && i.x < o[0].x) ||
                (r.x > o[1].x && i.x > o[1].x) ||
                (r.y < o[0].y && i.y < o[0].y) ||
                (r.y > o[1].y && i.y > o[1].y)
              );
            }
            function w_(r, i, o) {
              if (
                r.x < 0 ||
                r.x >= vt ||
                i.x < 0 ||
                i.x >= vt ||
                o.x < 0 ||
                o.x >= vt
              )
                return !1;
              const l = o.sub(i),
                h = l.perp(),
                m = r.sub(i);
              return (
                (l.x * m.x + l.y * m.y) /
                  Math.sqrt((l.x * l.x + l.y * l.y) * (m.x * m.x + m.y * m.y)) >
                  -0.866 && h.x * m.x + h.y * m.y < 0
              );
            }
            function E_(r, i, o) {
              const l = i ? 2 | r : -3 & r;
              return o ? 1 | l : -2 & l;
            }
            function Im() {
              const r = Math.PI / 32,
                i = Math.tan(r),
                o = pd;
              return o * Math.sqrt(1 + 2 * i * i) - o;
            }
            function Id(r, i, o) {
              const l = 1 << o.z,
                h = so(o.x / l),
                m = so((o.x + 1) / l),
                _ = $i(o.y / l),
                x = $i((o.y + 1) / l);
              return (function (E, T, C, A, L = 0, O) {
                const F = [];
                if (!E.length || !C || !A) return F;
                const V = (ae, De) => {
                    for (const xe of ae) F.push({ polygon: xe, bounds: De });
                  },
                  G = Math.ceil(Math.log2(C)),
                  K = Math.ceil(Math.log2(A)),
                  oe = G - K,
                  J = [];
                for (let ae = 0; ae < Math.abs(oe); ae++)
                  J.push(oe > 0 ? 0 : 1);
                for (let ae = 0; ae < Math.min(G, K); ae++)
                  J.push(0), J.push(1);
                let re = E;
                if (
                  ((re = Sd(re, T[0].y - L, T[1].y + L, 1)),
                  (re = Sd(re, T[0].x - L, T[1].x + L, 0)),
                  !re.length)
                )
                  return F;
                const le = [];
                for (
                  J.length
                    ? le.push({ polygons: re, bounds: T, depth: 0 })
                    : V(re, T);
                  le.length;

                ) {
                  const ae = le.pop(),
                    De = ae.depth,
                    xe = J[De],
                    Pe = ae.bounds[0],
                    $e = ae.bounds[1],
                    Ce = 0 === xe ? Pe.x : Pe.y,
                    Fe = 0 === xe ? $e.x : $e.y,
                    Re = O ? O(xe, Ce, Fe) : 0.5 * (Ce + Fe),
                    Ve = Sd(ae.polygons, Ce - L, Re + L, xe),
                    qe = Sd(ae.polygons, Re - L, Fe + L, xe);
                  if (Ve.length) {
                    const Me = [
                      Pe,
                      new et(0 === xe ? Re : $e.x, 1 === xe ? Re : $e.y),
                    ];
                    J.length > De + 1
                      ? le.push({ polygons: Ve, bounds: Me, depth: De + 1 })
                      : V(Ve, Me);
                  }
                  if (qe.length) {
                    const Me = [
                      new et(0 === xe ? Re : Pe.x, 1 === xe ? Re : Pe.y),
                      $e,
                    ];
                    J.length > De + 1
                      ? le.push({ polygons: qe, bounds: Me, depth: De + 1 })
                      : V(qe, Me);
                  }
                }
                return F;
              })(
                r,
                i,
                Math.ceil((m - h) / 11.25),
                Math.ceil((_ - x) / 11.25),
                1,
                (E, T, C) => {
                  if (0 === E) return 0.5 * (T + C);
                  {
                    const A = $i((o.y + T / vt) / l);
                    return (
                      (ii(0.5 * ($i((o.y + C / vt) / l) + A)) * l - o.y) * vt
                    );
                  }
                }
              );
            }
            st(Kp, "FillExtrusionBucket", { omit: ["layers", "features"] }),
              st(Xp, "PartMetadata");
            const Vv = new te({
              "fill-extrusion-edge-radius": new B(
                Ae["layout_fill-extrusion"]["fill-extrusion-edge-radius"]
              ),
            });
            var Cm = {
              paint: new te({
                "fill-extrusion-opacity": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-opacity"]
                ),
                "fill-extrusion-color": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-color"]
                ),
                "fill-extrusion-translate": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-translate"]
                ),
                "fill-extrusion-translate-anchor": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]
                ),
                "fill-extrusion-pattern": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-pattern"]
                ),
                "fill-extrusion-height": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-height"]
                ),
                "fill-extrusion-base": new W(
                  Ae["paint_fill-extrusion"]["fill-extrusion-base"]
                ),
                "fill-extrusion-vertical-gradient": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]
                ),
                "fill-extrusion-ambient-occlusion-intensity": new B(
                  Ae["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-intensity"
                  ]
                ),
                "fill-extrusion-ambient-occlusion-radius": new B(
                  Ae["paint_fill-extrusion"][
                    "fill-extrusion-ambient-occlusion-radius"
                  ]
                ),
                "fill-extrusion-rounded-roof": new B(
                  Ae["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]
                ),
              }),
              layout: Vv,
            };
            function T_(r, i, o) {
              var l = (2 * Math.PI * 6378137) / 256 / Math.pow(2, o);
              return [
                r * l - (2 * Math.PI * 6378137) / 2,
                i * l - (2 * Math.PI * 6378137) / 2,
              ];
            }
            class _i {
              constructor(i, o, l) {
                (this.z = i),
                  (this.x = o),
                  (this.y = l),
                  (this.key = Ju(0, i, i, o, l));
              }
              equals(i) {
                return this.z === i.z && this.x === i.x && this.y === i.y;
              }
              url(i, o) {
                const l =
                    ((_ = this.y),
                    (x = this.z),
                    (E = T_(
                      256 * (m = this.x),
                      256 * (_ = Math.pow(2, x) - _ - 1),
                      x
                    )),
                    (T = T_(256 * (m + 1), 256 * (_ + 1), x)),
                    E[0] + "," + E[1] + "," + T[0] + "," + T[1]),
                  h = (function (m, _, x) {
                    let E,
                      T = "";
                    for (let C = m; C > 0; C--)
                      (E = 1 << (C - 1)),
                        (T += (_ & E ? 1 : 0) + (x & E ? 2 : 0));
                    return T;
                  })(this.z, this.x, this.y);
                var m, _, x, E, T;
                return i[(this.x + this.y) % i.length]
                  .replace(
                    "{prefix}",
                    (this.x % 16).toString(16) + (this.y % 16).toString(16)
                  )
                  .replace(/{z}/g, String(this.z))
                  .replace(/{x}/g, String(this.x))
                  .replace(
                    /{y}/g,
                    String(
                      "tms" === o ? Math.pow(2, this.z) - this.y - 1 : this.y
                    )
                  )
                  .replace("{quadkey}", h)
                  .replace("{bbox-epsg-3857}", l);
              }
              toString() {
                return `${this.z}/${this.x}/${this.y}`;
              }
            }
            class D_ {
              constructor(i, o) {
                (this.wrap = i),
                  (this.canonical = o),
                  (this.key = Ju(i, o.z, o.z, o.x, o.y));
              }
            }
            class Nr {
              constructor(i, o, l, h, m) {
                (this.overscaledZ = i),
                  (this.wrap = o),
                  (this.canonical = new _i(l, +h, +m)),
                  (this.key =
                    0 === o && i === l
                      ? this.canonical.key
                      : Ju(o, i, l, h, m));
              }
              equals(i) {
                return (
                  this.overscaledZ === i.overscaledZ &&
                  this.wrap === i.wrap &&
                  this.canonical.equals(i.canonical)
                );
              }
              scaledTo(i) {
                const o = this.canonical.z - i;
                return i > this.canonical.z
                  ? new Nr(
                      i,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    )
                  : new Nr(
                      i,
                      this.wrap,
                      i,
                      this.canonical.x >> o,
                      this.canonical.y >> o
                    );
              }
              calculateScaledKey(i, o = !0) {
                if (this.overscaledZ === i && o) return this.key;
                if (i > this.canonical.z)
                  return Ju(
                    this.wrap * +o,
                    i,
                    this.canonical.z,
                    this.canonical.x,
                    this.canonical.y
                  );
                {
                  const l = this.canonical.z - i;
                  return Ju(
                    this.wrap * +o,
                    i,
                    i,
                    this.canonical.x >> l,
                    this.canonical.y >> l
                  );
                }
              }
              isChildOf(i) {
                if (i.wrap !== this.wrap) return !1;
                const o = this.canonical.z - i.canonical.z;
                return (
                  0 === i.overscaledZ ||
                  (i.overscaledZ < this.overscaledZ &&
                    i.canonical.x === this.canonical.x >> o &&
                    i.canonical.y === this.canonical.y >> o)
                );
              }
              children(i) {
                if (this.overscaledZ >= i)
                  return [
                    new Nr(
                      this.overscaledZ + 1,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y
                    ),
                  ];
                const o = this.canonical.z + 1,
                  l = 2 * this.canonical.x,
                  h = 2 * this.canonical.y;
                return [
                  new Nr(o, this.wrap, o, l, h),
                  new Nr(o, this.wrap, o, l + 1, h),
                  new Nr(o, this.wrap, o, l, h + 1),
                  new Nr(o, this.wrap, o, l + 1, h + 1),
                ];
              }
              isLessThan(i) {
                return (
                  this.wrap < i.wrap ||
                  (!(this.wrap > i.wrap) &&
                    (this.overscaledZ < i.overscaledZ ||
                      (!(this.overscaledZ > i.overscaledZ) &&
                        (this.canonical.x < i.canonical.x ||
                          (!(this.canonical.x > i.canonical.x) &&
                            this.canonical.y < i.canonical.y)))))
                );
              }
              wrapped() {
                return new Nr(
                  this.overscaledZ,
                  0,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              unwrapTo(i) {
                return new Nr(
                  this.overscaledZ,
                  i,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y
                );
              }
              overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
              }
              toUnwrapped() {
                return new D_(this.wrap, this.canonical);
              }
              toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
              }
            }
            function Ju(r, i, o, l, h) {
              const m = 1 << Math.min(o, 22);
              let _ = m * (h % m) + (l % m);
              return (
                r &&
                  o < 22 &&
                  (_ +=
                    m *
                    m *
                    ((r < 0 ? -2 * r - 1 : 2 * r) % (1 << (2 * (22 - o))))),
                16 * (32 * _ + o) + (i - o)
              );
            }
            st(_i, "CanonicalTileID"),
              st(Nr, "OverscaledTileID", { omit: ["projMatrix"] });
            class Vc extends et {
              constructor(i, o, l) {
                super(i, o), (this.z = l);
              }
            }
            function Cd(r, i) {
              return r.x * i.x + r.y * i.y;
            }
            function S_(r, i) {
              if (1 === r.length) {
                let o = 0;
                const l = i[o++];
                let h;
                for (; !h || l.equals(h); )
                  if (((h = i[o++]), !h)) return 1 / 0;
                for (; o < i.length; o++) {
                  const m = i[o],
                    _ = r[0],
                    x = h.sub(l),
                    E = m.sub(l),
                    T = _.sub(l),
                    C = Cd(x, x),
                    A = Cd(x, E),
                    L = Cd(E, E),
                    O = Cd(T, x),
                    F = Cd(T, E),
                    V = C * L - A * A,
                    G = (L * O - A * F) / V,
                    K = (C * F - A * O) / V,
                    oe = l.z * (1 - G - K) + h.z * G + m.z * K;
                  if (isFinite(oe)) return oe;
                }
                return 1 / 0;
              }
              {
                let o = 1 / 0;
                for (const l of i) o = Math.min(o, l.z);
                return o;
              }
            }
            function I_(r, i, o, l, h, m, _, x) {
              const E = _ * h.getElevationAt(r, i, !0, !0),
                T = 0 !== m[0],
                C = T
                  ? 0 === m[1]
                    ? _ * (m[0] / 7 - 450)
                    : _ *
                      (function (A, L, O) {
                        const F = Math.floor(L[0] / 8),
                          V = Math.floor(L[1] / 8),
                          G = 10 * (L[0] - 8 * F),
                          K = 10 * (L[1] - 8 * V),
                          oe = A.getElevationAt(F, V, !0, !0),
                          J = A.getMeterToDEM(O),
                          re = Math.floor(0.5 * (G * J - 1)),
                          le = Math.floor(0.5 * (K * J - 1)),
                          ae = A.tileCoordToPixel(F, V),
                          De = 2 * re + 1,
                          xe = 2 * le + 1,
                          Pe =
                            ((ut = De),
                            (nt = xe),
                            [
                              (qe = A).getElevationAtPixel(
                                (Me = ae.x - re),
                                (Je = ae.y - le),
                                !0
                              ),
                              qe.getElevationAtPixel(Me + nt, Je, !0),
                              qe.getElevationAtPixel(Me, Je + nt, !0),
                              qe.getElevationAtPixel(Me + ut, Je + nt, !0),
                            ]),
                          $e = Math.abs(Pe[0] - Pe[1]),
                          Ce = Math.abs(Pe[2] - Pe[3]),
                          Fe =
                            Math.abs(Pe[0] - Pe[2]) + Math.abs(Pe[1] - Pe[3]),
                          Re = Math.min(0.25, (0.5 * J * ($e + Ce)) / De),
                          Ve = Math.min(0.25, (0.5 * J * Fe) / xe);
                        var qe, Me, Je, ut, nt;
                        return oe + Math.max(Re * G, Ve * K);
                      })(h, m, x)
                  : E;
              return {
                base: E + (0 === o) ? -1 : o,
                top: T ? Math.max(C + l, E + o + 2) : E + l,
              };
            }
            const jv = ge(
                [
                  { name: "a_pos_normal", components: 2, type: "Int16" },
                  { name: "a_data", components: 4, type: "Uint8" },
                  { name: "a_linesofar", components: 1, type: "Float32" },
                ],
                4
              ),
              { members: Uv } = jv,
              Sb = ge([{ name: "a_packed", components: 4, type: "Float32" }]),
              { members: Ib } = Sb,
              Md = Dd.types,
              C_ = Math.cos((Math.PI / 180) * 37.5);
            class Ad {
              constructor(i) {
                (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((o) => o.id)),
                  (this.index = i.index),
                  (this.projection = i.projection),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.lineClipsArray = []),
                  (this.gradients = {}),
                  this.layers.forEach((o) => {
                    this.gradients[o.id] = {};
                  }),
                  (this.layoutVertexArray = new Ie()),
                  (this.layoutVertexArray2 = new je()),
                  (this.indexArray = new ft()),
                  (this.programConfigurations = new gs(i.layers, i.zoom)),
                  (this.segments = new gi()),
                  (this.maxLineLength = 0),
                  (this.stateDependentLayerIds = this.layers
                    .filter((o) => o.isStateDependent())
                    .map((o) => o.id));
              }
              populate(i, o, l, h) {
                this.hasPattern = Em("line", this.layers, o);
                const m = this.layers[0].layout.get("line-sort-key"),
                  _ = [];
                for (const {
                  feature: C,
                  id: A,
                  index: L,
                  sourceLayerIndex: O,
                } of i) {
                  const F = this.layers[0]._featureFilter.needGeometry,
                    V = tl(C, F);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new M(this.zoom),
                      V,
                      l
                    )
                  )
                    continue;
                  const G = m ? m.evaluate(V, {}, l) : void 0,
                    K = {
                      id: A,
                      properties: C.properties,
                      type: C.type,
                      sourceLayerIndex: O,
                      index: L,
                      geometry: F ? V.geometry : el(C, l, h),
                      patterns: {},
                      sortKey: G,
                    };
                  _.push(K);
                }
                m && _.sort((C, A) => C.sortKey - A.sortKey);
                const { lineAtlas: x, featureIndex: E } = o,
                  T = this.addConstantDashes(x);
                for (const C of _) {
                  const { geometry: A, index: L, sourceLayerIndex: O } = C;
                  if ((T && this.addFeatureDashes(C, x), this.hasPattern)) {
                    const F = Tm("line", this.layers, C, this.zoom, o);
                    this.patternFeatures.push(F);
                  } else
                    this.addFeature(C, A, L, l, x.positions, o.availableImages);
                  E.insert(i[L].feature, A, L, O, this.index);
                }
              }
              addConstantDashes(i) {
                let o = !1;
                for (const l of this.layers) {
                  const h = l.paint.get("line-dasharray").value,
                    m = l.layout.get("line-cap").value;
                  if ("constant" !== h.kind || "constant" !== m.kind) o = !0;
                  else {
                    const _ = m.value,
                      x = h.value;
                    if (!x) continue;
                    i.addDash(x, _);
                  }
                }
                return o;
              }
              addFeatureDashes(i, o) {
                const l = this.zoom;
                for (const h of this.layers) {
                  const m = h.paint.get("line-dasharray").value,
                    _ = h.layout.get("line-cap").value;
                  if ("constant" === m.kind && "constant" === _.kind) continue;
                  let x, E;
                  if ("constant" === m.kind) {
                    if (((x = m.value), !x)) continue;
                  } else x = m.evaluate({ zoom: l }, i);
                  (E =
                    "constant" === _.kind
                      ? _.value
                      : _.evaluate({ zoom: l }, i)),
                    o.addDash(x, E),
                    (i.patterns[h.id] = o.getKey(x, E));
                }
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  this.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.stateDependentLayers,
                    l,
                    h
                  );
              }
              addFeatures(i, o, l, h, m) {
                for (const _ of this.patternFeatures)
                  this.addFeature(_, _.geometry, _.index, o, l, h);
              }
              isEmpty() {
                return 0 === this.layoutVertexArray.length;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(i) {
                this.uploaded ||
                  (0 !== this.layoutVertexArray2.length &&
                    (this.layoutVertexBuffer2 = i.createVertexBuffer(
                      this.layoutVertexArray2,
                      Ib
                    )),
                  (this.layoutVertexBuffer = i.createVertexBuffer(
                    this.layoutVertexArray,
                    Uv
                  )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(i),
                  (this.uploaded = !0);
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              lineFeatureClips(i) {
                if (
                  i.properties &&
                  i.properties.hasOwnProperty("mapbox_clip_start") &&
                  i.properties.hasOwnProperty("mapbox_clip_end")
                )
                  return {
                    start: +i.properties.mapbox_clip_start,
                    end: +i.properties.mapbox_clip_end,
                  };
              }
              addFeature(i, o, l, h, m, _) {
                const x = this.layers[0].layout,
                  E = x.get("line-join").evaluate(i, {}),
                  T = x.get("line-cap").evaluate(i, {}),
                  C = x.get("line-miter-limit"),
                  A = x.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(i);
                for (const L of o) this.addLine(L, i, E, T, C, A);
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  i,
                  l,
                  m,
                  _,
                  h
                );
              }
              addLine(i, o, l, h, m, _) {
                if (
                  ((this.distance = 0),
                  (this.scaledDistance = 0),
                  (this.totalDistance = 0),
                  (this.lineSoFar = 0),
                  this.lineClips)
                ) {
                  this.lineClipsArray.push(this.lineClips);
                  for (let K = 0; K < i.length - 1; K++)
                    this.totalDistance += i[K].dist(i[K + 1]);
                  this.updateScaledDistance(),
                    (this.maxLineLength = Math.max(
                      this.maxLineLength,
                      this.totalDistance
                    ));
                }
                const x = "Polygon" === Md[o.type];
                let E = i.length;
                for (; E >= 2 && i[E - 1].equals(i[E - 2]); ) E--;
                let T = 0;
                for (; T < E - 1 && i[T].equals(i[T + 1]); ) T++;
                if (E < (x ? 3 : 2)) return;
                "bevel" === l && (m = 1.05);
                const C =
                    this.overscaling <= 16
                      ? (15 * vt) / (512 * this.overscaling)
                      : 0,
                  A = this.segments.prepareSegment(
                    10 * E,
                    this.layoutVertexArray,
                    this.indexArray
                  );
                let L, O, F, V, G;
                (this.e1 = this.e2 = -1),
                  x && ((L = i[E - 2]), (G = i[T].sub(L)._unit()._perp()));
                for (let K = T; K < E; K++) {
                  if (
                    ((F = K === E - 1 ? (x ? i[T + 1] : void 0) : i[K + 1]),
                    F && i[K].equals(F))
                  )
                    continue;
                  G && (V = G),
                    L && (O = L),
                    (L = i[K]),
                    (G = F ? F.sub(L)._unit()._perp() : V),
                    (V = V || G);
                  let oe = V.add(G);
                  (0 === oe.x && 0 === oe.y) || oe._unit();
                  const J = V.x * G.x + V.y * G.y,
                    re = oe.x * G.x + oe.y * G.y,
                    le = 0 !== re ? 1 / re : 1 / 0,
                    ae = 2 * Math.sqrt(2 - 2 * re),
                    De = re < C_ && O && F,
                    xe = V.x * G.y - V.y * G.x > 0;
                  if (De && K > T) {
                    const Ce = L.dist(O);
                    if (Ce > 2 * C) {
                      const Fe = L.sub(
                        L.sub(O)
                          ._mult(C / Ce)
                          ._round()
                      );
                      this.updateDistance(O, Fe),
                        this.addCurrentVertex(Fe, V, 0, 0, A),
                        (O = Fe);
                    }
                  }
                  const Pe = O && F;
                  let $e = Pe ? l : x ? "butt" : h;
                  if (
                    (Pe &&
                      "round" === $e &&
                      (le < _ ? ($e = "miter") : le <= 2 && ($e = "fakeround")),
                    "miter" === $e && le > m && ($e = "bevel"),
                    "bevel" === $e &&
                      (le > 2 && ($e = "flipbevel"), le < m && ($e = "miter")),
                    O && this.updateDistance(O, L),
                    "miter" === $e)
                  )
                    oe._mult(le), this.addCurrentVertex(L, oe, 0, 0, A);
                  else if ("flipbevel" === $e) {
                    if (le > 100) oe = G.mult(-1);
                    else {
                      const Ce = (le * V.add(G).mag()) / V.sub(G).mag();
                      oe._perp()._mult(Ce * (xe ? -1 : 1));
                    }
                    this.addCurrentVertex(L, oe, 0, 0, A),
                      this.addCurrentVertex(L, oe.mult(-1), 0, 0, A);
                  } else if ("bevel" === $e || "fakeround" === $e) {
                    const Ce = -Math.sqrt(le * le - 1),
                      Fe = xe ? Ce : 0,
                      Re = xe ? 0 : Ce;
                    if (
                      (O && this.addCurrentVertex(L, V, Fe, Re, A),
                      "fakeround" === $e)
                    ) {
                      const Ve = Math.round((180 * ae) / Math.PI / 20);
                      for (let qe = 1; qe < Ve; qe++) {
                        let Me = qe / Ve;
                        if (0.5 !== Me) {
                          const ut = Me - 0.5;
                          Me +=
                            Me *
                            ut *
                            (Me - 1) *
                            ((1.0904 +
                              J * (J * (3.55645 - 1.43519 * J) - 3.2452)) *
                              ut *
                              ut +
                              (0.848013 + J * (0.215638 * J - 1.06021)));
                        }
                        const Je = G.sub(V)
                          ._mult(Me)
                          ._add(V)
                          ._unit()
                          ._mult(xe ? -1 : 1);
                        this.addHalfVertex(L, Je.x, Je.y, !1, xe, 0, A);
                      }
                    }
                    F && this.addCurrentVertex(L, G, -Fe, -Re, A);
                  } else if ("butt" === $e)
                    this.addCurrentVertex(L, oe, 0, 0, A);
                  else if ("square" === $e) {
                    const Ce = O ? 1 : -1;
                    O || this.addCurrentVertex(L, oe, Ce, Ce, A),
                      this.addCurrentVertex(L, oe, 0, 0, A),
                      O && this.addCurrentVertex(L, oe, Ce, Ce, A);
                  } else
                    "round" === $e &&
                      (O &&
                        (this.addCurrentVertex(L, V, 0, 0, A),
                        this.addCurrentVertex(L, V, 1, 1, A, !0)),
                      F &&
                        (this.addCurrentVertex(L, G, -1, -1, A, !0),
                        this.addCurrentVertex(L, G, 0, 0, A)));
                  if (De && K < E - 1) {
                    const Ce = L.dist(F);
                    if (Ce > 2 * C) {
                      const Fe = L.add(
                        F.sub(L)
                          ._mult(C / Ce)
                          ._round()
                      );
                      this.updateDistance(L, Fe),
                        this.addCurrentVertex(Fe, G, 0, 0, A),
                        (L = Fe);
                    }
                  }
                }
              }
              addCurrentVertex(i, o, l, h, m, _ = !1) {
                const x = o.y * h - o.x,
                  E = -o.y - o.x * h;
                this.addHalfVertex(
                  i,
                  o.x + o.y * l,
                  o.y - o.x * l,
                  _,
                  !1,
                  l,
                  m
                ),
                  this.addHalfVertex(i, x, E, _, !0, -h, m);
              }
              addHalfVertex({ x: i, y: o }, l, h, m, _, x, E) {
                this.layoutVertexArray.emplaceBack(
                  (i << 1) + (m ? 1 : 0),
                  (o << 1) + (_ ? 1 : 0),
                  Math.round(63 * l) + 128,
                  Math.round(63 * h) + 128,
                  1 + (0 === x ? 0 : x < 0 ? -1 : 1),
                  0,
                  this.lineSoFar
                ),
                  this.lineClips &&
                    this.layoutVertexArray2.emplaceBack(
                      this.scaledDistance,
                      this.lineClipsArray.length,
                      this.lineClips.start,
                      this.lineClips.end
                    );
                const T = E.vertexLength++;
                this.e1 >= 0 &&
                  this.e2 >= 0 &&
                  (this.indexArray.emplaceBack(this.e1, this.e2, T),
                  E.primitiveLength++),
                  _ ? (this.e2 = T) : (this.e1 = T);
              }
              updateScaledDistance() {
                if (this.lineClips) {
                  const i =
                    this.totalDistance /
                    (this.lineClips.end - this.lineClips.start);
                  (this.scaledDistance = this.distance / this.totalDistance),
                    (this.lineSoFar = i * this.lineClips.start + this.distance);
                } else this.lineSoFar = this.distance;
              }
              updateDistance(i, o) {
                (this.distance += i.dist(o)), this.updateScaledDistance();
              }
            }
            st(Ad, "LineBucket", { omit: ["layers", "patternFeatures"] });
            const M_ = new te({
              "line-cap": new W(Ae.layout_line["line-cap"]),
              "line-join": new W(Ae.layout_line["line-join"]),
              "line-miter-limit": new B(Ae.layout_line["line-miter-limit"]),
              "line-round-limit": new B(Ae.layout_line["line-round-limit"]),
              "line-sort-key": new W(Ae.layout_line["line-sort-key"]),
            });
            var Mm = {
              paint: new te({
                "line-opacity": new W(Ae.paint_line["line-opacity"]),
                "line-color": new W(Ae.paint_line["line-color"]),
                "line-translate": new B(Ae.paint_line["line-translate"]),
                "line-translate-anchor": new B(
                  Ae.paint_line["line-translate-anchor"]
                ),
                "line-width": new W(Ae.paint_line["line-width"]),
                "line-gap-width": new W(Ae.paint_line["line-gap-width"]),
                "line-offset": new W(Ae.paint_line["line-offset"]),
                "line-blur": new W(Ae.paint_line["line-blur"]),
                "line-dasharray": new W(Ae.paint_line["line-dasharray"]),
                "line-pattern": new W(Ae.paint_line["line-pattern"]),
                "line-gradient": new ee(Ae.paint_line["line-gradient"]),
                "line-trim-offset": new B(Ae.paint_line["line-trim-offset"]),
              }),
              layout: M_,
            };
            const A_ = new (class extends W {
              possiblyEvaluate(r, i) {
                return (
                  (i = new M(Math.floor(i.zoom), {
                    now: i.now,
                    fadeDuration: i.fadeDuration,
                    transition: i.transition,
                  })),
                  super.possiblyEvaluate(r, i)
                );
              }
              evaluate(r, i, o, l) {
                return (
                  (i = ci({}, i, { zoom: Math.floor(i.zoom) })),
                  super.evaluate(r, i, o, l)
                );
              }
            })(Mm.paint.properties["line-width"].specification);
            function Am(r, i) {
              return i > 0 ? i + 2 * r : r;
            }
            A_.useIntegerZoom = !0;
            const P_ = ge(
                [
                  { name: "a_pos_offset", components: 4, type: "Int16" },
                  { name: "a_tex_size", components: 4, type: "Uint16" },
                  { name: "a_pixeloffset", components: 4, type: "Int16" },
                ],
                4
              ),
              Pm = ge(
                [
                  { name: "a_globe_anchor", components: 3, type: "Int16" },
                  { name: "a_globe_normal", components: 3, type: "Float32" },
                ],
                4
              ),
              Cb = ge(
                [{ name: "a_projected_pos", components: 4, type: "Float32" }],
                4
              );
            ge([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
            const $v = ge([
                { name: "a_placed", components: 2, type: "Uint8" },
                { name: "a_shift", components: 2, type: "Float32" },
              ]),
              Lm = ge([
                { name: "a_size_scale", components: 1, type: "Float32" },
                { name: "a_padding", components: 2, type: "Float32" },
              ]);
            ge([
              { type: "Int16", name: "projectedAnchorX" },
              { type: "Int16", name: "projectedAnchorY" },
              { type: "Int16", name: "projectedAnchorZ" },
              { type: "Int16", name: "tileAnchorX" },
              { type: "Int16", name: "tileAnchorY" },
              { type: "Float32", name: "x1" },
              { type: "Float32", name: "y1" },
              { type: "Float32", name: "x2" },
              { type: "Float32", name: "y2" },
              { type: "Int16", name: "padding" },
              { type: "Uint32", name: "featureIndex" },
              { type: "Uint16", name: "sourceLayerIndex" },
              { type: "Uint16", name: "bucketIndex" },
            ]);
            const km = ge(
                [
                  { name: "a_pos", components: 3, type: "Int16" },
                  { name: "a_anchor_pos", components: 2, type: "Int16" },
                  { name: "a_extrude", components: 2, type: "Int16" },
                ],
                4
              ),
              L_ = ge(
                [
                  { name: "a_pos_2f", components: 2, type: "Float32" },
                  { name: "a_radius", components: 1, type: "Float32" },
                  { name: "a_flags", components: 2, type: "Int16" },
                ],
                4
              );
            ge([{ name: "triangle", components: 3, type: "Uint16" }]),
              ge([
                { type: "Int16", name: "projectedAnchorX" },
                { type: "Int16", name: "projectedAnchorY" },
                { type: "Int16", name: "projectedAnchorZ" },
                { type: "Float32", name: "tileAnchorX" },
                { type: "Float32", name: "tileAnchorY" },
                { type: "Uint16", name: "glyphStartIndex" },
                { type: "Uint16", name: "numGlyphs" },
                { type: "Uint32", name: "vertexStartIndex" },
                { type: "Uint32", name: "lineStartIndex" },
                { type: "Uint32", name: "lineLength" },
                { type: "Uint16", name: "segment" },
                { type: "Uint16", name: "lowerSize" },
                { type: "Uint16", name: "upperSize" },
                { type: "Float32", name: "lineOffsetX" },
                { type: "Float32", name: "lineOffsetY" },
                { type: "Uint8", name: "writingMode" },
                { type: "Uint8", name: "placedOrientation" },
                { type: "Uint8", name: "hidden" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Int16", name: "associatedIconIndex" },
                { type: "Uint8", name: "flipState" },
              ]),
              ge([
                { type: "Int16", name: "projectedAnchorX" },
                { type: "Int16", name: "projectedAnchorY" },
                { type: "Int16", name: "projectedAnchorZ" },
                { type: "Float32", name: "tileAnchorX" },
                { type: "Float32", name: "tileAnchorY" },
                { type: "Int16", name: "rightJustifiedTextSymbolIndex" },
                { type: "Int16", name: "centerJustifiedTextSymbolIndex" },
                { type: "Int16", name: "leftJustifiedTextSymbolIndex" },
                { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
                { type: "Int16", name: "placedIconSymbolIndex" },
                { type: "Int16", name: "verticalPlacedIconSymbolIndex" },
                { type: "Uint16", name: "key" },
                { type: "Uint16", name: "textBoxStartIndex" },
                { type: "Uint16", name: "textBoxEndIndex" },
                { type: "Uint16", name: "verticalTextBoxStartIndex" },
                { type: "Uint16", name: "verticalTextBoxEndIndex" },
                { type: "Uint16", name: "iconBoxStartIndex" },
                { type: "Uint16", name: "iconBoxEndIndex" },
                { type: "Uint16", name: "verticalIconBoxStartIndex" },
                { type: "Uint16", name: "verticalIconBoxEndIndex" },
                { type: "Uint16", name: "featureIndex" },
                { type: "Uint16", name: "numHorizontalGlyphVertices" },
                { type: "Uint16", name: "numVerticalGlyphVertices" },
                { type: "Uint16", name: "numIconVertices" },
                { type: "Uint16", name: "numVerticalIconVertices" },
                { type: "Uint16", name: "useRuntimeCollisionCircles" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Float32", components: 2, name: "textOffset" },
                { type: "Float32", name: "collisionCircleDiameter" },
              ]),
              ge([{ type: "Float32", name: "offsetX" }]),
              ge([
                { type: "Int16", name: "x" },
                { type: "Int16", name: "y" },
              ]);
            const ys = 128;
            function Pd(r, i) {
              const { expression: o } = i;
              if ("constant" === o.kind)
                return {
                  kind: "constant",
                  layoutSize: o.evaluate(new M(r + 1)),
                };
              if ("source" === o.kind) return { kind: "source" };
              {
                const { zoomStops: l, interpolationType: h } = o;
                let m = 0;
                for (; m < l.length && l[m] <= r; ) m++;
                m = Math.max(0, m - 1);
                let _ = m;
                for (; _ < l.length && l[_] < r + 1; ) _++;
                _ = Math.min(l.length - 1, _);
                const x = l[m],
                  E = l[_];
                return "composite" === o.kind
                  ? {
                      kind: "composite",
                      minZoom: x,
                      maxZoom: E,
                      interpolationType: h,
                    }
                  : {
                      kind: "camera",
                      minZoom: x,
                      maxZoom: E,
                      minSize: o.evaluate(new M(x)),
                      maxSize: o.evaluate(new M(E)),
                      interpolationType: h,
                    };
              }
            }
            function jc(
              r,
              { uSize: i, uSizeT: o },
              { lowerSize: l, upperSize: h }
            ) {
              return "source" === r.kind
                ? l / ys
                : "composite" === r.kind
                ? rn(l / ys, h / ys, o)
                : i;
            }
            function eh(r, i) {
              let o = 0,
                l = 0;
              if ("constant" === r.kind) l = r.layoutSize;
              else if ("source" !== r.kind) {
                const { interpolationType: h, minZoom: m, maxZoom: _ } = r,
                  x = h ? Qt(oo.interpolationFactor(h, i, m, _), 0, 1) : 0;
                "camera" === r.kind
                  ? (l = rn(r.minSize, r.maxSize, x))
                  : (o = x);
              }
              return { uSizeT: o, uSize: l };
            }
            var Rm = Object.freeze({
              __proto__: null,
              SIZE_PACK_FACTOR: ys,
              evaluateSizeForFeature: jc,
              evaluateSizeForZoom: eh,
              getSizeData: Pd,
            });
            function Yp(r, i, o) {
              return (
                r.sections.forEach((l) => {
                  l.text = (function (h, m, _) {
                    const x = m.layout.get("text-transform").evaluate(_, {});
                    return (
                      "uppercase" === x
                        ? (h = h.toLocaleUpperCase())
                        : "lowercase" === x && (h = h.toLocaleLowerCase()),
                      I.applyArabicShaping && (h = I.applyArabicShaping(h)),
                      h
                    );
                  })(l.text, i, o);
                }),
                r
              );
            }
            const da = {
              "!": "\ufe15",
              "#": "\uff03",
              $: "\uff04",
              "%": "\uff05",
              "&": "\uff06",
              "(": "\ufe35",
              ")": "\ufe36",
              "*": "\uff0a",
              "+": "\uff0b",
              ",": "\ufe10",
              "-": "\ufe32",
              ".": "\u30fb",
              "/": "\uff0f",
              ":": "\ufe13",
              ";": "\ufe14",
              "<": "\ufe3f",
              "=": "\uff1d",
              ">": "\ufe40",
              "?": "\ufe16",
              "@": "\uff20",
              "[": "\ufe47",
              "\\": "\uff3c",
              "]": "\ufe48",
              "^": "\uff3e",
              _: "\ufe33",
              "`": "\uff40",
              "{": "\ufe37",
              "|": "\u2015",
              "}": "\ufe38",
              "~": "\uff5e",
              "\xa2": "\uffe0",
              "\xa3": "\uffe1",
              "\xa5": "\uffe5",
              "\xa6": "\uffe4",
              "\xac": "\uffe2",
              "\xaf": "\uffe3",
              "\u2013": "\ufe32",
              "\u2014": "\ufe31",
              "\u2018": "\ufe43",
              "\u2019": "\ufe44",
              "\u201c": "\ufe41",
              "\u201d": "\ufe42",
              "\u2026": "\ufe19",
              "\u2027": "\u30fb",
              "\u20a9": "\uffe6",
              "\u3001": "\ufe11",
              "\u3002": "\ufe12",
              "\u3008": "\ufe3f",
              "\u3009": "\ufe40",
              "\u300a": "\ufe3d",
              "\u300b": "\ufe3e",
              "\u300c": "\ufe41",
              "\u300d": "\ufe42",
              "\u300e": "\ufe43",
              "\u300f": "\ufe44",
              "\u3010": "\ufe3b",
              "\u3011": "\ufe3c",
              "\u3014": "\ufe39",
              "\u3015": "\ufe3a",
              "\u3016": "\ufe17",
              "\u3017": "\ufe18",
              "\uff01": "\ufe15",
              "\uff08": "\ufe35",
              "\uff09": "\ufe36",
              "\uff0c": "\ufe10",
              "\uff0d": "\ufe32",
              "\uff0e": "\u30fb",
              "\uff1a": "\ufe13",
              "\uff1b": "\ufe14",
              "\uff1c": "\ufe3f",
              "\uff1e": "\ufe40",
              "\uff1f": "\ufe16",
              "\uff3b": "\ufe47",
              "\uff3d": "\ufe48",
              "\uff3f": "\ufe33",
              "\uff5b": "\ufe37",
              "\uff5c": "\u2015",
              "\uff5d": "\ufe38",
              "\uff5f": "\ufe35",
              "\uff60": "\ufe36",
              "\uff61": "\ufe12",
              "\uff62": "\ufe41",
              "\uff63": "\ufe42",
              "\u2190": "\u2191",
              "\u2192": "\u2193",
            };
            function k_(r) {
              return (
                "\ufe36" === r ||
                "\ufe48" === r ||
                "\ufe38" === r ||
                "\ufe44" === r ||
                "\ufe42" === r ||
                "\ufe3e" === r ||
                "\ufe3c" === r ||
                "\ufe3a" === r ||
                "\ufe18" === r ||
                "\ufe40" === r ||
                "\ufe10" === r ||
                "\ufe13" === r ||
                "\ufe14" === r ||
                "\uff40" === r ||
                "\uffe3" === r ||
                "\ufe11" === r ||
                "\ufe12" === r
              );
            }
            function Om(r) {
              return (
                "\ufe35" === r ||
                "\ufe47" === r ||
                "\ufe37" === r ||
                "\ufe43" === r ||
                "\ufe41" === r ||
                "\ufe3d" === r ||
                "\ufe3b" === r ||
                "\ufe39" === r ||
                "\ufe17" === r ||
                "\ufe3f" === r
              );
            }
            var R_ = mn,
              O_ = function (r, i, o, l, h) {
                var m,
                  _,
                  x = 8 * h - l - 1,
                  E = (1 << x) - 1,
                  T = E >> 1,
                  C = -7,
                  A = o ? h - 1 : 0,
                  L = o ? -1 : 1,
                  O = r[i + A];
                for (
                  A += L, m = O & ((1 << -C) - 1), O >>= -C, C += x;
                  C > 0;
                  m = 256 * m + r[i + A], A += L, C -= 8
                );
                for (
                  _ = m & ((1 << -C) - 1), m >>= -C, C += l;
                  C > 0;
                  _ = 256 * _ + r[i + A], A += L, C -= 8
                );
                if (0 === m) m = 1 - T;
                else {
                  if (m === E) return _ ? NaN : (1 / 0) * (O ? -1 : 1);
                  (_ += Math.pow(2, l)), (m -= T);
                }
                return (O ? -1 : 1) * _ * Math.pow(2, m - l);
              },
              Fm = function (r, i, o, l, h, m) {
                var _,
                  x,
                  E,
                  T = 8 * m - h - 1,
                  C = (1 << T) - 1,
                  A = C >> 1,
                  L = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                  O = l ? 0 : m - 1,
                  F = l ? 1 : -1,
                  V = i < 0 || (0 === i && 1 / i < 0) ? 1 : 0;
                for (
                  i = Math.abs(i),
                    isNaN(i) || i === 1 / 0
                      ? ((x = isNaN(i) ? 1 : 0), (_ = C))
                      : ((_ = Math.floor(Math.log(i) / Math.LN2)),
                        i * (E = Math.pow(2, -_)) < 1 && (_--, (E *= 2)),
                        (i += _ + A >= 1 ? L / E : L * Math.pow(2, 1 - A)) *
                          E >=
                          2 && (_++, (E /= 2)),
                        _ + A >= C
                          ? ((x = 0), (_ = C))
                          : _ + A >= 1
                          ? ((x = (i * E - 1) * Math.pow(2, h)), (_ += A))
                          : ((x = i * Math.pow(2, A - 1) * Math.pow(2, h)),
                            (_ = 0)));
                  h >= 8;
                  r[o + O] = 255 & x, O += F, x /= 256, h -= 8
                );
                for (
                  _ = (_ << h) | x, T += h;
                  T > 0;
                  r[o + O] = 255 & _, O += F, _ /= 256, T -= 8
                );
                r[o + O - F] |= 128 * V;
              };
            function mn(r) {
              (this.buf =
                ArrayBuffer.isView && ArrayBuffer.isView(r)
                  ? r
                  : new Uint8Array(r || 0)),
                (this.pos = 0),
                (this.type = 0),
                (this.length = this.buf.length);
            }
            (mn.Varint = 0), (mn.Fixed64 = 1), (mn.Bytes = 2), (mn.Fixed32 = 5);
            var Nm = 4294967296,
              F_ = 1 / Nm,
              N_ = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
            function ol(r) {
              return r.type === mn.Bytes ? r.readVarint() + r.pos : r.pos + 1;
            }
            function z_(r, i, o) {
              var l =
                i <= 16383
                  ? 1
                  : i <= 2097151
                  ? 2
                  : i <= 268435455
                  ? 3
                  : Math.floor(Math.log(i) / (7 * Math.LN2));
              o.realloc(l);
              for (var h = o.pos - 1; h >= r; h--) o.buf[h + l] = o.buf[h];
            }
            function B_(r, i) {
              for (var o = 0; o < r.length; o++) i.writeVarint(r[o]);
            }
            function Hv(r, i) {
              for (var o = 0; o < r.length; o++) i.writeSVarint(r[o]);
            }
            function V_(r, i) {
              for (var o = 0; o < r.length; o++) i.writeFloat(r[o]);
            }
            function Mb(r, i) {
              for (var o = 0; o < r.length; o++) i.writeDouble(r[o]);
            }
            function Gv(r, i) {
              for (var o = 0; o < r.length; o++) i.writeBoolean(r[o]);
            }
            function Qp(r, i) {
              for (var o = 0; o < r.length; o++) i.writeFixed32(r[o]);
            }
            function qv(r, i) {
              for (var o = 0; o < r.length; o++) i.writeSFixed32(r[o]);
            }
            function th(r, i) {
              for (var o = 0; o < r.length; o++) i.writeFixed64(r[o]);
            }
            function sl(r, i) {
              for (var o = 0; o < r.length; o++) i.writeSFixed64(r[o]);
            }
            function Jp(r, i) {
              return (
                (r[i] | (r[i + 1] << 8) | (r[i + 2] << 16)) +
                16777216 * r[i + 3]
              );
            }
            function Ld(r, i, o) {
              (r[o] = i),
                (r[o + 1] = i >>> 8),
                (r[o + 2] = i >>> 16),
                (r[o + 3] = i >>> 24);
            }
            function nh(r, i) {
              return (
                (r[i] | (r[i + 1] << 8) | (r[i + 2] << 16)) + (r[i + 3] << 24)
              );
            }
            mn.prototype = {
              destroy: function () {
                this.buf = null;
              },
              readFields: function (r, i, o) {
                for (o = o || this.length; this.pos < o; ) {
                  var l = this.readVarint(),
                    h = l >> 3,
                    m = this.pos;
                  (this.type = 7 & l),
                    r(h, i, this),
                    this.pos === m && this.skip(l);
                }
                return i;
              },
              readMessage: function (r, i) {
                return this.readFields(r, i, this.readVarint() + this.pos);
              },
              readFixed32: function () {
                var r = Jp(this.buf, this.pos);
                return (this.pos += 4), r;
              },
              readSFixed32: function () {
                var r = nh(this.buf, this.pos);
                return (this.pos += 4), r;
              },
              readFixed64: function () {
                var r =
                  Jp(this.buf, this.pos) + Jp(this.buf, this.pos + 4) * Nm;
                return (this.pos += 8), r;
              },
              readSFixed64: function () {
                var r =
                  Jp(this.buf, this.pos) + nh(this.buf, this.pos + 4) * Nm;
                return (this.pos += 8), r;
              },
              readFloat: function () {
                var r = O_(this.buf, this.pos, !0, 23, 4);
                return (this.pos += 4), r;
              },
              readDouble: function () {
                var r = O_(this.buf, this.pos, !0, 52, 8);
                return (this.pos += 8), r;
              },
              readVarint: function (r) {
                var i,
                  o,
                  l = this.buf;
                return (
                  (i = 127 & (o = l[this.pos++])),
                  o < 128
                    ? i
                    : ((i |= (127 & (o = l[this.pos++])) << 7),
                      o < 128
                        ? i
                        : ((i |= (127 & (o = l[this.pos++])) << 14),
                          o < 128
                            ? i
                            : ((i |= (127 & (o = l[this.pos++])) << 21),
                              o < 128
                                ? i
                                : (function (h, m, _) {
                                    var x,
                                      E,
                                      T = _.buf;
                                    if (
                                      ((x = (112 & (E = T[_.pos++])) >> 4),
                                      E < 128 ||
                                        ((x |= (127 & (E = T[_.pos++])) << 3),
                                        E < 128) ||
                                        ((x |= (127 & (E = T[_.pos++])) << 10),
                                        E < 128) ||
                                        ((x |= (127 & (E = T[_.pos++])) << 17),
                                        E < 128) ||
                                        ((x |= (127 & (E = T[_.pos++])) << 24),
                                        E < 128) ||
                                        ((x |= (1 & (E = T[_.pos++])) << 31),
                                        E < 128))
                                    )
                                      return (function Wl(r, i, o) {
                                        return o
                                          ? 4294967296 * i + (r >>> 0)
                                          : 4294967296 * (i >>> 0) + (r >>> 0);
                                      })(h, x, m);
                                    throw new Error(
                                      "Expected varint not more than 10 bytes"
                                    );
                                  })(
                                    (i |= (15 & (o = l[this.pos])) << 28),
                                    r,
                                    this
                                  ))))
                );
              },
              readVarint64: function () {
                return this.readVarint(!0);
              },
              readSVarint: function () {
                var r = this.readVarint();
                return r % 2 == 1 ? (r + 1) / -2 : r / 2;
              },
              readBoolean: function () {
                return Boolean(this.readVarint());
              },
              readString: function () {
                var r = this.readVarint() + this.pos,
                  i = this.pos;
                return (
                  (this.pos = r),
                  r - i >= 12 && N_
                    ? N_.decode(this.buf.subarray(i, r))
                    : (function (o, l, h) {
                        for (var m = "", _ = l; _ < h; ) {
                          var x,
                            E,
                            T,
                            C = o[_],
                            A = null,
                            L = C > 239 ? 4 : C > 223 ? 3 : C > 191 ? 2 : 1;
                          if (_ + L > h) break;
                          1 === L
                            ? C < 128 && (A = C)
                            : 2 === L
                            ? 128 == (192 & (x = o[_ + 1])) &&
                              (A = ((31 & C) << 6) | (63 & x)) <= 127 &&
                              (A = null)
                            : 3 === L
                            ? ((E = o[_ + 2]),
                              128 == (192 & (x = o[_ + 1])) &&
                                128 == (192 & E) &&
                                ((A =
                                  ((15 & C) << 12) |
                                  ((63 & x) << 6) |
                                  (63 & E)) <= 2047 ||
                                  (A >= 55296 && A <= 57343)) &&
                                (A = null))
                            : 4 === L &&
                              ((E = o[_ + 2]),
                              (T = o[_ + 3]),
                              128 == (192 & (x = o[_ + 1])) &&
                                128 == (192 & E) &&
                                128 == (192 & T) &&
                                ((A =
                                  ((15 & C) << 18) |
                                  ((63 & x) << 12) |
                                  ((63 & E) << 6) |
                                  (63 & T)) <= 65535 ||
                                  A >= 1114112) &&
                                (A = null)),
                            null === A
                              ? ((A = 65533), (L = 1))
                              : A > 65535 &&
                                ((A -= 65536),
                                (m += String.fromCharCode(
                                  ((A >>> 10) & 1023) | 55296
                                )),
                                (A = 56320 | (1023 & A))),
                            (m += String.fromCharCode(A)),
                            (_ += L);
                        }
                        return m;
                      })(this.buf, i, r)
                );
              },
              readBytes: function () {
                var r = this.readVarint() + this.pos,
                  i = this.buf.subarray(this.pos, r);
                return (this.pos = r), i;
              },
              readPackedVarint: function (r, i) {
                if (this.type !== mn.Bytes) return r.push(this.readVarint(i));
                var o = ol(this);
                for (r = r || []; this.pos < o; ) r.push(this.readVarint(i));
                return r;
              },
              readPackedSVarint: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readSVarint());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readSVarint());
                return r;
              },
              readPackedBoolean: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readBoolean());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readBoolean());
                return r;
              },
              readPackedFloat: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readFloat());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readFloat());
                return r;
              },
              readPackedDouble: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readDouble());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readDouble());
                return r;
              },
              readPackedFixed32: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readFixed32());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readFixed32());
                return r;
              },
              readPackedSFixed32: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readSFixed32());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readSFixed32());
                return r;
              },
              readPackedFixed64: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readFixed64());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readFixed64());
                return r;
              },
              readPackedSFixed64: function (r) {
                if (this.type !== mn.Bytes) return r.push(this.readSFixed64());
                var i = ol(this);
                for (r = r || []; this.pos < i; ) r.push(this.readSFixed64());
                return r;
              },
              skip: function (r) {
                var i = 7 & r;
                if (i === mn.Varint) for (; this.buf[this.pos++] > 127; );
                else if (i === mn.Bytes)
                  this.pos = this.readVarint() + this.pos;
                else if (i === mn.Fixed32) this.pos += 4;
                else {
                  if (i !== mn.Fixed64)
                    throw new Error("Unimplemented type: " + i);
                  this.pos += 8;
                }
              },
              writeTag: function (r, i) {
                this.writeVarint((r << 3) | i);
              },
              realloc: function (r) {
                for (var i = this.length || 16; i < this.pos + r; ) i *= 2;
                if (i !== this.length) {
                  var o = new Uint8Array(i);
                  o.set(this.buf), (this.buf = o), (this.length = i);
                }
              },
              finish: function () {
                return (
                  (this.length = this.pos),
                  (this.pos = 0),
                  this.buf.subarray(0, this.length)
                );
              },
              writeFixed32: function (r) {
                this.realloc(4), Ld(this.buf, r, this.pos), (this.pos += 4);
              },
              writeSFixed32: function (r) {
                this.realloc(4), Ld(this.buf, r, this.pos), (this.pos += 4);
              },
              writeFixed64: function (r) {
                this.realloc(8),
                  Ld(this.buf, -1 & r, this.pos),
                  Ld(this.buf, Math.floor(r * F_), this.pos + 4),
                  (this.pos += 8);
              },
              writeSFixed64: function (r) {
                this.realloc(8),
                  Ld(this.buf, -1 & r, this.pos),
                  Ld(this.buf, Math.floor(r * F_), this.pos + 4),
                  (this.pos += 8);
              },
              writeVarint: function (r) {
                (r = +r || 0) > 268435455 || r < 0
                  ? (function (i, o) {
                      var l, h, m, x;
                      if (
                        (i >= 0
                          ? ((l = i % 4294967296 | 0),
                            (h = (i / 4294967296) | 0))
                          : ((h = ~(-i / 4294967296)),
                            4294967295 ^ (l = ~(-i % 4294967296))
                              ? (l = (l + 1) | 0)
                              : ((l = 0), (h = (h + 1) | 0))),
                        i >= 0x10000000000000000 || i < -0x10000000000000000)
                      )
                        throw new Error(
                          "Given varint doesn't fit into 10 bytes"
                        );
                      o.realloc(10),
                        (m = l),
                        ((x = o).buf[x.pos++] = (127 & m) | 128),
                        (m >>>= 7),
                        (x.buf[x.pos++] = (127 & m) | 128),
                        (m >>>= 7),
                        (x.buf[x.pos++] = (127 & m) | 128),
                        (m >>>= 7),
                        (x.buf[x.pos++] = (127 & m) | 128),
                        (x.buf[x.pos] = 127 & (m >>>= 7)),
                        (function (m, _) {
                          var x = (7 & m) << 4;
                          (_.buf[_.pos++] |= x | ((m >>>= 3) ? 128 : 0)),
                            m &&
                              ((_.buf[_.pos++] =
                                (127 & m) | ((m >>>= 7) ? 128 : 0)),
                              m &&
                                ((_.buf[_.pos++] =
                                  (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                m &&
                                  ((_.buf[_.pos++] =
                                    (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                  m &&
                                    ((_.buf[_.pos++] =
                                      (127 & m) | ((m >>>= 7) ? 128 : 0)),
                                    m && (_.buf[_.pos++] = 127 & m)))));
                        })(h, o);
                    })(r, this)
                  : (this.realloc(4),
                    (this.buf[this.pos++] = (127 & r) | (r > 127 ? 128 : 0)),
                    r <= 127 ||
                      ((this.buf[this.pos++] =
                        (127 & (r >>>= 7)) | (r > 127 ? 128 : 0)),
                      r <= 127 ||
                        ((this.buf[this.pos++] =
                          (127 & (r >>>= 7)) | (r > 127 ? 128 : 0)),
                        r <= 127 || (this.buf[this.pos++] = (r >>> 7) & 127))));
              },
              writeSVarint: function (r) {
                this.writeVarint(r < 0 ? 2 * -r - 1 : 2 * r);
              },
              writeBoolean: function (r) {
                this.writeVarint(Boolean(r));
              },
              writeString: function (r) {
                (r = String(r)), this.realloc(4 * r.length), this.pos++;
                var i = this.pos;
                this.pos = (function (l, h, m) {
                  for (var _, x, E = 0; E < h.length; E++) {
                    if ((_ = h.charCodeAt(E)) > 55295 && _ < 57344) {
                      if (!x) {
                        _ > 56319 || E + 1 === h.length
                          ? ((l[m++] = 239), (l[m++] = 191), (l[m++] = 189))
                          : (x = _);
                        continue;
                      }
                      if (_ < 56320) {
                        (l[m++] = 239), (l[m++] = 191), (l[m++] = 189), (x = _);
                        continue;
                      }
                      (_ = ((x - 55296) << 10) | (_ - 56320) | 65536),
                        (x = null);
                    } else
                      x &&
                        ((l[m++] = 239),
                        (l[m++] = 191),
                        (l[m++] = 189),
                        (x = null));
                    _ < 128
                      ? (l[m++] = _)
                      : (_ < 2048
                          ? (l[m++] = (_ >> 6) | 192)
                          : (_ < 65536
                              ? (l[m++] = (_ >> 12) | 224)
                              : ((l[m++] = (_ >> 18) | 240),
                                (l[m++] = ((_ >> 12) & 63) | 128)),
                            (l[m++] = ((_ >> 6) & 63) | 128)),
                        (l[m++] = (63 & _) | 128));
                  }
                  return m;
                })(this.buf, r, this.pos);
                var o = this.pos - i;
                o >= 128 && z_(i, o, this),
                  (this.pos = i - 1),
                  this.writeVarint(o),
                  (this.pos += o);
              },
              writeFloat: function (r) {
                this.realloc(4),
                  Fm(this.buf, r, this.pos, !0, 23, 4),
                  (this.pos += 4);
              },
              writeDouble: function (r) {
                this.realloc(8),
                  Fm(this.buf, r, this.pos, !0, 52, 8),
                  (this.pos += 8);
              },
              writeBytes: function (r) {
                var i = r.length;
                this.writeVarint(i), this.realloc(i);
                for (var o = 0; o < i; o++) this.buf[this.pos++] = r[o];
              },
              writeRawMessage: function (r, i) {
                this.pos++;
                var o = this.pos;
                r(i, this);
                var l = this.pos - o;
                l >= 128 && z_(o, l, this),
                  (this.pos = o - 1),
                  this.writeVarint(l),
                  (this.pos += l);
              },
              writeMessage: function (r, i, o) {
                this.writeTag(r, mn.Bytes), this.writeRawMessage(i, o);
              },
              writePackedVarint: function (r, i) {
                i.length && this.writeMessage(r, B_, i);
              },
              writePackedSVarint: function (r, i) {
                i.length && this.writeMessage(r, Hv, i);
              },
              writePackedBoolean: function (r, i) {
                i.length && this.writeMessage(r, Gv, i);
              },
              writePackedFloat: function (r, i) {
                i.length && this.writeMessage(r, V_, i);
              },
              writePackedDouble: function (r, i) {
                i.length && this.writeMessage(r, Mb, i);
              },
              writePackedFixed32: function (r, i) {
                i.length && this.writeMessage(r, Qp, i);
              },
              writePackedSFixed32: function (r, i) {
                i.length && this.writeMessage(r, qv, i);
              },
              writePackedFixed64: function (r, i) {
                i.length && this.writeMessage(r, th, i);
              },
              writePackedSFixed64: function (r, i) {
                i.length && this.writeMessage(r, sl, i);
              },
              writeBytesField: function (r, i) {
                this.writeTag(r, mn.Bytes), this.writeBytes(i);
              },
              writeFixed32Field: function (r, i) {
                this.writeTag(r, mn.Fixed32), this.writeFixed32(i);
              },
              writeSFixed32Field: function (r, i) {
                this.writeTag(r, mn.Fixed32), this.writeSFixed32(i);
              },
              writeFixed64Field: function (r, i) {
                this.writeTag(r, mn.Fixed64), this.writeFixed64(i);
              },
              writeSFixed64Field: function (r, i) {
                this.writeTag(r, mn.Fixed64), this.writeSFixed64(i);
              },
              writeVarintField: function (r, i) {
                this.writeTag(r, mn.Varint), this.writeVarint(i);
              },
              writeSVarintField: function (r, i) {
                this.writeTag(r, mn.Varint), this.writeSVarint(i);
              },
              writeStringField: function (r, i) {
                this.writeTag(r, mn.Bytes), this.writeString(i);
              },
              writeFloatField: function (r, i) {
                this.writeTag(r, mn.Fixed32), this.writeFloat(i);
              },
              writeDoubleField: function (r, i) {
                this.writeTag(r, mn.Fixed64), this.writeDouble(i);
              },
              writeBooleanField: function (r, i) {
                this.writeVarintField(r, Boolean(i));
              },
            };
            var kd = Vr(R_);
            function Wv(r, i, o) {
              (i.glyphs = []), 1 === r && o.readMessage(Bm, i);
            }
            function Bm(r, i, o) {
              if (3 === r) {
                const {
                  id: l,
                  bitmap: h,
                  width: m,
                  height: _,
                  left: x,
                  top: E,
                  advance: T,
                } = o.readMessage(Zv, {});
                i.glyphs.push({
                  id: l,
                  bitmap: new Xr({ width: m + 6, height: _ + 6 }, h),
                  metrics: { width: m, height: _, left: x, top: E, advance: T },
                });
              } else 4 === r ? (i.ascender = o.readSVarint()) : 5 === r && (i.descender = o.readSVarint());
            }
            function Zv(r, i, o) {
              1 === r
                ? (i.id = o.readVarint())
                : 2 === r
                ? (i.bitmap = o.readBytes())
                : 3 === r
                ? (i.width = o.readVarint())
                : 4 === r
                ? (i.height = o.readVarint())
                : 5 === r
                ? (i.left = o.readSVarint())
                : 6 === r
                ? (i.top = o.readSVarint())
                : 7 === r && (i.advance = o.readVarint());
            }
            function Rd(r) {
              let i = 0,
                o = 0;
              for (const _ of r) (i += _.w * _.h), (o = Math.max(o, _.w));
              r.sort((_, x) => x.h - _.h);
              const l = [
                {
                  x: 0,
                  y: 0,
                  w: Math.max(Math.ceil(Math.sqrt(i / 0.95)), o),
                  h: 1 / 0,
                },
              ];
              let h = 0,
                m = 0;
              for (const _ of r)
                for (let x = l.length - 1; x >= 0; x--) {
                  const E = l[x];
                  if (!(_.w > E.w || _.h > E.h)) {
                    if (
                      ((_.x = E.x),
                      (_.y = E.y),
                      (m = Math.max(m, _.y + _.h)),
                      (h = Math.max(h, _.x + _.w)),
                      _.w === E.w && _.h === E.h)
                    ) {
                      const T = l.pop();
                      x < l.length && (l[x] = T);
                    } else
                      _.h === E.h
                        ? ((E.x += _.w), (E.w -= _.w))
                        : _.w === E.w
                        ? ((E.y += _.h), (E.h -= _.h))
                        : (l.push({
                            x: E.x + _.w,
                            y: E.y,
                            w: E.w - _.w,
                            h: _.h,
                          }),
                          (E.y += _.h),
                          (E.h -= _.h));
                    break;
                  }
                }
              return { w: h, h: m, fill: i / (h * m) || 0 };
            }
            class Od {
              constructor(
                i,
                {
                  pixelRatio: o,
                  version: l,
                  stretchX: h,
                  stretchY: m,
                  content: _,
                }
              ) {
                (this.paddedRect = i),
                  (this.pixelRatio = o),
                  (this.stretchX = h),
                  (this.stretchY = m),
                  (this.content = _),
                  (this.version = l);
              }
              get tl() {
                return [this.paddedRect.x + 1, this.paddedRect.y + 1];
              }
              get br() {
                return [
                  this.paddedRect.x + this.paddedRect.w - 1,
                  this.paddedRect.y + this.paddedRect.h - 1,
                ];
              }
              get displaySize() {
                return [
                  (this.paddedRect.w - 2) / this.pixelRatio,
                  (this.paddedRect.h - 2) / this.pixelRatio,
                ];
              }
            }
            class Uc {
              constructor(i, o) {
                const l = {},
                  h = {};
                this.haveRenderCallbacks = [];
                const m = [];
                this.addImages(i, l, m), this.addImages(o, h, m);
                const { w: _, h: x } = Rd(m),
                  E = new Kr({ width: _ || 1, height: x || 1 });
                for (const T in i) {
                  const C = i[T],
                    A = l[T].paddedRect;
                  Kr.copy(
                    C.data,
                    E,
                    { x: 0, y: 0 },
                    { x: A.x + 1, y: A.y + 1 },
                    C.data
                  );
                }
                for (const T in o) {
                  const C = o[T],
                    A = h[T].paddedRect,
                    L = A.x + 1,
                    O = A.y + 1,
                    F = C.data.width,
                    V = C.data.height;
                  Kr.copy(C.data, E, { x: 0, y: 0 }, { x: L, y: O }, C.data),
                    Kr.copy(
                      C.data,
                      E,
                      { x: 0, y: V - 1 },
                      { x: L, y: O - 1 },
                      { width: F, height: 1 }
                    ),
                    Kr.copy(
                      C.data,
                      E,
                      { x: 0, y: 0 },
                      { x: L, y: O + V },
                      { width: F, height: 1 }
                    ),
                    Kr.copy(
                      C.data,
                      E,
                      { x: F - 1, y: 0 },
                      { x: L - 1, y: O },
                      { width: 1, height: V }
                    ),
                    Kr.copy(
                      C.data,
                      E,
                      { x: 0, y: 0 },
                      { x: L + F, y: O },
                      { width: 1, height: V }
                    );
                }
                (this.image = E),
                  (this.iconPositions = l),
                  (this.patternPositions = h);
              }
              addImages(i, o, l) {
                for (const h in i) {
                  const m = i[h],
                    _ = {
                      x: 0,
                      y: 0,
                      w: m.data.width + 2,
                      h: m.data.height + 2,
                    };
                  l.push(_),
                    (o[h] = new Od(_, m)),
                    m.hasRenderCallback && this.haveRenderCallbacks.push(h);
                }
              }
              patchUpdatedImages(i, o) {
                (this.haveRenderCallbacks = this.haveRenderCallbacks.filter(
                  (l) => i.hasImage(l)
                )),
                  i.dispatchRenderCallbacks(this.haveRenderCallbacks);
                for (const l in i.updatedImages)
                  this.patchUpdatedImage(
                    this.iconPositions[l],
                    i.getImage(l),
                    o
                  ),
                    this.patchUpdatedImage(
                      this.patternPositions[l],
                      i.getImage(l),
                      o
                    );
              }
              patchUpdatedImage(i, o, l) {
                if (!i || !o || i.version === o.version) return;
                i.version = o.version;
                const [h, m] = i.tl;
                l.update(o.data, void 0, { x: h, y: m });
              }
            }
            st(Od, "ImagePosition"), st(Uc, "ImageAtlas");
            const Po = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
            class Fd {
              constructor() {
                (this.scale = 1),
                  (this.fontStack = ""),
                  (this.imageName = null);
              }
              static forText(i, o) {
                const l = new Fd();
                return (l.scale = i || 1), (l.fontStack = o), l;
              }
              static forImage(i) {
                const o = new Fd();
                return (o.imageName = i), o;
              }
            }
            class ih {
              constructor() {
                (this.text = ""),
                  (this.sectionIndex = []),
                  (this.sections = []),
                  (this.imageSectionID = null);
              }
              static fromFeature(i, o) {
                const l = new ih();
                for (let h = 0; h < i.sections.length; h++) {
                  const m = i.sections[h];
                  m.image ? l.addImageSection(m) : l.addTextSection(m, o);
                }
                return l;
              }
              length() {
                return this.text.length;
              }
              getSection(i) {
                return this.sections[this.sectionIndex[i]];
              }
              getSections() {
                return this.sections;
              }
              getSectionIndex(i) {
                return this.sectionIndex[i];
              }
              getCharCode(i) {
                return this.text.charCodeAt(i);
              }
              verticalizePunctuation(i) {
                this.text = (function (o, l) {
                  let h = "";
                  for (let m = 0; m < o.length; m++) {
                    const _ = o.charCodeAt(m + 1) || null,
                      x = o.charCodeAt(m - 1) || null;
                    h +=
                      (!l &&
                        ((_ && Jh(_) && !da[o[m + 1]]) ||
                          (x && Jh(x) && !da[o[m - 1]]))) ||
                      !da[o[m]]
                        ? o[m]
                        : da[o[m]];
                  }
                  return h;
                })(this.text, i);
              }
              trim() {
                let i = 0;
                for (
                  let l = 0;
                  l < this.text.length && tf[this.text.charCodeAt(l)];
                  l++
                )
                  i++;
                let o = this.text.length;
                for (
                  let l = this.text.length - 1;
                  l >= 0 && l >= i && tf[this.text.charCodeAt(l)];
                  l--
                )
                  o--;
                (this.text = this.text.substring(i, o)),
                  (this.sectionIndex = this.sectionIndex.slice(i, o));
              }
              substring(i, o) {
                const l = new ih();
                return (
                  (l.text = this.text.substring(i, o)),
                  (l.sectionIndex = this.sectionIndex.slice(i, o)),
                  (l.sections = this.sections),
                  l
                );
              }
              toString() {
                return this.text;
              }
              getMaxScale() {
                return this.sectionIndex.reduce(
                  (i, o) => Math.max(i, this.sections[o].scale),
                  0
                );
              }
              addTextSection(i, o) {
                (this.text += i.text),
                  this.sections.push(Fd.forText(i.scale, i.fontStack || o));
                const l = this.sections.length - 1;
                for (let h = 0; h < i.text.length; ++h)
                  this.sectionIndex.push(l);
              }
              addImageSection(i) {
                const o = i.image ? i.image.name : "";
                if (0 === o.length)
                  return void Hn(
                    "Can't add FormattedSection with an empty image."
                  );
                const l = this.getNextImageSectionCharCode();
                l
                  ? ((this.text += String.fromCharCode(l)),
                    this.sections.push(Fd.forImage(o)),
                    this.sectionIndex.push(this.sections.length - 1))
                  : Hn("Reached maximum number of images 6401");
              }
              getNextImageSectionCharCode() {
                return this.imageSectionID
                  ? this.imageSectionID >= 63743
                    ? null
                    : ++this.imageSectionID
                  : ((this.imageSectionID = 57344), this.imageSectionID);
              }
            }
            function Vm(r, i, o, l, h, m, _, x, E, T, C, A, L, O, F) {
              const V = ih.fromFeature(r, h);
              A === Po.vertical && V.verticalizePunctuation(L);
              let G = [];
              const K = (function (ae, De, xe, Pe, $e, Ce) {
                  if (!ae) return [];
                  const Fe = [],
                    Re = (function (Je, ut, nt, Mt, Ke, yt) {
                      let Ct = 0;
                      for (let Zt = 0; Zt < Je.length(); Zt++) {
                        const It = Je.getSection(Zt);
                        Ct += $c(Je.getCharCode(Zt), It, Mt, Ke, ut, yt);
                      }
                      return Ct / Math.max(1, Math.ceil(Ct / nt));
                    })(ae, De, xe, Pe, $e, Ce),
                    Ve = ae.text.indexOf("\u200b") >= 0;
                  let qe = 0;
                  for (let Je = 0; Je < ae.length(); Je++) {
                    const ut = ae.getSection(Je),
                      nt = ae.getCharCode(Je);
                    if (
                      (tf[nt] || (qe += $c(nt, ut, Pe, $e, De, Ce)),
                      Je < ae.length() - 1)
                    ) {
                      const Mt = !(
                        (Me = nt) < 11904 ||
                        !(
                          ot_Bopomofo_Extended(Me) ||
                          ot_Bopomofo(Me) ||
                          ot_CJK_Compatibility_Forms(Me) ||
                          ot_CJK_Compatibility_Ideographs(Me) ||
                          ot_CJK_Compatibility(Me) ||
                          ot_CJK_Radicals_Supplement(Me) ||
                          ot_CJK_Strokes(Me) ||
                          ot_CJK_Symbols_and_Punctuation(Me) ||
                          ot_CJK_Unified_Ideographs_Extension_A(Me) ||
                          ot_CJK_Unified_Ideographs(Me) ||
                          ot_Enclosed_CJK_Letters_and_Months(Me) ||
                          ot_Halfwidth_and_Fullwidth_Forms(Me) ||
                          ot_Hiragana(Me) ||
                          ot_Ideographic_Description_Characters(Me) ||
                          ot_Kangxi_Radicals(Me) ||
                          ot_Katakana_Phonetic_Extensions(Me) ||
                          ot_Katakana(Me) ||
                          ot_Vertical_Forms(Me) ||
                          ot_Yi_Radicals(Me) ||
                          ot_Yi_Syllables(Me)
                        )
                      );
                      (Xv[nt] || Mt || ut.imageName) &&
                        Fe.push(
                          U_(
                            Je + 1,
                            qe,
                            Re,
                            Fe,
                            Kv(nt, ae.getCharCode(Je + 1), Mt && Ve),
                            !1
                          )
                        );
                    }
                  }
                  var Me;
                  return Yv(U_(ae.length(), qe, Re, Fe, 0, !0));
                })(V, T, m, i, l, O),
                {
                  processBidirectionalText: oe,
                  processStyledBidirectionalText: J,
                } = I;
              if (oe && 1 === V.sections.length) {
                const ae = oe(V.toString(), K);
                for (const De of ae) {
                  const xe = new ih();
                  (xe.text = De), (xe.sections = V.sections);
                  for (let Pe = 0; Pe < De.length; Pe++)
                    xe.sectionIndex.push(0);
                  G.push(xe);
                }
              } else if (J) {
                const ae = J(V.text, V.sectionIndex, K);
                for (const De of ae) {
                  const xe = new ih();
                  (xe.text = De[0]),
                    (xe.sectionIndex = De[1]),
                    (xe.sections = V.sections),
                    G.push(xe);
                }
              } else
                G = (function (ae, De) {
                  const xe = [],
                    Pe = ae.text;
                  let $e = 0;
                  for (const Ce of De) xe.push(ae.substring($e, Ce)), ($e = Ce);
                  return (
                    $e < Pe.length && xe.push(ae.substring($e, Pe.length)), xe
                  );
                })(V, K);
              const re = [],
                le = {
                  positionedLines: re,
                  text: V.toString(),
                  top: C[1],
                  bottom: C[1],
                  left: C[0],
                  right: C[0],
                  writingMode: A,
                  iconsInText: !1,
                  verticalizable: !1,
                  hasBaseline: !1,
                };
              return (
                (function (ae, De, xe, Pe, $e, Ce, Fe, Re, Ve, qe, Me, Je) {
                  let ut = 0,
                    nt = 0,
                    Mt = 0;
                  const Ke = "right" === Re ? 1 : "left" === Re ? 0 : 0.5;
                  let yt = !1;
                  for (const Rt of $e) {
                    const At = Rt.getSections();
                    for (const An of At) {
                      if (An.imageName) continue;
                      const Fn = De[An.fontStack];
                      if (
                        Fn &&
                        ((yt =
                          void 0 !== Fn.ascender && void 0 !== Fn.descender),
                        !yt)
                      )
                        break;
                    }
                    if (!yt) break;
                  }
                  let Ct = 0;
                  for (const Rt of $e) {
                    Rt.trim();
                    const At = Rt.getMaxScale(),
                      An = 24 * (At - 1),
                      Fn = { positionedGlyphs: [], lineOffset: 0 };
                    ae.positionedLines[Ct] = Fn;
                    const Nn = Fn.positionedGlyphs;
                    let gn = 0;
                    if (!Rt.length()) {
                      (nt += Ce), ++Ct;
                      continue;
                    }
                    let Wn = 0,
                      oi = 0;
                    for (let zn = 0; zn < Rt.length(); zn++) {
                      const Di = Rt.getSection(zn),
                        vi = Rt.getSectionIndex(zn),
                        Yn = Rt.getCharCode(zn);
                      let cn = Di.scale,
                        si = null,
                        Bn = null,
                        cr = null,
                        xi = 24,
                        Qi = 0;
                      const Gi = !(
                        Ve === Po.horizontal ||
                        (!Me && !Cc(Yn)) ||
                        (Me &&
                          (tf[Yn] ||
                            ((Zt = Yn),
                            ot_Arabic(Zt) ||
                              ot_Arabic_Supplement(Zt) ||
                              ot_Arabic_Extended_A(Zt) ||
                              ot_Arabic_Presentation_Forms_A(Zt) ||
                              ot_Arabic_Presentation_Forms_B(Zt))))
                      );
                      if (Di.imageName) {
                        const zr = Pe[Di.imageName];
                        if (!zr) continue;
                        (cr = Di.imageName),
                          (ae.iconsInText = ae.iconsInText || !0),
                          (Bn = zr.paddedRect);
                        const qi = zr.displaySize;
                        (cn = (24 * cn) / Je),
                          (si = {
                            width: qi[0],
                            height: qi[1],
                            left: 1,
                            top: -3,
                            advance: Gi ? qi[1] : qi[0],
                            localGlyph: !1,
                          }),
                          (Qi = yt
                            ? -si.height * cn
                            : 24 * At - 17 - qi[1] * cn),
                          (xi = si.advance);
                        const Ds = (Gi ? qi[0] : qi[1]) * cn - 24 * At;
                        Ds > 0 && Ds > gn && (gn = Ds);
                      } else {
                        const zr = xe[Di.fontStack];
                        if (!zr) continue;
                        zr[Yn] && (Bn = zr[Yn]);
                        const qi = De[Di.fontStack];
                        if (!qi) continue;
                        const Ds = qi.glyphs[Yn];
                        if (!Ds) continue;
                        if (
                          ((si = Ds.metrics), (xi = 8203 !== Yn ? 24 : 0), yt)
                        ) {
                          const ul =
                              void 0 !== qi.ascender
                                ? Math.abs(qi.ascender)
                                : 0,
                            Ss =
                              void 0 !== qi.descender
                                ? Math.abs(qi.descender)
                                : 0,
                            gf = (ul + Ss) * cn;
                          Wn < gf && ((Wn = gf), (oi = ((ul - Ss) / 2) * cn)),
                            (Qi = -ul * cn);
                        } else Qi = 24 * (At - cn) - 17;
                      }
                      Gi
                        ? ((ae.verticalizable = !0),
                          Nn.push({
                            glyph: Yn,
                            imageName: cr,
                            x: ut,
                            y: nt + Qi,
                            vertical: Gi,
                            scale: cn,
                            localGlyph: si.localGlyph,
                            fontStack: Di.fontStack,
                            sectionIndex: vi,
                            metrics: si,
                            rect: Bn,
                          }),
                          (ut += xi * cn + qe))
                        : (Nn.push({
                            glyph: Yn,
                            imageName: cr,
                            x: ut,
                            y: nt + Qi,
                            vertical: Gi,
                            scale: cn,
                            localGlyph: si.localGlyph,
                            fontStack: Di.fontStack,
                            sectionIndex: vi,
                            metrics: si,
                            rect: Bn,
                          }),
                          (ut += si.advance * cn + qe));
                    }
                    0 !== Nn.length &&
                      ((Mt = Math.max(ut - qe, Mt)),
                      yt
                        ? jm(Nn, Ke, gn, oi, (Ce * At) / 2)
                        : jm(Nn, Ke, gn, 0, Ce / 2)),
                      (ut = 0);
                    const yi = Ce * At + gn;
                    (Fn.lineOffset = Math.max(gn, An)), (nt += yi), ++Ct;
                  }
                  var Zt;
                  const It = nt,
                    { horizontalAlign: xt, verticalAlign: Dn } = $_(Fe);
                  (function (Rt, At, An, Fn, Nn, gn) {
                    const Wn = (At - An) * Nn,
                      oi = -gn * Fn;
                    for (const yi of Rt)
                      for (const zn of yi.positionedGlyphs)
                        (zn.x += Wn), (zn.y += oi);
                  })(ae.positionedLines, Ke, xt, Dn, Mt, It),
                    (ae.top += -Dn * It),
                    (ae.bottom = ae.top + It),
                    (ae.left += -xt * Mt),
                    (ae.right = ae.left + Mt),
                    (ae.hasBaseline = yt);
                })(le, i, o, l, G, _, x, E, A, T, L, F),
                !(function (ae) {
                  for (const De of ae)
                    if (0 !== De.positionedGlyphs.length) return !1;
                  return !0;
                })(re) && le
              );
            }
            const tf = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
              Xv = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0,
              };
            function $c(r, i, o, l, h, m) {
              if (i.imageName) {
                const _ = l[i.imageName];
                return _ ? (_.displaySize[0] * i.scale * 24) / m + h : 0;
              }
              {
                const _ = o[i.fontStack],
                  x = _ && _.glyphs[r];
                return x ? x.metrics.advance * i.scale + h : 0;
              }
            }
            function pa(r, i, o, l) {
              const h = Math.pow(r - i, 2);
              return l ? (r < i ? h / 2 : 2 * h) : h + Math.abs(o) * o;
            }
            function Kv(r, i, o) {
              let l = 0;
              return (
                10 === r && (l -= 1e4),
                o && (l += 150),
                (40 !== r && 65288 !== r) || (l += 50),
                (41 !== i && 65289 !== i) || (l += 50),
                l
              );
            }
            function U_(r, i, o, l, h, m) {
              let _ = null,
                x = pa(i, o, h, m);
              for (const E of l) {
                const T = pa(i - E.x, o, h, m) + E.badness;
                T <= x && ((_ = E), (x = T));
              }
              return { index: r, x: i, priorBreak: _, badness: x };
            }
            function Yv(r) {
              return r ? Yv(r.priorBreak).concat(r.index) : [];
            }
            function $_(r) {
              let i = 0.5,
                o = 0.5;
              switch (r) {
                case "right":
                case "top-right":
                case "bottom-right":
                  i = 1;
                  break;
                case "left":
                case "top-left":
                case "bottom-left":
                  i = 0;
              }
              switch (r) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                  o = 1;
                  break;
                case "top":
                case "top-right":
                case "top-left":
                  o = 0;
              }
              return { horizontalAlign: i, verticalAlign: o };
            }
            function jm(r, i, o, l, h) {
              if (!(i || o || l || h)) return;
              const m = r.length - 1,
                _ = r[m],
                x = (_.x + _.metrics.advance * _.scale) * i;
              for (let E = 0; E <= m; E++) (r[E].x -= x), (r[E].y += o + l + h);
            }
            function Ab(r, i, o) {
              const { horizontalAlign: l, verticalAlign: h } = $_(o),
                m = i[0] - r.displaySize[0] * l,
                _ = i[1] - r.displaySize[1] * h;
              return {
                image: r,
                top: _,
                bottom: _ + r.displaySize[1],
                left: m,
                right: m + r.displaySize[0],
              };
            }
            function Um(r, i, o, l, h, m) {
              const _ = r.image;
              let x;
              if (_.content) {
                const G = _.content,
                  K = _.pixelRatio || 1;
                x = [
                  G[0] / K,
                  G[1] / K,
                  _.displaySize[0] - G[2] / K,
                  _.displaySize[1] - G[3] / K,
                ];
              }
              const E = i.left * m,
                T = i.right * m;
              let C, A, L, O;
              "width" === o || "both" === o
                ? ((O = h[0] + E - l[3]), (A = h[0] + T + l[1]))
                : ((O = h[0] + (E + T - _.displaySize[0]) / 2),
                  (A = O + _.displaySize[0]));
              const F = i.top * m,
                V = i.bottom * m;
              return (
                "height" === o || "both" === o
                  ? ((C = h[1] + F - l[0]), (L = h[1] + V + l[2]))
                  : ((C = h[1] + (F + V - _.displaySize[1]) / 2),
                    (L = C + _.displaySize[1])),
                {
                  image: _,
                  top: C,
                  right: A,
                  bottom: L,
                  left: O,
                  collisionPadding: x,
                }
              );
            }
            class Zl extends et {
              constructor(i, o, l, h, m) {
                super(i, o),
                  (this.angle = h),
                  (this.z = l),
                  void 0 !== m && (this.segment = m);
              }
              clone() {
                return new Zl(this.x, this.y, this.z, this.angle, this.segment);
              }
            }
            function $m(r, i, o, l, h) {
              if (void 0 === i.segment) return !0;
              let m = i,
                _ = i.segment + 1,
                x = 0;
              for (; x > -o / 2; ) {
                if ((_--, _ < 0)) return !1;
                (x -= r[_].dist(m)), (m = r[_]);
              }
              (x += r[_].dist(r[_ + 1])), _++;
              const E = [];
              let T = 0;
              for (; x < o / 2; ) {
                const C = r[_],
                  A = r[_ + 1];
                if (!A) return !1;
                let L = r[_ - 1].angleTo(C) - C.angleTo(A);
                for (
                  L = Math.abs(((L + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
                    E.push({ distance: x, angleDelta: L }),
                    T += L;
                  x - E[0].distance > l;

                )
                  T -= E.shift().angleDelta;
                if (T > h) return !1;
                _++, (x += C.dist(A));
              }
              return !0;
            }
            function H_(r) {
              let i = 0;
              for (let o = 0; o < r.length - 1; o++) i += r[o].dist(r[o + 1]);
              return i;
            }
            function Hm(r, i, o) {
              return r ? 0.6 * i * o : 0;
            }
            function G_(r, i) {
              return Math.max(
                r ? r.right - r.left : 0,
                i ? i.right - i.left : 0
              );
            }
            function Qv(r, i, o, l, h, m) {
              const _ = Hm(o, h, m),
                x = G_(o, l) * m;
              let E = 0;
              const T = H_(r) / 2;
              for (let C = 0; C < r.length - 1; C++) {
                const A = r[C],
                  L = r[C + 1],
                  O = A.dist(L);
                if (E + O > T) {
                  const F = (T - E) / O,
                    V = rn(A.x, L.x, F),
                    G = rn(A.y, L.y, F),
                    K = new Zl(V, G, 0, L.angleTo(A), C);
                  return !_ || $m(r, K, x, _, i) ? K : void 0;
                }
                E += O;
              }
            }
            function vs(r, i, o, l, h, m, _, x, E) {
              const T = Hm(l, m, _),
                C = G_(l, h),
                A = C * _,
                L =
                  0 === r[0].x || r[0].x === E || 0 === r[0].y || r[0].y === E;
              return (
                i - A < i / 4 && (i = A + i / 4),
                q_(
                  r,
                  L ? ((i / 2) * x) % i : ((C / 2 + 2 * m) * _ * x) % i,
                  i,
                  T,
                  o,
                  A,
                  L,
                  !1,
                  E
                )
              );
            }
            function q_(r, i, o, l, h, m, _, x, E) {
              const T = m / 2,
                C = H_(r);
              let A = 0,
                L = i - o,
                O = [];
              for (let F = 0; F < r.length - 1; F++) {
                const V = r[F],
                  G = r[F + 1],
                  K = V.dist(G),
                  oe = G.angleTo(V);
                for (; L + o < A + K; ) {
                  L += o;
                  const J = (L - A) / K,
                    re = rn(V.x, G.x, J),
                    le = rn(V.y, G.y, J);
                  if (
                    re >= 0 &&
                    re < E &&
                    le >= 0 &&
                    le < E &&
                    L - T >= 0 &&
                    L + T <= C
                  ) {
                    const ae = new Zl(re, le, 0, oe, F);
                    ae._round(), (l && !$m(r, ae, m, l, h)) || O.push(ae);
                  }
                }
                A += K;
              }
              return (
                x || O.length || _ || (O = q_(r, A / 2, o, l, h, m, _, !0, E)),
                O
              );
            }
            function Gm(r, i, o, l, h) {
              const m = [];
              for (let _ = 0; _ < r.length; _++) {
                const x = r[_];
                let E;
                for (let T = 0; T < x.length - 1; T++) {
                  let C = x[T],
                    A = x[T + 1];
                  (C.x < i && A.x < i) ||
                    (C.x < i
                      ? (C = new et(
                          i,
                          C.y + ((i - C.x) / (A.x - C.x)) * (A.y - C.y)
                        )._round())
                      : A.x < i &&
                        (A = new et(
                          i,
                          C.y + ((i - C.x) / (A.x - C.x)) * (A.y - C.y)
                        )._round()),
                    (C.y < o && A.y < o) ||
                      (C.y < o
                        ? (C = new et(
                            C.x + ((o - C.y) / (A.y - C.y)) * (A.x - C.x),
                            o
                          )._round())
                        : A.y < o &&
                          (A = new et(
                            C.x + ((o - C.y) / (A.y - C.y)) * (A.x - C.x),
                            o
                          )._round()),
                      (C.x >= l && A.x >= l) ||
                        (C.x >= l
                          ? (C = new et(
                              l,
                              C.y + ((l - C.x) / (A.x - C.x)) * (A.y - C.y)
                            )._round())
                          : A.x >= l &&
                            (A = new et(
                              l,
                              C.y + ((l - C.x) / (A.x - C.x)) * (A.y - C.y)
                            )._round()),
                        (C.y >= h && A.y >= h) ||
                          (C.y >= h
                            ? (C = new et(
                                C.x + ((h - C.y) / (A.y - C.y)) * (A.x - C.x),
                                h
                              )._round())
                            : A.y >= h &&
                              (A = new et(
                                C.x + ((h - C.y) / (A.y - C.y)) * (A.x - C.x),
                                h
                              )._round()),
                          (E && C.equals(E[E.length - 1])) ||
                            ((E = [C]), m.push(E)),
                          E.push(A)))));
                }
              }
              return m;
            }
            st(Zl, "Anchor");
            const Nd = 1e20;
            function W_(r, i, o, l, h, m, _, x, E) {
              for (let T = i; T < i + l; T++) Z_(r, o * m + T, m, h, _, x, E);
              for (let T = o; T < o + h; T++) Z_(r, T * m + i, 1, l, _, x, E);
            }
            function Z_(r, i, o, l, h, m, _) {
              (m[0] = 0), (_[0] = -Nd), (_[1] = Nd), (h[0] = r[i]);
              for (let x = 1, E = 0, T = 0; x < l; x++) {
                h[x] = r[i + x * o];
                const C = x * x;
                do {
                  const A = m[E];
                  T = (h[x] - h[A] + C - A * A) / (x - A) / 2;
                } while (T <= _[E] && --E > -1);
                E++, (m[E] = x), (_[E] = T), (_[E + 1] = Nd);
              }
              for (let x = 0, E = 0; x < l; x++) {
                for (; _[E + 1] < x; ) E++;
                const T = m[E],
                  C = x - T;
                r[i + x * o] = h[T] + C * C;
              }
            }
            const nf = { none: 0, ideographs: 1, all: 2 };
            class rh {
              constructor(i, o, l) {
                (this.requestManager = i),
                  (this.localGlyphMode = o),
                  (this.localFontFamily = l),
                  (this.entries = {}),
                  (this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} });
              }
              setURL(i) {
                this.url = i;
              }
              getGlyphs(i, o) {
                const l = [];
                for (const h in i)
                  for (const m of i[h]) l.push({ stack: h, id: m });
                Ci(
                  l,
                  ({ stack: h, id: m }, _) => {
                    let x = this.entries[h];
                    x ||
                      (x = this.entries[h] =
                        {
                          glyphs: {},
                          requests: {},
                          ranges: {},
                          ascender: void 0,
                          descender: void 0,
                        });
                    let E = x.glyphs[m];
                    if (void 0 !== E)
                      return void _(null, { stack: h, id: m, glyph: E });
                    if (((E = this._tinySDF(x, h, m)), E))
                      return (
                        (x.glyphs[m] = E),
                        void _(null, { stack: h, id: m, glyph: E })
                      );
                    const T = Math.floor(m / 256);
                    if (256 * T > 65535)
                      return void _(new Error("glyphs > 65535 not supported"));
                    if (x.ranges[T])
                      return void _(null, { stack: h, id: m, glyph: E });
                    let C = x.requests[T];
                    C ||
                      ((C = x.requests[T] = []),
                      rh.loadGlyphRange(
                        h,
                        T,
                        this.url,
                        this.requestManager,
                        (A, L) => {
                          if (L) {
                            (x.ascender = L.ascender),
                              (x.descender = L.descender);
                            for (const O in L.glyphs)
                              this._doesCharSupportLocalGlyph(+O) ||
                                (x.glyphs[+O] = L.glyphs[+O]);
                            x.ranges[T] = !0;
                          }
                          for (const O of C) O(A, L);
                          delete x.requests[T];
                        }
                      )),
                      C.push((A, L) => {
                        A
                          ? _(A)
                          : L &&
                            _(null, {
                              stack: h,
                              id: m,
                              glyph: L.glyphs[m] || null,
                            });
                      });
                  },
                  (h, m) => {
                    if (h) o(h);
                    else if (m) {
                      const _ = {};
                      for (const { stack: x, id: E, glyph: T } of m)
                        void 0 === _[x] && (_[x] = {}),
                          void 0 === _[x].glyphs && (_[x].glyphs = {}),
                          (_[x].glyphs[E] = T && {
                            id: T.id,
                            bitmap: T.bitmap.clone(),
                            metrics: T.metrics,
                          }),
                          (_[x].ascender = this.entries[x].ascender),
                          (_[x].descender = this.entries[x].descender);
                      o(null, _);
                    }
                  }
                );
              }
              _doesCharSupportLocalGlyph(i) {
                return (
                  this.localGlyphMode !== nf.none &&
                  (this.localGlyphMode === nf.all
                    ? !!this.localFontFamily
                    : !!this.localFontFamily &&
                      (ot_CJK_Unified_Ideographs(i) ||
                        ot_Hangul_Syllables(i) ||
                        ot_Hiragana(i) ||
                        ot_Katakana(i) ||
                        ot_CJK_Symbols_and_Punctuation(i)))
                );
              }
              _tinySDF(i, o, l) {
                const h = this.localFontFamily;
                if (!h || !this._doesCharSupportLocalGlyph(l)) return;
                let m = i.tinySDF;
                if (!m) {
                  let V = "400";
                  /bold/i.test(o)
                    ? (V = "900")
                    : /medium/i.test(o)
                    ? (V = "500")
                    : /light/i.test(o) && (V = "200"),
                    (m = i.tinySDF =
                      new rh.TinySDF({
                        fontFamily: h,
                        fontWeight: V,
                        fontSize: 48,
                        buffer: 6,
                        radius: 16,
                      })),
                    (m.fontWeight = V);
                }
                if (this.localGlyphs[m.fontWeight][l])
                  return this.localGlyphs[m.fontWeight][l];
                const _ = String.fromCharCode(l),
                  {
                    data: x,
                    width: E,
                    height: T,
                    glyphWidth: C,
                    glyphHeight: A,
                    glyphLeft: L,
                    glyphTop: O,
                    glyphAdvance: F,
                  } = m.draw(_);
                return (this.localGlyphs[m.fontWeight][l] = {
                  id: l,
                  bitmap: new Xr({ width: E, height: T }, x),
                  metrics: {
                    width: C / 2,
                    height: A / 2,
                    left: L / 2,
                    top: O / 2 - 27,
                    advance: F / 2,
                    localGlyph: !0,
                  },
                });
              }
            }
            (rh.loadGlyphRange = function (r, i, o, l, h) {
              const m = 256 * i,
                _ = m + 255,
                x = l.transformRequest(
                  l
                    .normalizeGlyphsURL(o)
                    .replace("{fontstack}", r)
                    .replace("{range}", `${m}-${_}`),
                  Bs.Glyphs
                );
              Tl(x, (E, T) => {
                if (E) h(E);
                else if (T) {
                  const C = {},
                    A = new kd(T).readFields(Wv, {});
                  for (const L of A.glyphs) C[L.id] = L;
                  h(null, {
                    glyphs: C,
                    ascender: A.ascender,
                    descender: A.descender,
                  });
                }
              });
            }),
              (rh.TinySDF = class {
                constructor({
                  fontSize: r = 24,
                  buffer: i = 3,
                  radius: o = 8,
                  cutoff: l = 0.25,
                  fontFamily: h = "sans-serif",
                  fontWeight: m = "normal",
                  fontStyle: _ = "normal",
                } = {}) {
                  (this.buffer = i), (this.cutoff = l), (this.radius = o);
                  const x = (this.size = r + 4 * i),
                    E = this._createCanvas(x),
                    T = (this.ctx = E.getContext("2d", {
                      willReadFrequently: !0,
                    }));
                  (T.font = `${_} ${m} ${r}px ${h}`),
                    (T.textBaseline = "alphabetic"),
                    (T.textAlign = "left"),
                    (T.fillStyle = "black"),
                    (this.gridOuter = new Float64Array(x * x)),
                    (this.gridInner = new Float64Array(x * x)),
                    (this.f = new Float64Array(x)),
                    (this.z = new Float64Array(x + 1)),
                    (this.v = new Uint16Array(x));
                }
                _createCanvas(r) {
                  const i = document.createElement("canvas");
                  return (i.width = i.height = r), i;
                }
                draw(r) {
                  const {
                      width: i,
                      actualBoundingBoxAscent: o,
                      actualBoundingBoxDescent: l,
                      actualBoundingBoxLeft: h,
                      actualBoundingBoxRight: m,
                    } = this.ctx.measureText(r),
                    _ = Math.ceil(o),
                    x = Math.max(
                      0,
                      Math.min(this.size - this.buffer, Math.ceil(m - h))
                    ),
                    E = Math.min(this.size - this.buffer, _ + Math.ceil(l)),
                    T = x + 2 * this.buffer,
                    C = E + 2 * this.buffer,
                    A = Math.max(T * C, 0),
                    L = new Uint8ClampedArray(A),
                    O = {
                      data: L,
                      width: T,
                      height: C,
                      glyphWidth: x,
                      glyphHeight: E,
                      glyphTop: _,
                      glyphLeft: 0,
                      glyphAdvance: i,
                    };
                  if (0 === x || 0 === E) return O;
                  const {
                    ctx: F,
                    buffer: V,
                    gridInner: G,
                    gridOuter: K,
                  } = this;
                  F.clearRect(V, V, x, E), F.fillText(r, V, V + _);
                  const oe = F.getImageData(V, V, x, E);
                  K.fill(Nd, 0, A), G.fill(0, 0, A);
                  for (let J = 0; J < E; J++)
                    for (let re = 0; re < x; re++) {
                      const le = oe.data[4 * (J * x + re) + 3] / 255;
                      if (0 === le) continue;
                      const ae = (J + V) * T + re + V;
                      if (1 === le) (K[ae] = 0), (G[ae] = Nd);
                      else {
                        const De = 0.5 - le;
                        (K[ae] = De > 0 ? De * De : 0),
                          (G[ae] = De < 0 ? De * De : 0);
                      }
                    }
                  W_(K, 0, 0, T, C, T, this.f, this.v, this.z),
                    W_(G, V, V, x, E, T, this.f, this.v, this.z);
                  for (let J = 0; J < A; J++) {
                    const re = Math.sqrt(K[J]) - Math.sqrt(G[J]);
                    L[J] = Math.round(
                      255 - 255 * (re / this.radius + this.cutoff)
                    );
                  }
                  return O;
                }
              });
            function X_(r, i, o, l) {
              const h = [],
                m = r.image,
                _ = m.pixelRatio,
                x = m.paddedRect.w - 2,
                E = m.paddedRect.h - 2,
                T = r.right - r.left,
                C = r.bottom - r.top,
                A = m.stretchX || [[0, x]],
                L = m.stretchY || [[0, E]],
                O = (Ce, Fe) => Ce + Fe[1] - Fe[0],
                F = A.reduce(O, 0),
                V = L.reduce(O, 0),
                G = x - F,
                K = E - V;
              let oe = 0,
                J = F,
                re = 0,
                le = V,
                ae = 0,
                De = G,
                xe = 0,
                Pe = K;
              if (m.content && l) {
                const Ce = m.content;
                (oe = Ut(A, 0, Ce[0])),
                  (re = Ut(L, 0, Ce[1])),
                  (J = Ut(A, Ce[0], Ce[2])),
                  (le = Ut(L, Ce[1], Ce[3])),
                  (ae = Ce[0] - oe),
                  (xe = Ce[1] - re),
                  (De = Ce[2] - Ce[0] - J),
                  (Pe = Ce[3] - Ce[1] - le);
              }
              const $e = (Ce, Fe, Re, Ve) => {
                const qe = zd(Ce.stretch - oe, J, T, r.left),
                  Me = Bd(Ce.fixed - ae, De, Ce.stretch, F),
                  Je = zd(Fe.stretch - re, le, C, r.top),
                  ut = Bd(Fe.fixed - xe, Pe, Fe.stretch, V),
                  nt = zd(Re.stretch - oe, J, T, r.left),
                  Mt = Bd(Re.fixed - ae, De, Re.stretch, F),
                  Ke = zd(Ve.stretch - re, le, C, r.top),
                  yt = Bd(Ve.fixed - xe, Pe, Ve.stretch, V),
                  Ct = new et(qe, Je),
                  Zt = new et(nt, Je),
                  It = new et(nt, Ke),
                  xt = new et(qe, Ke),
                  Dn = new et(Me / _, ut / _),
                  Rt = new et(Mt / _, yt / _),
                  At = (i * Math.PI) / 180;
                if (At) {
                  const Nn = Math.sin(At),
                    gn = Math.cos(At),
                    Wn = [gn, -Nn, Nn, gn];
                  Ct._matMult(Wn),
                    Zt._matMult(Wn),
                    xt._matMult(Wn),
                    It._matMult(Wn);
                }
                const An = Ce.stretch + Ce.fixed,
                  Fn = Fe.stretch + Fe.fixed;
                return {
                  tl: Ct,
                  tr: Zt,
                  bl: xt,
                  br: It,
                  tex: {
                    x: m.paddedRect.x + 1 + An,
                    y: m.paddedRect.y + 1 + Fn,
                    w: Re.stretch + Re.fixed - An,
                    h: Ve.stretch + Ve.fixed - Fn,
                  },
                  writingMode: void 0,
                  glyphOffset: [0, 0],
                  sectionIndex: 0,
                  pixelOffsetTL: Dn,
                  pixelOffsetBR: Rt,
                  minFontScaleX: De / _ / T,
                  minFontScaleY: Pe / _ / C,
                  isSDF: o,
                };
              };
              if (l && (m.stretchX || m.stretchY)) {
                const Ce = Hi(A, G, F),
                  Fe = Hi(L, K, V);
                for (let Re = 0; Re < Ce.length - 1; Re++) {
                  const Ve = Ce[Re],
                    qe = Ce[Re + 1];
                  for (let Me = 0; Me < Fe.length - 1; Me++)
                    h.push($e(Ve, Fe[Me], qe, Fe[Me + 1]));
                }
              } else h.push($e({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: x + 1 }, { fixed: 0, stretch: E + 1 }));
              return h;
            }
            function Ut(r, i, o) {
              let l = 0;
              for (const h of r)
                l +=
                  Math.max(i, Math.min(o, h[1])) -
                  Math.max(i, Math.min(o, h[0]));
              return l;
            }
            function Hi(r, i, o) {
              const l = [{ fixed: -1, stretch: 0 }];
              for (const [h, m] of r) {
                const _ = l[l.length - 1];
                l.push({ fixed: h - _.stretch, stretch: _.stretch }),
                  l.push({
                    fixed: h - _.stretch,
                    stretch: _.stretch + (m - h),
                  });
              }
              return l.push({ fixed: i + 1, stretch: o }), l;
            }
            function zd(r, i, o, l) {
              return (r / i) * o + l;
            }
            function Bd(r, i, o, l) {
              return r - (i * o) / l;
            }
            function Jv(r, i, o, l) {
              const h = i + r.positionedLines[l].lineOffset;
              return 0 === l
                ? o + h / 2
                : o + (h + (i + r.positionedLines[l - 1].lineOffset)) / 2;
            }
            class e0 {
              constructor(i = [], o = K_) {
                if (
                  ((this.data = i),
                  (this.length = this.data.length),
                  (this.compare = o),
                  this.length > 0)
                )
                  for (let l = (this.length >> 1) - 1; l >= 0; l--)
                    this._down(l);
              }
              push(i) {
                this.data.push(i), this.length++, this._up(this.length - 1);
              }
              pop() {
                if (0 === this.length) return;
                const i = this.data[0],
                  o = this.data.pop();
                return (
                  this.length--,
                  this.length > 0 && ((this.data[0] = o), this._down(0)),
                  i
                );
              }
              peek() {
                return this.data[0];
              }
              _up(i) {
                const { data: o, compare: l } = this,
                  h = o[i];
                for (; i > 0; ) {
                  const m = (i - 1) >> 1,
                    _ = o[m];
                  if (l(h, _) >= 0) break;
                  (o[i] = _), (i = m);
                }
                o[i] = h;
              }
              _down(i) {
                const { data: o, compare: l } = this,
                  h = this.length >> 1,
                  m = o[i];
                for (; i < h; ) {
                  let _ = 1 + (i << 1),
                    x = o[_];
                  const E = _ + 1;
                  if (
                    (E < this.length && l(o[E], x) < 0 && ((_ = E), (x = o[E])),
                    l(x, m) >= 0)
                  )
                    break;
                  (o[i] = x), (i = _);
                }
                o[i] = m;
              }
            }
            function K_(r, i) {
              return r < i ? -1 : r > i ? 1 : 0;
            }
            function t0(r, i = 1, o = !1) {
              let l = 1 / 0,
                h = 1 / 0,
                m = -1 / 0,
                _ = -1 / 0;
              const x = r[0];
              for (let O = 0; O < x.length; O++) {
                const F = x[O];
                (!O || F.x < l) && (l = F.x),
                  (!O || F.y < h) && (h = F.y),
                  (!O || F.x > m) && (m = F.x),
                  (!O || F.y > _) && (_ = F.y);
              }
              const E = Math.min(m - l, _ - h);
              let T = E / 2;
              const C = new e0([], Y_);
              if (0 === E) return new et(l, h);
              for (let O = l; O < m; O += E)
                for (let F = h; F < _; F += E)
                  C.push(new sh(O + T, F + T, T, r));
              let A = (function (O) {
                  let F = 0,
                    V = 0,
                    G = 0;
                  const K = O[0];
                  for (
                    let oe = 0, J = K.length, re = J - 1;
                    oe < J;
                    re = oe++
                  ) {
                    const le = K[oe],
                      ae = K[re],
                      De = le.x * ae.y - ae.x * le.y;
                    (V += (le.x + ae.x) * De),
                      (G += (le.y + ae.y) * De),
                      (F += 3 * De);
                  }
                  return new sh(V / F, G / F, 0, O);
                })(r),
                L = C.length;
              for (; C.length; ) {
                const O = C.pop();
                (O.d > A.d || !A.d) &&
                  ((A = O),
                  o &&
                    console.log(
                      "found best %d after %d probes",
                      Math.round(1e4 * O.d) / 1e4,
                      L
                    )),
                  O.max - A.d <= i ||
                    ((T = O.h / 2),
                    C.push(new sh(O.p.x - T, O.p.y - T, T, r)),
                    C.push(new sh(O.p.x + T, O.p.y - T, T, r)),
                    C.push(new sh(O.p.x - T, O.p.y + T, T, r)),
                    C.push(new sh(O.p.x + T, O.p.y + T, T, r)),
                    (L += 4));
              }
              return (
                o &&
                  (console.log(`num probes: ${L}`),
                  console.log(`best distance: ${A.d}`)),
                A.p
              );
            }
            function Y_(r, i) {
              return i.max - r.max;
            }
            class sh {
              constructor(i, o, l, h) {
                (this.p = new et(i, o)),
                  (this.h = l),
                  (this.d = (function (m, _) {
                    let x = !1,
                      E = 1 / 0;
                    for (let T = 0; T < _.length; T++) {
                      const C = _[T];
                      for (let A = 0, L = C.length, O = L - 1; A < L; O = A++) {
                        const F = C[A],
                          V = C[O];
                        F.y > m.y != V.y > m.y &&
                          m.x <
                            ((V.x - F.x) * (m.y - F.y)) / (V.y - F.y) + F.x &&
                          (x = !x),
                          (E = Math.min(E, Sv(m, F, V)));
                      }
                    }
                    return (x ? 1 : -1) * Math.sqrt(E);
                  })(this.p, h)),
                  (this.max = this.d + this.h * Math.SQRT2);
              }
            }
            const Q_ = Number.POSITIVE_INFINITY,
              J_ = Math.sqrt(2);
            function qm(r, [i, o]) {
              let l = 0,
                h = 0;
              if (o === Q_) {
                i < 0 && (i = 0);
                const m = i / J_;
                switch (r) {
                  case "top-right":
                  case "top-left":
                    h = m - 7;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                    h = 7 - m;
                    break;
                  case "bottom":
                    h = 7 - i;
                    break;
                  case "top":
                    h = i - 7;
                }
                switch (r) {
                  case "top-right":
                  case "bottom-right":
                    l = -m;
                    break;
                  case "top-left":
                  case "bottom-left":
                    l = m;
                    break;
                  case "left":
                    l = i;
                    break;
                  case "right":
                    l = -i;
                }
              } else {
                switch (((i = Math.abs(i)), (o = Math.abs(o)), r)) {
                  case "top-right":
                  case "top-left":
                  case "top":
                    h = o - 7;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                  case "bottom":
                    h = 7 - o;
                }
                switch (r) {
                  case "top-right":
                  case "bottom-right":
                  case "right":
                    l = -i;
                    break;
                  case "top-left":
                  case "bottom-left":
                  case "left":
                    l = i;
                }
              }
              return [l, h];
            }
            function Hc(r, i, o, l, h, m, _, x, E, T) {
              r.createArrays(),
                (r.tilePixelRatio = vt / (512 * r.overscaling)),
                (r.compareText = {}),
                (r.iconsNeedLinear = !1);
              const C = r.layers[0].layout,
                A = r.layers[0]._unevaluatedLayout._values,
                L = {};
              if ("composite" === r.textSizeData.kind) {
                const { minZoom: V, maxZoom: G } = r.textSizeData;
                L.compositeTextSizes = [
                  A["text-size"].possiblyEvaluate(new M(V), x),
                  A["text-size"].possiblyEvaluate(new M(G), x),
                ];
              }
              if ("composite" === r.iconSizeData.kind) {
                const { minZoom: V, maxZoom: G } = r.iconSizeData;
                L.compositeIconSizes = [
                  A["icon-size"].possiblyEvaluate(new M(V), x),
                  A["icon-size"].possiblyEvaluate(new M(G), x),
                ];
              }
              (L.layoutTextSize = A["text-size"].possiblyEvaluate(
                new M(E + 1),
                x
              )),
                (L.layoutIconSize = A["icon-size"].possiblyEvaluate(
                  new M(E + 1),
                  x
                )),
                (L.textMaxSize = A["text-size"].possiblyEvaluate(new M(18), x));
              const O =
                  "map" === C.get("text-rotation-alignment") &&
                  "point" !== C.get("symbol-placement"),
                F = C.get("text-size");
              for (const V of r.features) {
                const G = C.get("text-font").evaluate(V, {}, x).join(","),
                  K = F.evaluate(V, {}, x),
                  oe = L.layoutTextSize.evaluate(V, {}, x),
                  J =
                    (L.layoutIconSize.evaluate(V, {}, x),
                    { horizontal: {}, vertical: void 0 }),
                  re = V.text;
                let le,
                  ae = [0, 0];
                if (re) {
                  const Pe = re.toString(),
                    $e = 24 * C.get("text-letter-spacing").evaluate(V, {}, x),
                    Ce = 24 * C.get("text-line-height").evaluate(V, {}, x),
                    Fe = $f(Pe) ? $e : 0,
                    Re = C.get("text-anchor").evaluate(V, {}, x),
                    Ve = C.get("text-variable-anchor");
                  if (!Ve) {
                    const nt = C.get("text-radial-offset").evaluate(V, {}, x);
                    ae = nt
                      ? qm(Re, [24 * nt, Q_])
                      : C.get("text-offset")
                          .evaluate(V, {}, x)
                          .map((Mt) => 24 * Mt);
                  }
                  let qe = O
                    ? "center"
                    : C.get("text-justify").evaluate(V, {}, x);
                  const Me = "point" === C.get("symbol-placement"),
                    Je = Me
                      ? 24 * C.get("text-max-width").evaluate(V, {}, x)
                      : 1 / 0,
                    ut = (nt) => {
                      r.allowVerticalPlacement &&
                        Qh(Pe) &&
                        (J.vertical = Vm(
                          re,
                          i,
                          o,
                          h,
                          G,
                          Je,
                          Ce,
                          Re,
                          nt,
                          Fe,
                          ae,
                          Po.vertical,
                          !0,
                          oe,
                          K
                        ));
                    };
                  if (!O && Ve) {
                    const nt = "auto" === qe ? Ve.map((Ke) => Wm(Ke)) : [qe];
                    let Mt = !1;
                    for (let Ke = 0; Ke < nt.length; Ke++) {
                      const yt = nt[Ke];
                      if (!J.horizontal[yt])
                        if (Mt) J.horizontal[yt] = J.horizontal[0];
                        else {
                          const Ct = Vm(
                            re,
                            i,
                            o,
                            h,
                            G,
                            Je,
                            Ce,
                            "center",
                            yt,
                            Fe,
                            ae,
                            Po.horizontal,
                            !1,
                            oe,
                            K
                          );
                          Ct &&
                            ((J.horizontal[yt] = Ct),
                            (Mt = 1 === Ct.positionedLines.length));
                        }
                    }
                    ut("left");
                  } else {
                    if (
                      ("auto" === qe && (qe = Wm(Re)),
                      Me ||
                        C.get("text-writing-mode").indexOf("horizontal") >= 0 ||
                        !Qh(Pe))
                    ) {
                      const nt = Vm(
                        re,
                        i,
                        o,
                        h,
                        G,
                        Je,
                        Ce,
                        Re,
                        qe,
                        Fe,
                        ae,
                        Po.horizontal,
                        !1,
                        oe,
                        K
                      );
                      nt && (J.horizontal[qe] = nt);
                    }
                    ut(Me ? "left" : qe);
                  }
                }
                let De = !1;
                if (V.icon && V.icon.name) {
                  const Pe = l[V.icon.name];
                  Pe &&
                    ((le = Ab(
                      h[V.icon.name],
                      C.get("icon-offset").evaluate(V, {}, x),
                      C.get("icon-anchor").evaluate(V, {}, x)
                    )),
                    (De = Pe.sdf),
                    void 0 === r.sdfIcons
                      ? (r.sdfIcons = Pe.sdf)
                      : r.sdfIcons !== Pe.sdf &&
                        Hn(
                          "Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"
                        ),
                    (Pe.pixelRatio !== r.pixelRatio ||
                      0 !== C.get("icon-rotate").constantOr(1)) &&
                      (r.iconsNeedLinear = !0));
                }
                const xe = r0(J.horizontal) || J.vertical;
                r.iconsInText || (r.iconsInText = !!xe && xe.iconsInText),
                  (xe || le) && Zm(r, V, J, le, l, L, oe, 0, ae, De, _, x, T);
              }
              m && r.generateCollisionDebugBuffers(E, r.collisionBoxArray);
            }
            function Wm(r) {
              switch (r) {
                case "right":
                case "top-right":
                case "bottom-right":
                  return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                  return "left";
              }
              return "center";
            }
            function Zm(r, i, o, l, h, m, _, x, E, T, C, A, L) {
              let O = m.textMaxSize.evaluate(i, {}, A);
              void 0 === O && (O = _);
              const F = r.layers[0].layout,
                V = F.get("icon-offset").evaluate(i, {}, A),
                G = r0(o.horizontal) || o.vertical,
                K = "globe" === L.name,
                J = _ / 24,
                re = (r.tilePixelRatio * O) / 24,
                le =
                  ((Re = r.overscaling),
                  r.zoom > 18 && Re > 2 && (Re >>= 1),
                  Math.max(vt / (512 * Re), 1) * F.get("symbol-spacing")),
                ae = F.get("text-padding") * r.tilePixelRatio,
                De = F.get("icon-padding") * r.tilePixelRatio,
                xe = Xt(F.get("text-max-angle")),
                Pe =
                  "map" === F.get("text-rotation-alignment") &&
                  "point" !== F.get("symbol-placement"),
                $e =
                  "map" === F.get("icon-rotation-alignment") &&
                  "point" !== F.get("symbol-placement"),
                Ce = F.get("symbol-placement"),
                Fe = le / 2;
              var Re;
              const Ve = F.get("icon-text-fit");
              let qe;
              l &&
                "none" !== Ve &&
                (r.allowVerticalPlacement &&
                  o.vertical &&
                  (qe = Um(
                    l,
                    o.vertical,
                    Ve,
                    F.get("icon-text-fit-padding"),
                    V,
                    J
                  )),
                G && (l = Um(l, G, Ve, F.get("icon-text-fit-padding"), V, J)));
              const Me = (Je, ut, nt) => {
                if (ut.x < 0 || ut.x >= vt || ut.y < 0 || ut.y >= vt) return;
                let Mt = null;
                if (K) {
                  const {
                    x: Ke,
                    y: yt,
                    z: Ct,
                  } = L.projectTilePoint(ut.x, ut.y, nt);
                  Mt = {
                    anchor: new Zl(Ke, yt, Ct, 0, void 0),
                    up: L.upVector(nt, ut.x, ut.y),
                  };
                }
                !(function (
                  Ke,
                  yt,
                  Ct,
                  Zt,
                  It,
                  xt,
                  Dn,
                  Rt,
                  At,
                  An,
                  Fn,
                  Nn,
                  gn,
                  Wn,
                  oi,
                  yi,
                  zn,
                  Di,
                  vi,
                  Yn,
                  cn,
                  si,
                  Bn,
                  cr,
                  xi
                ) {
                  const Qi = Ke.addToLineVertexArray(yt, Zt);
                  let Gi,
                    zr,
                    qi,
                    Ds,
                    ul,
                    Ss,
                    gf,
                    ph = 0,
                    py = 0,
                    fy = 0,
                    _f = 0,
                    hg = -1,
                    Jo = -1;
                  const co = {};
                  let Tr = jl("");
                  const Lo = Ct ? Ct.anchor : yt;
                  let fh = 0,
                    uo = 0;
                  if (
                    (void 0 ===
                    At._unevaluatedLayout.getValue("text-radial-offset")
                      ? ([fh, uo] = At.layout
                          .get("text-offset")
                          .evaluate(cn, {}, xi)
                          .map((Ji) => 24 * Ji))
                      : ((fh =
                          24 *
                          At.layout
                            .get("text-radial-offset")
                            .evaluate(cn, {}, xi)),
                        (uo = Q_)),
                    Ke.allowVerticalPlacement && It.vertical)
                  ) {
                    const Ji = It.vertical;
                    if (oi) (Ss = Km(Ji)), Rt && (gf = Km(Rt));
                    else {
                      const er =
                        At.layout.get("text-rotate").evaluate(cn, {}, xi) + 90;
                      (qi = Xm(An, Lo, yt, Fn, Nn, gn, Ji, Wn, er, yi)),
                        Rt && (Ds = Xm(An, Lo, yt, Fn, Nn, gn, Rt, Di, er));
                    }
                  }
                  if (xt) {
                    const Ji = At.layout
                        .get("icon-rotate")
                        .evaluate(cn, {}, xi),
                      er = "none" !== At.layout.get("icon-text-fit"),
                      va = X_(xt, Ji, Bn, er),
                      Jl = Rt ? X_(Rt, Ji, Bn, er) : void 0;
                    (zr = Xm(An, Lo, yt, Fn, Nn, gn, xt, Di, Ji)),
                      (ph = 4 * va.length);
                    const Qc = Ke.iconSizeData;
                    let es = null;
                    "source" === Qc.kind
                      ? ((es = [
                          ys * At.layout.get("icon-size").evaluate(cn, {}, xi),
                        ]),
                        es[0] > Xl &&
                          Hn(
                            `${Ke.layerIds[0]}: Value for "icon-size" is >= ${Gc}. Reduce your "icon-size".`
                          ))
                      : "composite" === Qc.kind &&
                        ((es = [
                          ys * si.compositeIconSizes[0].evaluate(cn, {}, xi),
                          ys * si.compositeIconSizes[1].evaluate(cn, {}, xi),
                        ]),
                        (es[0] > Xl || es[1] > Xl) &&
                          Hn(
                            `${Ke.layerIds[0]}: Value for "icon-size" is >= ${Gc}. Reduce your "icon-size".`
                          )),
                      Ke.addSymbols(
                        Ke.icon,
                        va,
                        es,
                        Yn,
                        vi,
                        cn,
                        !1,
                        Ct,
                        yt,
                        Qi.lineStartIndex,
                        Qi.lineLength,
                        -1,
                        cr,
                        xi
                      ),
                      (hg = Ke.icon.placedSymbolArray.length - 1),
                      Jl &&
                        ((py = 4 * Jl.length),
                        Ke.addSymbols(
                          Ke.icon,
                          Jl,
                          es,
                          Yn,
                          vi,
                          cn,
                          Po.vertical,
                          Ct,
                          yt,
                          Qi.lineStartIndex,
                          Qi.lineLength,
                          -1,
                          cr,
                          xi
                        ),
                        (Jo = Ke.icon.placedSymbolArray.length - 1));
                  }
                  for (const Ji in It.horizontal) {
                    const er = It.horizontal[Ji];
                    Gi ||
                      ((Tr = jl(er.text)),
                      oi
                        ? (ul = Km(er))
                        : (Gi = Xm(
                            An,
                            Lo,
                            yt,
                            Fn,
                            Nn,
                            gn,
                            er,
                            Wn,
                            At.layout.get("text-rotate").evaluate(cn, {}, xi),
                            yi
                          )));
                    const va = 1 === er.positionedLines.length;
                    if (
                      ((fy += n0(
                        Ke,
                        Ct,
                        yt,
                        er,
                        Dn,
                        At,
                        oi,
                        cn,
                        yi,
                        Qi,
                        It.vertical ? Po.horizontal : Po.horizontalOnly,
                        va ? Object.keys(It.horizontal) : [Ji],
                        co,
                        hg,
                        si,
                        cr,
                        xi
                      )),
                      va)
                    )
                      break;
                  }
                  It.vertical &&
                    (_f += n0(
                      Ke,
                      Ct,
                      yt,
                      It.vertical,
                      Dn,
                      At,
                      oi,
                      cn,
                      yi,
                      Qi,
                      Po.vertical,
                      ["vertical"],
                      co,
                      Jo,
                      si,
                      cr,
                      xi
                    ));
                  let Is = -1;
                  const Ql = (Ji, er) => (Ji ? Math.max(Ji, er) : er);
                  (Is = Ql(ul, Is)), (Is = Ql(Ss, Is)), (Is = Ql(gf, Is));
                  const mh = Is > -1 ? 1 : 0;
                  Ke.glyphOffsetArray.length >= fa.MAX_GLYPHS &&
                    Hn(
                      "Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"
                    ),
                    void 0 !== cn.sortKey &&
                      Ke.addToSortKeyRanges(
                        Ke.symbolInstances.length,
                        cn.sortKey
                      ),
                    Ke.symbolInstances.emplaceBack(
                      Lo.x,
                      Lo.y,
                      Lo.z,
                      yt.x,
                      yt.y,
                      co.right >= 0 ? co.right : -1,
                      co.center >= 0 ? co.center : -1,
                      co.left >= 0 ? co.left : -1,
                      co.vertical >= 0 ? co.vertical : -1,
                      hg,
                      Jo,
                      Tr,
                      void 0 !== Gi ? Gi : Ke.collisionBoxArray.length,
                      void 0 !== Gi ? Gi + 1 : Ke.collisionBoxArray.length,
                      void 0 !== qi ? qi : Ke.collisionBoxArray.length,
                      void 0 !== qi ? qi + 1 : Ke.collisionBoxArray.length,
                      void 0 !== zr ? zr : Ke.collisionBoxArray.length,
                      void 0 !== zr ? zr + 1 : Ke.collisionBoxArray.length,
                      Ds || Ke.collisionBoxArray.length,
                      Ds ? Ds + 1 : Ke.collisionBoxArray.length,
                      Fn,
                      fy,
                      _f,
                      ph,
                      py,
                      mh,
                      0,
                      fh,
                      uo,
                      Is
                    );
                })(
                  r,
                  ut,
                  Mt,
                  Je,
                  o,
                  l,
                  h,
                  qe,
                  r.layers[0],
                  r.collisionBoxArray,
                  i.index,
                  i.sourceLayerIndex,
                  r.index,
                  ae,
                  Pe,
                  E,
                  0,
                  De,
                  $e,
                  V,
                  i,
                  m,
                  T,
                  C,
                  A
                );
              };
              if ("line" === Ce)
                for (const Je of Gm(i.geometry, 0, 0, vt, vt)) {
                  const ut = vs(
                    Je,
                    le,
                    xe,
                    o.vertical || G,
                    l,
                    24,
                    re,
                    r.overscaling,
                    vt
                  );
                  for (const nt of ut)
                    (G && ey(r, G.text, Fe, nt)) || Me(Je, nt, A);
                }
              else if ("line-center" === Ce) {
                for (const Je of i.geometry)
                  if (Je.length > 1) {
                    const ut = Qv(Je, xe, o.vertical || G, l, 24, re);
                    ut && Me(Je, ut, A);
                  }
              } else if ("Polygon" === i.type)
                for (const Je of Gp(i.geometry, 0)) {
                  const ut = t0(Je, 16);
                  Me(Je[0], new Zl(ut.x, ut.y, 0, 0, void 0), A);
                }
              else if ("LineString" === i.type)
                for (const Je of i.geometry)
                  Me(Je, new Zl(Je[0].x, Je[0].y, 0, 0, void 0), A);
              else if ("Point" === i.type)
                for (const Je of i.geometry)
                  for (const ut of Je)
                    Me([ut], new Zl(ut.x, ut.y, 0, 0, void 0), A);
            }
            const Gc = 255,
              Xl = Gc * ys;
            function n0(r, i, o, l, h, m, _, x, E, T, C, A, L, O, F, V, G) {
              const K = (function (re, le, ae, De, xe, Pe, $e, Ce) {
                  const Fe = [];
                  if (0 === le.positionedLines.length) return Fe;
                  const Re =
                      (De.layout.get("text-rotate").evaluate(Pe, {}) *
                        Math.PI) /
                      180,
                    Ve = (function (nt) {
                      const Mt = nt[0],
                        Ke = nt[1],
                        yt = Mt * Ke;
                      return yt > 0
                        ? [Mt, -Ke]
                        : yt < 0
                        ? [-Mt, Ke]
                        : 0 === Mt
                        ? [Ke, Mt]
                        : [Ke, -Mt];
                    })(ae);
                  let qe = Math.abs(le.top - le.bottom);
                  for (const nt of le.positionedLines) qe -= nt.lineOffset;
                  const Me = le.positionedLines.length,
                    Je = qe / Me;
                  let ut = le.top - ae[1];
                  for (let nt = 0; nt < Me; ++nt) {
                    const Mt = le.positionedLines[nt];
                    ut = Jv(le, Je, ut, nt);
                    for (const Ke of Mt.positionedGlyphs) {
                      if (!Ke.rect) continue;
                      const yt = Ke.rect || {};
                      let Ct = 4,
                        Zt = !0,
                        It = 1,
                        xt = 0;
                      if (Ke.imageName) {
                        const Bn = $e[Ke.imageName];
                        if (!Bn) continue;
                        if (Bn.sdf) {
                          Hn(
                            "SDF images are not supported in formatted text and will be ignored."
                          );
                          continue;
                        }
                        (Zt = !1), (It = Bn.pixelRatio), (Ct = 1 / It);
                      }
                      const Dn = (xe || Ce) && Ke.vertical,
                        Rt = (Ke.metrics.advance * Ke.scale) / 2,
                        At = Ke.metrics,
                        An = Ke.rect;
                      if (null === An) continue;
                      Ce &&
                        le.verticalizable &&
                        (xt = Ke.imageName
                          ? Rt - (Ke.metrics.width * Ke.scale) / 2
                          : 0);
                      const Fn = xe ? [Ke.x + Rt, Ke.y] : [0, 0];
                      let Nn = [0, 0],
                        gn = [0, 0],
                        Wn = !1;
                      xe ||
                        (Dn
                          ? ((gn = [Ke.x + Rt + Ve[0], Ke.y + Ve[1] - xt]),
                            (Wn = !0))
                          : (Nn = [Ke.x + Rt + ae[0], Ke.y + ae[1] - xt]));
                      const oi =
                          (An.w * Ke.scale) / (It * (Ke.localGlyph ? 2 : 1)),
                        yi = (An.h * Ke.scale) / (It * (Ke.localGlyph ? 2 : 1));
                      let zn, Di, vi, Yn;
                      if (Dn) {
                        const Bn = Ke.y - ut,
                          cr = new et(-Rt, Rt - Bn),
                          xi = -Math.PI / 2,
                          Qi = new et(...gn);
                        (zn = new et(-Rt + Nn[0], Nn[1])),
                          zn._rotateAround(xi, cr)._add(Qi),
                          (zn.x += -Bn + Rt),
                          (zn.y -= (At.left - Ct) * Ke.scale);
                        const Gi = Ke.imageName
                            ? At.advance * Ke.scale
                            : 24 * Ke.scale,
                          zr = String.fromCharCode(Ke.glyph);
                        k_(zr)
                          ? (zn.x += (1 - Ct) * Ke.scale)
                          : Om(zr)
                          ? (zn.x +=
                              Gi - At.height * Ke.scale + (-Ct - 1) * Ke.scale)
                          : (zn.x +=
                              Ke.imageName ||
                              (At.width + 2 * Ct === An.w &&
                                At.height + 2 * Ct === An.h)
                                ? (Gi - yi) / 2
                                : (Gi - (At.height + 2 * Ct) * Ke.scale) / 2),
                          (Di = new et(zn.x, zn.y - oi)),
                          (vi = new et(zn.x + yi, zn.y)),
                          (Yn = new et(zn.x + yi, zn.y - oi));
                      } else {
                        const Bn = (At.left - Ct) * Ke.scale - Rt + Nn[0],
                          cr = (-At.top - Ct) * Ke.scale + Nn[1],
                          xi = Bn + oi,
                          Qi = cr + yi;
                        (zn = new et(Bn, cr)),
                          (Di = new et(xi, cr)),
                          (vi = new et(Bn, Qi)),
                          (Yn = new et(xi, Qi));
                      }
                      if (Re) {
                        let Bn;
                        (Bn = xe
                          ? new et(0, 0)
                          : Wn
                          ? new et(Ve[0], Ve[1])
                          : new et(ae[0], ae[1])),
                          zn._rotateAround(Re, Bn),
                          Di._rotateAround(Re, Bn),
                          vi._rotateAround(Re, Bn),
                          Yn._rotateAround(Re, Bn);
                      }
                      const cn = new et(0, 0),
                        si = new et(0, 0);
                      Fe.push({
                        tl: zn,
                        tr: Di,
                        bl: vi,
                        br: Yn,
                        tex: yt,
                        writingMode: le.writingMode,
                        glyphOffset: Fn,
                        sectionIndex: Ke.sectionIndex,
                        isSDF: Zt,
                        pixelOffsetTL: cn,
                        pixelOffsetBR: si,
                        minFontScaleX: 0,
                        minFontScaleY: 0,
                      });
                    }
                  }
                  return Fe;
                })(0, l, E, m, _, x, h, r.allowVerticalPlacement),
                oe = r.textSizeData;
              let J = null;
              "source" === oe.kind
                ? ((J = [ys * m.layout.get("text-size").evaluate(x, {}, G)]),
                  J[0] > Xl &&
                    Hn(
                      `${r.layerIds[0]}: Value for "text-size" is >= ${Gc}. Reduce your "text-size".`
                    ))
                : "composite" === oe.kind &&
                  ((J = [
                    ys * F.compositeTextSizes[0].evaluate(x, {}, G),
                    ys * F.compositeTextSizes[1].evaluate(x, {}, G),
                  ]),
                  (J[0] > Xl || J[1] > Xl) &&
                    Hn(
                      `${r.layerIds[0]}: Value for "text-size" is >= ${Gc}. Reduce your "text-size".`
                    )),
                r.addSymbols(
                  r.text,
                  K,
                  J,
                  E,
                  _,
                  x,
                  C,
                  i,
                  o,
                  T.lineStartIndex,
                  T.lineLength,
                  O,
                  V,
                  G
                );
              for (const re of A) L[re] = r.text.placedSymbolArray.length - 1;
              return 4 * K.length;
            }
            function r0(r) {
              for (const i in r) return r[i];
              return null;
            }
            function Xm(r, i, o, l, h, m, _, x, E, T) {
              let C = _.top,
                A = _.bottom,
                L = _.left,
                O = _.right;
              const F = _.collisionPadding;
              if (
                (F && ((L -= F[0]), (C -= F[1]), (O += F[2]), (A += F[3])), E)
              ) {
                const V = new et(L, C),
                  G = new et(O, C),
                  K = new et(L, A),
                  oe = new et(O, A),
                  J = Xt(E);
                let re = new et(0, 0);
                T && (re = new et(T[0], T[1])),
                  V._rotateAround(J, re),
                  G._rotateAround(J, re),
                  K._rotateAround(J, re),
                  oe._rotateAround(J, re),
                  (L = Math.min(V.x, G.x, K.x, oe.x)),
                  (O = Math.max(V.x, G.x, K.x, oe.x)),
                  (C = Math.min(V.y, G.y, K.y, oe.y)),
                  (A = Math.max(V.y, G.y, K.y, oe.y));
              }
              return (
                r.emplaceBack(i.x, i.y, i.z, o.x, o.y, L, C, O, A, x, l, h, m),
                r.length - 1
              );
            }
            function Km(r) {
              r.collisionPadding &&
                ((r.top -= r.collisionPadding[1]),
                (r.bottom += r.collisionPadding[3]));
              const i = r.bottom - r.top;
              return i > 0 ? Math.max(10, i) : null;
            }
            function ey(r, i, o, l) {
              const h = r.compareText;
              if (i in h) {
                const m = h[i];
                for (let _ = m.length - 1; _ >= 0; _--)
                  if (l.dist(m[_]) < o) return !0;
              } else h[i] = [];
              return h[i].push(l), !1;
            }
            function o0(r, i) {
              const o = r.fovAboveCenter,
                l = r.elevation ? r.elevation.getMinElevationBelowMSL() * i : 0,
                h =
                  (r._camera.position[2] * r.worldSize - l) /
                  Math.cos(r._pitch),
                m =
                  (Math.sin(o) * h) /
                  Math.sin(Math.max(Math.PI / 2 - r._pitch - o, 0.01)),
                _ = Math.sin(r._pitch) * m + h;
              return Math.min(1.01 * _, h * (1 / r._horizonShift));
            }
            function qc(r, i) {
              if (!i.isReprojectedInTileSpace)
                return {
                  scale: 1 << r.z,
                  x: r.x,
                  y: r.y,
                  x2: r.x + 1,
                  y2: r.y + 1,
                  projection: i,
                };
              const o = Math.pow(2, -r.z),
                l = r.x * o,
                h = (r.x + 1) * o,
                m = r.y * o,
                _ = (r.y + 1) * o,
                x = so(l),
                E = so(h),
                T = $i(m),
                C = $i(_),
                A = i.project(x, T),
                L = i.project(E, T),
                O = i.project(E, C),
                F = i.project(x, C);
              let V = Math.min(A.x, L.x, O.x, F.x),
                G = Math.min(A.y, L.y, O.y, F.y),
                K = Math.max(A.x, L.x, O.x, F.x),
                oe = Math.max(A.y, L.y, O.y, F.y);
              const J = o / 16;
              function re(ae, De, xe, Pe, $e, Ce) {
                const Fe = (xe + $e) / 2,
                  Re = (Pe + Ce) / 2,
                  Ve = i.project(so(Fe), $i(Re)),
                  qe = Math.max(0, V - Ve.x, G - Ve.y, Ve.x - K, Ve.y - oe);
                (V = Math.min(V, Ve.x)),
                  (K = Math.max(K, Ve.x)),
                  (G = Math.min(G, Ve.y)),
                  (oe = Math.max(oe, Ve.y)),
                  qe > J &&
                    (re(ae, Ve, xe, Pe, Fe, Re), re(Ve, De, Fe, Re, $e, Ce));
              }
              re(A, L, l, m, h, m),
                re(L, O, h, m, h, _),
                re(O, F, h, _, l, _),
                re(F, A, l, _, l, m),
                (V -= J),
                (G -= J),
                (K += J),
                (oe += J);
              const le = 1 / Math.max(K - V, oe - G);
              return {
                scale: le,
                x: V * le,
                y: G * le,
                x2: K * le,
                y2: oe * le,
                projection: i,
              };
            }
            const lh = sa(new Float32Array(16));
            class Kl {
              constructor(i) {
                (this.spec = i),
                  (this.name = i.name),
                  (this.wrap = !1),
                  (this.requiresDraping = !1),
                  (this.supportsWorldCopies = !1),
                  (this.supportsTerrain = !1),
                  (this.supportsFog = !1),
                  (this.supportsFreeCamera = !1),
                  (this.zAxisUnit = "meters"),
                  (this.isReprojectedInTileSpace = !0),
                  (this.unsupportedLayers = ["custom"]),
                  (this.center = [0, 0]),
                  (this.range = [3.5, 7]);
              }
              project(i, o) {
                return { x: 0, y: 0, z: 0 };
              }
              unproject(i, o) {
                return new Mn(0, 0);
              }
              projectTilePoint(i, o, l) {
                return { x: i, y: o, z: 0 };
              }
              locationPoint(i, o, l = !0) {
                return i._coordinatePoint(i.locationCoordinate(o), l);
              }
              pixelsPerMeter(i, o) {
                return Ao(1, i) * o;
              }
              pixelSpaceConversion(i, o, l) {
                return 1;
              }
              farthestPixelDistance(i) {
                return o0(i, i.pixelsPerMeter);
              }
              pointCoordinate(i, o, l, h) {
                const m = i.horizonLineFromTop(!1),
                  _ = new et(o, Math.max(m, l));
                return i.rayIntersectionCoordinate(
                  i.pointRayIntersection(_, h)
                );
              }
              pointCoordinate3D(i, o, l) {
                const h = new et(o, l);
                if (i.elevation) return i.elevation.pointCoordinate(h);
                {
                  const m = this.pointCoordinate(i, h.x, h.y, 0);
                  return [m.x, m.y, m.z];
                }
              }
              isPointAboveHorizon(i, o) {
                if (i.elevation) return !this.pointCoordinate3D(i, o.x, o.y);
                const l = i.horizonLineFromTop();
                return o.y < l;
              }
              createInversionMatrix(i, o) {
                return lh;
              }
              createTileMatrix(i, o, l) {
                let h, m, _;
                const x = l.canonical,
                  E = sa(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                  const T = qc(x, this);
                  (h = 1),
                    (m = T.x + l.wrap * T.scale),
                    (_ = T.y),
                    Oc(E, E, [h / T.scale, h / T.scale, i.pixelsPerMeter / o]);
                } else (h = o / i.zoomScale(x.z)), (m = (x.x + Math.pow(2, x.z) * l.wrap) * h), (_ = x.y * h);
                return id(E, E, [m, _, 0]), Oc(E, E, [h / vt, h / vt, 1]), E;
              }
              upVector(i, o, l) {
                return [0, 0, 1];
              }
              upVectorScale(i, o, l) {
                return { metersToTile: 1 };
              }
            }
            class ty extends Kl {
              constructor(i) {
                super(i),
                  (this.range = [4, 7]),
                  (this.center = i.center || [-96, 37.5]);
                const [o, l] = (this.parallels = i.parallels || [29.5, 45.5]),
                  h = Math.sin(Xt(o));
                (this.n = (h + Math.sin(Xt(l))) / 2),
                  (this.c = 1 + h * (2 * this.n - h)),
                  (this.r0 = Math.sqrt(this.c) / this.n);
              }
              project(i, o) {
                const { n: l, c: h, r0: m } = this,
                  _ = Xt(i - this.center[0]),
                  x = Xt(o),
                  E = Math.sqrt(h - 2 * l * Math.sin(x)) / l;
                return {
                  x: E * Math.sin(_ * l),
                  y: E * Math.cos(_ * l) - m,
                  z: 0,
                };
              }
              unproject(i, o) {
                const { n: l, c: h, r0: m } = this,
                  _ = m + o;
                let x = Math.atan2(i, Math.abs(_)) * Math.sign(_);
                _ * l < 0 && (x -= Math.PI * Math.sign(i) * Math.sign(_));
                const E = Xt(this.center[0]) * l;
                x = bn(x, -Math.PI - E, Math.PI - E);
                const T = Qt(Oi(x / l) + this.center[0], -180, 180),
                  C = Math.asin(
                    Qt((h - (i * i + _ * _) * l * l) / (2 * l), -1, 1)
                  ),
                  A = Qt(Oi(C), -Ti, Ti);
                return new Mn(T, A);
              }
            }
            const Yl = 1.340264,
              Vd = -0.081106,
              ch = 893e-6,
              jd = 0.003796,
              rf = Math.sqrt(3) / 2;
            class s0 extends Kl {
              project(i, o) {
                (o = (o / 180) * Math.PI), (i = (i / 180) * Math.PI);
                const l = Math.asin(rf * Math.sin(o)),
                  h = l * l,
                  m = h * h * h;
                return {
                  x:
                    0.5 *
                    ((i * Math.cos(l)) /
                      (rf * (Yl + 3 * Vd * h + m * (7 * ch + 9 * jd * h))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((l * (Yl + Vd * h + m * (ch + jd * h))) / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(i, o) {
                i = (2 * i - 0.5) * Math.PI;
                let l = (o = (2 * (1 - o) - 1) * Math.PI),
                  h = l * l,
                  m = h * h * h;
                for (
                  let C, A, L, O = 0;
                  O < 12 &&
                  ((A = l * (Yl + Vd * h + m * (ch + jd * h)) - o),
                  (L = Yl + 3 * Vd * h + m * (7 * ch + 9 * jd * h)),
                  (C = A / L),
                  (l = Qt(l - C, -Math.PI / 3, Math.PI / 3)),
                  (h = l * l),
                  (m = h * h * h),
                  !(Math.abs(C) < 1e-12));
                  ++O
                );
                const _ =
                    (rf * i * (Yl + 3 * Vd * h + m * (7 * ch + 9 * jd * h))) /
                    Math.cos(l),
                  x = Math.asin(Math.sin(l) / rf),
                  E = Qt((180 * _) / Math.PI, -180, 180),
                  T = Qt((180 * x) / Math.PI, -Ti, Ti);
                return new Mn(E, T);
              }
            }
            class a0 extends Kl {
              constructor(i) {
                super(i), (this.wrap = !0), (this.supportsWorldCopies = !0);
              }
              project(i, o) {
                return { x: 0.5 + i / 360, y: 0.5 - o / 360, z: 0 };
              }
              unproject(i, o) {
                const l = 360 * (i - 0.5),
                  h = Qt(360 * (0.5 - o), -Ti, Ti);
                return new Mn(l, h);
              }
            }
            const uh = Math.PI / 2;
            function Ud(r) {
              return Math.tan((uh + r) / 2);
            }
            class l0 extends Kl {
              constructor(i) {
                super(i), (this.center = i.center || [0, 30]);
                const [o, l] = (this.parallels = i.parallels || [30, 30]);
                let h = Xt(o),
                  m = Xt(l);
                (this.southernCenter = h + m < 0),
                  this.southernCenter && ((h = -h), (m = -m));
                const _ = Math.cos(h),
                  x = Ud(h);
                (this.n =
                  h === m
                    ? Math.sin(h)
                    : Math.log(_ / Math.cos(m)) / Math.log(Ud(m) / x)),
                  (this.f = (_ * Math.pow(Ud(h), this.n)) / this.n);
              }
              project(i, o) {
                (o = Xt(o)),
                  this.southernCenter && (o = -o),
                  (i = Xt(i - this.center[0]));
                const l = 1e-6,
                  { n: h, f: m } = this;
                m > 0
                  ? o < -uh + l && (o = -uh + l)
                  : o > uh - l && (o = uh - l);
                const _ = m / Math.pow(Ud(o), h);
                let x = _ * Math.sin(h * i),
                  E = m - _ * Math.cos(h * i);
                return (
                  (x = 0.5 * (x / Math.PI + 0.5)),
                  (E = 0.5 * (E / Math.PI + 0.5)),
                  { x, y: this.southernCenter ? E : 1 - E, z: 0 }
                );
              }
              unproject(i, o) {
                (i = (2 * i - 0.5) * Math.PI),
                  this.southernCenter && (o = 1 - o),
                  (o = (2 * (1 - o) - 0.5) * Math.PI);
                const { n: l, f: h } = this,
                  m = h - o,
                  _ = Math.sign(m),
                  x = Math.sign(l) * Math.sqrt(i * i + m * m);
                let E = Math.atan2(i, Math.abs(m)) * _;
                m * l < 0 && (E -= Math.PI * Math.sign(i) * _);
                const T = Qt(Oi(E / l) + this.center[0], -180, 180),
                  C = Qt(
                    Oi(2 * Math.atan(Math.pow(h / x, 1 / l)) - uh),
                    -Ti,
                    Ti
                  );
                return new Mn(T, this.southernCenter ? -C : C);
              }
            }
            class Ym extends Kl {
              constructor(i) {
                super(i),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0),
                  (this.supportsTerrain = !0),
                  (this.supportsFog = !0),
                  (this.supportsFreeCamera = !0),
                  (this.isReprojectedInTileSpace = !1),
                  (this.unsupportedLayers = []),
                  (this.range = null);
              }
              project(i, o) {
                return { x: ua(i), y: ii(o), z: 0 };
              }
              unproject(i, o) {
                const l = so(i),
                  h = $i(o);
                return new Mn(l, h);
              }
            }
            const Qm = Xt(Ti);
            class Jm extends Kl {
              project(i, o) {
                const l = (o = Xt(o)) * o,
                  h = l * l;
                return {
                  x:
                    0.5 *
                    (((i = Xt(i)) *
                      (0.8707 -
                        0.131979 * l +
                        h * (h * (0.003971 * l - 0.001529 * h) - 0.013791))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((o *
                        (1.007226 +
                          l *
                            (0.015085 +
                              h * (0.028874 * l - 0.044475 - 0.005916 * h)))) /
                        Math.PI +
                        1),
                  z: 0,
                };
              }
              unproject(i, o) {
                i = (2 * i - 0.5) * Math.PI;
                let l = (o = (2 * (1 - o) - 1) * Math.PI),
                  h = 25,
                  m = 0,
                  _ = l * l;
                do {
                  _ = l * l;
                  const T = _ * _;
                  (m =
                    (l *
                      (1.007226 +
                        _ *
                          (0.015085 +
                            T * (0.028874 * _ - 0.044475 - 0.005916 * T))) -
                      o) /
                    (1.007226 +
                      _ *
                        (0.045255 +
                          T * (0.259866 * _ - 0.311325 - 0.005916 * 11 * T)))),
                    (l = Qt(l - m, -Qm, Qm));
                } while (Math.abs(m) > 1e-6 && --h > 0);
                _ = l * l;
                const x = Qt(
                    Oi(
                      i /
                        (0.8707 +
                          _ *
                            (_ *
                              (_ * _ * _ * (0.003971 - 0.001529 * _) -
                                0.013791) -
                              0.131979))
                    ),
                    -180,
                    180
                  ),
                  E = Oi(l);
                return new Mn(x, E);
              }
            }
            const c0 = Xt(Ti);
            class eg extends Kl {
              project(i, o) {
                (o = Xt(o)), (i = Xt(i));
                const l = Math.cos(o),
                  h = 2 / Math.PI,
                  m = Math.acos(l * Math.cos(i / 2)),
                  _ = Math.sin(m) / m,
                  x = 0.5 * (i * h + (2 * l * Math.sin(i / 2)) / _) || 0,
                  E = 0.5 * (o + Math.sin(o) / _) || 0;
                return {
                  x: 0.5 * (x / Math.PI + 0.5),
                  y: 1 - 0.5 * (E / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(i, o) {
                let l = (i = (2 * i - 0.5) * Math.PI),
                  h = (o = (2 * (1 - o) - 1) * Math.PI),
                  m = 25;
                const _ = 1e-6;
                let x = 0,
                  E = 0;
                do {
                  const T = Math.cos(h),
                    C = Math.sin(h),
                    A = 2 * C * T,
                    L = C * C,
                    O = T * T,
                    F = Math.cos(l / 2),
                    V = Math.sin(l / 2),
                    G = 2 * F * V,
                    K = V * V,
                    oe = 1 - O * F * F,
                    J = oe ? 1 / oe : 0,
                    re = oe ? Math.acos(T * F) * Math.sqrt(1 / oe) : 0,
                    le = 0.5 * (2 * re * T * V + (2 * l) / Math.PI) - i,
                    ae = 0.5 * (re * C + h) - o,
                    De = 0.5 * J * (O * K + re * T * F * L) + 1 / Math.PI,
                    xe = J * ((G * A) / 4 - re * C * V),
                    Pe = 0.125 * J * (A * V - re * C * O * G),
                    $e = 0.5 * J * (L * F + re * K * T) + 0.5,
                    Ce = xe * Pe - $e * De;
                  (x = (ae * xe - le * $e) / Ce),
                    (E = (le * Pe - ae * De) / Ce),
                    (l = Qt(l - x, -Math.PI, Math.PI)),
                    (h = Qt(h - E, -c0, c0));
                } while ((Math.abs(x) > _ || Math.abs(E) > _) && --m > 0);
                return new Mn(Oi(l), Oi(h));
              }
            }
            class ny extends Kl {
              constructor(i) {
                super(i),
                  (this.center = i.center || [0, 0]),
                  (this.parallels = i.parallels || [0, 0]),
                  (this.cosPhi = Math.max(
                    0.01,
                    Math.cos(Xt(this.parallels[0]))
                  )),
                  (this.scale =
                    1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi))),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0);
              }
              project(i, o) {
                const { scale: l, cosPhi: h } = this;
                return {
                  x: Xt(i) * h * l + 0.5,
                  y: (-Math.sin(Xt(o)) / h) * l + 0.5,
                  z: 0,
                };
              }
              unproject(i, o) {
                const { scale: l, cosPhi: h } = this,
                  m = -(o - 0.5) / l,
                  _ = Qt(Oi((i - 0.5) / l) / h, -180, 180),
                  x = Math.asin(Qt(m * h, -1, 1)),
                  E = Qt(Oi(x), -Ti, Ti);
                return new Mn(_, E);
              }
            }
            class Pb extends Ym {
              constructor(i) {
                super(i),
                  (this.requiresDraping = !0),
                  (this.supportsWorldCopies = !1),
                  (this.supportsFog = !0),
                  (this.zAxisUnit = "pixels"),
                  (this.unsupportedLayers = ["debug"]),
                  (this.range = [3, 5]);
              }
              projectTilePoint(i, o, l) {
                const h = hd(i, o, l);
                return Kn(h, h, Gu(Qo(l))), { x: h[0], y: h[1], z: h[2] };
              }
              locationPoint(i, o) {
                const l = ud(o.lat, o.lng),
                  h = St([], l),
                  m = i.elevation
                    ? i.elevation.getAtPointOrZero(
                        i.locationCoordinate(o),
                        i._centerAltitude
                      )
                    : i._centerAltitude;
                rd(l, l, h, Ao(1, 0) * vt * m);
                const _ = sa(new Float64Array(16));
                return (
                  Rc(_, i.pixelMatrix, i.globeMatrix),
                  Kn(l, l, _),
                  new et(l[0], l[1])
                );
              }
              pixelsPerMeter(i, o) {
                return Ao(1, 0) * o;
              }
              pixelSpaceConversion(i, o, l) {
                const h = Ao(1, i) * o,
                  m = rn(Ao(1, 45) * o, h, l);
                return this.pixelsPerMeter(i, o) / m;
              }
              createTileMatrix(i, o, l) {
                const h = Pp(Qo(l.canonical));
                return Rc(new Float64Array(16), i.globeMatrix, h);
              }
              createInversionMatrix(i, o) {
                const { center: l } = i,
                  h = Gu(Qo(o));
                return (
                  Dp(h, h, Xt(l.lng)),
                  Wf(h, h, Xt(l.lat)),
                  Oc(h, h, [
                    i._pixelsPerMercatorPixel,
                    i._pixelsPerMercatorPixel,
                    1,
                  ]),
                  Float32Array.from(h)
                );
              }
              pointCoordinate(i, o, l, h) {
                return bv(i, o, l, !0) || new qu(0, 0);
              }
              pointCoordinate3D(i, o, l) {
                const h = this.pointCoordinate(i, o, l, 0);
                return [h.x, h.y, h.z];
              }
              isPointAboveHorizon(i, o) {
                return !bv(i, o.x, o.y, !1);
              }
              farthestPixelDistance(i) {
                const o = (function (h, m) {
                    const _ = h.cameraToCenterDistance,
                      x = h._centerAltitude * m,
                      E = h._camera,
                      T = h._camera.forward(),
                      C = Ya([], lr([], T, -_), [0, 0, x]),
                      A = h.worldSize / (2 * Math.PI),
                      L = [0, 0, -A],
                      O = h.width / h.height,
                      F = Math.tan(h.fovAboveCenter),
                      V = lr([], E.up(), F),
                      G = lr([], E.right(), F * O),
                      K = St([], Ya([], Ya([], T, V), G)),
                      oe = [];
                    let J;
                    if (new Jf(C, K).closestPointOnSphere(L, A, oe)) {
                      const re = Ya([], oe, L),
                        le = _s([], re, C);
                      J = Math.cos(h.fovAboveCenter) * Fc(le);
                    } else {
                      const re = _s([], C, L),
                        le = _s([], L, C);
                      St(le, le);
                      const ae = Fc(re) - A;
                      J = Math.sqrt(ae * (ae + 2 * A));
                      const De = Math.acos(J / (A + ae)) - Math.acos(Co(T, le));
                      J *= Math.cos(De);
                    }
                    return 1.01 * J;
                  })(i, this.pixelsPerMeter(i.center.lat, i.worldSize)),
                  l = Yi(i.zoom);
                if (l > 0) {
                  const h = o0(i, Ao(1, i.center.lat) * i.worldSize),
                    m = i.worldSize / (2 * Math.PI),
                    _ = (Math.max(i.width, i.height) / i.worldSize) * Math.PI;
                  return rn(o, h + m * (1 - Math.cos(_)), Math.pow(l, 10));
                }
                return o;
              }
              upVector(i, o, l) {
                return hd(o, l, i, 1);
              }
              upVectorScale(i) {
                return { metersToTile: ld(dd(Qo(i))) };
              }
            }
            function Lt(r) {
              const i = r.parallels,
                o = !!i && Math.abs(i[0] + i[1]) < 0.01;
              switch (r.name) {
                case "mercator":
                  return new Ym(r);
                case "equirectangular":
                  return new a0(r);
                case "naturalEarth":
                  return new Jm(r);
                case "equalEarth":
                  return new s0(r);
                case "winkelTripel":
                  return new eg(r);
                case "albers":
                  return o ? new ny(r) : new ty(r);
                case "lambertConformalConic":
                  return o ? new ny(r) : new l0(r);
                case "globe":
                  return new Pb(r);
              }
              throw new Error(`Invalid projection name: ${r.name}`);
            }
            const u0 = Dd.types,
              iy = [
                {
                  name: "a_fade_opacity",
                  components: 1,
                  type: "Uint8",
                  offset: 0,
                },
              ];
            function Wc(r, i, o, l, h, m, _, x, E, T, C, A, L) {
              const O = x ? Math.min(Xl, Math.round(x[0])) : 0,
                F = x ? Math.min(Xl, Math.round(x[1])) : 0;
              r.emplaceBack(
                i,
                o,
                Math.round(32 * l),
                Math.round(32 * h),
                m,
                _,
                (O << 1) + (E ? 1 : 0),
                F,
                16 * T,
                16 * C,
                256 * A,
                256 * L
              );
            }
            function ao(r, i, o, l, h, m, _) {
              r.emplaceBack(i, o, l, h, m, _);
            }
            function $d(r, i, o, l, h) {
              r.emplaceBack(i, o, l, h),
                r.emplaceBack(i, o, l, h),
                r.emplaceBack(i, o, l, h),
                r.emplaceBack(i, o, l, h);
            }
            function h0(r) {
              for (const i of r.sections) if (vp(i.text)) return !0;
              return !1;
            }
            class Hd {
              constructor(i) {
                (this.layoutVertexArray = new Ne()),
                  (this.indexArray = new ft()),
                  (this.programConfigurations = i),
                  (this.segments = new gi()),
                  (this.dynamicLayoutVertexArray = new je()),
                  (this.opacityVertexArray = new dt()),
                  (this.placedSymbolArray = new ni()),
                  (this.globeExtVertexArray = new Xe());
              }
              isEmpty() {
                return (
                  0 === this.layoutVertexArray.length &&
                  0 === this.indexArray.length &&
                  0 === this.dynamicLayoutVertexArray.length &&
                  0 === this.opacityVertexArray.length
                );
              }
              upload(i, o, l, h) {
                this.isEmpty() ||
                  (l &&
                    ((this.layoutVertexBuffer = i.createVertexBuffer(
                      this.layoutVertexArray,
                      P_.members
                    )),
                    (this.indexBuffer = i.createIndexBuffer(
                      this.indexArray,
                      o
                    )),
                    (this.dynamicLayoutVertexBuffer = i.createVertexBuffer(
                      this.dynamicLayoutVertexArray,
                      Cb.members,
                      !0
                    )),
                    (this.opacityVertexBuffer = i.createVertexBuffer(
                      this.opacityVertexArray,
                      iy,
                      !0
                    )),
                    this.globeExtVertexArray.length > 0 &&
                      (this.globeExtVertexBuffer = i.createVertexBuffer(
                        this.globeExtVertexArray,
                        Pm.members,
                        !0
                      )),
                    (this.opacityVertexBuffer.itemSize = 1)),
                  (l || h) && this.programConfigurations.upload(i));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.dynamicLayoutVertexBuffer.destroy(),
                  this.opacityVertexBuffer.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy());
              }
            }
            st(Hd, "SymbolBuffers");
            class bs {
              constructor(i, o, l) {
                (this.layoutVertexArray = new i()),
                  (this.layoutAttributes = o),
                  (this.indexArray = new l()),
                  (this.segments = new gi()),
                  (this.collisionVertexArray = new Wt()),
                  (this.collisionVertexArrayExt = new jt());
              }
              upload(i) {
                (this.layoutVertexBuffer = i.createVertexBuffer(
                  this.layoutVertexArray,
                  this.layoutAttributes
                )),
                  (this.indexBuffer = i.createIndexBuffer(this.indexArray)),
                  (this.collisionVertexBuffer = i.createVertexBuffer(
                    this.collisionVertexArray,
                    $v.members,
                    !0
                  )),
                  (this.collisionVertexBufferExt = i.createVertexBuffer(
                    this.collisionVertexArrayExt,
                    Lm.members,
                    !0
                  ));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy(),
                  this.collisionVertexBuffer.destroy(),
                  this.collisionVertexBufferExt.destroy());
              }
            }
            st(bs, "CollisionBuffers");
            class fa {
              constructor(i) {
                (this.collisionBoxArray = i.collisionBoxArray),
                  (this.zoom = i.zoom),
                  (this.overscaling = i.overscaling),
                  (this.layers = i.layers),
                  (this.layerIds = this.layers.map((_) => _.id)),
                  (this.index = i.index),
                  (this.pixelRatio = i.pixelRatio),
                  (this.sourceLayerIndex = i.sourceLayerIndex),
                  (this.hasPattern = !1),
                  (this.hasRTLText = !1),
                  (this.fullyClipped = !1),
                  (this.sortKeyRanges = []),
                  (this.collisionCircleArray = []),
                  (this.placementInvProjMatrix = sa([])),
                  (this.placementViewportMatrix = sa([]));
                const o = this.layers[0]._unevaluatedLayout._values;
                (this.textSizeData = Pd(this.zoom, o["text-size"])),
                  (this.iconSizeData = Pd(this.zoom, o["icon-size"]));
                const l = this.layers[0].layout,
                  h = l.get("symbol-sort-key"),
                  m = l.get("symbol-z-order");
                (this.canOverlap =
                  l.get("text-allow-overlap") ||
                  l.get("icon-allow-overlap") ||
                  l.get("text-ignore-placement") ||
                  l.get("icon-ignore-placement")),
                  (this.sortFeaturesByKey =
                    "viewport-y" !== m && void 0 !== h.constantOr(1)),
                  (this.sortFeaturesByY =
                    ("viewport-y" === m ||
                      ("auto" === m && !this.sortFeaturesByKey)) &&
                    this.canOverlap),
                  (this.writingModes = l
                    .get("text-writing-mode")
                    .map((_) => Po[_])),
                  (this.stateDependentLayerIds = this.layers
                    .filter((_) => _.isStateDependent())
                    .map((_) => _.id)),
                  (this.sourceID = i.sourceID),
                  (this.projection = i.projection);
              }
              createArrays() {
                (this.text = new Hd(
                  new gs(this.layers, this.zoom, (i) => /^text/.test(i))
                )),
                  (this.icon = new Hd(
                    new gs(this.layers, this.zoom, (i) => /^icon/.test(i))
                  )),
                  (this.glyphOffsetArray = new Ui()),
                  (this.lineVertexArray = new Fu()),
                  (this.symbolInstances = new Rn());
              }
              calculateGlyphDependencies(i, o, l, h, m) {
                for (let _ = 0; _ < i.length; _++)
                  if (((o[i.charCodeAt(_)] = !0), h && m)) {
                    const x = da[i.charAt(_)];
                    x && (o[x.charCodeAt(0)] = !0);
                  }
              }
              populate(i, o, l, h) {
                const m = this.layers[0],
                  _ = m.layout,
                  x = "globe" === this.projection.name,
                  E = _.get("text-font"),
                  T = _.get("text-field"),
                  C = _.get("icon-image"),
                  A =
                    ("constant" !== T.value.kind ||
                      (T.value.value instanceof Lr &&
                        !T.value.value.isEmpty()) ||
                      T.value.value.toString().length > 0) &&
                    ("constant" !== E.value.kind || E.value.value.length > 0),
                  L =
                    "constant" !== C.value.kind ||
                    !!C.value.value ||
                    Object.keys(C.parameters).length > 0,
                  O = _.get("symbol-sort-key");
                if (((this.features = []), !A && !L)) return;
                const F = o.iconDependencies,
                  V = o.glyphDependencies,
                  G = o.availableImages,
                  K = new M(this.zoom);
                for (const {
                  feature: oe,
                  id: J,
                  index: re,
                  sourceLayerIndex: le,
                } of i) {
                  const ae = m._featureFilter.needGeometry,
                    De = tl(oe, ae);
                  if (!m._featureFilter.filter(K, De, l)) continue;
                  if (
                    (ae || (De.geometry = el(oe, l, h)),
                    x && 1 !== oe.type && l.z <= 5)
                  ) {
                    const Ce = De.geometry,
                      Fe = 0.98078528056,
                      Re = (Ve, qe) =>
                        Co(hd(Ve.x, Ve.y, l, 1), hd(qe.x, qe.y, l, 1)) < Fe;
                    for (let Ve = 0; Ve < Ce.length; Ve++)
                      Ce[Ve] = e_(Ce[Ve], Re);
                  }
                  let xe, Pe;
                  if (A) {
                    const Ce = m.getValueAndResolveTokens(
                        "text-field",
                        De,
                        l,
                        G
                      ),
                      Fe = Lr.factory(Ce);
                    h0(Fe) && (this.hasRTLText = !0),
                      (!this.hasRTLText ||
                        "unavailable" === b() ||
                        (this.hasRTLText && I.isParsed())) &&
                        (xe = Yp(Fe, m, De));
                  }
                  if (L) {
                    const Ce = m.getValueAndResolveTokens(
                      "icon-image",
                      De,
                      l,
                      G
                    );
                    Pe = Ce instanceof go ? Ce : go.fromString(Ce);
                  }
                  if (!xe && !Pe) continue;
                  const $e = this.sortFeaturesByKey
                    ? O.evaluate(De, {}, l)
                    : void 0;
                  if (
                    (this.features.push({
                      id: J,
                      text: xe,
                      icon: Pe,
                      index: re,
                      sourceLayerIndex: le,
                      geometry: De.geometry,
                      properties: oe.properties,
                      type: u0[oe.type],
                      sortKey: $e,
                    }),
                    Pe && (F[Pe.name] = !0),
                    xe)
                  ) {
                    const Ce = E.evaluate(De, {}, l).join(","),
                      Fe =
                        "map" === _.get("text-rotation-alignment") &&
                        "point" !== _.get("symbol-placement");
                    this.allowVerticalPlacement =
                      this.writingModes &&
                      this.writingModes.indexOf(Po.vertical) >= 0;
                    for (const Re of xe.sections)
                      if (Re.image) F[Re.image.name] = !0;
                      else {
                        const Ve = Qh(xe.toString()),
                          qe = Re.fontStack || Ce,
                          Me = (V[qe] = V[qe] || {});
                        this.calculateGlyphDependencies(
                          Re.text,
                          Me,
                          Fe,
                          this.allowVerticalPlacement,
                          Ve
                        );
                      }
                  }
                }
                "line" === _.get("symbol-placement") &&
                  (this.features = (function (oe) {
                    const J = {},
                      re = {},
                      le = [];
                    let ae = 0;
                    function De(Ce) {
                      le.push(oe[Ce]), ae++;
                    }
                    function xe(Ce, Fe, Re) {
                      const Ve = re[Ce];
                      return (
                        delete re[Ce],
                        (re[Fe] = Ve),
                        le[Ve].geometry[0].pop(),
                        (le[Ve].geometry[0] = le[Ve].geometry[0].concat(Re[0])),
                        Ve
                      );
                    }
                    function Pe(Ce, Fe, Re) {
                      const Ve = J[Fe];
                      return (
                        delete J[Fe],
                        (J[Ce] = Ve),
                        le[Ve].geometry[0].shift(),
                        (le[Ve].geometry[0] = Re[0].concat(le[Ve].geometry[0])),
                        Ve
                      );
                    }
                    function $e(Ce, Fe, Re) {
                      const Ve = Re ? Fe[0][Fe[0].length - 1] : Fe[0][0];
                      return `${Ce}:${Ve.x}:${Ve.y}`;
                    }
                    for (let Ce = 0; Ce < oe.length; Ce++) {
                      const Fe = oe[Ce],
                        Re = Fe.geometry,
                        Ve = Fe.text ? Fe.text.toString() : null;
                      if (!Ve) {
                        De(Ce);
                        continue;
                      }
                      const qe = $e(Ve, Re),
                        Me = $e(Ve, Re, !0);
                      if (qe in re && Me in J && re[qe] !== J[Me]) {
                        const Je = Pe(qe, Me, Re),
                          ut = xe(qe, Me, le[Je].geometry);
                        delete J[qe],
                          delete re[Me],
                          (re[$e(Ve, le[ut].geometry, !0)] = ut),
                          (le[Je].geometry = null);
                      } else
                        qe in re
                          ? xe(qe, Me, Re)
                          : Me in J
                          ? Pe(qe, Me, Re)
                          : (De(Ce), (J[qe] = ae - 1), (re[Me] = ae - 1));
                    }
                    return le.filter((Ce) => Ce.geometry);
                  })(this.features)),
                  this.sortFeaturesByKey &&
                    this.features.sort((oe, J) => oe.sortKey - J.sortKey);
              }
              update(i, o, l, h) {
                this.stateDependentLayers.length &&
                  (this.text.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.layers,
                    l,
                    h
                  ),
                  this.icon.programConfigurations.updatePaintArrays(
                    i,
                    o,
                    this.layers,
                    l,
                    h
                  ));
              }
              isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.text.programConfigurations.needsUpload ||
                  this.icon.programConfigurations.needsUpload
                );
              }
              upload(i) {
                !this.uploaded &&
                  this.hasDebugData() &&
                  (this.textCollisionBox.upload(i),
                  this.iconCollisionBox.upload(i)),
                  this.text.upload(
                    i,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.text.programConfigurations.needsUpload
                  ),
                  this.icon.upload(
                    i,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.icon.programConfigurations.needsUpload
                  ),
                  (this.uploaded = !0);
              }
              destroyDebugData() {
                this.textCollisionBox.destroy(),
                  this.iconCollisionBox.destroy();
              }
              getProjection() {
                return (
                  this.projectionInstance ||
                    (this.projectionInstance = Lt(this.projection)),
                  this.projectionInstance
                );
              }
              destroy() {
                this.text.destroy(),
                  this.icon.destroy(),
                  this.hasDebugData() && this.destroyDebugData();
              }
              addToLineVertexArray(i, o) {
                const l = this.lineVertexArray.length;
                if (void 0 !== i.segment)
                  for (const { x: h, y: m } of o)
                    this.lineVertexArray.emplaceBack(h, m);
                return {
                  lineStartIndex: l,
                  lineLength: this.lineVertexArray.length - l,
                };
              }
              addSymbols(i, o, l, h, m, _, x, E, T, C, A, L, O, F) {
                const V = i.indexArray,
                  G = i.layoutVertexArray,
                  K = i.globeExtVertexArray,
                  oe = i.segments.prepareSegment(
                    4 * o.length,
                    G,
                    V,
                    this.canOverlap ? _.sortKey : void 0
                  ),
                  J = this.glyphOffsetArray.length,
                  re = oe.vertexLength,
                  le =
                    this.allowVerticalPlacement && x === Po.vertical
                      ? Math.PI / 2
                      : 0,
                  ae = _.text && _.text.sections;
                for (let xe = 0; xe < o.length; xe++) {
                  const {
                      tl: Pe,
                      tr: $e,
                      bl: Ce,
                      br: Fe,
                      tex: Re,
                      pixelOffsetTL: Ve,
                      pixelOffsetBR: qe,
                      minFontScaleX: Me,
                      minFontScaleY: Je,
                      glyphOffset: ut,
                      isSDF: nt,
                      sectionIndex: Mt,
                    } = o[xe],
                    Ke = oe.vertexLength,
                    yt = ut[1];
                  if (
                    (Wc(
                      G,
                      T.x,
                      T.y,
                      Pe.x,
                      yt + Pe.y,
                      Re.x,
                      Re.y,
                      l,
                      nt,
                      Ve.x,
                      Ve.y,
                      Me,
                      Je
                    ),
                    Wc(
                      G,
                      T.x,
                      T.y,
                      $e.x,
                      yt + $e.y,
                      Re.x + Re.w,
                      Re.y,
                      l,
                      nt,
                      qe.x,
                      Ve.y,
                      Me,
                      Je
                    ),
                    Wc(
                      G,
                      T.x,
                      T.y,
                      Ce.x,
                      yt + Ce.y,
                      Re.x,
                      Re.y + Re.h,
                      l,
                      nt,
                      Ve.x,
                      qe.y,
                      Me,
                      Je
                    ),
                    Wc(
                      G,
                      T.x,
                      T.y,
                      Fe.x,
                      yt + Fe.y,
                      Re.x + Re.w,
                      Re.y + Re.h,
                      l,
                      nt,
                      qe.x,
                      qe.y,
                      Me,
                      Je
                    ),
                    E)
                  ) {
                    const { x: Ct, y: Zt, z: It } = E.anchor,
                      [xt, Dn, Rt] = E.up;
                    ao(K, Ct, Zt, It, xt, Dn, Rt),
                      ao(K, Ct, Zt, It, xt, Dn, Rt),
                      ao(K, Ct, Zt, It, xt, Dn, Rt),
                      ao(K, Ct, Zt, It, xt, Dn, Rt),
                      $d(i.dynamicLayoutVertexArray, Ct, Zt, It, le);
                  } else $d(i.dynamicLayoutVertexArray, T.x, T.y, T.z, le);
                  V.emplaceBack(Ke, Ke + 1, Ke + 2),
                    V.emplaceBack(Ke + 1, Ke + 2, Ke + 3),
                    (oe.vertexLength += 4),
                    (oe.primitiveLength += 2),
                    this.glyphOffsetArray.emplaceBack(ut[0]),
                    (xe !== o.length - 1 && Mt === o[xe + 1].sectionIndex) ||
                      i.programConfigurations.populatePaintArrays(
                        G.length,
                        _,
                        _.index,
                        {},
                        O,
                        F,
                        ae && ae[Mt]
                      );
                }
                const De = E ? E.anchor : T;
                i.placedSymbolArray.emplaceBack(
                  De.x,
                  De.y,
                  De.z,
                  T.x,
                  T.y,
                  J,
                  this.glyphOffsetArray.length - J,
                  re,
                  C,
                  A,
                  T.segment,
                  l ? l[0] : 0,
                  l ? l[1] : 0,
                  h[0],
                  h[1],
                  x,
                  0,
                  !1,
                  0,
                  L,
                  0
                );
              }
              _commitLayoutVertex(i, o, l, h, m, _, x) {
                i.emplaceBack(o, l, h, m, _, Math.round(x.x), Math.round(x.y));
              }
              _addCollisionDebugVertices(i, o, l, h, m, _, x) {
                const E = l.segments.prepareSegment(
                    4,
                    l.layoutVertexArray,
                    l.indexArray
                  ),
                  T = E.vertexLength,
                  C = x.tileAnchorX,
                  A = x.tileAnchorY;
                for (let O = 0; O < 4; O++)
                  l.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                l.collisionVertexArrayExt.emplaceBack(
                  o,
                  -i.padding,
                  -i.padding
                ),
                  l.collisionVertexArrayExt.emplaceBack(
                    o,
                    i.padding,
                    -i.padding
                  ),
                  l.collisionVertexArrayExt.emplaceBack(
                    o,
                    i.padding,
                    i.padding
                  ),
                  l.collisionVertexArrayExt.emplaceBack(
                    o,
                    -i.padding,
                    i.padding
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    C,
                    A,
                    new et(i.x1, i.y1)
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    C,
                    A,
                    new et(i.x2, i.y1)
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    C,
                    A,
                    new et(i.x2, i.y2)
                  ),
                  this._commitLayoutVertex(
                    l.layoutVertexArray,
                    h,
                    m,
                    _,
                    C,
                    A,
                    new et(i.x1, i.y2)
                  ),
                  (E.vertexLength += 4);
                const L = l.indexArray;
                L.emplaceBack(T, T + 1),
                  L.emplaceBack(T + 1, T + 2),
                  L.emplaceBack(T + 2, T + 3),
                  L.emplaceBack(T + 3, T),
                  (E.primitiveLength += 4);
              }
              _addTextDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceTextSize(i, _, o, x);
                  this._addCollisionDebugVertices(
                    E,
                    T,
                    this.textCollisionBox,
                    E.projectedAnchorX,
                    E.projectedAnchorY,
                    E.projectedAnchorZ,
                    _
                  );
                }
              }
              _addIconDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceIconSize(
                      i,
                      o,
                      _.placedIconSymbolIndex
                    );
                  this._addCollisionDebugVertices(
                    E,
                    T,
                    this.iconCollisionBox,
                    E.projectedAnchorX,
                    E.projectedAnchorY,
                    E.projectedAnchorZ,
                    _
                  );
                }
              }
              generateCollisionDebugBuffers(i, o) {
                this.hasDebugData() && this.destroyDebugData(),
                  (this.textCollisionBox = new bs(ct, km.members, mi)),
                  (this.iconCollisionBox = new bs(ct, km.members, mi));
                const l = eh(this.iconSizeData, i),
                  h = eh(this.textSizeData, i);
                for (let m = 0; m < this.symbolInstances.length; m++) {
                  const _ = this.symbolInstances.get(m);
                  this._addTextDebugCollisionBoxes(
                    h,
                    i,
                    o,
                    _.textBoxStartIndex,
                    _.textBoxEndIndex,
                    _
                  ),
                    this._addTextDebugCollisionBoxes(
                      h,
                      i,
                      o,
                      _.verticalTextBoxStartIndex,
                      _.verticalTextBoxEndIndex,
                      _
                    ),
                    this._addIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.iconBoxStartIndex,
                      _.iconBoxEndIndex,
                      _
                    ),
                    this._addIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.verticalIconBoxStartIndex,
                      _.verticalIconBoxEndIndex,
                      _
                    );
                }
              }
              getSymbolInstanceTextSize(i, o, l, h) {
                const m = this.text.placedSymbolArray.get(
                    o.rightJustifiedTextSymbolIndex >= 0
                      ? o.rightJustifiedTextSymbolIndex
                      : o.centerJustifiedTextSymbolIndex >= 0
                      ? o.centerJustifiedTextSymbolIndex
                      : o.leftJustifiedTextSymbolIndex >= 0
                      ? o.leftJustifiedTextSymbolIndex
                      : o.verticalPlacedTextSymbolIndex >= 0
                      ? o.verticalPlacedTextSymbolIndex
                      : h
                  ),
                  _ = jc(this.textSizeData, i, m) / 24;
                return this.tilePixelRatio * _;
              }
              getSymbolInstanceIconSize(i, o, l) {
                const h = this.icon.placedSymbolArray.get(l),
                  m = jc(this.iconSizeData, i, h);
                return this.tilePixelRatio * m;
              }
              _commitDebugCollisionVertexUpdate(i, o, l) {
                i.emplaceBack(o, -l, -l),
                  i.emplaceBack(o, l, -l),
                  i.emplaceBack(o, l, l),
                  i.emplaceBack(o, -l, l);
              }
              _updateTextDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceTextSize(i, _, o, x);
                  this._commitDebugCollisionVertexUpdate(
                    this.textCollisionBox.collisionVertexArrayExt,
                    T,
                    E.padding
                  );
                }
              }
              _updateIconDebugCollisionBoxes(i, o, l, h, m, _) {
                for (let x = h; x < m; x++) {
                  const E = l.get(x),
                    T = this.getSymbolInstanceIconSize(i, o, _);
                  this._commitDebugCollisionVertexUpdate(
                    this.iconCollisionBox.collisionVertexArrayExt,
                    T,
                    E.padding
                  );
                }
              }
              updateCollisionDebugBuffers(i, o) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexArrayExt.clear(),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexArrayExt.clear();
                const l = eh(this.iconSizeData, i),
                  h = eh(this.textSizeData, i);
                for (let m = 0; m < this.symbolInstances.length; m++) {
                  const _ = this.symbolInstances.get(m);
                  this._updateTextDebugCollisionBoxes(
                    h,
                    i,
                    o,
                    _.textBoxStartIndex,
                    _.textBoxEndIndex,
                    _
                  ),
                    this._updateTextDebugCollisionBoxes(
                      h,
                      i,
                      o,
                      _.verticalTextBoxStartIndex,
                      _.verticalTextBoxEndIndex,
                      _
                    ),
                    this._updateIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.iconBoxStartIndex,
                      _.iconBoxEndIndex,
                      _.placedIconSymbolIndex
                    ),
                    this._updateIconDebugCollisionBoxes(
                      l,
                      i,
                      o,
                      _.verticalIconBoxStartIndex,
                      _.verticalIconBoxEndIndex,
                      _.placedIconSymbolIndex
                    );
                }
                this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexBufferExt &&
                  this.textCollisionBox.collisionVertexBufferExt.updateData(
                    this.textCollisionBox.collisionVertexArrayExt
                  ),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexBufferExt &&
                    this.iconCollisionBox.collisionVertexBufferExt.updateData(
                      this.iconCollisionBox.collisionVertexArrayExt
                    );
              }
              _deserializeCollisionBoxesForSymbol(i, o, l, h, m, _, x, E, T) {
                const C = {};
                if (o < l) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(o);
                  (C.textBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (C.textFeatureIndex = le);
                }
                if (h < m) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(h);
                  (C.verticalTextBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (C.verticalTextFeatureIndex = le);
                }
                if (_ < x) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(_);
                  (C.iconBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (C.iconFeatureIndex = le);
                }
                if (E < T) {
                  const {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                    featureIndex: le,
                  } = i.get(E);
                  (C.verticalIconBox = {
                    x1: A,
                    y1: L,
                    x2: O,
                    y2: F,
                    padding: V,
                    projectedAnchorX: G,
                    projectedAnchorY: K,
                    projectedAnchorZ: oe,
                    tileAnchorX: J,
                    tileAnchorY: re,
                  }),
                    (C.verticalIconFeatureIndex = le);
                }
                return C;
              }
              deserializeCollisionBoxes(i) {
                this.collisionArrays = [];
                for (let o = 0; o < this.symbolInstances.length; o++) {
                  const l = this.symbolInstances.get(o);
                  this.collisionArrays.push(
                    this._deserializeCollisionBoxesForSymbol(
                      i,
                      l.textBoxStartIndex,
                      l.textBoxEndIndex,
                      l.verticalTextBoxStartIndex,
                      l.verticalTextBoxEndIndex,
                      l.iconBoxStartIndex,
                      l.iconBoxEndIndex,
                      l.verticalIconBoxStartIndex,
                      l.verticalIconBoxEndIndex
                    )
                  );
                }
              }
              hasTextData() {
                return this.text.segments.get().length > 0;
              }
              hasIconData() {
                return this.icon.segments.get().length > 0;
              }
              hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
              }
              hasTextCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.textCollisionBox.segments.get().length > 0
                );
              }
              hasIconCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.iconCollisionBox.segments.get().length > 0
                );
              }
              addIndicesForPlacedSymbol(i, o) {
                const l = i.placedSymbolArray.get(o),
                  h = l.vertexStartIndex + 4 * l.numGlyphs;
                for (let m = l.vertexStartIndex; m < h; m += 4)
                  i.indexArray.emplaceBack(m, m + 1, m + 2),
                    i.indexArray.emplaceBack(m + 1, m + 2, m + 3);
              }
              getSortedSymbolIndexes(i) {
                if (
                  this.sortedAngle === i &&
                  void 0 !== this.symbolInstanceIndexes
                )
                  return this.symbolInstanceIndexes;
                const o = Math.sin(i),
                  l = Math.cos(i),
                  h = [],
                  m = [],
                  _ = [];
                for (let x = 0; x < this.symbolInstances.length; ++x) {
                  _.push(x);
                  const E = this.symbolInstances.get(x);
                  h.push(0 | Math.round(o * E.tileAnchorX + l * E.tileAnchorY)),
                    m.push(E.featureIndex);
                }
                return _.sort((x, E) => h[x] - h[E] || m[E] - m[x]), _;
              }
              addToSortKeyRanges(i, o) {
                const l = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                l && l.sortKey === o
                  ? (l.symbolInstanceEnd = i + 1)
                  : this.sortKeyRanges.push({
                      sortKey: o,
                      symbolInstanceStart: i,
                      symbolInstanceEnd: i + 1,
                    });
              }
              sortFeatures(i) {
                if (
                  this.sortFeaturesByY &&
                  this.sortedAngle !== i &&
                  !(
                    this.text.segments.get().length > 1 ||
                    this.icon.segments.get().length > 1
                  )
                ) {
                  (this.symbolInstanceIndexes = this.getSortedSymbolIndexes(i)),
                    (this.sortedAngle = i),
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    (this.featureSortOrder = []);
                  for (const o of this.symbolInstanceIndexes) {
                    const l = this.symbolInstances.get(o);
                    this.featureSortOrder.push(l.featureIndex);
                    const {
                      rightJustifiedTextSymbolIndex: h,
                      centerJustifiedTextSymbolIndex: m,
                      leftJustifiedTextSymbolIndex: _,
                      verticalPlacedTextSymbolIndex: x,
                      placedIconSymbolIndex: E,
                      verticalPlacedIconSymbolIndex: T,
                    } = l;
                    h >= 0 && this.addIndicesForPlacedSymbol(this.text, h),
                      m >= 0 &&
                        m !== h &&
                        this.addIndicesForPlacedSymbol(this.text, m),
                      _ >= 0 &&
                        _ !== m &&
                        _ !== h &&
                        this.addIndicesForPlacedSymbol(this.text, _),
                      x >= 0 && this.addIndicesForPlacedSymbol(this.text, x),
                      E >= 0 && this.addIndicesForPlacedSymbol(this.icon, E),
                      T >= 0 && this.addIndicesForPlacedSymbol(this.icon, T);
                  }
                  this.text.indexBuffer &&
                    this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer &&
                      this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
              }
            }
            st(fa, "SymbolBucket", {
              omit: ["layers", "collisionBoxArray", "features", "compareText"],
            }),
              (fa.MAX_GLYPHS = 65535),
              (fa.addDynamicAttributes = $d);
            const ry = new te({
              "symbol-placement": new B(Ae.layout_symbol["symbol-placement"]),
              "symbol-spacing": new B(Ae.layout_symbol["symbol-spacing"]),
              "symbol-avoid-edges": new B(
                Ae.layout_symbol["symbol-avoid-edges"]
              ),
              "symbol-sort-key": new W(Ae.layout_symbol["symbol-sort-key"]),
              "symbol-z-order": new B(Ae.layout_symbol["symbol-z-order"]),
              "icon-allow-overlap": new B(
                Ae.layout_symbol["icon-allow-overlap"]
              ),
              "icon-ignore-placement": new B(
                Ae.layout_symbol["icon-ignore-placement"]
              ),
              "icon-optional": new B(Ae.layout_symbol["icon-optional"]),
              "icon-rotation-alignment": new B(
                Ae.layout_symbol["icon-rotation-alignment"]
              ),
              "icon-size": new W(Ae.layout_symbol["icon-size"]),
              "icon-text-fit": new B(Ae.layout_symbol["icon-text-fit"]),
              "icon-text-fit-padding": new B(
                Ae.layout_symbol["icon-text-fit-padding"]
              ),
              "icon-image": new W(Ae.layout_symbol["icon-image"]),
              "icon-rotate": new W(Ae.layout_symbol["icon-rotate"]),
              "icon-padding": new B(Ae.layout_symbol["icon-padding"]),
              "icon-keep-upright": new B(Ae.layout_symbol["icon-keep-upright"]),
              "icon-offset": new W(Ae.layout_symbol["icon-offset"]),
              "icon-anchor": new W(Ae.layout_symbol["icon-anchor"]),
              "icon-pitch-alignment": new B(
                Ae.layout_symbol["icon-pitch-alignment"]
              ),
              "text-pitch-alignment": new B(
                Ae.layout_symbol["text-pitch-alignment"]
              ),
              "text-rotation-alignment": new B(
                Ae.layout_symbol["text-rotation-alignment"]
              ),
              "text-field": new W(Ae.layout_symbol["text-field"]),
              "text-font": new W(Ae.layout_symbol["text-font"]),
              "text-size": new W(Ae.layout_symbol["text-size"]),
              "text-max-width": new W(Ae.layout_symbol["text-max-width"]),
              "text-line-height": new W(Ae.layout_symbol["text-line-height"]),
              "text-letter-spacing": new W(
                Ae.layout_symbol["text-letter-spacing"]
              ),
              "text-justify": new W(Ae.layout_symbol["text-justify"]),
              "text-radial-offset": new W(
                Ae.layout_symbol["text-radial-offset"]
              ),
              "text-variable-anchor": new B(
                Ae.layout_symbol["text-variable-anchor"]
              ),
              "text-anchor": new W(Ae.layout_symbol["text-anchor"]),
              "text-max-angle": new B(Ae.layout_symbol["text-max-angle"]),
              "text-writing-mode": new B(Ae.layout_symbol["text-writing-mode"]),
              "text-rotate": new W(Ae.layout_symbol["text-rotate"]),
              "text-padding": new B(Ae.layout_symbol["text-padding"]),
              "text-keep-upright": new B(Ae.layout_symbol["text-keep-upright"]),
              "text-transform": new W(Ae.layout_symbol["text-transform"]),
              "text-offset": new W(Ae.layout_symbol["text-offset"]),
              "text-allow-overlap": new B(
                Ae.layout_symbol["text-allow-overlap"]
              ),
              "text-ignore-placement": new B(
                Ae.layout_symbol["text-ignore-placement"]
              ),
              "text-optional": new B(Ae.layout_symbol["text-optional"]),
            });
            var Gd = {
              paint: new te({
                "icon-opacity": new W(Ae.paint_symbol["icon-opacity"]),
                "icon-color": new W(Ae.paint_symbol["icon-color"]),
                "icon-halo-color": new W(Ae.paint_symbol["icon-halo-color"]),
                "icon-halo-width": new W(Ae.paint_symbol["icon-halo-width"]),
                "icon-halo-blur": new W(Ae.paint_symbol["icon-halo-blur"]),
                "icon-translate": new B(Ae.paint_symbol["icon-translate"]),
                "icon-translate-anchor": new B(
                  Ae.paint_symbol["icon-translate-anchor"]
                ),
                "text-opacity": new W(Ae.paint_symbol["text-opacity"]),
                "text-color": new W(Ae.paint_symbol["text-color"], {
                  runtimeType: Ur,
                  getOverride: (r) => r.textColor,
                  hasOverride: (r) => !!r.textColor,
                }),
                "text-halo-color": new W(Ae.paint_symbol["text-halo-color"]),
                "text-halo-width": new W(Ae.paint_symbol["text-halo-width"]),
                "text-halo-blur": new W(Ae.paint_symbol["text-halo-blur"]),
                "text-translate": new B(Ae.paint_symbol["text-translate"]),
                "text-translate-anchor": new B(
                  Ae.paint_symbol["text-translate-anchor"]
                ),
              }),
              layout: ry,
            };
            class d0 {
              constructor(i) {
                (this.type = i.property.overrides
                  ? i.property.overrides.runtimeType
                  : wn),
                  (this.defaultValue = i);
              }
              evaluate(i) {
                if (i.formattedSection) {
                  const o = this.defaultValue.property.overrides;
                  if (o && o.hasOverride(i.formattedSection))
                    return o.getOverride(i.formattedSection);
                }
                return i.feature && i.featureState
                  ? this.defaultValue.evaluate(i.feature, i.featureState)
                  : this.defaultValue.property.specification.default;
              }
              eachChild(i) {
                this.defaultValue.isConstant() ||
                  i(this.defaultValue.value._styleExpression.expression);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return null;
              }
            }
            st(d0, "FormatSectionOverride", { omit: ["defaultValue"] });
            class qd extends Zr {
              constructor(i) {
                super(i, Gd);
              }
              recalculate(i, o) {
                super.recalculate(i, o),
                  "auto" === this.layout.get("icon-rotation-alignment") &&
                    (this.layout._values["icon-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-rotation-alignment") &&
                    (this.layout._values["text-rotation-alignment"] =
                      "point" !== this.layout.get("symbol-placement")
                        ? "map"
                        : "viewport"),
                  "auto" === this.layout.get("text-pitch-alignment") &&
                    (this.layout._values["text-pitch-alignment"] =
                      this.layout.get("text-rotation-alignment")),
                  "auto" === this.layout.get("icon-pitch-alignment") &&
                    (this.layout._values["icon-pitch-alignment"] =
                      this.layout.get("icon-rotation-alignment"));
                const l = this.layout.get("text-writing-mode");
                if (l) {
                  const h = [];
                  for (const m of l) h.indexOf(m) < 0 && h.push(m);
                  this.layout._values["text-writing-mode"] = h;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                this._setPaintOverrides();
              }
              getValueAndResolveTokens(i, o, l, h) {
                const m = this.layout.get(i).evaluate(o, {}, l, h),
                  _ = this._unevaluatedLayout._values[i];
                return _.isDataDriven() || Zo(_.value) || !m
                  ? m
                  : ((x = o.properties),
                    m.replace(/{([^{}]+)}/g, (T, C) =>
                      C in x ? String(x[C]) : ""
                    ));
                var x;
              }
              createBucket(i) {
                return new fa(i);
              }
              queryRadius() {
                return 0;
              }
              queryIntersectsFeature() {
                return !1;
              }
              _setPaintOverrides() {
                for (const i of Gd.paint.overridableProperties) {
                  if (!qd.hasPaintOverride(this.layout, i)) continue;
                  const o = this.paint.get(i),
                    l = new d0(o),
                    h = new Iu(l, o.property.specification);
                  let m = null;
                  (m =
                    "constant" === o.value.kind || "source" === o.value.kind
                      ? new $h("source", h)
                      : new Ec(
                          "composite",
                          h,
                          o.value.zoomStops,
                          o.value._interpolationType
                        )),
                    (this.paint._values[i] = new Z(
                      o.property,
                      m,
                      o.parameters
                    ));
                }
              }
              _handleOverridablePaintPropertyUpdate(i, o, l) {
                return (
                  !(!this.layout || o.isDataDriven() || l.isDataDriven()) &&
                  qd.hasPaintOverride(this.layout, i)
                );
              }
              static hasPaintOverride(i, o) {
                const l = i.get("text-field"),
                  h = Gd.paint.properties[o];
                let m = !1;
                const _ = (x) => {
                  for (const E of x)
                    if (h.overrides && h.overrides.hasOverride(E))
                      return void (m = !0);
                };
                if ("constant" === l.value.kind && l.value.value instanceof Lr)
                  _(l.value.value.sections);
                else if ("source" === l.value.kind) {
                  const x = (T) => {
                      m ||
                        (T instanceof Sl && un(T.value) === mu
                          ? _(T.value.sections)
                          : T instanceof _o
                          ? _(T.sections)
                          : T.eachChild(x));
                    },
                    E = l.value;
                  E._styleExpression && x(E._styleExpression.expression);
                }
                return m;
              }
              getProgramConfiguration(i) {
                return new oa(this, i);
              }
            }
            var Lb = {
                paint: new te({
                  "background-color": new B(
                    Ae.paint_background["background-color"]
                  ),
                  "background-pattern": new B(
                    Ae.paint_background["background-pattern"]
                  ),
                  "background-opacity": new B(
                    Ae.paint_background["background-opacity"]
                  ),
                }),
              },
              of = {
                paint: new te({
                  "raster-opacity": new B(Ae.paint_raster["raster-opacity"]),
                  "raster-hue-rotate": new B(
                    Ae.paint_raster["raster-hue-rotate"]
                  ),
                  "raster-brightness-min": new B(
                    Ae.paint_raster["raster-brightness-min"]
                  ),
                  "raster-brightness-max": new B(
                    Ae.paint_raster["raster-brightness-max"]
                  ),
                  "raster-saturation": new B(
                    Ae.paint_raster["raster-saturation"]
                  ),
                  "raster-contrast": new B(Ae.paint_raster["raster-contrast"]),
                  "raster-resampling": new B(
                    Ae.paint_raster["raster-resampling"]
                  ),
                  "raster-fade-duration": new B(
                    Ae.paint_raster["raster-fade-duration"]
                  ),
                }),
              };
            class sf extends Zr {
              constructor(i) {
                super(i, {}), (this.implementation = i);
              }
              is3D() {
                return "3d" === this.implementation.renderingMode;
              }
              hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
              }
              isLayerDraped() {
                return void 0 !== this.implementation.renderToTile;
              }
              shouldRedrape() {
                return (
                  !!this.implementation.shouldRerenderTiles &&
                  this.implementation.shouldRerenderTiles()
                );
              }
              recalculate() {}
              updateTransitions() {}
              hasTransition() {
                return !1;
              }
              serialize() {}
              onAdd(i) {
                this.implementation.onAdd &&
                  this.implementation.onAdd(i, i.painter.context.gl);
              }
              onRemove(i) {
                this.implementation.onRemove &&
                  this.implementation.onRemove(i, i.painter.context.gl);
              }
            }
            var tg = {
              paint: new te({
                "sky-type": new B(Ae.paint_sky["sky-type"]),
                "sky-atmosphere-sun": new B(Ae.paint_sky["sky-atmosphere-sun"]),
                "sky-atmosphere-sun-intensity": new B(
                  Ae.paint_sky["sky-atmosphere-sun-intensity"]
                ),
                "sky-gradient-center": new B(
                  Ae.paint_sky["sky-gradient-center"]
                ),
                "sky-gradient-radius": new B(
                  Ae.paint_sky["sky-gradient-radius"]
                ),
                "sky-gradient": new ee(Ae.paint_sky["sky-gradient"]),
                "sky-atmosphere-halo-color": new B(
                  Ae.paint_sky["sky-atmosphere-halo-color"]
                ),
                "sky-atmosphere-color": new B(
                  Ae.paint_sky["sky-atmosphere-color"]
                ),
                "sky-opacity": new B(Ae.paint_sky["sky-opacity"]),
              }),
            };
            function Wd(r, i, o) {
              const l = [0, 0, 1],
                h = Qf([]);
              return (
                ad(h, h, o ? -Xt(r) + Math.PI : Xt(r)),
                Uu(h, h, -Xt(i)),
                ju(l, l, h),
                St(l, l)
              );
            }
            const ng = {
              circle: class extends Zr {
                constructor(r) {
                  super(r, Mv);
                }
                createBucket(r) {
                  return new kp(r);
                }
                queryRadius(r) {
                  const i = r;
                  return (
                    Gl("circle-radius", this, i) +
                    Gl("circle-stroke-width", this, i) +
                    Op(this.paint.get("circle-translate"))
                  );
                }
                queryIntersectsFeature(r, i, o, l, h, m, _, x) {
                  const E = r_(
                      this.paint.get("circle-translate"),
                      this.paint.get("circle-translate-anchor"),
                      m.angle,
                      r.pixelToTileUnitsFactor
                    ),
                    T =
                      this.paint.get("circle-radius").evaluate(i, o) +
                      this.paint.get("circle-stroke-width").evaluate(i, o);
                  return o_(
                    r,
                    l,
                    m,
                    _,
                    x,
                    "map" === this.paint.get("circle-pitch-alignment"),
                    "map" === this.paint.get("circle-pitch-scale"),
                    E,
                    T
                  );
                }
                getProgramIds() {
                  return ["circle"];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
              },
              heatmap: class extends Zr {
                createBucket(r) {
                  return new l_(r);
                }
                constructor(r) {
                  super(r, u_), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(r) {
                  "heatmap-color" === r && this._updateColorRamp();
                }
                _updateColorRamp() {
                  (this.colorRamp = gm({
                    expression:
                      this._transitionablePaint._values["heatmap-color"].value
                        .expression,
                    evaluationKey: "heatmapDensity",
                    image: this.colorRamp,
                  })),
                    (this.colorRampTexture = null);
                }
                resize() {
                  this.heatmapFbo &&
                    (this.heatmapFbo.destroy(), (this.heatmapFbo = null));
                }
                queryRadius(r) {
                  return Gl("heatmap-radius", this, r);
                }
                queryIntersectsFeature(r, i, o, l, h, m, _, x) {
                  const E = this.paint.get("heatmap-radius").evaluate(i, o);
                  return o_(r, l, m, _, x, !0, !0, new et(0, 0), E);
                }
                hasOffscreenPass() {
                  return (
                    0 !== this.paint.get("heatmap-opacity") &&
                    "none" !== this.visibility
                  );
                }
                getProgramIds() {
                  return ["heatmap", "heatmapTexture"];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
              },
              hillshade: class extends Zr {
                constructor(r) {
                  super(r, bb);
                }
                hasOffscreenPass() {
                  return (
                    0 !== this.paint.get("hillshade-exaggeration") &&
                    "none" !== this.visibility
                  );
                }
                getProgramIds() {
                  return ["hillshade", "hillshadePrepare"];
                }
              },
              fill: class extends Zr {
                constructor(r) {
                  super(r, Rv);
                }
                getProgramIds() {
                  const r = this.paint.get("fill-pattern"),
                    i = r && r.constantOr(1),
                    o = [i ? "fillPattern" : "fill"];
                  return (
                    this.paint.get("fill-antialias") &&
                      o.push(
                        i && !this.getPaintProperty("fill-outline-color")
                          ? "fillOutlinePattern"
                          : "fillOutline"
                      ),
                    o
                  );
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
                recalculate(r, i) {
                  super.recalculate(r, i);
                  const o = this.paint._values["fill-outline-color"];
                  "constant" === o.value.kind &&
                    void 0 === o.value.value &&
                    (this.paint._values["fill-outline-color"] =
                      this.paint._values["fill-color"]);
                }
                createBucket(r) {
                  return new qp(r);
                }
                queryRadius() {
                  return Op(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(r, i, o, l, h, m) {
                  return (
                    !r.queryGeometry.isAboveHorizon &&
                    n_(
                      i_(
                        r.tilespaceGeometry,
                        this.paint.get("fill-translate"),
                        this.paint.get("fill-translate-anchor"),
                        m.angle,
                        r.pixelToTileUnitsFactor
                      ),
                      l
                    )
                  );
                }
                isTileClipped() {
                  return !0;
                }
              },
              "fill-extrusion": class extends Zr {
                constructor(r) {
                  super(r, Cm);
                }
                createBucket(r) {
                  return new Kp(r);
                }
                queryRadius() {
                  return Op(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                  return !0;
                }
                getProgramIds() {
                  return [
                    this.paint.get("fill-extrusion-pattern").constantOr(1)
                      ? "fillExtrusionPattern"
                      : "fillExtrusion",
                  ];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
                queryIntersectsFeature(r, i, o, l, h, m, _, x, E) {
                  const T = r_(
                      this.paint.get("fill-extrusion-translate"),
                      this.paint.get("fill-extrusion-translate-anchor"),
                      m.angle,
                      r.pixelToTileUnitsFactor
                    ),
                    C = this.paint.get("fill-extrusion-height").evaluate(i, o),
                    A = this.paint.get("fill-extrusion-base").evaluate(i, o),
                    L = [0, 0],
                    O = x && m.elevation,
                    F = m.elevation ? m.elevation.exaggeration() : 1,
                    V = r.tile.getBucket(this);
                  if (O && V instanceof Kp) {
                    const re = V.centroidVertexArray,
                      le = E + 1;
                    le < re.length &&
                      ((L[0] = re.geta_centroid_pos0(le)),
                      (L[1] = re.geta_centroid_pos1(le)));
                  }
                  if (0 === L[0] && 1 === L[1]) return !1;
                  "globe" === m.projection.name &&
                    (l = Id(
                      [l],
                      [new et(0, 0), new et(vt, vt)],
                      r.tileID.canonical
                    )
                      .map((re) => re.polygon)
                      .flat());
                  const G = O ? x : null,
                    [K, oe] =
                      ((le = l),
                      (ae = A),
                      (De = C),
                      (xe = T),
                      (Pe = _),
                      ($e = G),
                      (Ce = L),
                      (Fe = F),
                      (Re = m.center.lat),
                      "globe" === (re = m).projection.name
                        ? (function (
                            qe,
                            Me,
                            Je,
                            ut,
                            nt,
                            Mt,
                            Ke,
                            yt,
                            Ct,
                            Zt,
                            It
                          ) {
                            const xt = [],
                              Dn = [],
                              Rt = qe.projection.upVectorScale(
                                It,
                                qe.center.lat,
                                qe.worldSize
                              ).metersToTile,
                              At = [0, 0, 0, 1],
                              An = [0, 0, 0, 1],
                              Fn = (gn, Wn, oi, yi) => {
                                (gn[0] = Wn),
                                  (gn[1] = oi),
                                  (gn[2] = yi),
                                  (gn[3] = 1);
                              },
                              Nn = Im();
                            Je > 0 && (Je += Nn), (ut += Nn);
                            for (const gn of Me) {
                              const Wn = [],
                                oi = [];
                              for (const yi of gn) {
                                const zn = yi.x + nt.x,
                                  Di = yi.y + nt.y,
                                  vi = qe.projection.projectTilePoint(
                                    zn,
                                    Di,
                                    It
                                  ),
                                  Yn = qe.projection.upVector(It, yi.x, yi.y);
                                let cn = Je,
                                  si = ut;
                                if (Ke) {
                                  const Bn = I_(zn, Di, Je, ut, Ke, yt, Ct, Zt);
                                  (cn += Bn.base), (si += Bn.top);
                                }
                                0 !== Je
                                  ? Fn(
                                      At,
                                      vi.x + Yn[0] * Rt * cn,
                                      vi.y + Yn[1] * Rt * cn,
                                      vi.z + Yn[2] * Rt * cn
                                    )
                                  : Fn(At, vi.x, vi.y, vi.z),
                                  Fn(
                                    An,
                                    vi.x + Yn[0] * Rt * si,
                                    vi.y + Yn[1] * Rt * si,
                                    vi.z + Yn[2] * Rt * si
                                  ),
                                  Kn(At, At, Mt),
                                  Kn(An, An, Mt),
                                  Wn.push(new Vc(At[0], At[1], At[2])),
                                  oi.push(new Vc(An[0], An[1], An[2]));
                              }
                              xt.push(Wn), Dn.push(oi);
                            }
                            return [xt, Dn];
                          })(
                            re,
                            le,
                            ae,
                            De,
                            xe,
                            Pe,
                            $e,
                            Ce,
                            Fe,
                            Re,
                            r.tileID.canonical
                          )
                        : $e
                        ? (function (qe, Me, Je, ut, nt, Mt, Ke, yt, Ct) {
                            const Zt = [],
                              It = [],
                              xt = [0, 0, 0, 1];
                            for (const Dn of qe) {
                              const Rt = [],
                                At = [];
                              for (const An of Dn) {
                                const Fn = An.x + ut.x,
                                  Nn = An.y + ut.y,
                                  gn = I_(Fn, Nn, Me, Je, Mt, Ke, yt, Ct);
                                (xt[0] = Fn),
                                  (xt[1] = Nn),
                                  (xt[2] = gn.base),
                                  (xt[3] = 1),
                                  aa(xt, xt, nt),
                                  (xt[3] = Math.max(xt[3], 1e-5));
                                const Wn = new Vc(
                                  xt[0] / xt[3],
                                  xt[1] / xt[3],
                                  xt[2] / xt[3]
                                );
                                (xt[0] = Fn),
                                  (xt[1] = Nn),
                                  (xt[2] = gn.top),
                                  (xt[3] = 1),
                                  aa(xt, xt, nt),
                                  (xt[3] = Math.max(xt[3], 1e-5));
                                const oi = new Vc(
                                  xt[0] / xt[3],
                                  xt[1] / xt[3],
                                  xt[2] / xt[3]
                                );
                                Rt.push(Wn), At.push(oi);
                              }
                              Zt.push(Rt), It.push(At);
                            }
                            return [Zt, It];
                          })(le, ae, De, xe, Pe, $e, Ce, Fe, Re)
                        : (function (qe, Me, Je, ut, nt) {
                            const Mt = [],
                              Ke = [],
                              yt = nt[8] * Me,
                              Ct = nt[9] * Me,
                              Zt = nt[10] * Me,
                              It = nt[11] * Me,
                              xt = nt[8] * Je,
                              Dn = nt[9] * Je,
                              Rt = nt[10] * Je,
                              At = nt[11] * Je;
                            for (const An of qe) {
                              const Fn = [],
                                Nn = [];
                              for (const gn of An) {
                                const Wn = gn.x + ut.x,
                                  oi = gn.y + ut.y,
                                  yi = nt[0] * Wn + nt[4] * oi + nt[12],
                                  zn = nt[1] * Wn + nt[5] * oi + nt[13],
                                  Di = nt[2] * Wn + nt[6] * oi + nt[14],
                                  vi = nt[3] * Wn + nt[7] * oi + nt[15],
                                  Yn = yi + yt,
                                  cn = zn + Ct,
                                  si = Di + Zt,
                                  Bn = Math.max(vi + It, 1e-5),
                                  cr = yi + xt,
                                  xi = zn + Dn,
                                  Qi = Di + Rt,
                                  Gi = Math.max(vi + At, 1e-5);
                                Fn.push(new Vc(Yn / Bn, cn / Bn, si / Bn)),
                                  Nn.push(new Vc(cr / Gi, xi / Gi, Qi / Gi));
                              }
                              Mt.push(Fn), Ke.push(Nn);
                            }
                            return [Mt, Ke];
                          })(le, ae, De, xe, Pe)),
                    J = r.queryGeometry;
                  var re, le, ae, De, xe, Pe, $e, Ce, Fe, Re;
                  return (function (re, le, ae) {
                    let De = 1 / 0;
                    n_(ae, le) && (De = S_(ae, le[0]));
                    for (let xe = 0; xe < le.length; xe++) {
                      const Pe = le[xe],
                        $e = re[xe];
                      for (let Ce = 0; Ce < Pe.length - 1; Ce++) {
                        const Fe = Pe[Ce],
                          Re = [Fe, Pe[Ce + 1], $e[Ce + 1], $e[Ce], Fe];
                        t_(ae, Re) && (De = Math.min(De, S_(ae, Re)));
                      }
                    }
                    return De !== 1 / 0 && De;
                  })(
                    K,
                    oe,
                    J.isPointQuery() ? J.screenBounds : J.screenGeometry
                  );
                }
              },
              line: class extends Zr {
                constructor(r) {
                  super(r, Mm), (this.gradientVersion = 0);
                }
                _handleSpecialPaintPropertyUpdate(r) {
                  if ("line-gradient" === r) {
                    const i =
                      this._transitionablePaint._values["line-gradient"].value
                        .expression;
                    (this.stepInterpolant =
                      i._styleExpression &&
                      i._styleExpression.expression instanceof Fh),
                      (this.gradientVersion =
                        (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
                  }
                }
                gradientExpression() {
                  return this._transitionablePaint._values["line-gradient"]
                    .value.expression;
                }
                widthExpression() {
                  return this._transitionablePaint._values["line-width"].value
                    .expression;
                }
                recalculate(r, i) {
                  super.recalculate(r, i),
                    (this.paint._values["line-floorwidth"] =
                      A_.possiblyEvaluate(
                        this._transitioningPaint._values["line-width"].value,
                        r
                      ));
                }
                createBucket(r) {
                  return new Ad(r);
                }
                getProgramIds() {
                  return [
                    this.paint.get("line-pattern").constantOr(1)
                      ? "linePattern"
                      : "line",
                  ];
                }
                getProgramConfiguration(r) {
                  return new oa(this, r);
                }
                queryRadius(r) {
                  const i = r,
                    o = Am(
                      Gl("line-width", this, i),
                      Gl("line-gap-width", this, i)
                    ),
                    l = Gl("line-offset", this, i);
                  return (
                    o / 2 + Math.abs(l) + Op(this.paint.get("line-translate"))
                  );
                }
                queryIntersectsFeature(r, i, o, l, h, m) {
                  if (r.queryGeometry.isAboveHorizon) return !1;
                  const _ = i_(
                      r.tilespaceGeometry,
                      this.paint.get("line-translate"),
                      this.paint.get("line-translate-anchor"),
                      m.angle,
                      r.pixelToTileUnitsFactor
                    ),
                    x =
                      (r.pixelToTileUnitsFactor / 2) *
                      Am(
                        this.paint.get("line-width").evaluate(i, o),
                        this.paint.get("line-gap-width").evaluate(i, o)
                      ),
                    E = this.paint.get("line-offset").evaluate(i, o);
                  return (
                    E &&
                      (l = (function (T, C) {
                        const A = [],
                          L = new et(0, 0);
                        for (let O = 0; O < T.length; O++) {
                          const F = T[O],
                            V = [];
                          for (let G = 0; G < F.length; G++) {
                            const K = F[G],
                              oe = F[G + 1],
                              J =
                                0 === G
                                  ? L
                                  : K.sub(F[G - 1])
                                      ._unit()
                                      ._perp(),
                              re =
                                G === F.length - 1
                                  ? L
                                  : oe.sub(K)._unit()._perp(),
                              le = J._add(re)._unit();
                            le._mult(1 / (le.x * re.x + le.y * re.y)),
                              V.push(le._mult(C)._add(K));
                          }
                          A.push(V);
                        }
                        return A;
                      })(l, E * r.pixelToTileUnitsFactor)),
                    (function (T, C, A) {
                      for (let L = 0; L < C.length; L++) {
                        const O = C[L];
                        if (T.length >= 3)
                          for (let F = 0; F < O.length; F++)
                            if (nl(T, O[F])) return !0;
                        if (Dv(T, O, A)) return !0;
                      }
                      return !1;
                    })(_, l, x)
                  );
                }
                isTileClipped() {
                  return !0;
                }
              },
              symbol: qd,
              background: class extends Zr {
                constructor(r) {
                  super(r, Lb);
                }
                getProgramIds() {
                  return [
                    this.paint.get("background-pattern")
                      ? "backgroundPattern"
                      : "background",
                  ];
                }
              },
              raster: class extends Zr {
                constructor(r) {
                  super(r, of);
                }
                getProgramIds() {
                  return ["raster"];
                }
              },
              sky: class extends Zr {
                constructor(r) {
                  super(r, tg), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(r) {
                  "sky-gradient" === r
                    ? this._updateColorRamp()
                    : ("sky-atmosphere-sun" !== r &&
                        "sky-atmosphere-halo-color" !== r &&
                        "sky-atmosphere-color" !== r &&
                        "sky-atmosphere-sun-intensity" !== r) ||
                      (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                  (this.colorRamp = gm({
                    expression:
                      this._transitionablePaint._values["sky-gradient"].value
                        .expression,
                    evaluationKey: "skyRadialProgress",
                  })),
                    this.colorRampTexture &&
                      (this.colorRampTexture.destroy(),
                      (this.colorRampTexture = null));
                }
                needsSkyboxCapture(r) {
                  if (
                    this._skyboxInvalidated ||
                    !this.skyboxTexture ||
                    !this.skyboxGeometry
                  )
                    return !0;
                  if (!this.paint.get("sky-atmosphere-sun")) {
                    const i = r.style.light.properties.get("position");
                    return (
                      this._lightPosition.azimuthal !== i.azimuthal ||
                      this._lightPosition.polar !== i.polar
                    );
                  }
                  return !1;
                }
                getCenter(r, i) {
                  if ("atmosphere" === this.paint.get("sky-type")) {
                    const l = this.paint.get("sky-atmosphere-sun"),
                      h = !l,
                      m = r.style.light,
                      _ = m.properties.get("position");
                    return (
                      h &&
                        "viewport" === m.properties.get("anchor") &&
                        Hn(
                          "The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."
                        ),
                      h
                        ? Wd(_.azimuthal, 90 - _.polar, i)
                        : Wd(l[0], 90 - l[1], i)
                    );
                  }
                  const o = this.paint.get("sky-gradient-center");
                  return Wd(o[0], 90 - o[1], i);
                }
                is3D() {
                  return !1;
                }
                isSky() {
                  return !0;
                }
                markSkyboxValid(r) {
                  (this._skyboxInvalidated = !1),
                    (this._lightPosition =
                      r.style.light.properties.get("position"));
                }
                hasOffscreenPass() {
                  return !0;
                }
                getProgramIds() {
                  const r = this.paint.get("sky-type");
                  return "atmosphere" === r
                    ? ["skyboxCapture", "skybox"]
                    : "gradient" === r
                    ? ["skyboxGradient"]
                    : null;
                }
              },
            };
            class af {
              constructor(i, o, l, h) {
                (this.context = i),
                  (this.format = l),
                  (this.texture = i.gl.createTexture()),
                  this.update(o, h);
              }
              update(i, o, l) {
                const { width: h, height: m } = i,
                  { context: _ } = this,
                  { gl: x } = _,
                  {
                    HTMLImageElement: E,
                    HTMLCanvasElement: T,
                    HTMLVideoElement: C,
                    ImageData: A,
                    ImageBitmap: L,
                  } = Be;
                if (
                  (x.bindTexture(x.TEXTURE_2D, this.texture),
                  _.pixelStoreUnpackFlipY.set(!1),
                  _.pixelStoreUnpack.set(1),
                  _.pixelStoreUnpackPremultiplyAlpha.set(
                    this.format === x.RGBA && (!o || !1 !== o.premultiply)
                  ),
                  l || (this.size && this.size[0] === h && this.size[1] === m))
                ) {
                  const { x: O, y: F } = l || { x: 0, y: 0 };
                  i instanceof E ||
                  i instanceof T ||
                  i instanceof C ||
                  i instanceof A ||
                  (L && i instanceof L)
                    ? x.texSubImage2D(
                        x.TEXTURE_2D,
                        0,
                        O,
                        F,
                        x.RGBA,
                        x.UNSIGNED_BYTE,
                        i
                      )
                    : x.texSubImage2D(
                        x.TEXTURE_2D,
                        0,
                        O,
                        F,
                        h,
                        m,
                        x.RGBA,
                        x.UNSIGNED_BYTE,
                        i.data
                      );
                } else (this.size = [h, m]), i instanceof E || i instanceof T || i instanceof C || i instanceof A || (L && i instanceof L) ? x.texImage2D(x.TEXTURE_2D, 0, this.format, this.format, x.UNSIGNED_BYTE, i) : x.texImage2D(x.TEXTURE_2D, 0, this.format, h, m, 0, this.format, x.UNSIGNED_BYTE, i.data);
                (this.useMipmap = Boolean(
                  o && o.useMipmap && this.isSizePowerOfTwo()
                )),
                  this.useMipmap && x.generateMipmap(x.TEXTURE_2D);
              }
              bind(i, o) {
                const { context: l } = this,
                  { gl: h } = l;
                h.bindTexture(h.TEXTURE_2D, this.texture),
                  i !== this.filter &&
                    (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, i),
                    h.texParameteri(
                      h.TEXTURE_2D,
                      h.TEXTURE_MIN_FILTER,
                      this.useMipmap
                        ? i === h.NEAREST
                          ? h.NEAREST_MIPMAP_NEAREST
                          : h.LINEAR_MIPMAP_NEAREST
                        : i
                    ),
                    (this.filter = i)),
                  o !== this.wrap &&
                    (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, o),
                    h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, o),
                    (this.wrap = o));
              }
              isSizePowerOfTwo() {
                return (
                  this.size[0] === this.size[1] &&
                  (Math.log(this.size[0]) / Math.LN2) % 1 == 0
                );
              }
              destroy() {
                const { gl: i } = this.context;
                i.deleteTexture(this.texture), (this.texture = null);
              }
            }
            class p0 {
              constructor(i) {
                (this._callback = i),
                  (this._triggered = !1),
                  typeof MessageChannel < "u" &&
                    ((this._channel = new MessageChannel()),
                    (this._channel.port2.onmessage = () => {
                      (this._triggered = !1), this._callback();
                    }));
              }
              trigger() {
                this._triggered ||
                  ((this._triggered = !0),
                  this._channel
                    ? this._channel.port1.postMessage(!0)
                    : setTimeout(() => {
                        (this._triggered = !1), this._callback();
                      }, 0));
              }
              remove() {
                (this._channel = void 0), (this._callback = () => {});
              }
            }
            class f0 {
              constructor() {
                (this.tasks = {}),
                  (this.taskQueue = []),
                  No(["process"], this),
                  (this.invoker = new p0(this.process)),
                  (this.nextId = 0);
              }
              add(i, o) {
                const l = this.nextId++,
                  h = (function ({ type: m, isSymbolTile: _, zoom: x }) {
                    return (
                      (x = x || 0),
                      "message" === m
                        ? 0
                        : "maybePrepare" !== m || _
                        ? "parseTile" !== m || _
                          ? "parseTile" === m && _
                            ? 300 - x
                            : "maybePrepare" === m && _
                            ? 400 - x
                            : 500
                          : 200 - x
                        : 100 - x
                    );
                  })(o);
                if (0 === h) {
                  zs();
                  try {
                    i();
                  } finally {
                  }
                  return { cancel: () => {} };
                }
                return (
                  (this.tasks[l] = { fn: i, metadata: o, priority: h, id: l }),
                  this.taskQueue.push(l),
                  this.invoker.trigger(),
                  {
                    cancel: () => {
                      delete this.tasks[l];
                    },
                  }
                );
              }
              process() {
                zs();
                try {
                  if (
                    ((this.taskQueue = this.taskQueue.filter(
                      (l) => !!this.tasks[l]
                    )),
                    !this.taskQueue.length)
                  )
                    return;
                  const i = this.pick();
                  if (null === i) return;
                  const o = this.tasks[i];
                  if (
                    (delete this.tasks[i],
                    this.taskQueue.length && this.invoker.trigger(),
                    !o)
                  )
                    return;
                  o.fn();
                } finally {
                }
              }
              pick() {
                let i = null,
                  o = 1 / 0;
                for (let h = 0; h < this.taskQueue.length; h++) {
                  const m = this.tasks[this.taskQueue[h]];
                  m.priority < o && ((o = m.priority), (i = h));
                }
                if (null === i) return null;
                const l = this.taskQueue[i];
                return this.taskQueue.splice(i, 1), l;
              }
              remove() {
                this.invoker.remove();
              }
            }
            class oy {
              constructor(i) {
                (this._stringToNumber = {}), (this._numberToString = []);
                for (let o = 0; o < i.length; o++) {
                  const l = i[o];
                  (this._stringToNumber[l] = o), (this._numberToString[o] = l);
                }
              }
              encode(i) {
                return this._stringToNumber[i];
              }
              decode(i) {
                return this._numberToString[i];
              }
            }
            const m0 = ["tile", "layer", "source", "sourceLayer", "state"];
            class ig {
              constructor(i, o, l, h, m) {
                (this.type = "Feature"),
                  (this._vectorTileFeature = i),
                  (this._z = o),
                  (this._x = l),
                  (this._y = h),
                  (this.properties = i.properties),
                  (this.id = m);
              }
              get geometry() {
                return (
                  void 0 === this._geometry &&
                    (this._geometry = this._vectorTileFeature.toGeoJSON(
                      this._x,
                      this._y,
                      this._z
                    ).geometry),
                  this._geometry
                );
              }
              set geometry(i) {
                this._geometry = i;
              }
              toJSON() {
                const i = {
                  type: "Feature",
                  state: void 0,
                  geometry: this.geometry,
                  properties: this.properties,
                };
                void 0 !== this.id && (i.id = this.id);
                for (const o of m0) void 0 !== this[o] && (i[o] = this[o]);
                return i;
              }
            }
            const Zc = new Uint16Array(8184);
            for (let r = 0; r < 2046; r++) {
              let i = r + 2,
                o = 0,
                l = 0,
                h = 0,
                m = 0,
                _ = 0,
                x = 0;
              for (
                1 & i ? (h = m = _ = 32) : (o = l = x = 32);
                (i >>= 1) > 1;

              ) {
                const T = (o + h) >> 1,
                  C = (l + m) >> 1;
                1 & i
                  ? ((h = o), (m = l), (o = _), (l = x))
                  : ((o = h), (l = m), (h = _), (m = x)),
                  (_ = T),
                  (x = C);
              }
              const E = 4 * r;
              (Zc[E + 0] = o),
                (Zc[E + 1] = l),
                (Zc[E + 2] = h),
                (Zc[E + 3] = m);
            }
            const Es = new Uint16Array(2178),
              al = new Uint8Array(1089),
              lf = new Uint16Array(1089);
            function cf(r) {
              return 0 === r ? -0.03125 : 32 === r ? 0.03125 : 0;
            }
            var g0 = ge([
              { name: "a_pos", type: "Int16", components: 2 },
              { name: "a_texture_pos", type: "Int16", components: 2 },
            ]);
            const _0 = {
              type: 2,
              extent: vt,
              loadGeometry: () => [
                [
                  new et(0, 0),
                  new et(8193, 0),
                  new et(8193, 8193),
                  new et(0, 8193),
                  new et(0, 0),
                ],
              ],
            };
            class sy {
              constructor(i, o, l, h, m) {
                (this.tileID = i),
                  (this.uid = rs()),
                  (this.uses = 0),
                  (this.tileSize = o),
                  (this.tileZoom = l),
                  (this.buckets = {}),
                  (this.expirationTime = null),
                  (this.queryPadding = 0),
                  (this.hasSymbolBuckets = !1),
                  (this.hasRTLText = !1),
                  (this.dependencies = {}),
                  (this.isRaster = m),
                  (this.expiredRequestCount = 0),
                  (this.state = "loading"),
                  h &&
                    h.transform &&
                    (this.projection = h.transform.projection);
              }
              registerFadeDuration(i) {
                const o = i + this.timeAdded;
                o < cs.now() ||
                  (this.fadeEndTime && o < this.fadeEndTime) ||
                  (this.fadeEndTime = o);
              }
              wasRequested() {
                return (
                  "errored" === this.state ||
                  "loaded" === this.state ||
                  "reloading" === this.state
                );
              }
              get tileTransform() {
                return (
                  this._tileTransform ||
                    (this._tileTransform = qc(
                      this.tileID.canonical,
                      this.projection
                    )),
                  this._tileTransform
                );
              }
              loadVectorData(i, o, l) {
                if ((this.unloadVectorData(), (this.state = "loaded"), i)) {
                  i.featureIndex &&
                    ((this.latestFeatureIndex = i.featureIndex),
                    i.rawTileData
                      ? ((this.latestRawTileData = i.rawTileData),
                        (this.latestFeatureIndex.rawTileData = i.rawTileData))
                      : this.latestRawTileData &&
                        (this.latestFeatureIndex.rawTileData =
                          this.latestRawTileData)),
                    (this.collisionBoxArray = i.collisionBoxArray),
                    (this.buckets = (function (h, m) {
                      const _ = {};
                      if (!m) return _;
                      for (const x of h) {
                        const E = x.layerIds
                          .map((T) => m.getLayer(T))
                          .filter(Boolean);
                        if (0 !== E.length) {
                          (x.layers = E),
                            x.stateDependentLayerIds &&
                              (x.stateDependentLayers =
                                x.stateDependentLayerIds.map(
                                  (T) => E.filter((C) => C.id === T)[0]
                                ));
                          for (const T of E) _[T.id] = x;
                        }
                      }
                      return _;
                    })(i.buckets, o.style)),
                    (this.hasSymbolBuckets = !1);
                  for (const h in this.buckets) {
                    const m = this.buckets[h];
                    if (m instanceof fa) {
                      if (((this.hasSymbolBuckets = !0), !l)) break;
                      m.justReloaded = !0;
                    }
                  }
                  if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                    for (const h in this.buckets) {
                      const m = this.buckets[h];
                      if (m instanceof fa && m.hasRTLText) {
                        (this.hasRTLText = !0),
                          I.isLoading() ||
                            I.isLoaded() ||
                            "deferred" !== b() ||
                            D();
                        break;
                      }
                    }
                  this.queryPadding = 0;
                  for (const h in this.buckets) {
                    const m = this.buckets[h];
                    this.queryPadding = Math.max(
                      this.queryPadding,
                      o.style.getLayer(h).queryRadius(m)
                    );
                  }
                  i.imageAtlas && (this.imageAtlas = i.imageAtlas),
                    i.glyphAtlasImage &&
                      (this.glyphAtlasImage = i.glyphAtlasImage),
                    i.lineAtlas && (this.lineAtlas = i.lineAtlas);
                } else this.collisionBoxArray = new Cn();
              }
              unloadVectorData() {
                if (this.hasData()) {
                  for (const i in this.buckets) this.buckets[i].destroy();
                  (this.buckets = {}),
                    this.imageAtlas && (this.imageAtlas = null),
                    this.lineAtlas && (this.lineAtlas = null),
                    this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                    this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                    this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                    this._tileBoundsBuffer &&
                      (this._tileBoundsBuffer.destroy(),
                      this._tileBoundsIndexBuffer.destroy(),
                      this._tileBoundsSegments.destroy(),
                      (this._tileBoundsBuffer = null)),
                    this._tileDebugBuffer &&
                      (this._tileDebugBuffer.destroy(),
                      this._tileDebugSegments.destroy(),
                      (this._tileDebugBuffer = null)),
                    this._tileDebugIndexBuffer &&
                      (this._tileDebugIndexBuffer.destroy(),
                      (this._tileDebugIndexBuffer = null)),
                    this._globeTileDebugBorderBuffer &&
                      (this._globeTileDebugBorderBuffer.destroy(),
                      (this._globeTileDebugBorderBuffer = null)),
                    this._tileDebugTextBuffer &&
                      (this._tileDebugTextBuffer.destroy(),
                      this._tileDebugTextSegments.destroy(),
                      this._tileDebugTextIndexBuffer.destroy(),
                      (this._tileDebugTextBuffer = null)),
                    this._globeTileDebugTextBuffer &&
                      (this._globeTileDebugTextBuffer.destroy(),
                      (this._globeTileDebugTextBuffer = null)),
                    (this.latestFeatureIndex = null),
                    (this.state = "unloaded");
                }
              }
              getBucket(i) {
                return this.buckets[i.id];
              }
              upload(i) {
                for (const l in this.buckets) {
                  const h = this.buckets[l];
                  h.uploadPending() && h.upload(i);
                }
                const o = i.gl;
                this.imageAtlas &&
                  !this.imageAtlas.uploaded &&
                  ((this.imageAtlasTexture = new af(
                    i,
                    this.imageAtlas.image,
                    o.RGBA
                  )),
                  (this.imageAtlas.uploaded = !0)),
                  this.glyphAtlasImage &&
                    ((this.glyphAtlasTexture = new af(
                      i,
                      this.glyphAtlasImage,
                      o.ALPHA
                    )),
                    (this.glyphAtlasImage = null)),
                  this.lineAtlas &&
                    !this.lineAtlas.uploaded &&
                    ((this.lineAtlasTexture = new af(
                      i,
                      this.lineAtlas.image,
                      o.ALPHA
                    )),
                    (this.lineAtlas.uploaded = !0));
              }
              prepare(i) {
                this.imageAtlas &&
                  this.imageAtlas.patchUpdatedImages(i, this.imageAtlasTexture);
              }
              queryRenderedFeatures(i, o, l, h, m, _, x, E) {
                return this.latestFeatureIndex &&
                  this.latestFeatureIndex.rawTileData
                  ? this.latestFeatureIndex.query(
                      {
                        tileResult: h,
                        pixelPosMatrix: x,
                        transform: _,
                        params: m,
                        tileTransform: this.tileTransform,
                      },
                      i,
                      o,
                      l
                    )
                  : {};
              }
              querySourceFeatures(i, o) {
                const l = this.latestFeatureIndex;
                if (!l || !l.rawTileData) return;
                const h = l.loadVTLayers(),
                  m = o ? o.sourceLayer : "",
                  _ = h._geojsonTileLayer || h[m];
                if (!_) return;
                const x = Mu(o && o.filter),
                  { z: E, x: T, y: C } = this.tileID.canonical,
                  A = { z: E, x: T, y: C };
                for (let L = 0; L < _.length; L++) {
                  const O = _.feature(L);
                  if (x.needGeometry) {
                    const G = tl(O, !0);
                    if (
                      !x.filter(
                        new M(this.tileID.overscaledZ),
                        G,
                        this.tileID.canonical
                      )
                    )
                      continue;
                  } else if (!x.filter(new M(this.tileID.overscaledZ), O))
                    continue;
                  const F = l.getId(O, m),
                    V = new ig(O, E, T, C, F);
                  (V.tile = A), i.push(V);
                }
              }
              hasData() {
                return (
                  "loaded" === this.state ||
                  "reloading" === this.state ||
                  "expired" === this.state
                );
              }
              patternsLoaded() {
                return (
                  !!this.imageAtlas &&
                  !!Object.keys(this.imageAtlas.patternPositions).length
                );
              }
              setExpiryData(i) {
                const o = this.expirationTime;
                if (i.cacheControl) {
                  const l = no(i.cacheControl);
                  l["max-age"] &&
                    (this.expirationTime = Date.now() + 1e3 * l["max-age"]);
                } else i.expires && (this.expirationTime = new Date(i.expires).getTime());
                if (this.expirationTime) {
                  const l = Date.now();
                  let h = !1;
                  if (this.expirationTime > l) h = !1;
                  else if (o)
                    if (this.expirationTime < o) h = !0;
                    else {
                      const m = this.expirationTime - o;
                      m
                        ? (this.expirationTime = l + Math.max(m, 3e4))
                        : (h = !0);
                    }
                  else h = !0;
                  h
                    ? (this.expiredRequestCount++, (this.state = "expired"))
                    : (this.expiredRequestCount = 0);
                }
              }
              getExpiryTimeout() {
                if (this.expirationTime)
                  return this.expiredRequestCount
                    ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                    : Math.min(
                        this.expirationTime - new Date().getTime(),
                        Math.pow(2, 31) - 1
                      );
              }
              setFeatureState(i, o) {
                if (
                  !this.latestFeatureIndex ||
                  !this.latestFeatureIndex.rawTileData ||
                  0 === Object.keys(i).length ||
                  !o
                )
                  return;
                const l = this.latestFeatureIndex.loadVTLayers(),
                  h = o.style.listImages();
                for (const m in this.buckets) {
                  if (!o.style.hasLayer(m)) continue;
                  const _ = this.buckets[m],
                    x = _.layers[0].sourceLayer || "_geojsonTileLayer",
                    E = l[x],
                    T = i[x];
                  if (!E || !T || 0 === Object.keys(T).length) continue;
                  if (
                    (_.update(
                      T,
                      E,
                      h,
                      (this.imageAtlas && this.imageAtlas.patternPositions) ||
                        {}
                    ),
                    _ instanceof Ad || _ instanceof qp)
                  ) {
                    const A = o.style._getSourceCache(_.layers[0].source);
                    o._terrain &&
                      o._terrain.enabled &&
                      A &&
                      _.programConfigurations.needsUpload &&
                      o._terrain._clearRenderCacheForTile(A.id, this.tileID);
                  }
                  const C = o && o.style && o.style.getLayer(m);
                  C &&
                    (this.queryPadding = Math.max(
                      this.queryPadding,
                      C.queryRadius(_)
                    ));
                }
              }
              holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
              }
              symbolFadeFinished() {
                return (
                  !this.symbolFadeHoldUntil ||
                  this.symbolFadeHoldUntil < cs.now()
                );
              }
              clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
              }
              setHoldDuration(i) {
                this.symbolFadeHoldUntil = cs.now() + i;
              }
              setTexture(i, o) {
                const l = o.context,
                  h = l.gl;
                (this.texture = this.texture || o.getTileTexture(i.width)),
                  this.texture
                    ? this.texture.update(i, { useMipmap: !0 })
                    : ((this.texture = new af(l, i, h.RGBA, { useMipmap: !0 })),
                      this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE));
              }
              setDependencies(i, o) {
                const l = {};
                for (const h of o) l[h] = !0;
                this.dependencies[i] = l;
              }
              hasDependency(i, o) {
                for (const l of i) {
                  const h = this.dependencies[l];
                  if (h) for (const m of o) if (h[m]) return !0;
                }
                return !1;
              }
              clearQueryDebugViz() {}
              _makeDebugTileBoundsBuffers(i, o) {
                if (!o || "mercator" === o.name || this._tileDebugBuffer)
                  return;
                const l = el(_0, this.tileID.canonical, this.tileTransform)[0],
                  h = new Ge(),
                  m = new br();
                for (let _ = 0; _ < l.length; _++) {
                  const { x, y: E } = l[_];
                  h.emplaceBack(x, E), m.emplaceBack(_);
                }
                m.emplaceBack(0),
                  (this._tileDebugIndexBuffer = i.createIndexBuffer(m)),
                  (this._tileDebugBuffer = i.createVertexBuffer(h, Ja.members)),
                  (this._tileDebugSegments = gi.simpleSegment(
                    0,
                    0,
                    h.length,
                    m.length
                  ));
              }
              _makeTileBoundsBuffers(i, o) {
                if (this._tileBoundsBuffer || !o || "mercator" === o.name)
                  return;
                const l = el(_0, this.tileID.canonical, this.tileTransform)[0];
                let h, m;
                if (this.isRaster) {
                  const _ = (function (x, E) {
                    const T = qc(x, E),
                      C = Math.pow(2, x.z);
                    for (let G = 0; G < 33; G++)
                      for (let K = 0; K < 33; K++) {
                        const oe = so((x.x + (K + cf(K)) / 32) / C),
                          J = $i((x.y + (G + cf(G)) / 32) / C),
                          re = E.project(oe, J),
                          le = 33 * G + K;
                        (Es[2 * le + 0] = Math.round(
                          (re.x * T.scale - T.x) * vt
                        )),
                          (Es[2 * le + 1] = Math.round(
                            (re.y * T.scale - T.y) * vt
                          ));
                      }
                    al.fill(0), lf.fill(0);
                    for (let G = 2045; G >= 0; G--) {
                      const K = 4 * G,
                        oe = Zc[K + 0],
                        J = Zc[K + 1],
                        re = Zc[K + 2],
                        le = Zc[K + 3],
                        ae = (oe + re) >> 1,
                        De = (J + le) >> 1,
                        xe = ae + De - J,
                        Pe = De + oe - ae,
                        $e = 33 * J + oe,
                        Ce = 33 * le + re,
                        Fe = 33 * De + ae,
                        Re =
                          Math.hypot(
                            (Es[2 * $e + 0] + Es[2 * Ce + 0]) / 2 -
                              Es[2 * Fe + 0],
                            (Es[2 * $e + 1] + Es[2 * Ce + 1]) / 2 -
                              Es[2 * Fe + 1]
                          ) >= 16;
                      (al[Fe] = al[Fe] || (Re ? 1 : 0)),
                        G < 1022 &&
                          (al[Fe] =
                            al[Fe] ||
                            al[33 * ((J + Pe) >> 1) + ((oe + xe) >> 1)] ||
                            al[33 * ((le + Pe) >> 1) + ((re + xe) >> 1)]);
                    }
                    const A = new Le(),
                      L = new ft();
                    let O = 0;
                    function F(G, K) {
                      const oe = 33 * K + G;
                      return (
                        0 === lf[oe] &&
                          (A.emplaceBack(
                            Es[2 * oe + 0],
                            Es[2 * oe + 1],
                            (G * vt) / 32,
                            (K * vt) / 32
                          ),
                          (lf[oe] = ++O)),
                        lf[oe] - 1
                      );
                    }
                    function V(G, K, oe, J, re, le) {
                      const ae = (G + oe) >> 1,
                        De = (K + J) >> 1;
                      if (
                        Math.abs(G - re) + Math.abs(K - le) > 1 &&
                        al[33 * De + ae]
                      )
                        V(re, le, G, K, ae, De), V(oe, J, re, le, ae, De);
                      else {
                        const xe = F(G, K),
                          Pe = F(oe, J),
                          $e = F(re, le);
                        L.emplaceBack(xe, Pe, $e);
                      }
                    }
                    return (
                      V(0, 0, 32, 32, 32, 0),
                      V(32, 32, 0, 0, 0, 32),
                      { vertices: A, indices: L }
                    );
                  })(this.tileID.canonical, o);
                  (h = _.vertices), (m = _.indices);
                } else {
                  (h = new Le()), (m = new ft());
                  for (const { x, y: E } of l) h.emplaceBack(x, E, 0, 0);
                  const _ = Up(h.int16, void 0, 4);
                  for (let x = 0; x < _.length; x += 3)
                    m.emplaceBack(_[x], _[x + 1], _[x + 2]);
                }
                (this._tileBoundsBuffer = i.createVertexBuffer(h, g0.members)),
                  (this._tileBoundsIndexBuffer = i.createIndexBuffer(m)),
                  (this._tileBoundsSegments = gi.simpleSegment(
                    0,
                    0,
                    h.length,
                    m.length
                  ));
              }
              _makeGlobeTileDebugBuffers(i, o) {
                const l = o.projection;
                if (!l || "globe" !== l.name || o.freezeTileCoverage) return;
                const h = this.tileID.canonical,
                  m = Gu(Ev(h, o)),
                  _ = Yi(o.zoom);
                let x;
                _ > 0 && (x = Tp(new Float64Array(16), o.globeMatrix)),
                  this._makeGlobeTileDebugBorderBuffer(i, h, o, m, x, _),
                  this._makeGlobeTileDebugTextBuffer(i, h, o, m, x, _);
              }
              _globePoint(i, o, l, h, m, _, x) {
                let E = hd(i, o, l);
                if (_) {
                  const T = 1 << l.z,
                    C = ua(h.center.lng),
                    A = ii(h.center.lat),
                    L = (l.x + 0.5) / T - C;
                  let O = 0;
                  L > 0.5 ? (O = -1) : L < -0.5 && (O = 1);
                  let F = (i / vt + l.x) / T + O,
                    V = (o / vt + l.y) / T;
                  (F = (F - C) * h._pixelsPerMercatorPixel + C),
                    (V = (V - A) * h._pixelsPerMercatorPixel + A);
                  const G = [F * h.worldSize, V * h.worldSize, 0];
                  Kn(G, G, _), (E = Hu(E, G, x));
                }
                return Kn(E, E, m);
              }
              _makeGlobeTileDebugBorderBuffer(i, o, l, h, m, _) {
                const x = new Ge(),
                  E = new br(),
                  T = new be(),
                  C = (L, O, F, V, G) => {
                    const K = (F - L) / (G - 1),
                      oe = (V - O) / (G - 1),
                      J = x.length;
                    for (let re = 0; re < G; re++) {
                      const le = L + re * K,
                        ae = O + re * oe;
                      x.emplaceBack(le, ae);
                      const De = this._globePoint(le, ae, o, l, h, m, _);
                      T.emplaceBack(De[0], De[1], De[2]), E.emplaceBack(J + re);
                    }
                  },
                  A = vt;
                C(0, 0, A, 0, 16),
                  C(A, 0, A, A, 16),
                  C(A, A, 0, A, 16),
                  C(0, A, 0, 0, 16),
                  (this._tileDebugIndexBuffer = i.createIndexBuffer(E)),
                  (this._tileDebugBuffer = i.createVertexBuffer(x, Ja.members)),
                  (this._globeTileDebugBorderBuffer = i.createVertexBuffer(
                    T,
                    Nc.members
                  )),
                  (this._tileDebugSegments = gi.simpleSegment(
                    0,
                    0,
                    x.length,
                    E.length
                  ));
              }
              _makeGlobeTileDebugTextBuffer(i, o, l, h, m, _) {
                const E = new Ge(),
                  T = new ft(),
                  C = new be(),
                  A = 25;
                T.reserve(32), E.reserve(A), C.reserve(A);
                const L = (O, F) => A * O + F;
                for (let O = 0; O < A; O++) {
                  const F = 2048 * O;
                  for (let V = 0; V < A; V++) {
                    const G = 2048 * V;
                    E.emplaceBack(G, F);
                    const K = this._globePoint(G, F, o, l, h, m, _);
                    C.emplaceBack(K[0], K[1], K[2]);
                  }
                }
                for (let O = 0; O < 4; O++)
                  for (let F = 0; F < 4; F++) {
                    const V = L(O, F),
                      G = L(O, F + 1),
                      K = L(O + 1, F),
                      oe = L(O + 1, F + 1);
                    T.emplaceBack(V, G, K), T.emplaceBack(K, G, oe);
                  }
                (this._tileDebugTextIndexBuffer = i.createIndexBuffer(T)),
                  (this._tileDebugTextBuffer = i.createVertexBuffer(
                    E,
                    Ja.members
                  )),
                  (this._globeTileDebugTextBuffer = i.createVertexBuffer(
                    C,
                    Nc.members
                  )),
                  (this._tileDebugTextSegments = gi.simpleSegment(0, 0, A, 32));
              }
            }
            class kb {
              constructor() {
                (this.state = {}),
                  (this.stateChanges = {}),
                  (this.deletedStates = {});
              }
              updateState(i, o, l) {
                const h = String(o);
                if (
                  ((this.stateChanges[i] = this.stateChanges[i] || {}),
                  (this.stateChanges[i][h] = this.stateChanges[i][h] || {}),
                  ci(this.stateChanges[i][h], l),
                  null === this.deletedStates[i])
                ) {
                  this.deletedStates[i] = {};
                  for (const m in this.state[i])
                    m !== h && (this.deletedStates[i][m] = null);
                } else if (
                  this.deletedStates[i] &&
                  null === this.deletedStates[i][h]
                ) {
                  this.deletedStates[i][h] = {};
                  for (const m in this.state[i][h])
                    l[m] || (this.deletedStates[i][h][m] = null);
                } else
                  for (const m in l)
                    this.deletedStates[i] &&
                      this.deletedStates[i][h] &&
                      null === this.deletedStates[i][h][m] &&
                      delete this.deletedStates[i][h][m];
              }
              removeFeatureState(i, o, l) {
                if (null === this.deletedStates[i]) return;
                const h = String(o);
                if (
                  ((this.deletedStates[i] = this.deletedStates[i] || {}),
                  l && void 0 !== o)
                )
                  null !== this.deletedStates[i][h] &&
                    ((this.deletedStates[i][h] =
                      this.deletedStates[i][h] || {}),
                    (this.deletedStates[i][h][l] = null));
                else if (void 0 !== o)
                  if (this.stateChanges[i] && this.stateChanges[i][h])
                    for (l in ((this.deletedStates[i][h] = {}),
                    this.stateChanges[i][h]))
                      this.deletedStates[i][h][l] = null;
                  else this.deletedStates[i][h] = null;
                else this.deletedStates[i] = null;
              }
              getState(i, o) {
                const l = String(o),
                  h = ci(
                    {},
                    (this.state[i] || {})[l],
                    (this.stateChanges[i] || {})[l]
                  );
                if (null === this.deletedStates[i]) return {};
                if (this.deletedStates[i]) {
                  const m = this.deletedStates[i][o];
                  if (null === m) return {};
                  for (const _ in m) delete h[_];
                }
                return h;
              }
              initializeTileState(i, o) {
                i.setFeatureState(this.state, o);
              }
              coalesceChanges(i, o) {
                const l = {};
                for (const h in this.stateChanges) {
                  this.state[h] = this.state[h] || {};
                  const m = {};
                  for (const _ in this.stateChanges[h])
                    this.state[h][_] || (this.state[h][_] = {}),
                      ci(this.state[h][_], this.stateChanges[h][_]),
                      (m[_] = this.state[h][_]);
                  l[h] = m;
                }
                for (const h in this.deletedStates) {
                  this.state[h] = this.state[h] || {};
                  const m = {};
                  if (null === this.deletedStates[h])
                    for (const _ in this.state[h])
                      (m[_] = {}), (this.state[h][_] = {});
                  else
                    for (const _ in this.deletedStates[h]) {
                      if (null === this.deletedStates[h][_])
                        this.state[h][_] = {};
                      else if (this.state[h][_])
                        for (const x of Object.keys(this.deletedStates[h][_]))
                          delete this.state[h][_][x];
                      m[_] = this.state[h][_];
                    }
                  (l[h] = l[h] || {}), ci(l[h], m);
                }
                if (
                  ((this.stateChanges = {}),
                  (this.deletedStates = {}),
                  0 !== Object.keys(l).length)
                )
                  for (const h in i) i[h].setFeatureState(l, o);
              }
            }
            class y0 {
              constructor(i) {
                (this.size = i),
                  (this.minimums = []),
                  (this.maximums = []),
                  (this.leaves = []);
              }
              getElevation(i, o) {
                const l = this.toIdx(i, o);
                return { min: this.minimums[l], max: this.maximums[l] };
              }
              isLeaf(i, o) {
                return this.leaves[this.toIdx(i, o)];
              }
              toIdx(i, o) {
                return o * this.size + i;
              }
            }
            function v0(r, i, o, l) {
              let h = 0,
                m = Number.MAX_VALUE;
              for (let _ = 0; _ < 3; _++)
                if (Math.abs(l[_]) < 1e-15) {
                  if (o[_] < r[_] || o[_] > i[_]) return null;
                } else {
                  const x = 1 / l[_];
                  let E = (r[_] - o[_]) * x,
                    T = (i[_] - o[_]) * x;
                  if (E > T) {
                    const C = E;
                    (E = T), (T = C);
                  }
                  if ((E > h && (h = E), T < m && (m = T), h > m)) return null;
                }
              return h;
            }
            function x0(r, i, o, l, h, m, _, x, E, T, C) {
              const A = l - r,
                L = h - i,
                O = m - o,
                F = _ - r,
                V = x - i,
                G = E - o,
                K = C[1] * G - C[2] * V,
                oe = C[2] * F - C[0] * G,
                J = C[0] * V - C[1] * F,
                re = A * K + L * oe + O * J;
              if (Math.abs(re) < 1e-15) return null;
              const le = 1 / re,
                ae = T[0] - r,
                De = T[1] - i,
                xe = T[2] - o,
                Pe = (ae * K + De * oe + xe * J) * le;
              if (Pe < 0 || Pe > 1) return null;
              const $e = De * O - xe * L,
                Ce = xe * A - ae * O,
                Fe = ae * L - De * A,
                Re = (C[0] * $e + C[1] * Ce + C[2] * Fe) * le;
              return Re < 0 || Pe + Re > 1
                ? null
                : (F * $e + V * Ce + G * Fe) * le;
            }
            function b0(r, i, o) {
              return (r - i) / (o - i);
            }
            function w0(r, i, o, l, h, m, _, x, E) {
              const T = 1 << o,
                C = m - l,
                A = _ - h,
                L = ((r + 1) / T) * C + l,
                O = ((i + 0) / T) * A + h,
                F = ((i + 1) / T) * A + h;
              (x[0] = ((r + 0) / T) * C + l),
                (x[1] = O),
                (E[0] = L),
                (E[1] = F);
            }
            class E0 {
              constructor(i) {
                if (
                  ((this.maximums = []),
                  (this.minimums = []),
                  (this.leaves = []),
                  (this.childOffsets = []),
                  (this.nodeCount = 0),
                  (this.dem = i),
                  (this._siblingOffset = [
                    [0, 0],
                    [1, 0],
                    [0, 1],
                    [1, 1],
                  ]),
                  !this.dem)
                )
                  return;
                const o = (function (m) {
                    const _ = Math.ceil(Math.log2(m.dim / 8)),
                      x = [];
                    let E = Math.ceil(Math.pow(2, _));
                    const T = 1 / E,
                      C = (O, F, V, G, K) => {
                        const oe = G ? 1 : 0,
                          J = (O + 1) * V - oe,
                          re = F * V,
                          le = (F + 1) * V - oe;
                        (K[0] = O * V), (K[1] = re), (K[2] = J), (K[3] = le);
                      };
                    let A = new y0(E);
                    const L = [];
                    for (let O = 0; O < E * E; O++) {
                      C(O % E, Math.floor(O / E), T, !1, L);
                      const F = ga(L[0], L[1], m),
                        V = ga(L[2], L[1], m),
                        G = ga(L[2], L[3], m),
                        K = ga(L[0], L[3], m);
                      A.minimums.push(Math.min(F, V, G, K)),
                        A.maximums.push(Math.max(F, V, G, K)),
                        A.leaves.push(1);
                    }
                    for (x.push(A), E /= 2; E >= 1; E /= 2) {
                      const O = x[x.length - 1];
                      A = new y0(E);
                      for (let F = 0; F < E * E; F++) {
                        C(F % E, Math.floor(F / E), 2, !0, L);
                        const V = O.getElevation(L[0], L[1]),
                          G = O.getElevation(L[2], L[1]),
                          K = O.getElevation(L[2], L[3]),
                          oe = O.getElevation(L[0], L[3]),
                          J = O.isLeaf(L[0], L[1]),
                          re = O.isLeaf(L[2], L[1]),
                          le = O.isLeaf(L[2], L[3]),
                          ae = O.isLeaf(L[0], L[3]),
                          De = Math.min(V.min, G.min, K.min, oe.min),
                          xe = Math.max(V.max, G.max, K.max, oe.max),
                          Pe = J && re && le && ae;
                        A.maximums.push(xe),
                          A.minimums.push(De),
                          A.leaves.push(xe - De <= 5 && Pe ? 1 : 0);
                      }
                      x.push(A);
                    }
                    return x;
                  })(this.dem),
                  l = o.length - 1,
                  h = o[l];
                this._addNode(h.minimums[0], h.maximums[0], h.leaves[0]),
                  this._construct(o, 0, 0, l, 0);
              }
              raycastRoot(i, o, l, h, m, _, x = 1) {
                return v0([i, o, -100], [l, h, this.maximums[0] * x], m, _);
              }
              raycast(i, o, l, h, m, _, x = 1) {
                if (!this.nodeCount) return null;
                const E = this.raycastRoot(i, o, l, h, m, _, x);
                if (null == E) return null;
                const T = [],
                  C = [],
                  A = [],
                  L = [],
                  O = [{ idx: 0, t: E, nodex: 0, nodey: 0, depth: 0 }];
                for (; O.length > 0; ) {
                  const {
                    idx: F,
                    t: V,
                    nodex: G,
                    nodey: K,
                    depth: oe,
                  } = O.pop();
                  if (this.leaves[F]) {
                    w0(G, K, oe, i, o, l, h, A, L);
                    const re = 1 << oe,
                      le = (G + 0) / re,
                      ae = (G + 1) / re,
                      De = (K + 0) / re,
                      xe = (K + 1) / re,
                      Pe = ga(le, De, this.dem) * x,
                      $e = ga(ae, De, this.dem) * x,
                      Ce = ga(ae, xe, this.dem) * x,
                      Fe = ga(le, xe, this.dem) * x,
                      Re = x0(
                        A[0],
                        A[1],
                        Pe,
                        L[0],
                        A[1],
                        $e,
                        L[0],
                        L[1],
                        Ce,
                        m,
                        _
                      ),
                      Ve = x0(
                        L[0],
                        L[1],
                        Ce,
                        A[0],
                        L[1],
                        Fe,
                        A[0],
                        A[1],
                        Pe,
                        m,
                        _
                      ),
                      qe = Math.min(
                        null !== Re ? Re : Number.MAX_VALUE,
                        null !== Ve ? Ve : Number.MAX_VALUE
                      );
                    if (qe !== Number.MAX_VALUE) return qe;
                    {
                      const Me = rd([], m, _, V);
                      if (
                        ll(
                          Pe,
                          $e,
                          Fe,
                          Ce,
                          b0(Me[0], A[0], L[0]),
                          b0(Me[1], A[1], L[1])
                        ) >= Me[2]
                      )
                        return V;
                    }
                    continue;
                  }
                  let J = 0;
                  for (let re = 0; re < this._siblingOffset.length; re++) {
                    w0(
                      (G << 1) + this._siblingOffset[re][0],
                      (K << 1) + this._siblingOffset[re][1],
                      oe + 1,
                      i,
                      o,
                      l,
                      h,
                      A,
                      L
                    ),
                      (A[2] = -100),
                      (L[2] = this.maximums[this.childOffsets[F] + re] * x);
                    const le = v0(A, L, m, _);
                    if (null != le) {
                      const ae = le;
                      T[re] = ae;
                      let De = !1;
                      for (let xe = 0; xe < J && !De; xe++)
                        ae >= T[C[xe]] && (C.splice(xe, 0, re), (De = !0));
                      De || (C[J] = re), J++;
                    }
                  }
                  for (let re = 0; re < J; re++) {
                    const le = C[re];
                    O.push({
                      idx: this.childOffsets[F] + le,
                      t: T[le],
                      nodex: (G << 1) + this._siblingOffset[le][0],
                      nodey: (K << 1) + this._siblingOffset[le][1],
                      depth: oe + 1,
                    });
                  }
                }
                return null;
              }
              _addNode(i, o, l) {
                return (
                  this.minimums.push(i),
                  this.maximums.push(o),
                  this.leaves.push(l),
                  this.childOffsets.push(0),
                  this.nodeCount++
                );
              }
              _construct(i, o, l, h, m) {
                if (1 === i[h].isLeaf(o, l)) return;
                this.childOffsets[m] || (this.childOffsets[m] = this.nodeCount);
                const _ = h - 1,
                  x = i[_];
                let E = 0,
                  T = 0;
                for (let C = 0; C < this._siblingOffset.length; C++) {
                  const A = 2 * o + this._siblingOffset[C][0],
                    L = 2 * l + this._siblingOffset[C][1],
                    O = x.getElevation(A, L),
                    F = x.isLeaf(A, L),
                    V = this._addNode(O.min, O.max, F);
                  F && (E |= 1 << C), T || (T = V);
                }
                for (let C = 0; C < this._siblingOffset.length; C++)
                  E & (1 << C) ||
                    this._construct(
                      i,
                      2 * o + this._siblingOffset[C][0],
                      2 * l + this._siblingOffset[C][1],
                      _,
                      T + C
                    );
              }
            }
            function ll(r, i, o, l, h, m) {
              return rn(rn(r, o, m), rn(i, l, m), h);
            }
            function ga(r, i, o) {
              const l = o.dim,
                h = Qt(r * l - 0.5, 0, l - 1),
                m = Qt(i * l - 0.5, 0, l - 1),
                _ = Math.floor(h),
                x = Math.floor(m),
                E = Math.min(_ + 1, l - 1),
                T = Math.min(x + 1, l - 1);
              return ll(
                o.get(_, x),
                o.get(E, x),
                o.get(_, T),
                o.get(E, T),
                h - _,
                m - x
              );
            }
            const ay = {
              mapbox: [6553.6, 25.6, 0.1, 1e4],
              terrarium: [256, 1, 1 / 256, 32768],
            };
            function ly(r, i, o) {
              return (256 * r * 256 + 256 * i + o) / 10 - 1e4;
            }
            function rg(r, i, o) {
              return 256 * r + i + o / 256 - 32768;
            }
            class Zd {
              get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
              }
              constructor(i, o, l, h = !1, m = !1) {
                if (((this.uid = i), o.height !== o.width))
                  throw new RangeError("DEM tiles must be square");
                if (l && "mapbox" !== l && "terrarium" !== l)
                  return Hn(
                    `"${l}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`
                  );
                this.stride = o.height;
                const _ = (this.dim = o.height - 2),
                  x = new Uint32Array(o.data.buffer);
                if (
                  ((this.pixels = new Uint8Array(o.data.buffer)),
                  (this.encoding = l || "mapbox"),
                  (this.borderReady = h),
                  !h)
                ) {
                  for (let E = 0; E < _; E++)
                    (x[this._idx(-1, E)] = x[this._idx(0, E)]),
                      (x[this._idx(_, E)] = x[this._idx(_ - 1, E)]),
                      (x[this._idx(E, -1)] = x[this._idx(E, 0)]),
                      (x[this._idx(E, _)] = x[this._idx(E, _ - 1)]);
                  (x[this._idx(-1, -1)] = x[this._idx(0, 0)]),
                    (x[this._idx(_, -1)] = x[this._idx(_ - 1, 0)]),
                    (x[this._idx(-1, _)] = x[this._idx(0, _ - 1)]),
                    (x[this._idx(_, _)] = x[this._idx(_ - 1, _ - 1)]),
                    m && this._buildQuadTree();
                }
              }
              _buildQuadTree() {
                this._tree = new E0(this);
              }
              get(i, o, l = !1) {
                l && ((i = Qt(i, -1, this.dim)), (o = Qt(o, -1, this.dim)));
                const h = 4 * this._idx(i, o);
                return (
                  "terrarium" === this.encoding ? rg : ly
                )(this.pixels[h], this.pixels[h + 1], this.pixels[h + 2]);
              }
              static getUnpackVector(i) {
                return ay[i];
              }
              get unpackVector() {
                return ay[this.encoding];
              }
              _idx(i, o) {
                if (i < -1 || i >= this.dim + 1 || o < -1 || o >= this.dim + 1)
                  throw new RangeError(
                    "out of range source coordinates for DEM data"
                  );
                return (o + 1) * this.stride + (i + 1);
              }
              static pack(i, o) {
                const l = [0, 0, 0, 0],
                  h = Zd.getUnpackVector(o);
                let m = Math.floor((i + h[3]) / h[2]);
                return (
                  (l[2] = m % 256),
                  (m = Math.floor(m / 256)),
                  (l[1] = m % 256),
                  (m = Math.floor(m / 256)),
                  (l[0] = m),
                  l
                );
              }
              getPixels() {
                return new Kr(
                  { width: this.stride, height: this.stride },
                  this.pixels
                );
              }
              backfillBorder(i, o, l) {
                if (this.dim !== i.dim)
                  throw new Error("dem dimension mismatch");
                let h = o * this.dim,
                  m = o * this.dim + this.dim,
                  _ = l * this.dim,
                  x = l * this.dim + this.dim;
                switch (o) {
                  case -1:
                    h = m - 1;
                    break;
                  case 1:
                    m = h + 1;
                }
                switch (l) {
                  case -1:
                    _ = x - 1;
                    break;
                  case 1:
                    x = _ + 1;
                }
                const E = -o * this.dim,
                  T = -l * this.dim;
                for (let C = _; C < x; C++)
                  for (let A = h; A < m; A++) {
                    const L = 4 * this._idx(A, C),
                      O = 4 * this._idx(A + E, C + T);
                    (this.pixels[L + 0] = i.pixels[O + 0]),
                      (this.pixels[L + 1] = i.pixels[O + 1]),
                      (this.pixels[L + 2] = i.pixels[O + 2]),
                      (this.pixels[L + 3] = i.pixels[O + 3]);
                  }
              }
              onDeserialize() {
                this._tree && (this._tree.dem = this);
              }
            }
            st(Zd, "DEMData"), st(E0, "DemMinMaxQuadTree", { omit: ["dem"] });
            class og {
              constructor(i, o) {
                (this.max = i), (this.onRemove = o), this.reset();
              }
              reset() {
                for (const i in this.data)
                  for (const o of this.data[i])
                    o.timeout && clearTimeout(o.timeout),
                      this.onRemove(o.value);
                return (this.data = {}), (this.order = []), this;
              }
              add(i, o, l) {
                const h = i.wrapped().key;
                void 0 === this.data[h] && (this.data[h] = []);
                const m = { value: o, timeout: void 0 };
                if (
                  (void 0 !== l &&
                    (m.timeout = setTimeout(() => {
                      this.remove(i, m);
                    }, l)),
                  this.data[h].push(m),
                  this.order.push(h),
                  this.order.length > this.max)
                ) {
                  const _ = this._getAndRemoveByKey(this.order[0]);
                  _ && this.onRemove(_);
                }
                return this;
              }
              has(i) {
                return i.wrapped().key in this.data;
              }
              getAndRemove(i) {
                return this.has(i)
                  ? this._getAndRemoveByKey(i.wrapped().key)
                  : null;
              }
              _getAndRemoveByKey(i) {
                const o = this.data[i].shift();
                return (
                  o.timeout && clearTimeout(o.timeout),
                  0 === this.data[i].length && delete this.data[i],
                  this.order.splice(this.order.indexOf(i), 1),
                  o.value
                );
              }
              getByKey(i) {
                const o = this.data[i];
                return o ? o[0].value : null;
              }
              get(i) {
                return this.has(i) ? this.data[i.wrapped().key][0].value : null;
              }
              remove(i, o) {
                if (!this.has(i)) return this;
                const l = i.wrapped().key,
                  h = void 0 === o ? 0 : this.data[l].indexOf(o),
                  m = this.data[l][h];
                return (
                  this.data[l].splice(h, 1),
                  m.timeout && clearTimeout(m.timeout),
                  0 === this.data[l].length && delete this.data[l],
                  this.onRemove(m.value),
                  this.order.splice(this.order.indexOf(l), 1),
                  this
                );
              }
              setMaxSize(i) {
                for (this.max = i; this.order.length > this.max; ) {
                  const o = this._getAndRemoveByKey(this.order[0]);
                  o && this.onRemove(o);
                }
                return this;
              }
              filter(i) {
                const o = [];
                for (const l in this.data)
                  for (const h of this.data[l]) i(h.value) || o.push(h);
                for (const l of o) this.remove(l.value.tileID, l);
              }
            }
            class hh {
              constructor(i, o, l) {
                (this.func = i), (this.mask = o), (this.range = l);
              }
            }
            (hh.ReadOnly = !1),
              (hh.ReadWrite = !0),
              (hh.disabled = new hh(519, hh.ReadOnly, [0, 1]));
            class uf {
              constructor(i, o, l, h, m, _) {
                (this.test = i),
                  (this.ref = o),
                  (this.mask = l),
                  (this.fail = h),
                  (this.depthFail = m),
                  (this.pass = _);
              }
            }
            uf.disabled = new uf(
              { func: 519, mask: 0 },
              0,
              0,
              7680,
              7680,
              7680
            );
            class ya {
              constructor(i, o, l) {
                (this.blendFunction = i),
                  (this.blendColor = o),
                  (this.mask = l);
              }
            }
            (ya.Replace = [1, 0]),
              (ya.disabled = new ya(ya.Replace, di.transparent, [
                !1,
                !1,
                !1,
                !1,
              ])),
              (ya.unblended = new ya(ya.Replace, di.transparent, [
                !0,
                !0,
                !0,
                !0,
              ])),
              (ya.alphaBlended = new ya([1, 771], di.transparent, [
                !0,
                !0,
                !0,
                !0,
              ]));
            class Ts {
              constructor(i, o, l) {
                (this.enable = i), (this.mode = o), (this.frontFace = l);
              }
            }
            (Ts.disabled = new Ts(!1, 1029, 2305)),
              (Ts.backCCW = new Ts(!0, 1029, 2305)),
              (Ts.backCW = new Ts(!0, 1029, 2304)),
              (Ts.frontCW = new Ts(!0, 1028, 2304)),
              (Ts.frontCCW = new Ts(!0, 1028, 2305));
            class Xc extends pc {
              constructor(i, o, l) {
                super(),
                  (this.id = i),
                  (this._onlySymbols = l),
                  o.on("data", (h) => {
                    "source" === h.dataType &&
                      "metadata" === h.sourceDataType &&
                      (this._sourceLoaded = !0),
                      this._sourceLoaded &&
                        !this._paused &&
                        "source" === h.dataType &&
                        "content" === h.sourceDataType &&
                        (this.reload(),
                        this.transform && this.update(this.transform));
                  }),
                  o.on("error", () => {
                    this._sourceErrored = !0;
                  }),
                  (this._source = o),
                  (this._tiles = {}),
                  (this._cache = new og(0, this._unloadTile.bind(this))),
                  (this._timers = {}),
                  (this._cacheTimers = {}),
                  (this._minTileCacheSize = o.minTileCacheSize),
                  (this._maxTileCacheSize = o.maxTileCacheSize),
                  (this._loadedParentTiles = {}),
                  (this._coveredTiles = {}),
                  (this._state = new kb()),
                  (this._isRaster =
                    "raster" === this._source.type ||
                    "raster-dem" === this._source.type ||
                    ("custom" === this._source.type &&
                      "raster" === this._source._dataType));
              }
              onAdd(i) {
                (this.map = i),
                  (this._minTileCacheSize =
                    void 0 === this._minTileCacheSize && i
                      ? i._minTileCacheSize
                      : this._minTileCacheSize),
                  (this._maxTileCacheSize =
                    void 0 === this._maxTileCacheSize && i
                      ? i._maxTileCacheSize
                      : this._maxTileCacheSize);
              }
              loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded || !this._source.loaded()) return !1;
                for (const i in this._tiles) {
                  const o = this._tiles[i];
                  if ("loaded" !== o.state && "errored" !== o.state) return !1;
                }
                return !0;
              }
              getSource() {
                return this._source;
              }
              pause() {
                this._paused = !0;
              }
              resume() {
                if (!this._paused) return;
                const i = this._shouldReloadOnResume;
                (this._paused = !1),
                  (this._shouldReloadOnResume = !1),
                  i && this.reload(),
                  this.transform && this.update(this.transform);
              }
              _loadTile(i, o) {
                return (
                  (i.isSymbolTile = this._onlySymbols),
                  this._source.loadTile(i, o)
                );
              }
              _unloadTile(i) {
                if (this._source.unloadTile)
                  return this._source.unloadTile(i, () => {});
              }
              _abortTile(i) {
                if (this._source.abortTile)
                  return this._source.abortTile(i, () => {});
              }
              serialize() {
                return this._source.serialize();
              }
              prepare(i) {
                this._source.prepare && this._source.prepare(),
                  this._state.coalesceChanges(
                    this._tiles,
                    this.map ? this.map.painter : null
                  );
                for (const o in this._tiles) {
                  const l = this._tiles[o];
                  l.upload(i), l.prepare(this.map.style.imageManager);
                }
              }
              getIds() {
                return Rs(this._tiles)
                  .map((i) => i.tileID)
                  .sort(Xd)
                  .map((i) => i.key);
              }
              getRenderableIds(i) {
                const o = [];
                for (const l in this._tiles)
                  this._isIdRenderable(+l, i) && o.push(this._tiles[l]);
                return i
                  ? o
                      .sort((l, h) => {
                        const m = l.tileID,
                          _ = h.tileID,
                          x = new et(m.canonical.x, m.canonical.y)._rotate(
                            this.transform.angle
                          ),
                          E = new et(_.canonical.x, _.canonical.y)._rotate(
                            this.transform.angle
                          );
                        return (
                          m.overscaledZ - _.overscaledZ ||
                          E.y - x.y ||
                          E.x - x.x
                        );
                      })
                      .map((l) => l.tileID.key)
                  : o
                      .map((l) => l.tileID)
                      .sort(Xd)
                      .map((l) => l.key);
              }
              hasRenderableParent(i) {
                const o = this.findLoadedParent(i, 0);
                return !!o && this._isIdRenderable(o.tileID.key);
              }
              _isIdRenderable(i, o) {
                return (
                  this._tiles[i] &&
                  this._tiles[i].hasData() &&
                  !this._coveredTiles[i] &&
                  (o || !this._tiles[i].holdingForFade())
                );
              }
              reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                  this._cache.reset();
                  for (const i in this._tiles)
                    "errored" !== this._tiles[i].state &&
                      this._reloadTile(+i, "reloading");
                }
              }
              _reloadTile(i, o) {
                const l = this._tiles[i];
                l &&
                  ("loading" !== l.state && (l.state = o),
                  this._loadTile(l, this._tileLoaded.bind(this, l, i, o)));
              }
              _tileLoaded(i, o, l, h) {
                if (h)
                  if (((i.state = "errored"), 404 !== h.status))
                    this._source.fire(new us(h, { tile: i }));
                  else if (
                    "raster-dem" === this._source.type &&
                    this.usedForTerrain &&
                    this.map.painter.terrain
                  ) {
                    const m = this.map.painter.terrain;
                    this.update(this.transform, m.getScaledDemTileSize(), !0),
                      m.resetTileLookupCache(this.id);
                  } else this.update(this.transform);
                else
                  (i.timeAdded = cs.now()),
                    "expired" === l && (i.refreshedUponExpiration = !0),
                    this._setTileReloadTimer(o, i),
                    "raster-dem" === this._source.type &&
                      i.dem &&
                      this._backfillDEM(i),
                    this._state.initializeTileState(
                      i,
                      this.map ? this.map.painter : null
                    ),
                    this._source.fire(
                      new Ra("data", {
                        dataType: "source",
                        tile: i,
                        coord: i.tileID,
                        sourceCacheId: this.id,
                      })
                    );
              }
              _backfillDEM(i) {
                const o = this.getRenderableIds();
                for (let h = 0; h < o.length; h++) {
                  const m = o[h];
                  if (i.neighboringTiles && i.neighboringTiles[m]) {
                    const _ = this.getTileByID(m);
                    l(i, _), l(_, i);
                  }
                }
                function l(h, m) {
                  if (!h.dem || h.dem.borderReady) return;
                  (h.needsHillshadePrepare = !0),
                    (h.needsDEMTextureUpload = !0);
                  let _ = m.tileID.canonical.x - h.tileID.canonical.x;
                  const x = m.tileID.canonical.y - h.tileID.canonical.y,
                    E = Math.pow(2, h.tileID.canonical.z),
                    T = m.tileID.key;
                  (0 === _ && 0 === x) ||
                    Math.abs(x) > 1 ||
                    (Math.abs(_) > 1 &&
                      (1 === Math.abs(_ + E)
                        ? (_ += E)
                        : 1 === Math.abs(_ - E) && (_ -= E)),
                    m.dem &&
                      h.dem &&
                      (h.dem.backfillBorder(m.dem, _, x),
                      h.neighboringTiles &&
                        h.neighboringTiles[T] &&
                        (h.neighboringTiles[T].backfilled = !0)));
                }
              }
              getTile(i) {
                return this.getTileByID(i.key);
              }
              getTileByID(i) {
                return this._tiles[i];
              }
              _retainLoadedChildren(i, o, l, h) {
                for (const m in this._tiles) {
                  let _ = this._tiles[m];
                  if (
                    h[m] ||
                    !_.hasData() ||
                    _.tileID.overscaledZ <= o ||
                    _.tileID.overscaledZ > l
                  )
                    continue;
                  let x = _.tileID;
                  for (; _ && _.tileID.overscaledZ > o + 1; ) {
                    const T = _.tileID.scaledTo(_.tileID.overscaledZ - 1);
                    (_ = this._tiles[T.key]), _ && _.hasData() && (x = T);
                  }
                  let E = x;
                  for (; E.overscaledZ > o; )
                    if (((E = E.scaledTo(E.overscaledZ - 1)), i[E.key])) {
                      h[x.key] = x;
                      break;
                    }
                }
              }
              findLoadedParent(i, o) {
                if (i.key in this._loadedParentTiles) {
                  const l = this._loadedParentTiles[i.key];
                  return l && l.tileID.overscaledZ >= o ? l : null;
                }
                for (let l = i.overscaledZ - 1; l >= o; l--) {
                  const h = i.scaledTo(l),
                    m = this._getLoadedTile(h);
                  if (m) return m;
                }
              }
              _getLoadedTile(i) {
                const o = this._tiles[i.key];
                return o && o.hasData()
                  ? o
                  : this._cache.getByKey(
                      this._source.reparseOverscaled
                        ? i.wrapped().key
                        : i.canonical.key
                    );
              }
              updateCacheSize(i, o) {
                o = o || this._source.tileSize;
                const l = Math.ceil(i.width / o) + 1,
                  h = Math.ceil(i.height / o) + 1,
                  m = Math.floor(l * h * 5),
                  _ =
                    "number" == typeof this._minTileCacheSize
                      ? Math.max(this._minTileCacheSize, m)
                      : m,
                  x =
                    "number" == typeof this._maxTileCacheSize
                      ? Math.min(this._maxTileCacheSize, _)
                      : _;
                this._cache.setMaxSize(x);
              }
              handleWrapJump(i) {
                const o = Math.round(
                  (i - (void 0 === this._prevLng ? i : this._prevLng)) / 360
                );
                if (((this._prevLng = i), o)) {
                  const l = {};
                  for (const h in this._tiles) {
                    const m = this._tiles[h];
                    (m.tileID = m.tileID.unwrapTo(m.tileID.wrap + o)),
                      (l[m.tileID.key] = m);
                  }
                  this._tiles = l;
                  for (const h in this._timers)
                    clearTimeout(this._timers[h]), delete this._timers[h];
                  for (const h in this._tiles)
                    this._setTileReloadTimer(+h, this._tiles[h]);
                }
              }
              update(i, o, l) {
                if (
                  ((this.transform = i),
                  !this._sourceLoaded ||
                    this._paused ||
                    this.transform.freezeTileCoverage ||
                    (this.usedForTerrain && !l))
                )
                  return;
                let h;
                this.updateCacheSize(i, o),
                  "globe" !== this.transform.projection.name &&
                    this.handleWrapJump(this.transform.center.lng),
                  (this._coveredTiles = {}),
                  this.used || this.usedForTerrain
                    ? this._source.tileID
                      ? (h = i
                          .getVisibleUnwrappedCoordinates(this._source.tileID)
                          .map(
                            (x) =>
                              new Nr(
                                x.canonical.z,
                                x.wrap,
                                x.canonical.z,
                                x.canonical.x,
                                x.canonical.y
                              )
                          ))
                      : ((h = i.coveringTiles({
                          tileSize: o || this._source.tileSize,
                          minzoom: this._source.minzoom,
                          maxzoom: this._source.maxzoom,
                          roundZoom: this._source.roundZoom && !l,
                          reparseOverscaled: this._source.reparseOverscaled,
                          isTerrainDEM: this.usedForTerrain,
                        })),
                        this._source.hasTile &&
                          (h = h.filter((x) => this._source.hasTile(x))))
                    : (h = []);
                const m = this._updateRetainedTiles(h);
                if (Kc(this._source.type) && 0 !== h.length) {
                  const x = {},
                    E = {},
                    T = Object.keys(m);
                  for (const A of T) {
                    const L = m[A],
                      O = this._tiles[A];
                    if (!O || (O.fadeEndTime && O.fadeEndTime <= cs.now()))
                      continue;
                    const F = this.findLoadedParent(
                      L,
                      Math.max(
                        L.overscaledZ - Xc.maxOverzooming,
                        this._source.minzoom
                      )
                    );
                    F &&
                      (this._addTile(F.tileID), (x[F.tileID.key] = F.tileID)),
                      (E[A] = L);
                  }
                  const C = h[h.length - 1].overscaledZ;
                  for (const A in this._tiles) {
                    const L = this._tiles[A];
                    if (m[A] || !L.hasData()) continue;
                    let O = L.tileID;
                    for (; O.overscaledZ > C; ) {
                      O = O.scaledTo(O.overscaledZ - 1);
                      const F = this._tiles[O.key];
                      if (F && F.hasData() && E[O.key]) {
                        m[A] = L.tileID;
                        break;
                      }
                    }
                  }
                  for (const A in x)
                    m[A] || ((this._coveredTiles[A] = !0), (m[A] = x[A]));
                }
                for (const x in m) this._tiles[x].clearFadeHold();
                const _ = (function (x, E) {
                  const T = [];
                  for (const C in x) C in E || T.push(C);
                  return T;
                })(this._tiles, m);
                for (const x of _) {
                  const E = this._tiles[x];
                  E.hasSymbolBuckets && !E.holdingForFade()
                    ? E.setHoldDuration(this.map._fadeDuration)
                    : (E.hasSymbolBuckets && !E.symbolFadeFinished()) ||
                      this._removeTile(+x);
                }
                this._updateLoadedParentTileCache(),
                  this._onlySymbols &&
                    this._source.afterUpdate &&
                    this._source.afterUpdate();
              }
              releaseSymbolFadeTiles() {
                for (const i in this._tiles)
                  this._tiles[i].holdingForFade() && this._removeTile(+i);
              }
              _updateRetainedTiles(i) {
                const o = {};
                if (0 === i.length) return o;
                const l = {},
                  h = i.reduce((T, C) => Math.min(T, C.overscaledZ), 1 / 0),
                  m = i[0].overscaledZ,
                  _ = Math.max(m - Xc.maxOverzooming, this._source.minzoom),
                  x = Math.max(m + Xc.maxUnderzooming, this._source.minzoom),
                  E = {};
                for (const T of i) {
                  const C = this._addTile(T);
                  (o[T.key] = T),
                    C.hasData() || (h < this._source.maxzoom && (E[T.key] = T));
                }
                this._retainLoadedChildren(E, h, x, o);
                for (const T of i) {
                  let C = this._tiles[T.key];
                  if (C.hasData()) continue;
                  if (T.canonical.z >= this._source.maxzoom) {
                    const L = T.children(this._source.maxzoom)[0],
                      O = this.getTile(L);
                    if (O && O.hasData()) {
                      o[L.key] = L;
                      continue;
                    }
                  } else {
                    const L = T.children(this._source.maxzoom);
                    if (
                      o[L[0].key] &&
                      o[L[1].key] &&
                      o[L[2].key] &&
                      o[L[3].key]
                    )
                      continue;
                  }
                  let A = C.wasRequested();
                  for (let L = T.overscaledZ - 1; L >= _; --L) {
                    const O = T.scaledTo(L);
                    if (
                      l[O.key] ||
                      ((l[O.key] = !0),
                      (C = this.getTile(O)),
                      !C && A && (C = this._addTile(O)),
                      C &&
                        ((o[O.key] = O), (A = C.wasRequested()), C.hasData()))
                    )
                      break;
                  }
                }
                return o;
              }
              _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for (const i in this._tiles) {
                  const o = [];
                  let l,
                    h = this._tiles[i].tileID;
                  for (; h.overscaledZ > 0; ) {
                    if (h.key in this._loadedParentTiles) {
                      l = this._loadedParentTiles[h.key];
                      break;
                    }
                    o.push(h.key);
                    const m = h.scaledTo(h.overscaledZ - 1);
                    if (((l = this._getLoadedTile(m)), l)) break;
                    h = m;
                  }
                  for (const m of o) this._loadedParentTiles[m] = l;
                }
              }
              _addTile(i) {
                let o = this._tiles[i.key];
                if (o) return o;
                (o = this._cache.getAndRemove(i)),
                  o &&
                    (this._setTileReloadTimer(i.key, o),
                    (o.tileID = i),
                    this._state.initializeTileState(
                      o,
                      this.map ? this.map.painter : null
                    ),
                    this._cacheTimers[i.key] &&
                      (clearTimeout(this._cacheTimers[i.key]),
                      delete this._cacheTimers[i.key],
                      this._setTileReloadTimer(i.key, o)));
                const l = Boolean(o);
                if (!l) {
                  const h = this.map ? this.map.painter : null;
                  (o = new sy(
                    i,
                    this._source.tileSize * i.overscaleFactor(),
                    this.transform.tileZoom,
                    h,
                    this._isRaster
                  )),
                    this._loadTile(
                      o,
                      this._tileLoaded.bind(this, o, i.key, o.state)
                    );
                }
                return o
                  ? (o.uses++,
                    (this._tiles[i.key] = o),
                    l ||
                      this._source.fire(
                        new Ra("dataloading", {
                          tile: o,
                          coord: o.tileID,
                          dataType: "source",
                        })
                      ),
                    o)
                  : null;
              }
              _setTileReloadTimer(i, o) {
                i in this._timers &&
                  (clearTimeout(this._timers[i]), delete this._timers[i]);
                const l = o.getExpiryTimeout();
                l &&
                  (this._timers[i] = setTimeout(() => {
                    this._reloadTile(i, "expired"), delete this._timers[i];
                  }, l));
              }
              _removeTile(i) {
                const o = this._tiles[i];
                o &&
                  (o.uses--,
                  delete this._tiles[i],
                  this._timers[i] &&
                    (clearTimeout(this._timers[i]), delete this._timers[i]),
                  o.uses > 0 ||
                    (o.hasData() && "reloading" !== o.state
                      ? this._cache.add(o.tileID, o, o.getExpiryTimeout())
                      : ((o.aborted = !0),
                        this._abortTile(o),
                        this._unloadTile(o))));
              }
              clearTiles() {
                (this._shouldReloadOnResume = !1), (this._paused = !1);
                for (const i in this._tiles) this._removeTile(+i);
                this._source._clear && this._source._clear(),
                  this._cache.reset(),
                  this.map &&
                    this.usedForTerrain &&
                    this.map.painter.terrain &&
                    this.map.painter.terrain.resetTileLookupCache(this.id);
              }
              tilesIn(i, o, l) {
                const h = [],
                  m = this.transform;
                if (!m) return h;
                const _ = "globe" === m.projection.name,
                  x = ua(m.center.lng);
                for (const E in this._tiles) {
                  const T = this._tiles[E];
                  if ((l && T.clearQueryDebugViz(), T.holdingForFade()))
                    continue;
                  let C;
                  if (_) {
                    const A = T.tileID.canonical;
                    if (0 === A.z) {
                      const L = [
                        Math.abs(Qt(x, ...Yc(A, -1)) - x),
                        Math.abs(Qt(x, ...Yc(A, 1)) - x),
                      ];
                      C = [0, 2 * L.indexOf(Math.min(...L)) - 1];
                    } else {
                      const L = [
                        Math.abs(Qt(x, ...Yc(A, -1)) - x),
                        Math.abs(Qt(x, ...Yc(A, 0)) - x),
                        Math.abs(Qt(x, ...Yc(A, 1)) - x),
                      ];
                      C = [L.indexOf(Math.min(...L)) - 1];
                    }
                  } else C = [0];
                  for (const A of C) {
                    const L = i.containsTile(T, m, o, A);
                    L && h.push(L);
                  }
                }
                return h;
              }
              getVisibleCoordinates(i) {
                const o = this.getRenderableIds(i).map(
                  (l) => this._tiles[l].tileID
                );
                for (const l of o)
                  l.projMatrix = this.transform.calculateProjMatrix(
                    l.toUnwrapped()
                  );
                return o;
              }
              hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (Kc(this._source.type))
                  for (const i in this._tiles) {
                    const o = this._tiles[i];
                    if (void 0 !== o.fadeEndTime && o.fadeEndTime >= cs.now())
                      return !0;
                  }
                return !1;
              }
              setFeatureState(i, o, l) {
                this._state.updateState((i = i || "_geojsonTileLayer"), o, l);
              }
              removeFeatureState(i, o, l) {
                this._state.removeFeatureState(
                  (i = i || "_geojsonTileLayer"),
                  o,
                  l
                );
              }
              getFeatureState(i, o) {
                return this._state.getState((i = i || "_geojsonTileLayer"), o);
              }
              setDependencies(i, o, l) {
                const h = this._tiles[i];
                h && h.setDependencies(o, l);
              }
              reloadTilesForDependencies(i, o) {
                for (const l in this._tiles)
                  this._tiles[l].hasDependency(i, o) &&
                    this._reloadTile(+l, "reloading");
                this._cache.filter((l) => !l.hasDependency(i, o));
              }
              _preloadTiles(i, o) {
                if (!this._sourceLoaded) {
                  const x = () => {
                    this._sourceLoaded &&
                      (this._source.off("data", x), this._preloadTiles(i, o));
                  };
                  return void this._source.on("data", x);
                }
                const l = new Map(),
                  h = Array.isArray(i) ? i : [i],
                  m = this.map.painter.terrain,
                  _ =
                    this.usedForTerrain && m
                      ? m.getScaledDemTileSize()
                      : this._source.tileSize;
                for (const x of h) {
                  const E = x.coveringTiles({
                    tileSize: _,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom && !this.usedForTerrain,
                    reparseOverscaled: this._source.reparseOverscaled,
                    isTerrainDEM: this.usedForTerrain,
                  });
                  for (const T of E) l.set(T.key, T);
                  this.usedForTerrain && x.updateElevation(!1);
                }
                Ci(
                  Array.from(l.values()),
                  (x, E) => {
                    const T = new sy(
                      x,
                      this._source.tileSize * x.overscaleFactor(),
                      this.transform.tileZoom,
                      this.map.painter,
                      this._isRaster
                    );
                    this._loadTile(T, (C) => {
                      "raster-dem" === this._source.type &&
                        T.dem &&
                        this._backfillDEM(T),
                        E(C, T);
                    });
                  },
                  o
                );
              }
            }
            function Xd(r, i) {
              const o = Math.abs(2 * r.wrap) - +(r.wrap < 0),
                l = Math.abs(2 * i.wrap) - +(i.wrap < 0);
              return (
                r.overscaledZ - i.overscaledZ ||
                l - o ||
                i.canonical.y - r.canonical.y ||
                i.canonical.x - r.canonical.x
              );
            }
            function Kc(r) {
              return (
                "raster" === r ||
                "image" === r ||
                "video" === r ||
                "custom" === r
              );
            }
            function Yc(r, i) {
              const o = 1 << r.z;
              return [r.x / o + i, (r.x + 1) / o + i];
            }
            (Xc.maxOverzooming = 10), (Xc.maxUnderzooming = 3);
            class cl {
              constructor(i, o, l) {
                (this._demTile = i),
                  (this._dem = this._demTile.dem),
                  (this._scale = o),
                  (this._offset = l);
              }
              static create(i, o, l) {
                const h = l || i.findDEMTileFor(o);
                if (!h || !h.dem) return;
                const m = h.dem,
                  _ = h.tileID,
                  x = 1 << (o.canonical.z - _.canonical.z);
                return new cl(h, h.tileSize / vt / x, [
                  (o.canonical.x / x - _.canonical.x) * m.dim,
                  (o.canonical.y / x - _.canonical.y) * m.dim,
                ]);
              }
              tileCoordToPixel(i, o) {
                const l = o * this._scale + this._offset[1],
                  h = Math.floor(i * this._scale + this._offset[0]),
                  m = Math.floor(l);
                return new et(h, m);
              }
              getElevationAt(i, o, l, h) {
                const m = i * this._scale + this._offset[0],
                  _ = o * this._scale + this._offset[1],
                  x = Math.floor(m),
                  E = Math.floor(_),
                  T = this._dem;
                return (
                  (h = !!h),
                  l
                    ? rn(
                        rn(T.get(x, E, h), T.get(x, E + 1, h), _ - E),
                        rn(T.get(x + 1, E, h), T.get(x + 1, E + 1, h), _ - E),
                        m - x
                      )
                    : T.get(x, E, h)
                );
              }
              getElevationAtPixel(i, o, l) {
                return this._dem.get(i, o, !!l);
              }
              getMeterToDEM(i) {
                return (
                  (1 << this._demTile.tileID.canonical.z) *
                  Ao(1, i) *
                  this._dem.stride
                );
              }
            }
            class df {
              constructor(i, o) {
                (this.tileID = i),
                  (this.x = i.canonical.x),
                  (this.y = i.canonical.y),
                  (this.z = i.canonical.z),
                  (this.grid = new Js(vt, 16, 0)),
                  (this.featureIndexArray = new Bl()),
                  (this.promoteId = o);
              }
              insert(i, o, l, h, m, _ = 0) {
                const x = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(l, h, m, _);
                const E = this.grid;
                for (let T = 0; T < o.length; T++) {
                  const C = o[T],
                    A = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (let L = 0; L < C.length; L++) {
                    const O = C[L];
                    (A[0] = Math.min(A[0], O.x)),
                      (A[1] = Math.min(A[1], O.y)),
                      (A[2] = Math.max(A[2], O.x)),
                      (A[3] = Math.max(A[3], O.y));
                  }
                  A[0] < vt &&
                    A[1] < vt &&
                    A[2] >= 0 &&
                    A[3] >= 0 &&
                    E.insert(x, A[0], A[1], A[2], A[3]);
                }
              }
              loadVTLayers() {
                if (!this.vtLayers) {
                  (this.vtLayers = new Wp(new kd(this.rawTileData)).layers),
                    (this.sourceLayerCoder = new oy(
                      this.vtLayers
                        ? Object.keys(this.vtLayers).sort()
                        : ["_geojsonTileLayer"]
                    )),
                    (this.vtFeatures = {});
                  for (const i in this.vtLayers) this.vtFeatures[i] = [];
                }
                return this.vtLayers;
              }
              query(i, o, l, h) {
                this.loadVTLayers();
                const m = i.params || {},
                  _ = Mu(m.filter),
                  x = i.tileResult,
                  E = i.transform,
                  T = x.bufferedTilespaceBounds,
                  C = this.grid.query(
                    T.min.x,
                    T.min.y,
                    T.max.x,
                    T.max.y,
                    (F, V, G, K) => pm(x.bufferedTilespaceGeometry, F, V, G, K)
                  );
                C.sort(cy);
                let A = null;
                E.elevation &&
                  C.length > 0 &&
                  (A = cl.create(E.elevation, this.tileID));
                const L = {};
                let O;
                for (let F = 0; F < C.length; F++) {
                  const V = C[F];
                  if (V === O) continue;
                  O = V;
                  const G = this.featureIndexArray.get(V);
                  let K = null;
                  this.loadMatchingFeature(
                    L,
                    G,
                    _,
                    m.layers,
                    m.availableImages,
                    o,
                    l,
                    h,
                    (oe, J, re, le = 0) => (
                      K || (K = el(oe, this.tileID.canonical, i.tileTransform)),
                      J.queryIntersectsFeature(
                        x,
                        oe,
                        re,
                        K,
                        this.z,
                        i.transform,
                        i.pixelPosMatrix,
                        A,
                        le
                      )
                    )
                  );
                }
                return L;
              }
              loadMatchingFeature(i, o, l, h, m, _, x, E, T) {
                const {
                    featureIndex: C,
                    bucketIndex: A,
                    sourceLayerIndex: L,
                    layoutVertexArrayOffset: O,
                  } = o,
                  F = this.bucketLayerIDs[A];
                if (
                  h &&
                  !(function (oe, J) {
                    for (let re = 0; re < oe.length; re++)
                      if (J.indexOf(oe[re]) >= 0) return !0;
                    return !1;
                  })(h, F)
                )
                  return;
                const V = this.sourceLayerCoder.decode(L),
                  G = this.vtLayers[V].feature(C);
                if (l.needGeometry) {
                  const oe = tl(G, !0);
                  if (
                    !l.filter(
                      new M(this.tileID.overscaledZ),
                      oe,
                      this.tileID.canonical
                    )
                  )
                    return;
                } else if (!l.filter(new M(this.tileID.overscaledZ), G)) return;
                const K = this.getId(G, V);
                for (let oe = 0; oe < F.length; oe++) {
                  const J = F[oe];
                  if (h && h.indexOf(J) < 0) continue;
                  const re = _[J];
                  if (!re) continue;
                  let le = {};
                  void 0 !== K &&
                    E &&
                    (le = E.getState(re.sourceLayer || "_geojsonTileLayer", K));
                  const ae = ci({}, x[J]);
                  (ae.paint = Kd(ae.paint, re.paint, G, le, m)),
                    (ae.layout = Kd(ae.layout, re.layout, G, le, m));
                  const De = !T || T(G, re, le, O);
                  if (!De) continue;
                  const xe = new ig(G, this.z, this.x, this.y, K);
                  xe.layer = ae;
                  let Pe = i[J];
                  void 0 === Pe && (Pe = i[J] = []),
                    Pe.push({
                      featureIndex: C,
                      feature: xe,
                      intersectionZ: De,
                    });
                }
              }
              lookupSymbolFeatures(i, o, l, h, m, _, x, E) {
                const T = {};
                this.loadVTLayers();
                const C = Mu(m);
                for (const A of i)
                  this.loadMatchingFeature(
                    T,
                    {
                      bucketIndex: l,
                      sourceLayerIndex: h,
                      featureIndex: A,
                      layoutVertexArrayOffset: 0,
                    },
                    C,
                    _,
                    x,
                    E,
                    o
                  );
                return T;
              }
              loadFeature(i) {
                const { featureIndex: o, sourceLayerIndex: l } = i;
                this.loadVTLayers();
                const h = this.sourceLayerCoder.decode(l),
                  m = this.vtFeatures[h];
                if (m[o]) return m[o];
                const _ = this.vtLayers[h].feature(o);
                return (m[o] = _), _;
              }
              hasLayer(i) {
                for (const o of this.bucketLayerIDs)
                  for (const l of o) if (i === l) return !0;
                return !1;
              }
              getId(i, o) {
                let l = i.id;
                if (this.promoteId) {
                  const h =
                    "string" == typeof this.promoteId
                      ? this.promoteId
                      : this.promoteId[o];
                  null != h && (l = i.properties[h]),
                    "boolean" == typeof l && (l = Number(l));
                }
                return l;
              }
            }
            function Kd(r, i, o, l, h) {
              return en(r, (m, _) => {
                const x = i instanceof Y ? i.get(_) : null;
                return x && x.evaluate ? x.evaluate(o, l, h) : x;
              });
            }
            function cy(r, i) {
              return i - r;
            }
            st(df, "FeatureIndex", {
              omit: ["rawTileData", "sourceLayerCoder"],
            });
            class ag {
              constructor(i, o) {
                (this.width = i),
                  (this.height = o),
                  (this.nextRow = 0),
                  (this.image = new Xr({ width: i, height: o })),
                  (this.positions = {}),
                  (this.uploaded = !1);
              }
              getDash(i, o) {
                const l = this.getKey(i, o);
                return this.positions[l];
              }
              trim() {
                const i = this.width,
                  o = (this.height = ss(this.nextRow));
                this.image.resize({ width: i, height: o });
              }
              getKey(i, o) {
                return i.join(",") + o;
              }
              getDashRanges(i, o, l) {
                const h = [];
                let m = i.length % 2 == 1 ? -i[i.length - 1] * l : 0,
                  _ = i[0] * l,
                  x = !0;
                h.push({
                  left: m,
                  right: _,
                  isDash: x,
                  zeroLength: 0 === i[0],
                });
                let E = i[0];
                for (let T = 1; T < i.length; T++) {
                  x = !x;
                  const C = i[T];
                  (m = E * l),
                    (E += C),
                    (_ = E * l),
                    h.push({
                      left: m,
                      right: _,
                      isDash: x,
                      zeroLength: 0 === C,
                    });
                }
                return h;
              }
              addRoundDash(i, o, l) {
                const h = o / 2;
                for (let m = -l; m <= l; m++) {
                  const _ = this.width * (this.nextRow + l + m);
                  let x = 0,
                    E = i[x];
                  for (let T = 0; T < this.width; T++) {
                    T / E.right > 1 && (E = i[++x]);
                    const C = Math.abs(T - E.left),
                      A = Math.abs(T - E.right),
                      L = Math.min(C, A);
                    let O;
                    const F = (m / l) * (h + 1);
                    if (E.isDash) {
                      const V = h - Math.abs(F);
                      O = Math.sqrt(L * L + V * V);
                    } else O = h - Math.sqrt(L * L + F * F);
                    this.image.data[_ + T] = Math.max(
                      0,
                      Math.min(255, O + 128)
                    );
                  }
                }
              }
              addRegularDash(i, o) {
                for (let E = i.length - 1; E >= 0; --E) {
                  const T = i[E],
                    C = i[E + 1];
                  T.zeroLength
                    ? i.splice(E, 1)
                    : C &&
                      C.isDash === T.isDash &&
                      ((C.left = T.left), i.splice(E, 1));
                }
                const l = i[0],
                  h = i[i.length - 1];
                l.isDash === h.isDash &&
                  ((l.left = h.left - this.width),
                  (h.right = l.right + this.width));
                const m = this.width * this.nextRow;
                let _ = 0,
                  x = i[_];
                for (let E = 0; E < this.width; E++) {
                  E / x.right > 1 && (x = i[++_]);
                  const T = Math.abs(E - x.left),
                    C = Math.abs(E - x.right),
                    A = Math.min(T, C);
                  this.image.data[m + E] = Math.max(
                    0,
                    Math.min(255, (x.isDash ? A : -A) + o + 128)
                  );
                }
              }
              addDash(i, o) {
                const l = this.getKey(i, o);
                if (this.positions[l]) return this.positions[l];
                const h = "round" === o,
                  m = h ? 7 : 0,
                  _ = 2 * m + 1;
                if (this.nextRow + _ > this.height)
                  return Hn("LineAtlas out of space"), null;
                0 === i.length && i.push(1);
                let x = 0;
                for (let C = 0; C < i.length; C++)
                  i[C] < 0 &&
                    (Hn(
                      "Negative value is found in line dasharray, replacing values with 0"
                    ),
                    (i[C] = 0)),
                    (x += i[C]);
                if (0 !== x) {
                  const C = this.width / x,
                    A = this.getDashRanges(i, this.width, C);
                  h
                    ? this.addRoundDash(A, C, m)
                    : this.addRegularDash(A, "square" === o ? 0.5 * C : 0);
                }
                const E = this.nextRow + m;
                this.nextRow += _;
                const T = { tl: [E, m], br: [x, 0] };
                return (this.positions[l] = T), T;
              }
            }
            st(ag, "LineAtlas");
            class ff {
              constructor(i) {
                const o = {},
                  l = [];
                for (const x in i) {
                  const E = i[x],
                    T = (o[x] = {});
                  for (const C in E.glyphs) {
                    const A = E.glyphs[+C];
                    if (!A || 0 === A.bitmap.width || 0 === A.bitmap.height)
                      continue;
                    const L = A.metrics.localGlyph ? 2 : 1,
                      O = {
                        x: 0,
                        y: 0,
                        w: A.bitmap.width + 2 * L,
                        h: A.bitmap.height + 2 * L,
                      };
                    l.push(O), (T[C] = O);
                  }
                }
                const { w: h, h: m } = Rd(l),
                  _ = new Xr({ width: h || 1, height: m || 1 });
                for (const x in i) {
                  const E = i[x];
                  for (const T in E.glyphs) {
                    const C = E.glyphs[+T];
                    if (!C || 0 === C.bitmap.width || 0 === C.bitmap.height)
                      continue;
                    const A = o[x][T],
                      L = C.metrics.localGlyph ? 2 : 1;
                    Xr.copy(
                      C.bitmap,
                      _,
                      { x: 0, y: 0 },
                      { x: A.x + L, y: A.y + L },
                      C.bitmap
                    );
                  }
                }
                (this.image = _), (this.positions = o);
              }
            }
            st(ff, "GlyphAtlas");
            class uy {
              constructor(i) {
                (this.tileID = new Nr(
                  i.tileID.overscaledZ,
                  i.tileID.wrap,
                  i.tileID.canonical.z,
                  i.tileID.canonical.x,
                  i.tileID.canonical.y
                )),
                  (this.tileZoom = i.tileZoom),
                  (this.uid = i.uid),
                  (this.zoom = i.zoom),
                  (this.canonical = i.tileID.canonical),
                  (this.pixelRatio = i.pixelRatio),
                  (this.tileSize = i.tileSize),
                  (this.source = i.source),
                  (this.overscaling = this.tileID.overscaleFactor()),
                  (this.showCollisionBoxes = i.showCollisionBoxes),
                  (this.collectResourceTiming = !!i.collectResourceTiming),
                  (this.returnDependencies = !!i.returnDependencies),
                  (this.promoteId = i.promoteId),
                  (this.enableTerrain = !!i.enableTerrain),
                  (this.isSymbolTile = i.isSymbolTile),
                  (this.tileTransform = qc(i.tileID.canonical, i.projection)),
                  (this.projection = i.projection);
              }
              parse(i, o, l, h, m) {
                (this.status = "parsing"),
                  (this.data = i),
                  (this.collisionBoxArray = new Cn());
                const _ = new oy(Object.keys(i.layers).sort()),
                  x = new df(this.tileID, this.promoteId);
                x.bucketLayerIDs = [];
                const E = {},
                  T = new ag(256, 256),
                  C = {
                    featureIndex: x,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: T,
                    availableImages: l,
                  },
                  A = o.familiesBySource[this.source];
                for (const le in A) {
                  const ae = i.layers[le];
                  if (!ae) continue;
                  let De = !1,
                    xe = !1;
                  for (const Ce of A[le])
                    "symbol" === Ce[0].type ? (De = !0) : (xe = !0);
                  if (
                    (!0 === this.isSymbolTile && !De) ||
                    (!1 === this.isSymbolTile && !xe)
                  )
                    continue;
                  1 === ae.version &&
                    Hn(
                      `Vector tile source "${this.source}" layer "${le}" does not use vector tile spec v2 and therefore may have some rendering errors.`
                    );
                  const Pe = _.encode(le),
                    $e = [];
                  for (let Ce = 0; Ce < ae.length; Ce++) {
                    const Fe = ae.feature(Ce),
                      Re = x.getId(Fe, le);
                    $e.push({
                      feature: Fe,
                      id: Re,
                      index: Ce,
                      sourceLayerIndex: Pe,
                    });
                  }
                  for (const Ce of A[le]) {
                    const Fe = Ce[0];
                    (void 0 !== this.isSymbolTile &&
                      ("symbol" === Fe.type) !== this.isSymbolTile) ||
                      (Fe.minzoom && this.zoom < Math.floor(Fe.minzoom)) ||
                      (Fe.maxzoom && this.zoom >= Fe.maxzoom) ||
                      ("none" !== Fe.visibility &&
                        (Yd(Ce, this.zoom, l),
                        (E[Fe.id] = Fe.createBucket({
                          index: x.bucketLayerIDs.length,
                          layers: Ce,
                          zoom: this.zoom,
                          canonical: this.canonical,
                          pixelRatio: this.pixelRatio,
                          overscaling: this.overscaling,
                          collisionBoxArray: this.collisionBoxArray,
                          sourceLayerIndex: Pe,
                          sourceID: this.source,
                          enableTerrain: this.enableTerrain,
                          projection: this.projection.spec,
                          availableImages: l,
                        })).populate(
                          $e,
                          C,
                          this.tileID.canonical,
                          this.tileTransform
                        ),
                        x.bucketLayerIDs.push(Ce.map((Re) => Re.id))));
                  }
                }
                let L, O, F, V;
                T.trim();
                const G = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom,
                  },
                  K = () => {
                    if (L) return m(L);
                    if (O && F && V) {
                      const le = new ff(O),
                        ae = new Uc(F, V);
                      for (const De in E) {
                        const xe = E[De];
                        xe instanceof fa
                          ? (Yd(xe.layers, this.zoom, l),
                            Hc(
                              xe,
                              O,
                              le.positions,
                              F,
                              ae.iconPositions,
                              this.showCollisionBoxes,
                              l,
                              this.tileID.canonical,
                              this.tileZoom,
                              this.projection
                            ))
                          : xe.hasPattern &&
                            (xe instanceof Ad ||
                              xe instanceof qp ||
                              xe instanceof Kp) &&
                            (Yd(xe.layers, this.zoom, l),
                            xe.addFeatures(
                              C,
                              this.tileID.canonical,
                              ae.patternPositions,
                              l,
                              this.tileTransform
                            ));
                      }
                      (this.status = "done"),
                        m(null, {
                          buckets: Rs(E).filter((De) => !De.isEmpty()),
                          featureIndex: x,
                          collisionBoxArray: this.collisionBoxArray,
                          glyphAtlasImage: le.image,
                          lineAtlas: T,
                          imageAtlas: ae,
                          glyphMap: this.returnDependencies ? O : null,
                          iconMap: this.returnDependencies ? F : null,
                          glyphPositions: this.returnDependencies
                            ? le.positions
                            : null,
                        });
                    }
                  },
                  oe = en(C.glyphDependencies, (le) =>
                    Object.keys(le).map(Number)
                  );
                Object.keys(oe).length
                  ? h.send(
                      "getGlyphs",
                      { uid: this.uid, stacks: oe },
                      (le, ae) => {
                        L || ((L = le), (O = ae), K());
                      },
                      void 0,
                      !1,
                      G
                    )
                  : (O = {});
                const J = Object.keys(C.iconDependencies);
                J.length
                  ? h.send(
                      "getImages",
                      {
                        icons: J,
                        source: this.source,
                        tileID: this.tileID,
                        type: "icons",
                      },
                      (le, ae) => {
                        L || ((L = le), (F = ae), K());
                      },
                      void 0,
                      !1,
                      G
                    )
                  : (F = {});
                const re = Object.keys(C.patternDependencies);
                re.length
                  ? h.send(
                      "getImages",
                      {
                        icons: re,
                        source: this.source,
                        tileID: this.tileID,
                        type: "patterns",
                      },
                      (le, ae) => {
                        L || ((L = le), (V = ae), K());
                      },
                      void 0,
                      !1,
                      G
                    )
                  : (V = {}),
                  K();
              }
            }
            function Yd(r, i, o) {
              const l = new M(i);
              for (const h of r) h.recalculate(l, o);
            }
            class hy {
              constructor(i) {
                (this.entries = {}), (this.scheduler = i);
              }
              request(i, o, l, h) {
                const m = (this.entries[i] = this.entries[i] || {
                  callbacks: [],
                });
                if (m.result) {
                  const [_, x] = m.result;
                  return (
                    this.scheduler
                      ? this.scheduler.add(() => {
                          h(_, x);
                        }, o)
                      : h(_, x),
                    () => {}
                  );
                }
                return (
                  m.callbacks.push(h),
                  m.cancel ||
                    (m.cancel = l((_, x) => {
                      m.result = [_, x];
                      for (const E of m.callbacks)
                        this.scheduler
                          ? this.scheduler.add(() => {
                              E(_, x);
                            }, o)
                          : E(_, x);
                      setTimeout(() => delete this.entries[i], 3e3);
                    })),
                  () => {
                    m.result ||
                      ((m.callbacks = m.callbacks.filter((_) => _ !== h)),
                      m.callbacks.length ||
                        (m.cancel(), delete this.entries[i]));
                  }
                );
              }
            }
            function T0(r, i, o) {
              const l = JSON.stringify(r.request);
              return (
                r.data &&
                  (this.deduped.entries[l] = { result: [null, r.data] }),
                this.deduped.request(
                  l,
                  {
                    type: "parseTile",
                    isSymbolTile: r.isSymbolTile,
                    zoom: r.tileZoom,
                  },
                  (h) => {
                    const m = Tl(r.request, (_, x, E, T) => {
                      _
                        ? h(_)
                        : x &&
                          h(null, {
                            vectorTile: o ? void 0 : new Wp(new kd(x)),
                            rawData: x,
                            cacheControl: E,
                            expires: T,
                          });
                    });
                    return () => {
                      m.cancel(), h();
                    };
                  },
                  i
                )
              );
            }
            const dy = [
              Int8Array,
              Uint8Array,
              Uint8ClampedArray,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array,
            ];
            class mf {
              static from(i) {
                if (!(i instanceof ArrayBuffer))
                  throw new Error("Data must be an instance of ArrayBuffer.");
                const [o, l] = new Uint8Array(i, 0, 2);
                if (219 !== o)
                  throw new Error(
                    "Data does not appear to be in a KDBush format."
                  );
                const h = l >> 4;
                if (1 !== h)
                  throw new Error(`Got v${h} data when expected v1.`);
                const m = dy[15 & l];
                if (!m) throw new Error("Unrecognized array type.");
                const [_] = new Uint16Array(i, 2, 1),
                  [x] = new Uint32Array(i, 4, 1);
                return new mf(x, _, m, i);
              }
              constructor(i, o = 64, l = Float64Array, h) {
                if (isNaN(i) || i < 0)
                  throw new Error(`Unpexpected numItems value: ${i}.`);
                (this.numItems = +i),
                  (this.nodeSize = Math.min(Math.max(+o, 2), 65535)),
                  (this.ArrayType = l),
                  (this.IndexArrayType = i < 65536 ? Uint16Array : Uint32Array);
                const m = dy.indexOf(this.ArrayType),
                  _ = 2 * i * this.ArrayType.BYTES_PER_ELEMENT,
                  x = i * this.IndexArrayType.BYTES_PER_ELEMENT,
                  E = (8 - (x % 8)) % 8;
                if (m < 0)
                  throw new Error(`Unexpected typed array class: ${l}.`);
                h && h instanceof ArrayBuffer
                  ? ((this.data = h),
                    (this.ids = new this.IndexArrayType(this.data, 8, i)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + x + E,
                      2 * i
                    )),
                    (this._pos = 2 * i),
                    (this._finished = !0))
                  : ((this.data = new ArrayBuffer(8 + _ + x + E)),
                    (this.ids = new this.IndexArrayType(this.data, 8, i)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + x + E,
                      2 * i
                    )),
                    (this._pos = 0),
                    (this._finished = !1),
                    new Uint8Array(this.data, 0, 2).set([219, 16 + m]),
                    (new Uint16Array(this.data, 2, 1)[0] = o),
                    (new Uint32Array(this.data, 4, 1)[0] = i));
              }
              add(i, o) {
                const l = this._pos >> 1;
                return (
                  (this.ids[l] = l),
                  (this.coords[this._pos++] = i),
                  (this.coords[this._pos++] = o),
                  l
                );
              }
              finish() {
                const i = this._pos >> 1;
                if (i !== this.numItems)
                  throw new Error(
                    `Added ${i} items when expected ${this.numItems}.`
                  );
                return (
                  lg(
                    this.ids,
                    this.coords,
                    this.nodeSize,
                    0,
                    this.numItems - 1,
                    0
                  ),
                  (this._finished = !0),
                  this
                );
              }
              range(i, o, l, h) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish()."
                  );
                const { ids: m, coords: _, nodeSize: x } = this,
                  E = [0, m.length - 1, 0],
                  T = [];
                for (; E.length; ) {
                  const C = E.pop() || 0,
                    A = E.pop() || 0,
                    L = E.pop() || 0;
                  if (A - L <= x) {
                    for (let G = L; G <= A; G++) {
                      const K = _[2 * G],
                        oe = _[2 * G + 1];
                      K >= i && K <= l && oe >= o && oe <= h && T.push(m[G]);
                    }
                    continue;
                  }
                  const O = (L + A) >> 1,
                    F = _[2 * O],
                    V = _[2 * O + 1];
                  F >= i && F <= l && V >= o && V <= h && T.push(m[O]),
                    (0 === C ? i <= F : o <= V) &&
                      (E.push(L), E.push(O - 1), E.push(1 - C)),
                    (0 === C ? l >= F : h >= V) &&
                      (E.push(O + 1), E.push(A), E.push(1 - C));
                }
                return T;
              }
              within(i, o, l) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish()."
                  );
                const { ids: h, coords: m, nodeSize: _ } = this,
                  x = [0, h.length - 1, 0],
                  E = [],
                  T = l * l;
                for (; x.length; ) {
                  const C = x.pop() || 0,
                    A = x.pop() || 0,
                    L = x.pop() || 0;
                  if (A - L <= _) {
                    for (let G = L; G <= A; G++)
                      lo(m[2 * G], m[2 * G + 1], i, o) <= T && E.push(h[G]);
                    continue;
                  }
                  const O = (L + A) >> 1,
                    F = m[2 * O],
                    V = m[2 * O + 1];
                  lo(F, V, i, o) <= T && E.push(h[O]),
                    (0 === C ? i - l <= F : o - l <= V) &&
                      (x.push(L), x.push(O - 1), x.push(1 - C)),
                    (0 === C ? i + l >= F : o + l >= V) &&
                      (x.push(O + 1), x.push(A), x.push(1 - C));
                }
                return E;
              }
            }
            function lg(r, i, o, l, h, m) {
              if (h - l <= o) return;
              const _ = (l + h) >> 1;
              cg(r, i, _, l, h, m),
                lg(r, i, o, l, _ - 1, 1 - m),
                lg(r, i, o, _ + 1, h, 1 - m);
            }
            function cg(r, i, o, l, h, m) {
              for (; h > l; ) {
                if (h - l > 600) {
                  const T = h - l + 1,
                    C = o - l + 1,
                    A = Math.log(T),
                    L = 0.5 * Math.exp((2 * A) / 3),
                    O =
                      0.5 *
                      Math.sqrt((A * L * (T - L)) / T) *
                      (C - T / 2 < 0 ? -1 : 1);
                  cg(
                    r,
                    i,
                    o,
                    Math.max(l, Math.floor(o - (C * L) / T + O)),
                    Math.min(h, Math.floor(o + ((T - C) * L) / T + O)),
                    m
                  );
                }
                const _ = i[2 * o + m];
                let x = l,
                  E = h;
                for (
                  dh(r, i, l, o), i[2 * h + m] > _ && dh(r, i, l, h);
                  x < E;

                ) {
                  for (dh(r, i, x, E), x++, E--; i[2 * x + m] < _; ) x++;
                  for (; i[2 * E + m] > _; ) E--;
                }
                i[2 * l + m] === _ ? dh(r, i, l, E) : (E++, dh(r, i, E, h)),
                  E <= o && (l = E + 1),
                  o <= E && (h = E - 1);
              }
            }
            function dh(r, i, o, l) {
              ug(r, o, l), ug(i, 2 * o, 2 * l), ug(i, 2 * o + 1, 2 * l + 1);
            }
            function ug(r, i, o) {
              const l = r[i];
              (r[i] = r[o]), (r[o] = l);
            }
            function lo(r, i, o, l) {
              const h = r - o,
                m = i - l;
              return h * h + m * m;
            }
            (d.ARRAY_TYPE = Xn),
              (d.AUTH_ERR_MSG = ce),
              (d.Aabb = Fr),
              (d.Actor = class {
                constructor(r, i, o) {
                  (this.target = r),
                    (this.parent = i),
                    (this.mapId = o),
                    (this.callbacks = {}),
                    (this.cancelCallbacks = {}),
                    No(["receive"], this),
                    this.target.addEventListener("message", this.receive, !1),
                    (this.globalScope = zs() ? r : Be),
                    (this.scheduler = new f0());
                }
                send(r, i, o, l, h = !1, m) {
                  const _ = Math.round(1e18 * Math.random())
                    .toString(36)
                    .substring(0, 10);
                  o && ((o.metadata = m), (this.callbacks[_] = o));
                  const x = lc(this.globalScope) ? void 0 : [];
                  return (
                    this.target.postMessage(
                      {
                        id: _,
                        type: r,
                        hasCallback: !!o,
                        targetMapId: l,
                        mustQueue: h,
                        sourceMapId: this.mapId,
                        data: Rr(i, x),
                      },
                      x
                    ),
                    {
                      cancel: () => {
                        o && delete this.callbacks[_],
                          this.target.postMessage({
                            id: _,
                            type: "<cancel>",
                            targetMapId: l,
                            sourceMapId: this.mapId,
                          });
                      },
                    }
                  );
                }
                receive(r) {
                  const i = r.data,
                    o = i.id;
                  if (o && (!i.targetMapId || this.mapId === i.targetMapId))
                    if ("<cancel>" === i.type) {
                      const l = this.cancelCallbacks[o];
                      delete this.cancelCallbacks[o], l && l.cancel();
                    } else if (i.mustQueue || zs()) {
                      const l = this.callbacks[o];
                      this.cancelCallbacks[o] = this.scheduler.add(
                        () => this.processTask(o, i),
                        (l && l.metadata) || { type: "message" }
                      );
                    } else this.processTask(o, i);
                }
                processTask(r, i) {
                  if ("<response>" === i.type) {
                    const o = this.callbacks[r];
                    delete this.callbacks[r],
                      o && (i.error ? o(Ga(i.error)) : o(null, Ga(i.data)));
                  } else {
                    const o = lc(this.globalScope) ? void 0 : [],
                      l = i.hasCallback
                        ? (m, _) => {
                            delete this.cancelCallbacks[r],
                              this.target.postMessage(
                                {
                                  id: r,
                                  type: "<response>",
                                  sourceMapId: this.mapId,
                                  error: m ? Rr(m) : null,
                                  data: Rr(_, o),
                                },
                                o
                              );
                          }
                        : (m) => {},
                      h = Ga(i.data);
                    if (this.parent[i.type])
                      this.parent[i.type](i.sourceMapId, h, l);
                    else if (this.parent.getWorkerSource) {
                      const m = i.type.split(".");
                      this.parent
                        .getWorkerSource(i.sourceMapId, m[0], h.source)
                        [m[1]](h, l);
                    } else l(new Error(`Could not find function ${i.type}`));
                  }
                }
                remove() {
                  this.scheduler.remove(),
                    this.target.removeEventListener(
                      "message",
                      this.receive,
                      !1
                    );
                }
              }),
              (d.CanonicalTileID = _i),
              (d.Color = di),
              (d.ColorMode = ya),
              (d.CullFaceMode = Ts),
              (d.DEMData = Zd),
              (d.DataConstantProperty = B),
              (d.DedupedRequest = hy),
              (d.DepthMode = hh),
              (d.EXTENT = vt),
              (d.Elevation = class {
                isDataAvailableAtPoint(r) {
                  const i = this._source();
                  if (this.isUsingMockSource() || !i || r.y < 0 || r.y > 1)
                    return !1;
                  const o = i.getSource().maxzoom,
                    l = 1 << o,
                    h = Math.floor(r.x),
                    m = Math.floor((r.x - h) * l),
                    _ = Math.floor(r.y * l),
                    x = this.findDEMTileFor(new Nr(o, h, o, m, _));
                  return !(!x || !x.dem);
                }
                getAtPointOrZero(r, i = 0) {
                  return this.getAtPoint(r, i) || 0;
                }
                getAtPoint(r, i, o = !0) {
                  if (this.isUsingMockSource()) return null;
                  null == i && (i = null);
                  const l = this._source();
                  if (!l || r.y < 0 || r.y > 1) return i;
                  const h = l.getSource().maxzoom,
                    m = 1 << h,
                    _ = Math.floor(r.x),
                    x = r.x - _,
                    E = new Nr(h, _, h, Math.floor(x * m), Math.floor(r.y * m)),
                    T = this.findDEMTileFor(E);
                  if (!T || !T.dem) return i;
                  const C = T.dem,
                    A = 1 << T.tileID.canonical.z,
                    L = (x * A - T.tileID.canonical.x) * C.dim,
                    O = (r.y * A - T.tileID.canonical.y) * C.dim,
                    F = Math.floor(L),
                    V = Math.floor(O);
                  return (
                    (o ? this.exaggeration() : 1) *
                    rn(
                      rn(C.get(F, V), C.get(F, V + 1), O - V),
                      rn(C.get(F + 1, V), C.get(F + 1, V + 1), O - V),
                      L - F
                    )
                  );
                }
                getAtTileOffset(r, i, o) {
                  const l = 1 << r.canonical.z;
                  return this.getAtPointOrZero(
                    new qu(
                      r.wrap + (r.canonical.x + i / vt) / l,
                      (r.canonical.y + o / vt) / l
                    )
                  );
                }
                getAtTileOffsetFunc(r, i, o, l) {
                  return (h) => {
                    const m = this.getAtTileOffset(r, h.x, h.y),
                      _ = l.upVector(r.canonical, h.x, h.y);
                    return (
                      lr(
                        _,
                        _,
                        m * l.upVectorScale(r.canonical, i, o).metersToTile
                      ),
                      _
                    );
                  };
                }
                getForTilePoints(r, i, o, l) {
                  if (this.isUsingMockSource()) return !1;
                  const h = cl.create(this, r, l);
                  return (
                    !!h &&
                    (i.forEach((m) => {
                      m[2] =
                        this.exaggeration() * h.getElevationAt(m[0], m[1], o);
                    }),
                    !0)
                  );
                }
                getMinMaxForTile(r) {
                  if (this.isUsingMockSource()) return null;
                  const i = this.findDEMTileFor(r);
                  if (!i || !i.dem) return null;
                  const o = i.dem.tree,
                    l = i.tileID,
                    h = 1 << (r.canonical.z - l.canonical.z);
                  let m = r.canonical.x / h - l.canonical.x,
                    _ = r.canonical.y / h - l.canonical.y,
                    x = 0;
                  for (
                    let E = 0;
                    E < r.canonical.z - l.canonical.z && !o.leaves[x];
                    E++
                  ) {
                    (m *= 2), (_ *= 2);
                    const T = 2 * Math.floor(_) + Math.floor(m);
                    (x = o.childOffsets[x] + T), (m %= 1), (_ %= 1);
                  }
                  return {
                    min: this.exaggeration() * o.minimums[x],
                    max: this.exaggeration() * o.maximums[x],
                  };
                }
                getMinElevationBelowMSL() {
                  throw new Error("Pure virtual method called.");
                }
                raycast(r, i, o) {
                  throw new Error("Pure virtual method called.");
                }
                pointCoordinate(r) {
                  throw new Error("Pure virtual method called.");
                }
                _source() {
                  throw new Error("Pure virtual method called.");
                }
                isUsingMockSource() {
                  throw new Error("Pure virtual method called.");
                }
                exaggeration() {
                  throw new Error("Pure virtual method called.");
                }
                findDEMTileFor(r) {
                  throw new Error("Pure virtual method called.");
                }
                get visibleDemTiles() {
                  throw new Error("Getter must be implemented in subclass.");
                }
              }),
              (d.ErrorEvent = us),
              (d.EvaluationParameters = M),
              (d.Event = Ra),
              (d.Evented = pc),
              (d.FillExtrusionBucket = Kp),
              (d.Frustum = Cp),
              (d.FrustumCorners = qg),
              (d.GLOBE_RADIUS = la),
              (d.GLOBE_SCALE_MATCH_LATITUDE = 45),
              (d.GLOBE_ZOOM_THRESHOLD_MAX = 6),
              (d.GLOBE_ZOOM_THRESHOLD_MIN = 5),
              (d.GlobeSharedBuffers = class {
                constructor(r) {
                  this._createGrid(r), this._createPoles(r);
                }
                destroy() {
                  this._poleIndexBuffer.destroy(),
                    this._gridBuffer.destroy(),
                    this._gridIndexBuffer.destroy(),
                    this._poleNorthVertexBuffer.destroy(),
                    this._poleSouthVertexBuffer.destroy();
                  for (const r of this._poleSegments) r.destroy();
                  for (const r of this._gridSegments)
                    r.withSkirts.destroy(), r.withoutSkirts.destroy();
                  if (this._wireframeIndexBuffer) {
                    this._wireframeIndexBuffer.destroy();
                    for (const r of this._wireframeSegments) r.destroy();
                  }
                }
                _fillGridMeshWithLods(r, i) {
                  const o = new Ge(),
                    l = new ft(),
                    h = [],
                    m = r + 1 + 2,
                    _ = i[0] + 1,
                    x = i[0] + 1 + (1 + i.length),
                    E = (T, C, A) => {
                      let L = T === m - 1 ? T - 2 : 0 === T ? T : T - 1;
                      return (L += A ? 24575 : 0), [L, C];
                    };
                  for (let T = 0; T < m; ++T) o.emplaceBack(...E(T, 0, !0));
                  for (let T = 0; T < _; ++T)
                    for (let C = 0; C < m; ++C)
                      o.emplaceBack(...E(C, T, (0 === C || C === m - 1) && !0));
                  for (let T = 0; T < i.length; ++T) {
                    const C = i[T];
                    for (let A = 0; A < m; ++A) o.emplaceBack(...E(A, C, !0));
                  }
                  for (let T = 0; T < i.length; ++T) {
                    const C = l.length,
                      A = i[T] + 1 + 2,
                      L = new ft();
                    for (let V = 0; V < A - 1; V++) {
                      const G = V === A - 2,
                        K = G ? m * (x - i.length + T - V) : m;
                      for (let oe = 0; oe < m - 1; oe++) {
                        const J = V * m + oe;
                        0 === V || G || 0 === oe || oe === m - 2
                          ? (L.emplaceBack(J + 1, J, J + K),
                            L.emplaceBack(J + K, J + K + 1, J + 1))
                          : (l.emplaceBack(J + 1, J, J + K),
                            l.emplaceBack(J + K, J + K + 1, J + 1));
                      }
                    }
                    const O = gi.simpleSegment(0, C, o.length, l.length - C);
                    for (let V = 0; V < L.uint16.length; V += 3)
                      l.emplaceBack(
                        L.uint16[V],
                        L.uint16[V + 1],
                        L.uint16[V + 2]
                      );
                    const F = gi.simpleSegment(0, C, o.length, l.length - C);
                    h.push({ withoutSkirts: O, withSkirts: F });
                  }
                  return { vertices: o, indices: l, segments: h };
                }
                _createGrid(r) {
                  const i = this._fillGridMeshWithLods(64, $u);
                  (this._gridSegments = i.segments),
                    (this._gridBuffer = r.createVertexBuffer(
                      i.vertices,
                      Ja.members
                    )),
                    (this._gridIndexBuffer = r.createIndexBuffer(
                      i.indices,
                      !0
                    ));
                }
                _createPoles(r) {
                  const i = new ft();
                  for (let h = 0; h <= 64; h++) i.emplaceBack(0, h + 1, h + 2);
                  this._poleIndexBuffer = r.createIndexBuffer(i, !0);
                  const o = new Tn(),
                    l = new Tn();
                  this._poleSegments = [];
                  for (let h = 0, m = 0; h < 5; h++) {
                    const _ = 360 / (1 << h);
                    o.emplaceBack(0, -la, 0, 0.5, 0),
                      l.emplaceBack(0, -la, 0, 0.5, 1);
                    for (let x = 0; x <= 64; x++) {
                      const E = x / 64,
                        T = rn(0, _, E),
                        [C, A, L] = cd(Qg, rm, T, la);
                      o.emplaceBack(C, A, L, E, 0),
                        l.emplaceBack(C, A, L, E, 1);
                    }
                    this._poleSegments.push(gi.simpleSegment(m, 0, 66, 64)),
                      (m += 66);
                  }
                  (this._poleNorthVertexBuffer = r.createVertexBuffer(
                    o,
                    Gg,
                    !1
                  )),
                    (this._poleSouthVertexBuffer = r.createVertexBuffer(
                      l,
                      Gg,
                      !1
                    ));
                }
                getGridBuffers(r, i) {
                  return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    i
                      ? this._gridSegments[r].withSkirts
                      : this._gridSegments[r].withoutSkirts,
                  ];
                }
                getPoleBuffers(r) {
                  return [
                    this._poleNorthVertexBuffer,
                    this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[r],
                  ];
                }
                getWirefameBuffers(r, i) {
                  if (!this._wireframeSegments) {
                    const o = new mi(),
                      l = 64,
                      h = l + 1 + 2,
                      m = 1;
                    this._wireframeSegments = [];
                    for (let _ = 0, x = 0; _ < $u.length; _++) {
                      const E = $u[_];
                      for (let C = m; C < E + m; C++)
                        for (let A = m; A < l + m; A++) {
                          const L = C * h + A;
                          o.emplaceBack(L, L + 1),
                            o.emplaceBack(L, L + h),
                            o.emplaceBack(L, L + h + 1);
                        }
                      const T = E * l * 3;
                      this._wireframeSegments.push(
                        gi.simpleSegment(0, x, (E + 1) * h, T)
                      ),
                        (x += T);
                    }
                    this._wireframeIndexBuffer = r.createIndexBuffer(o);
                  }
                  return [
                    this._gridBuffer,
                    this._wireframeIndexBuffer,
                    this._wireframeSegments[i],
                  ];
                }
              }),
              (d.GlyphManager = rh),
              (d.ImagePosition = Od),
              (d.KDBush = mf),
              (d.LivePerformanceUtils = Lf),
              (d.LngLat = Mn),
              (d.LngLatBounds = Lc),
              (d.LocalGlyphMode = nf),
              (d.MAX_MERCATOR_LATITUDE = Ti),
              (d.MercatorCoordinate = qu),
              (d.ONE_EM = 24),
              (d.OverscaledTileID = Nr),
              (d.PerformanceMarkers = ka),
              (d.Point = et),
              (d.Properties = te),
              (d.RGBAImage = Kr),
              (d.Ray = Jf),
              (d.RequestManager = class {
                constructor(r, i, o) {
                  (this._transformRequestFn = r),
                    (this._customAccessToken = i),
                    (this._silenceAuthErrors = !!o),
                    this._createSkuToken();
                }
                _createSkuToken() {
                  const r = (function () {
                    let i = "";
                    for (let o = 0; o < 10; o++)
                      i +=
                        "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[
                          Math.floor(62 * Math.random())
                        ];
                    return {
                      token: ["1", vl, i].join(""),
                      tokenExpiresAt: Date.now() + 432e5,
                    };
                  })();
                  (this._skuToken = r.token),
                    (this._skuTokenExpiresAt = r.tokenExpiresAt);
                }
                _isSkuTokenExpired() {
                  return Date.now() > this._skuTokenExpiresAt;
                }
                transformRequest(r, i) {
                  return (
                    (this._transformRequestFn &&
                      this._transformRequestFn(r, i)) || { url: r }
                  );
                }
                normalizeStyleURL(r, i) {
                  if (!me(r)) return r;
                  const o = Qe(r);
                  return (
                    (o.path = `/styles/v1${o.path}`),
                    this._makeAPIURL(o, this._customAccessToken || i)
                  );
                }
                normalizeGlyphsURL(r, i) {
                  if (!me(r)) return r;
                  const o = Qe(r);
                  return (
                    (o.path = `/fonts/v1${o.path}`),
                    this._makeAPIURL(o, this._customAccessToken || i)
                  );
                }
                normalizeSourceURL(r, i, o, l) {
                  if (!me(r)) return r;
                  const h = Qe(r);
                  return (
                    (h.path = `/v4/${h.authority}.json`),
                    h.params.push("secure"),
                    o && h.params.push(`language=${o}`),
                    l && h.params.push(`worldview=${l}`),
                    this._makeAPIURL(h, this._customAccessToken || i)
                  );
                }
                normalizeSpriteURL(r, i, o, l) {
                  const h = Qe(r);
                  return me(r)
                    ? ((h.path = `/styles/v1${h.path}/sprite${i}${o}`),
                      this._makeAPIURL(h, this._customAccessToken || l))
                    : ((h.path += `${i}${o}`), We(h));
                }
                normalizeTileURL(r, i, o) {
                  if (
                    (this._isSkuTokenExpired() && this._createSkuToken(),
                    r && !me(r))
                  )
                    return r;
                  const l = Qe(r);
                  (l.path = l.path.replace(
                    /(\.(png|jpg)\d*)(?=$)/,
                    `${
                      i || (o && "raster" !== l.authority && 512 === o)
                        ? "@2x"
                        : ""
                    }${Ot.supported ? ".webp" : "$1"}`
                  )),
                    "raster" === l.authority
                      ? (l.path = `/${zt.RASTER_URL_PREFIX}${l.path}`)
                      : ((l.path = l.path.replace(/^.+\/v4\//, "/")),
                        (l.path = `/${zt.TILE_URL_VERSION}${l.path}`));
                  const h =
                    this._customAccessToken ||
                    (function (m) {
                      for (const _ of m) {
                        const x = _.match(/^access_token=(.*)$/);
                        if (x) return x[1];
                      }
                      return null;
                    })(l.params) ||
                    zt.ACCESS_TOKEN;
                  return (
                    zt.REQUIRE_ACCESS_TOKEN &&
                      h &&
                      this._skuToken &&
                      l.params.push(`sku=${this._skuToken}`),
                    this._makeAPIURL(l, h)
                  );
                }
                canonicalizeTileURL(r, i) {
                  const o = Qe(r);
                  if (
                    !o.path.match(/^(\/v4\/|\/raster\/v1\/)/) ||
                    !o.path.match(/\.[\w]+$/)
                  )
                    return r;
                  let l = "mapbox://";
                  o.path.match(/^\/raster\/v1\//)
                    ? (l += `raster/${o.path.replace(
                        `/${zt.RASTER_URL_PREFIX}/`,
                        ""
                      )}`)
                    : (l += `tiles/${o.path.replace(
                        `/${zt.TILE_URL_VERSION}/`,
                        ""
                      )}`);
                  let h = o.params;
                  return (
                    i && (h = h.filter((m) => !m.match(/^access_token=/))),
                    h.length && (l += `?${h.join("&")}`),
                    l
                  );
                }
                canonicalizeTileset(r, i) {
                  const o = !!i && me(i),
                    l = [];
                  for (const h of r.tiles || [])
                    ve(h) ? l.push(this.canonicalizeTileURL(h, o)) : l.push(h);
                  return l;
                }
                _makeAPIURL(r, i) {
                  const o =
                      "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",
                    l = Qe(zt.API_URL);
                  if (
                    ((r.protocol = l.protocol),
                    (r.authority = l.authority),
                    "http" === r.protocol)
                  ) {
                    const h = r.params.indexOf("secure");
                    h >= 0 && r.params.splice(h, 1);
                  }
                  if (
                    ("/" !== l.path && (r.path = `${l.path}${r.path}`),
                    !zt.REQUIRE_ACCESS_TOKEN)
                  )
                    return We(r);
                  if (((i = i || zt.ACCESS_TOKEN), !this._silenceAuthErrors)) {
                    if (!i)
                      throw new Error(
                        `An API access token is required to use Mapbox GL. ${o}`
                      );
                    if ("s" === i[0])
                      throw new Error(
                        `Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o}`
                      );
                  }
                  return (
                    (r.params = r.params.filter(
                      (h) => -1 === h.indexOf("access_token")
                    )),
                    r.params.push(`access_token=${i || ""}`),
                    We(r)
                  );
                }
              }),
              (d.ResourceType = Bs),
              (d.SegmentVector = gi),
              (d.SourceCache = Xc),
              (d.StencilMode = uf),
              (d.StructArrayLayout1ui2 = br),
              (d.StructArrayLayout2f1f2i16 = wt),
              (d.StructArrayLayout2i4 = Ge),
              (d.StructArrayLayout2ui4 = mi),
              (d.StructArrayLayout3f12 = jt),
              (d.StructArrayLayout3ui6 = ft),
              (d.StructArrayLayout4i8 = Le),
              (d.StructArrayLayout5f20 = Tn),
              (d.Texture = af),
              (d.Tile = sy),
              (d.Transitionable = z),
              (d.Uniform1f = nn),
              (d.Uniform1i = class extends Za {
                constructor(r) {
                  super(r), (this.current = 0);
                }
                set(r, i, o) {
                  this.fetchUniformLocation(r, i) &&
                    this.current !== o &&
                    ((this.current = o), this.gl.uniform1i(this.location, o));
                }
              }),
              (d.Uniform2f = class extends Za {
                constructor(r) {
                  super(r), (this.current = [0, 0]);
                }
                set(r, i, o) {
                  this.fetchUniformLocation(r, i) &&
                    ((o[0] === this.current[0] && o[1] === this.current[1]) ||
                      ((this.current = o),
                      this.gl.uniform2f(this.location, o[0], o[1])));
                }
              }),
              (d.Uniform3f = class extends Za {
                constructor(r) {
                  super(r), (this.current = [0, 0, 0]);
                }
                set(r, i, o) {
                  this.fetchUniformLocation(r, i) &&
                    ((o[0] === this.current[0] &&
                      o[1] === this.current[1] &&
                      o[2] === this.current[2]) ||
                      ((this.current = o),
                      this.gl.uniform3f(this.location, o[0], o[1], o[2])));
                }
              }),
              (d.Uniform4f = fv),
              (d.UniformColor = mv),
              (d.UniformMatrix2f = class extends Za {
                constructor(r) {
                  super(r), (this.current = _b);
                }
                set(r, i, o) {
                  if (this.fetchUniformLocation(r, i))
                    for (let l = 0; l < 4; l++)
                      if (o[l] !== this.current[l]) {
                        (this.current = o),
                          this.gl.uniformMatrix2fv(this.location, !1, o);
                        break;
                      }
                }
              }),
              (d.UniformMatrix3f = class extends Za {
                constructor(r) {
                  super(r), (this.current = gb);
                }
                set(r, i, o) {
                  if (this.fetchUniformLocation(r, i))
                    for (let l = 0; l < 9; l++)
                      if (o[l] !== this.current[l]) {
                        (this.current = o),
                          this.gl.uniformMatrix3fv(this.location, !1, o);
                        break;
                      }
                }
              }),
              (d.UniformMatrix4f = class extends Za {
                constructor(r) {
                  super(r), (this.current = mb);
                }
                set(r, i, o) {
                  if (this.fetchUniformLocation(r, i)) {
                    if (o[12] !== this.current[12] || o[0] !== this.current[0])
                      return (
                        (this.current = o),
                        void this.gl.uniformMatrix4fv(this.location, !1, o)
                      );
                    for (let l = 1; l < 16; l++)
                      if (o[l] !== this.current[l]) {
                        (this.current = o),
                          this.gl.uniformMatrix4fv(this.location, !1, o);
                        break;
                      }
                  }
                }
              }),
              (d.UnwrappedTileID = D_),
              (d.ValidationError = at),
              (d.VectorTileFeature = Dd),
              (d.VectorTileWorkerSource = class extends pc {
                constructor(r, i, o, l, h) {
                  super(),
                    (this.actor = r),
                    (this.layerIndex = i),
                    (this.availableImages = o),
                    (this.loadVectorData = h || T0),
                    (this.loading = {}),
                    (this.loaded = {}),
                    (this.deduped = new hy(r.scheduler)),
                    (this.isSpriteLoaded = l),
                    (this.scheduler = r.scheduler);
                }
                loadTile(r, i) {
                  const o = r.uid,
                    l = r && r.request,
                    h = l && l.collectResourceTiming,
                    m = (this.loading[o] = new uy(r));
                  m.abort = this.loadVectorData(r, (_, x) => {
                    const E = !this.loading[o];
                    if ((delete this.loading[o], E || _ || !x))
                      return (
                        (m.status = "done"), E || (this.loaded[o] = m), i(_)
                      );
                    const T = x.rawData,
                      C = {};
                    x.expires && (C.expires = x.expires),
                      x.cacheControl && (C.cacheControl = x.cacheControl),
                      (m.vectorTile = x.vectorTile || new Wp(new kd(T)));
                    const A = () => {
                      m.parse(
                        m.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.actor,
                        (L, O) => {
                          if (L || !O) return i(L);
                          const F = {};
                          if (h) {
                            const V = Ih(l);
                            V.length > 0 &&
                              (F.resourceTiming = JSON.parse(
                                JSON.stringify(V)
                              ));
                          }
                          i(null, ci({ rawTileData: T.slice(0) }, O, C, F));
                        }
                      );
                    };
                    this.isSpriteLoaded
                      ? A()
                      : this.once("isSpriteLoaded", () => {
                          this.scheduler
                            ? this.scheduler.add(A, {
                                type: "parseTile",
                                isSymbolTile: r.isSymbolTile,
                                zoom: r.tileZoom,
                              })
                            : A();
                        }),
                      (this.loaded = this.loaded || {}),
                      (this.loaded[o] = m);
                  });
                }
                reloadTile(r, i) {
                  const o = this.loaded,
                    l = r.uid,
                    h = this;
                  if (o && o[l]) {
                    const m = o[l];
                    (m.showCollisionBoxes = r.showCollisionBoxes),
                      (m.enableTerrain = !!r.enableTerrain),
                      (m.projection = r.projection),
                      (m.tileTransform = qc(r.tileID.canonical, r.projection));
                    const _ = (x, E) => {
                      const T = m.reloadCallback;
                      T &&
                        (delete m.reloadCallback,
                        m.parse(
                          m.vectorTile,
                          h.layerIndex,
                          this.availableImages,
                          h.actor,
                          T
                        )),
                        i(x, E);
                    };
                    "parsing" === m.status
                      ? (m.reloadCallback = _)
                      : "done" === m.status &&
                        (m.vectorTile
                          ? m.parse(
                              m.vectorTile,
                              this.layerIndex,
                              this.availableImages,
                              this.actor,
                              _
                            )
                          : _());
                  }
                }
                abortTile(r, i) {
                  const o = r.uid,
                    l = this.loading[o];
                  l && (l.abort && l.abort(), delete this.loading[o]), i();
                }
                removeTile(r, i) {
                  const o = this.loaded,
                    l = r.uid;
                  o && o[l] && delete o[l], i();
                }
              }),
              (d.WritingMode = Po),
              (d.ZoomDependentExpression = Ec),
              (d.add = Ya),
              (d.addDynamicAttributes = $d),
              (d.adjoint = function (r, i) {
                var o = i[0],
                  l = i[1],
                  h = i[2],
                  m = i[3],
                  _ = i[4],
                  x = i[5],
                  E = i[6],
                  T = i[7],
                  C = i[8];
                return (
                  (r[0] = _ * C - x * T),
                  (r[1] = h * T - l * C),
                  (r[2] = l * x - h * _),
                  (r[3] = x * E - m * C),
                  (r[4] = o * C - h * E),
                  (r[5] = h * m - o * x),
                  (r[6] = m * T - _ * E),
                  (r[7] = l * E - o * T),
                  (r[8] = o * _ - l * m),
                  r
                );
              }),
              (d.asyncAll = Ci),
              (d.bezier = Ca),
              (d.bindAll = No),
              (d.boundsAttributes = g0),
              (d.bufferConvexPolygon = function (r, i) {
                const o = [];
                for (let l = 0; l < r.length; l++) {
                  const h = bn(l - 1, -1, r.length - 1),
                    m = bn(l + 1, -1, r.length - 1),
                    _ = r[l],
                    x = r[m],
                    E = r[h].sub(_).unit(),
                    T = x.sub(_).unit(),
                    C = T.angleWithSep(E.x, E.y),
                    A = E.add(T)
                      .unit()
                      .mult((-1 * i) / Math.sin(C / 2));
                  o.push(_.add(A));
                }
                return o;
              }),
              (d.cacheEntryPossiblyAdded = function (r) {
                io++,
                  io > uu &&
                    (r.getActor().send("enforceCacheSizeLimit", wl), (io = 0));
              }),
              (d.calculateGlobeLabelMatrix = function (r, i) {
                const { x: o, y: l } = r.point,
                  h = nm(o, l, r.worldSize / r._pixelsPerMercatorPixel, 0, 0);
                return Rc(h, h, Pp(Qo(i)));
              }),
              (d.calculateGlobeMatrix = function (r) {
                const { x: i, y: o } = r.point,
                  { lng: l, lat: h } = r._center;
                return nm(i, o, r.worldSize, l, h);
              }),
              (d.calculateGlobeMercatorMatrix = function (r) {
                const i = r.pixelsPerMeter,
                  o = i / Ao(1, r.center.lat),
                  l = sa(new Float64Array(16));
                return (
                  id(l, l, [r.point.x, r.point.y, 0]),
                  Oc(l, l, [o, o, i]),
                  Float32Array.from(l)
                );
              }),
              (d.circumferenceAtLatitude = om),
              (d.clamp = Qt),
              (d.clearTileCache = function (r) {
                if (!uc()) return;
                const i = Be.caches.delete(bl);
                r && i.catch(r).then(() => r());
              }),
              (d.clipLine = Gm),
              (d.clone = function (r) {
                var i = new Xn(16);
                return (
                  (i[0] = r[0]),
                  (i[1] = r[1]),
                  (i[2] = r[2]),
                  (i[3] = r[3]),
                  (i[4] = r[4]),
                  (i[5] = r[5]),
                  (i[6] = r[6]),
                  (i[7] = r[7]),
                  (i[8] = r[8]),
                  (i[9] = r[9]),
                  (i[10] = r[10]),
                  (i[11] = r[11]),
                  (i[12] = r[12]),
                  (i[13] = r[13]),
                  (i[14] = r[14]),
                  (i[15] = r[15]),
                  i
                );
              }),
              (d.clone$1 = jr),
              (d.collisionCircleLayout = L_),
              (d.config = zt),
              (d.conjugate = function (r, i) {
                return (
                  (r[0] = -i[0]),
                  (r[1] = -i[1]),
                  (r[2] = -i[2]),
                  (r[3] = i[3]),
                  r
                );
              }),
              (d.create = function () {
                var r = new Xn(16);
                return (
                  Xn != Float32Array &&
                    ((r[1] = 0),
                    (r[2] = 0),
                    (r[3] = 0),
                    (r[4] = 0),
                    (r[6] = 0),
                    (r[7] = 0),
                    (r[8] = 0),
                    (r[9] = 0),
                    (r[11] = 0),
                    (r[12] = 0),
                    (r[13] = 0),
                    (r[14] = 0)),
                  (r[0] = 1),
                  (r[5] = 1),
                  (r[10] = 1),
                  (r[15] = 1),
                  r
                );
              }),
              (d.create$1 = Ep),
              (d.createExpression = Ba),
              (d.createLayout = ge),
              (d.createStyleLayer = function (r) {
                return "custom" === r.type ? new sf(r) : new ng[r.type](r);
              }),
              (d.cross = Xf),
              (d.degToRad = Xt),
              (d.distance = function (r, i) {
                return Math.hypot(i[0] - r[0], i[1] - r[1], i[2] - r[2]);
              }),
              (d.div = function (r, i, o) {
                return (
                  (r[0] = i[0] / o[0]),
                  (r[1] = i[1] / o[1]),
                  (r[2] = i[2] / o[2]),
                  r
                );
              }),
              (d.dot = Co),
              (d.earthRadius = pd),
              (d.ease = ac),
              (d.easeCubicInOut = au),
              (d.ecefToLatLng = function ([r, i, o]) {
                const l = Math.hypot(r, i, o),
                  h = Math.atan2(r, o),
                  m = 0.5 * Math.PI - Math.acos(-i / l);
                return new Mn(Oi(h), Oi(m));
              }),
              (d.emitValidationErrors = Au),
              (d.endsWith = xl),
              (d.enforceCacheSizeLimit = function (r) {
                Pa(),
                  Cr &&
                    Cr.then((i) => {
                      i.keys().then((o) => {
                        for (let l = 0; l < o.length - r; l++) i.delete(o[l]);
                      });
                    });
              }),
              (d.evaluateSizeForFeature = jc),
              (d.evaluateSizeForZoom = eh),
              (d.evaluateVariableOffset = qm),
              (d.evented = v),
              (d.exactEquals = function (r, i) {
                return (
                  r[0] === i[0] &&
                  r[1] === i[1] &&
                  r[2] === i[2] &&
                  r[3] === i[3]
                );
              }),
              (d.exactEquals$1 = function (r, i) {
                return r[0] === i[0] && r[1] === i[1] && r[2] === i[2];
              }),
              (d.exported = cs),
              (d.exported$1 = Ot),
              (d.extend = ci),
              (d.extend$1 = Vo),
              (d.fillExtrusionHeightLift = Im),
              (d.filterObject = Ns),
              (d.fromMat4 = function (r, i) {
                return (
                  (r[0] = i[0]),
                  (r[1] = i[1]),
                  (r[2] = i[2]),
                  (r[3] = i[4]),
                  (r[4] = i[5]),
                  (r[5] = i[6]),
                  (r[6] = i[8]),
                  (r[7] = i[9]),
                  (r[8] = i[10]),
                  r
                );
              }),
              (d.fromQuat = function (r, i) {
                var o = i[0],
                  l = i[1],
                  h = i[2],
                  m = i[3],
                  _ = o + o,
                  x = l + l,
                  E = h + h,
                  T = o * _,
                  C = l * _,
                  A = l * x,
                  L = h * _,
                  O = h * x,
                  F = h * E,
                  V = m * _,
                  G = m * x,
                  K = m * E;
                return (
                  (r[0] = 1 - A - F),
                  (r[1] = C + K),
                  (r[2] = L - G),
                  (r[3] = 0),
                  (r[4] = C - K),
                  (r[5] = 1 - T - F),
                  (r[6] = O + V),
                  (r[7] = 0),
                  (r[8] = L + G),
                  (r[9] = O - V),
                  (r[10] = 1 - T - A),
                  (r[11] = 0),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[14] = 0),
                  (r[15] = 1),
                  r
                );
              }),
              (d.fromRotation = function (r, i) {
                var o = Math.sin(i),
                  l = Math.cos(i);
                return (
                  (r[0] = l),
                  (r[1] = o),
                  (r[2] = 0),
                  (r[3] = -o),
                  (r[4] = l),
                  (r[5] = 0),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 1),
                  r
                );
              }),
              (d.fromScaling = Vg),
              (d.furthestTileCorner = function (r) {
                const i = Math.round(((r + 45 + 360) % 360) / 90) % 4;
                return sc[i];
              }),
              (d.getAABBPointSquareDist = function (r, i, o) {
                let l = 0;
                for (let h = 0; h < 2; ++h) {
                  const m = o ? o[h] : 0;
                  r[h] > m && (l += (r[h] - m) * (r[h] - m)),
                    i[h] < m && (l += (m - i[h]) * (m - i[h]));
                }
                return l;
              }),
              (d.getAnchorAlignment = $_),
              (d.getAnchorJustification = Wm),
              (d.getBounds = function (r) {
                let i = 1 / 0,
                  o = 1 / 0,
                  l = -1 / 0,
                  h = -1 / 0;
                for (const m of r)
                  (i = Math.min(i, m.x)),
                    (o = Math.min(o, m.y)),
                    (l = Math.max(l, m.x)),
                    (h = Math.max(h, m.y));
                return { min: new et(i, o), max: new et(l, h) };
              }),
              (d.getColumn = as),
              (d.getDefaultExportFromCjs = Vr),
              (d.getGridMatrix = function (r, i, o, l) {
                const h = i.getNorth(),
                  m = i.getSouth(),
                  _ = i.getWest(),
                  x = i.getEast(),
                  E = 1 << r.z,
                  T = x - _,
                  C = h - m,
                  A = T / 64,
                  L = -C / $u[o],
                  O = [0, A, 0, L, 0, 0, h, _, 0];
                if (r.z > 0) {
                  const F = 180 / l;
                  kc(O, O, [
                    F / T + 1,
                    0,
                    0,
                    0,
                    F / C + 1,
                    0,
                    (-0.5 * F) / A,
                    (0.5 * F) / L,
                    1,
                  ]);
                }
                return (O[2] = E), (O[5] = r.x), (O[8] = r.y), O;
              }),
              (d.getImage = ne),
              (d.getJSON = function (r, i) {
                return La(ci(r, { type: "json" }), i);
              }),
              (d.getLatitudinalLod = function (r) {
                const i = Ti - 5;
                r = (Qt(r, -i, i) / i) * 90;
                const o = Math.pow(Math.abs(Math.sin(Xt(r))), 3);
                return Math.round(o * ($u.length - 1));
              }),
              (d.getMapSessionAPI = qn),
              (d.getPerformanceMeasurement = Ih),
              (d.getProjection = Lt),
              (d.getRTLTextPluginStatus = b),
              (d.getReferrer = js),
              (d.getTilePoint = function (r, { x: i, y: o }, l = 0) {
                return new et(
                  ((i - l) * r.scale - r.x) * vt,
                  (o * r.scale - r.y) * vt
                );
              }),
              (d.getTileVec3 = function (r, i, o = 0) {
                return Ka(
                  ((i.x - o) * r.scale - r.x) * vt,
                  (i.y * r.scale - r.y) * vt,
                  Er(i.z, i.y)
                );
              }),
              (d.getVideo = function (r, i) {
                const o = Be.document.createElement("video");
                (o.muted = !0),
                  (o.onloadstart = function () {
                    i(null, o);
                  });
                for (let l = 0; l < r.length; l++) {
                  const h = Be.document.createElement("source");
                  hu(r[l]) || (o.crossOrigin = "Anonymous"),
                    (h.src = r[l]),
                    o.appendChild(h);
                }
                return { cancel: () => {} };
              }),
              (d.globeCenterToScreenPoint = function (r) {
                const i = [0, 0, 0],
                  o = sa(new Float64Array(16));
                return (
                  Rc(o, r.pixelMatrix, r.globeMatrix),
                  Kn(i, i, o),
                  new et(i[0], i[1])
                );
              }),
              (d.globeDenormalizeECEF = Pp),
              (d.globeECEFOrigin = function (r, i) {
                const o = [0, 0, 0];
                return Kn(o, o, Gu(Qo(i.canonical))), Kn(o, o, r), o;
              }),
              (d.globeMetersToEcef = ld),
              (d.globeNormalizeECEF = Gu),
              (d.globePixelsToTileUnits = function (r, i) {
                return (vt / (512 * Math.pow(2, r))) * dd(Qo(i));
              }),
              (d.globePoleMatrixForTile = function (r, i, o) {
                const l = sa(new Float64Array(16)),
                  h = (i / (1 << r) - 0.5) * Math.PI * 2;
                return Dp(l, o.globeMatrix, h), Float32Array.from(l);
              }),
              (d.globeTileBounds = Qo),
              (d.globeTiltAtLngLat = Kg),
              (d.globeToMercatorTransition = Yi),
              (d.globeUseCustomAntiAliasing = function (r, i, o) {
                const l = Yi(o.zoom),
                  h = r.style.map._antialias,
                  m = !!i.extStandardDerivatives,
                  _ =
                    i.extStandardDerivativesForceOff ||
                    (r.terrain && r.terrain.exaggeration() > 0);
                return 0 === l && !h && !_ && m;
              }),
              (d.identity = sa),
              (d.identity$1 = Qf),
              (d.invert = Tp),
              (d.isFullscreen = function () {
                return (
                  !!Be.document.fullscreenElement ||
                  !!Be.document.webkitFullscreenElement
                );
              }),
              (d.isLngLatBehindGlobe = im),
              (d.isMapAuthenticated = function (r) {
                return fr.has(r);
              }),
              (d.isMapboxURL = me),
              (d.isSafariWithAntialiasingBug = function (r) {
                const i = r.navigator ? r.navigator.userAgent : null;
                return (
                  !!lc(r) &&
                  i &&
                  (i.match("Version/15.4") ||
                    i.match("Version/15.5") ||
                    i.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
                );
              }),
              (d.latFromMercatorY = $i),
              (d.latLngToECEF = ud),
              (d.len = Kf),
              (d.length = Fc),
              (d.length$1 = function (r) {
                return Math.hypot(r[0], r[1], r[2], r[3]);
              }),
              (d.lngFromMercatorX = so),
              (d.loadVectorTile = T0),
              (d.makeRequest = La),
              (d.mapValue = function (r, i, o, l, h) {
                return Qt(((r - i) / (o - i)) * (h - l) + l, l, h);
              }),
              (d.mercatorScale = sm),
              (d.mercatorXfromLng = ua),
              (d.mercatorYfromLat = ii),
              (d.mercatorZfromAltitude = Ao),
              (d.mul = Ip),
              (d.mul$1 = yv),
              (d.multiply = Rc),
              (d.multiply$1 = kc),
              (d.multiply$2 = Ug),
              (d.nextPowerOfTwo = ss),
              (d.normalize = St),
              (d.normalize$1 = Hg),
              (d.normalize$2 = Yf),
              (d.number = rn),
              (d.ortho = function (r, i, o, l, h, m, _) {
                var x = 1 / (i - o),
                  E = 1 / (l - h),
                  T = 1 / (m - _);
                return (
                  (r[0] = -2 * x),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = -2 * E),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[10] = 2 * T),
                  (r[11] = 0),
                  (r[12] = (i + o) * x),
                  (r[13] = (h + l) * E),
                  (r[14] = (_ + m) * T),
                  (r[15] = 1),
                  r
                );
              }),
              (d.pbf = R_),
              (d.perspective = function (r, i, o, l, h) {
                var m,
                  _ = 1 / Math.tan(i / 2);
                return (
                  (r[0] = _ / o),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = _),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[11] = -1),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[15] = 0),
                  null != h && h !== 1 / 0
                    ? ((r[10] = (h + l) * (m = 1 / (l - h))),
                      (r[14] = 2 * h * l * m))
                    : ((r[10] = -1), (r[14] = -2 * l)),
                  r
                );
              }),
              (d.pick = function (r, i) {
                const o = {};
                for (let l = 0; l < i.length; l++) {
                  const h = i[l];
                  h in r && (o[h] = r[h]);
                }
                return o;
              }),
              (d.plugin = I),
              (d.pointGeometry = is),
              (d.polesInViewport = function (r) {
                const i = sa(new Float64Array(16));
                Rc(i, r.pixelMatrix, r.globeMatrix);
                const o = [0, Yo, 0],
                  l = [0, Mo, 0];
                return (
                  Kn(o, o, i),
                  Kn(l, l, i),
                  [
                    o[0] > 0 &&
                      o[0] <= r.width &&
                      o[1] > 0 &&
                      o[1] <= r.height &&
                      !im(r, new Mn(r.center.lat, 90)),
                    l[0] > 0 &&
                      l[0] <= r.width &&
                      l[1] > 0 &&
                      l[1] <= r.height &&
                      !im(r, new Mn(r.center.lat, -90)),
                  ]
                );
              }),
              (d.polygonContainsPoint = nl),
              (d.polygonIntersectsBox = pm),
              (d.polygonIntersectsPolygon = t_),
              (d.polygonizeBounds = function (r, i, o = 0, l = !0) {
                const h = new et(o, o),
                  m = r.sub(h),
                  _ = i.add(h),
                  x = [m, new et(_.x, m.y), _, new et(m.x, _.y)];
                return l && x.push(m.clone()), x;
              }),
              (d.posAttributes = Ja),
              (d.postMapLoadEvent = ui),
              (d.postPerformanceEvent = wi),
              (d.postTurnstileEvent = tn),
              (d.potpack = Rd),
              (d.prevPowerOfTwo = function (r) {
                return r <= 1
                  ? 1
                  : Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
              }),
              (d.radToDeg = Oi),
              (d.refProperties = [
                "type",
                "source",
                "source-layer",
                "minzoom",
                "maxzoom",
                "filter",
                "layout",
              ]),
              (d.registerForPluginStateChange = function (r) {
                return (
                  r({ pluginStatus: f, pluginURL: a }),
                  v.on("pluginStateChange", r),
                  r
                );
              }),
              (d.removeAuthState = function (r) {
                fr.delete(r);
              }),
              (d.renderColorRamp = gm),
              (d.resample = lm),
              (d.rotateX = Wf),
              (d.rotateX$1 = Uu),
              (d.rotateY = Dp),
              (d.rotateY$1 = ad),
              (d.rotateZ = function (r, i, o) {
                var l = Math.sin(o),
                  h = Math.cos(o),
                  m = i[0],
                  _ = i[1],
                  x = i[2],
                  E = i[3],
                  T = i[4],
                  C = i[5],
                  A = i[6],
                  L = i[7];
                return (
                  i !== r &&
                    ((r[8] = i[8]),
                    (r[9] = i[9]),
                    (r[10] = i[10]),
                    (r[11] = i[11]),
                    (r[12] = i[12]),
                    (r[13] = i[13]),
                    (r[14] = i[14]),
                    (r[15] = i[15])),
                  (r[0] = m * h + T * l),
                  (r[1] = _ * h + C * l),
                  (r[2] = x * h + A * l),
                  (r[3] = E * h + L * l),
                  (r[4] = T * h - m * l),
                  (r[5] = C * h - _ * l),
                  (r[6] = A * h - x * l),
                  (r[7] = L * h - E * l),
                  r
                );
              }),
              (d.rotateZ$1 = function (r, i, o) {
                o *= 0.5;
                var l = i[0],
                  h = i[1],
                  m = i[2],
                  _ = i[3],
                  x = Math.sin(o),
                  E = Math.cos(o);
                return (
                  (r[0] = l * E + h * x),
                  (r[1] = h * E - l * x),
                  (r[2] = m * E + _ * x),
                  (r[3] = _ * E - m * x),
                  r
                );
              }),
              (d.scale = Oc),
              (d.scale$1 = sd),
              (d.scale$2 = lr),
              (d.scaleAndAdd = rd),
              (d.set = function (r, i, o, l) {
                return (r[0] = i), (r[1] = o), (r[2] = l), r;
              }),
              (d.setCacheLimits = function (r, i) {
                (wl = r), (uu = i);
              }),
              (d.setColumn = function (r, i, o) {
                (r[4 * i + 0] = o[0]),
                  (r[4 * i + 1] = o[1]),
                  (r[4 * i + 2] = o[2]),
                  (r[4 * i + 3] = o[3]);
              }),
              (d.setRTLTextPlugin = function (r, i, o = !1) {
                if (f === Mc || f === Ru || f === Ou)
                  throw new Error(
                    "setRTLTextPlugin cannot be called multiple times."
                  );
                (a = cs.resolveURL(r)), (f = Mc), (qa = i), g(), o || D();
              }),
              (d.smoothstep = Ma),
              (d.spec = Ae),
              (d.squaredLength = function (r) {
                var i = r[0],
                  o = r[1],
                  l = r[2];
                return i * i + o * o + l * l;
              }),
              (d.storeAuthState = function (r, i) {
                i ? fr.add(r) : fr.delete(r);
              }),
              (d.sub = _s),
              (d.subtract = Zf),
              (d.symbolSize = Rm),
              (d.tileAABB = function (r, i, o, l, h, m, _, x, E) {
                if ("globe" === E.name)
                  return (function xb(r, i, o) {
                    const l = i / r.worldSize,
                      h = r.globeMatrix;
                    if (o.z <= 1) {
                      const xe = Qo(o).getCorners();
                      return Mp(xe, h, l), Fr.fromPoints(xe);
                    }
                    const m = tm(o),
                      _ = Xg(m);
                    Mp(_, h, l);
                    const x = Number.MAX_VALUE,
                      E = [-x, -x, -x],
                      T = [x, x, x];
                    if (m.contains(r.center)) {
                      for (const $e of _) Vu(T, T, $e), Qa(E, E, $e);
                      E[2] = 0;
                      const xe = r.point,
                        Pe = [xe.x * l, xe.y * l, 0];
                      return Vu(T, T, Pe), Qa(E, E, Pe), new Fr(T, E);
                    }
                    const C = [h[12] * l, h[13] * l, h[14] * l],
                      A = m.getCenter(),
                      L = Qt(r.center.lat, -Ti, Ti),
                      O = Qt(A.lat, -Ti, Ti),
                      F = ua(r.center.lng),
                      V = ii(L);
                    let G = F - ua(A.lng);
                    const K = V - ii(O);
                    G > 0.5 ? (G -= 1) : G < -0.5 && (G += 1);
                    let oe = 0;
                    Math.abs(G) > Math.abs(K)
                      ? (oe = G >= 0 ? 1 : 3)
                      : ((oe = K >= 0 ? 0 : 2),
                        rd(
                          C,
                          C,
                          [h[4] * l, h[5] * l, h[6] * l],
                          -Math.sin(Xt(K >= 0 ? m.getSouth() : m.getNorth())) *
                            la
                        ));
                    const J = _[oe],
                      re = _[(oe + 1) % 4],
                      le = new wv(J, re, C),
                      ae = [
                        em(le, 0) || J[0],
                        em(le, 1) || J[1],
                        em(le, 2) || J[2],
                      ],
                      De = Yi(r.zoom);
                    if (De > 0) {
                      const xe = (function (
                        { x: $e, y: Ce, z: Fe },
                        Re,
                        Ve,
                        qe,
                        Me
                      ) {
                        const Je = 1 / (1 << Fe);
                        let ut = $e * Je,
                          nt = ut + Je,
                          Mt = Ce * Je,
                          Ke = Mt + Je,
                          yt = 0;
                        const Ct = (ut + nt) / 2 - qe;
                        return (
                          Ct > 0.5 ? (yt = -1) : Ct < -0.5 && (yt = 1),
                          (ut = ((ut + yt) * Re - (qe *= Re)) * Ve + qe),
                          (nt = ((nt + yt) * Re - qe) * Ve + qe),
                          (Mt = (Mt * Re - (Me *= Re)) * Ve + Me),
                          (Ke = (Ke * Re - Me) * Ve + Me),
                          [
                            [ut, Ke, 0],
                            [nt, Ke, 0],
                            [nt, Mt, 0],
                            [ut, Mt, 0],
                          ]
                        );
                      })(o, i, r._pixelsPerMercatorPixel, F, V);
                      for (let $e = 0; $e < _.length; $e++)
                        Hu(_[$e], xe[$e], De);
                      const Pe = Ya([], xe[oe], xe[(oe + 1) % 4]);
                      lr(Pe, Pe, 0.5), Hu(ae, Pe, De);
                    }
                    for (const xe of _) Vu(T, T, xe), Qa(E, E, xe);
                    return (
                      (T[2] = Math.min(J[2], re[2])),
                      Vu(T, T, ae),
                      Qa(E, E, ae),
                      new Fr(T, E)
                    );
                  })(r, i, new _i(o, l, h));
                const T = qc({ z: o, x: l, y: h }, E);
                return new Fr(
                  [(m + T.x / T.scale) * i, i * (T.y / T.scale), _],
                  [(m + T.x2 / T.scale) * i, i * (T.y2 / T.scale), x]
                );
              }),
              (d.tileCornersToBounds = tm),
              (d.tileTransform = qc),
              (d.transformMat3 = function (r, i, o) {
                var l = i[0],
                  h = i[1],
                  m = i[2];
                return (
                  (r[0] = l * o[0] + h * o[3] + m * o[6]),
                  (r[1] = l * o[1] + h * o[4] + m * o[7]),
                  (r[2] = l * o[2] + h * o[5] + m * o[8]),
                  r
                );
              }),
              (d.transformMat4 = Kn),
              (d.transformMat4$1 = aa),
              (d.transformQuat = ju),
              (d.transitionTileAABBinECEF = Ev),
              (d.translate = id),
              (d.transpose = function (r, i) {
                if (r === i) {
                  var o = i[1],
                    l = i[2],
                    h = i[5];
                  (r[1] = i[3]),
                    (r[2] = i[6]),
                    (r[3] = o),
                    (r[5] = i[7]),
                    (r[6] = l),
                    (r[7] = h);
                } else
                  (r[0] = i[0]),
                    (r[1] = i[3]),
                    (r[2] = i[6]),
                    (r[3] = i[1]),
                    (r[4] = i[4]),
                    (r[5] = i[7]),
                    (r[6] = i[2]),
                    (r[7] = i[5]),
                    (r[8] = i[8]);
                return r;
              }),
              (d.triggerPluginCompletionEvent = u),
              (d.uniqueId = rs),
              (d.updateGlobeVertexNormal = function (r, i, o, l, h) {
                const m = 5 * i + 2;
                (r.float32[m + 0] = o),
                  (r.float32[m + 1] = l),
                  (r.float32[m + 2] = h);
              }),
              (d.validateCustomStyleLayer = function (r) {
                const i = [],
                  o = r.id;
                return (
                  void 0 === o &&
                    i.push({
                      message: `layers.${o}: missing required property "id"`,
                    }),
                  void 0 === r.render &&
                    i.push({
                      message: `layers.${o}: missing required method "render"`,
                    }),
                  r.renderingMode &&
                    "2d" !== r.renderingMode &&
                    "3d" !== r.renderingMode &&
                    i.push({
                      message: `layers.${o}: property "renderingMode" must be either "2d" or "3d"`,
                    }),
                  i
                );
              }),
              (d.validateFilter = (r) => kr(zl(r))),
              (d.validateFog = (r) => kr(dn(r))),
              (d.validateLayer = (r) => kr(gp(r))),
              (d.validateLight = (r) => kr(yp(r))),
              (d.validateSource = (r) => kr(Kh(r))),
              (d.validateStyle = Yh),
              (d.validateTerrain = (r) => kr(Ze(r))),
              (d.values = Rs),
              (d.vectorTile = Dm),
              (d.version = Oo),
              (d.warnOnce = Hn),
              (d.window = Be),
              (d.wrap = bn);
          }),
          rp(0, function (d) {
            function Be(se) {
              if (
                "number" == typeof se ||
                "boolean" == typeof se ||
                "string" == typeof se ||
                null == se
              )
                return JSON.stringify(se);
              if (Array.isArray(se)) {
                let $ = "[";
                for (const ne of se) $ += `${Be(ne)},`;
                return `${$}]`;
              }
              let U = "{";
              for (const $ of Object.keys(se).sort()) U += `${$}:${Be(se[$])},`;
              return `${U}}`;
            }
            function Oo(se) {
              let U = "";
              for (const $ of d.refProperties) U += `/${Be(se[$])}`;
              return U;
            }
            class Jr {
              constructor(U) {
                (this.keyCache = {}), U && this.replace(U);
              }
              replace(U) {
                (this._layerConfigs = {}),
                  (this._layers = {}),
                  this.update(U, []);
              }
              update(U, $) {
                for (const ce of U)
                  (this._layerConfigs[ce.id] = ce),
                    (this._layers[ce.id] =
                      d.createStyleLayer(ce)).compileFilter(),
                    this.keyCache[ce.id] && delete this.keyCache[ce.id];
                for (const ce of $)
                  delete this.keyCache[ce],
                    delete this._layerConfigs[ce],
                    delete this._layers[ce];
                this.familiesBySource = {};
                const ne = (function (ce, me) {
                  const ve = {};
                  for (let fe = 0; fe < ce.length; fe++) {
                    const Se = (me && me[ce[fe].id]) || Oo(ce[fe]);
                    me && (me[ce[fe].id] = Se);
                    let Ye = ve[Se];
                    Ye || (Ye = ve[Se] = []), Ye.push(ce[fe]);
                  }
                  const ye = [];
                  for (const fe in ve) ye.push(ve[fe]);
                  return ye;
                })(d.values(this._layerConfigs), this.keyCache);
                for (const ce of ne) {
                  const me = ce.map((Qe) => this._layers[Qe.id]),
                    ve = me[0];
                  if ("none" === ve.visibility) continue;
                  const ye = ve.source || "";
                  let fe = this.familiesBySource[ye];
                  fe || (fe = this.familiesBySource[ye] = {});
                  const Se = ve.sourceLayer || "_geojsonTileLayer";
                  let Ye = fe[Se];
                  Ye || (Ye = fe[Se] = []), Ye.push(me);
                }
              }
            }
            class zt {
              loadTile(U, $) {
                const {
                    uid: ne,
                    encoding: ce,
                    rawImageData: me,
                    padding: ve,
                    buildQuadTree: ye,
                  } = U,
                  fe =
                    d.window.ImageBitmap && me instanceof d.window.ImageBitmap
                      ? this.getImageData(me, ve)
                      : me;
                $(null, new d.DEMData(ne, fe, ce, ve < 1, ye));
              }
              getImageData(U, $) {
                (this.offscreenCanvas && this.offscreenCanvasContext) ||
                  ((this.offscreenCanvas = new OffscreenCanvas(
                    U.width,
                    U.height
                  )),
                  (this.offscreenCanvasContext =
                    this.offscreenCanvas.getContext("2d", {
                      willReadFrequently: !0,
                    }))),
                  (this.offscreenCanvas.width = U.width),
                  (this.offscreenCanvas.height = U.height),
                  this.offscreenCanvasContext.drawImage(
                    U,
                    0,
                    0,
                    U.width,
                    U.height
                  );
                const ne = this.offscreenCanvasContext.getImageData(
                  -$,
                  -$,
                  U.width + 2 * $,
                  U.height + 2 * $
                );
                return (
                  this.offscreenCanvasContext.clearRect(
                    0,
                    0,
                    this.offscreenCanvas.width,
                    this.offscreenCanvas.height
                  ),
                  ne
                );
              }
            }
            function Ot(se, U) {
              if (0 !== se.length) {
                Ii(se[0], U);
                for (var $ = 1; $ < se.length; $++) Ii(se[$], !U);
              }
            }
            function Ii(se, U) {
              for (
                var $ = 0, ne = 0, ce = 0, me = se.length, ve = me - 1;
                ce < me;
                ve = ce++
              ) {
                var ye = (se[ce][0] - se[ve][0]) * (se[ve][1] + se[ce][1]),
                  fe = $ + ye;
                (ne += Math.abs($) >= Math.abs(ye) ? $ - fe + ye : ye - fe + $),
                  ($ = fe);
              }
              $ + ne >= 0 != !!U && se.reverse();
            }
            var pr = d.getDefaultExportFromCjs(function se(U, $) {
              var ne,
                ce = U && U.type;
              if ("FeatureCollection" === ce)
                for (ne = 0; ne < U.features.length; ne++)
                  se(U.features[ne], $);
              else if ("GeometryCollection" === ce)
                for (ne = 0; ne < U.geometries.length; ne++)
                  se(U.geometries[ne], $);
              else if ("Feature" === ce) se(U.geometry, $);
              else if ("Polygon" === ce) Ot(U.coordinates, $);
              else if ("MultiPolygon" === ce)
                for (ne = 0; ne < U.coordinates.length; ne++)
                  Ot(U.coordinates[ne], $);
              return U;
            });
            const Fo = d.VectorTileFeature.prototype.toGeoJSON;
            var ns = { exports: {} },
              oc = d.pointGeometry,
              vl = d.vectorTile.VectorTileFeature,
              Vr = eo;
            function eo(se, U) {
              (this.options = U || {}),
                (this.features = se),
                (this.length = se.length);
            }
            function Ir(se, U) {
              (this.id = "number" == typeof se.id ? se.id : void 0),
                (this.type = se.type),
                (this.rawGeometry =
                  1 === se.type ? [se.geometry] : se.geometry),
                (this.properties = se.tags),
                (this.extent = U || 4096);
            }
            (eo.prototype.feature = function (se) {
              return new Ir(this.features[se], this.options.extent);
            }),
              (Ir.prototype.loadGeometry = function () {
                var se = this.rawGeometry;
                this.geometry = [];
                for (var U = 0; U < se.length; U++) {
                  for (var $ = se[U], ne = [], ce = 0; ce < $.length; ce++)
                    ne.push(new oc($[ce][0], $[ce][1]));
                  this.geometry.push(ne);
                }
                return this.geometry;
              }),
              (Ir.prototype.bbox = function () {
                this.geometry || this.loadGeometry();
                for (
                  var se = this.geometry,
                    U = 1 / 0,
                    $ = -1 / 0,
                    ne = 1 / 0,
                    ce = -1 / 0,
                    me = 0;
                  me < se.length;
                  me++
                )
                  for (var ve = se[me], ye = 0; ye < ve.length; ye++) {
                    var fe = ve[ye];
                    (U = Math.min(U, fe.x)),
                      ($ = Math.max($, fe.x)),
                      (ne = Math.min(ne, fe.y)),
                      (ce = Math.max(ce, fe.y));
                  }
                return [U, ne, $, ce];
              }),
              (Ir.prototype.toGeoJSON = vl.prototype.toGeoJSON);
            var Sa = d.pbf,
              is = Vr;
            function mo(se) {
              var U = new Sa();
              return (
                (function ($, ne) {
                  for (var ce in $.layers) ne.writeMessage(3, et, $.layers[ce]);
                })(se, U),
                U.finish()
              );
            }
            function et(se, U) {
              var $;
              U.writeVarintField(15, se.version || 1),
                U.writeStringField(1, se.name || ""),
                U.writeVarintField(5, se.extent || 4096);
              var ne = { keys: [], values: [], keycache: {}, valuecache: {} };
              for ($ = 0; $ < se.length; $++)
                (ne.feature = se.feature($)), U.writeMessage(2, Dh, ne);
              var ce = ne.keys;
              for ($ = 0; $ < ce.length; $++) U.writeStringField(3, ce[$]);
              var me = ne.values;
              for ($ = 0; $ < me.length; $++) U.writeMessage(4, au, me[$]);
            }
            function Dh(se, U) {
              var $ = se.feature;
              void 0 !== $.id && U.writeVarintField(1, $.id),
                U.writeMessage(2, Ia, se),
                U.writeVarintField(3, $.type),
                U.writeMessage(4, sc, $);
            }
            function Ia(se, U) {
              var $ = se.feature,
                ne = se.keys,
                ce = se.values,
                me = se.keycache,
                ve = se.valuecache;
              for (var ye in $.properties) {
                var fe = $.properties[ye],
                  Se = me[ye];
                if (null !== fe) {
                  void 0 === Se && (ne.push(ye), (me[ye] = Se = ne.length - 1)),
                    U.writeVarint(Se);
                  var Ye = typeof fe;
                  "string" !== Ye &&
                    "boolean" !== Ye &&
                    "number" !== Ye &&
                    (fe = JSON.stringify(fe));
                  var Qe = Ye + ":" + fe,
                    We = ve[Qe];
                  void 0 === We && (ce.push(fe), (ve[Qe] = We = ce.length - 1)),
                    U.writeVarint(We);
                }
              }
            }
            function Xt(se, U) {
              return (U << 3) + (7 & se);
            }
            function Oi(se) {
              return (se << 1) ^ (se >> 31);
            }
            function sc(se, U) {
              for (
                var $ = se.loadGeometry(),
                  ne = se.type,
                  ce = 0,
                  me = 0,
                  ve = $.length,
                  ye = 0;
                ye < ve;
                ye++
              ) {
                var fe = $[ye],
                  Se = 1;
                1 === ne && (Se = fe.length), U.writeVarint(Xt(1, Se));
                for (
                  var Ye = 3 === ne ? fe.length - 1 : fe.length, Qe = 0;
                  Qe < Ye;
                  Qe++
                ) {
                  1 === Qe && 1 !== ne && U.writeVarint(Xt(2, Ye - 1));
                  var We = fe[Qe].x - ce,
                    Pt = fe[Qe].y - me;
                  U.writeVarint(Oi(We)),
                    U.writeVarint(Oi(Pt)),
                    (ce += We),
                    (me += Pt);
                }
                3 === ne && U.writeVarint(Xt(7, 1));
              }
            }
            function au(se, U) {
              var $ = typeof se;
              "string" === $
                ? U.writeStringField(1, se)
                : "boolean" === $
                ? U.writeBooleanField(7, se)
                : "number" === $ &&
                  (se % 1 != 0
                    ? U.writeDoubleField(3, se)
                    : se < 0
                    ? U.writeSVarintField(6, se)
                    : U.writeVarintField(5, se));
            }
            (ns.exports = mo),
              (ns.exports.fromVectorTileJs = mo),
              (ns.exports.fromGeojsonVt = function (se, U) {
                U = U || {};
                var $ = {};
                for (var ne in se)
                  ($[ne] = new is(se[ne].features, U)),
                    ($[ne].name = ne),
                    ($[ne].version = U.version),
                    ($[ne].extent = U.extent);
                return mo({ layers: $ });
              }),
              (ns.exports.GeoJSONWrapper = is);
            var Ca = d.getDefaultExportFromCjs(ns.exports);
            const ac = {
                minZoom: 0,
                maxZoom: 16,
                minPoints: 2,
                radius: 40,
                extent: 512,
                nodeSize: 64,
                log: !1,
                generateId: !1,
                reduce: null,
                map: (se) => se,
              },
              Qt =
                Math.fround ||
                ((Ma = new Float32Array(1)), (se) => ((Ma[0] = +se), Ma[0]));
            var Ma;
            class ci {
              constructor(U) {
                (this.options = Object.assign(Object.create(ac), U)),
                  (this.trees = new Array(this.options.maxZoom + 1)),
                  (this.stride = this.options.reduce ? 7 : 6),
                  (this.clusterProps = []);
              }
              load(U) {
                const { log: $, minZoom: ne, maxZoom: ce } = this.options;
                $ && console.time("total time");
                const me = `prepare ${U.length} points`;
                $ && console.time(me), (this.points = U);
                const ve = [];
                for (let fe = 0; fe < U.length; fe++) {
                  const Se = U[fe];
                  if (!Se.geometry) continue;
                  const [Ye, Qe] = Se.geometry.coordinates,
                    We = Qt(os(Ye)),
                    Pt = Qt(ss(Qe));
                  ve.push(We, Pt, 1 / 0, fe, -1, 1),
                    this.options.reduce && ve.push(0);
                }
                let ye = (this.trees[ce + 1] = this._createTree(ve));
                $ && console.timeEnd(me);
                for (let fe = ce; fe >= ne; fe--) {
                  const Se = +Date.now();
                  (ye = this.trees[fe] =
                    this._createTree(this._cluster(ye, fe))),
                    $ &&
                      console.log(
                        "z%d: %d clusters in %dms",
                        fe,
                        ye.numItems,
                        +Date.now() - Se
                      );
                }
                return $ && console.timeEnd("total time"), this;
              }
              getClusters(U, $) {
                let ne = ((((U[0] + 180) % 360) + 360) % 360) - 180;
                const ce = Math.max(-90, Math.min(90, U[1]));
                let me =
                  180 === U[2]
                    ? 180
                    : ((((U[2] + 180) % 360) + 360) % 360) - 180;
                const ve = Math.max(-90, Math.min(90, U[3]));
                if (U[2] - U[0] >= 360) (ne = -180), (me = 180);
                else if (ne > me) {
                  const Qe = this.getClusters([ne, ce, 180, ve], $),
                    We = this.getClusters([-180, ce, me, ve], $);
                  return Qe.concat(We);
                }
                const ye = this.trees[this._limitZoom($)],
                  fe = ye.range(os(ne), ss(ve), os(me), ss(ce)),
                  Se = ye.data,
                  Ye = [];
                for (const Qe of fe) {
                  const We = this.stride * Qe;
                  Ye.push(
                    Se[We + 5] > 1
                      ? Os(Se, We, this.clusterProps)
                      : this.points[Se[We + 3]]
                  );
                }
                return Ye;
              }
              getChildren(U) {
                const $ = this._getOriginId(U),
                  ne = this._getOriginZoom(U),
                  ce = "No cluster with the specified id.",
                  me = this.trees[ne];
                if (!me) throw new Error(ce);
                const ve = me.data;
                if ($ * this.stride >= ve.length) throw new Error(ce);
                const ye =
                    this.options.radius /
                    (this.options.extent * Math.pow(2, ne - 1)),
                  fe = me.within(
                    ve[$ * this.stride],
                    ve[$ * this.stride + 1],
                    ye
                  ),
                  Se = [];
                for (const Ye of fe) {
                  const Qe = Ye * this.stride;
                  ve[Qe + 4] === U &&
                    Se.push(
                      ve[Qe + 5] > 1
                        ? Os(ve, Qe, this.clusterProps)
                        : this.points[ve[Qe + 3]]
                    );
                }
                if (0 === Se.length) throw new Error(ce);
                return Se;
              }
              getLeaves(U, $, ne) {
                const ce = [];
                return (
                  this._appendLeaves(ce, U, ($ = $ || 10), (ne = ne || 0), 0),
                  ce
                );
              }
              getTile(U, $, ne) {
                const ce = this.trees[this._limitZoom(U)],
                  me = Math.pow(2, U),
                  { extent: ve, radius: ye } = this.options,
                  fe = ye / ve,
                  Se = (ne - fe) / me,
                  Ye = (ne + 1 + fe) / me,
                  Qe = { features: [] };
                return (
                  this._addTileFeatures(
                    ce.range(($ - fe) / me, Se, ($ + 1 + fe) / me, Ye),
                    ce.data,
                    $,
                    ne,
                    me,
                    Qe
                  ),
                  0 === $ &&
                    this._addTileFeatures(
                      ce.range(1 - fe / me, Se, 1, Ye),
                      ce.data,
                      me,
                      ne,
                      me,
                      Qe
                    ),
                  $ === me - 1 &&
                    this._addTileFeatures(
                      ce.range(0, Se, fe / me, Ye),
                      ce.data,
                      -1,
                      ne,
                      me,
                      Qe
                    ),
                  Qe.features.length ? Qe : null
                );
              }
              getClusterExpansionZoom(U) {
                let $ = this._getOriginZoom(U) - 1;
                for (; $ <= this.options.maxZoom; ) {
                  const ne = this.getChildren(U);
                  if (($++, 1 !== ne.length)) break;
                  U = ne[0].properties.cluster_id;
                }
                return $;
              }
              _appendLeaves(U, $, ne, ce, me) {
                const ve = this.getChildren($);
                for (const ye of ve) {
                  const fe = ye.properties;
                  if (
                    (fe && fe.cluster
                      ? me + fe.point_count <= ce
                        ? (me += fe.point_count)
                        : (me = this._appendLeaves(
                            U,
                            fe.cluster_id,
                            ne,
                            ce,
                            me
                          ))
                      : me < ce
                      ? me++
                      : U.push(ye),
                    U.length === ne)
                  )
                    break;
                }
                return me;
              }
              _createTree(U) {
                const $ = new d.KDBush(
                  (U.length / this.stride) | 0,
                  this.options.nodeSize,
                  Float32Array
                );
                for (let ne = 0; ne < U.length; ne += this.stride)
                  $.add(U[ne], U[ne + 1]);
                return $.finish(), ($.data = U), $;
              }
              _addTileFeatures(U, $, ne, ce, me, ve) {
                for (const ye of U) {
                  const fe = ye * this.stride,
                    Se = $[fe + 5] > 1;
                  let Ye, Qe, We;
                  if (Se)
                    (Ye = rs($, fe, this.clusterProps)),
                      (Qe = $[fe]),
                      (We = $[fe + 1]);
                  else {
                    const Et = this.points[$[fe + 3]];
                    Ye = Et.properties;
                    const [Gt, tn] = Et.geometry.coordinates;
                    (Qe = os(Gt)), (We = ss(tn));
                  }
                  const Pt = {
                    type: 1,
                    geometry: [
                      [
                        Math.round(this.options.extent * (Qe * me - ne)),
                        Math.round(this.options.extent * (We * me - ce)),
                      ],
                    ],
                    tags: Ye,
                  };
                  let Bt;
                  (Bt =
                    Se || this.options.generateId
                      ? $[fe + 3]
                      : this.points[$[fe + 3]].id),
                    void 0 !== Bt && (Pt.id = Bt),
                    ve.features.push(Pt);
                }
              }
              _limitZoom(U) {
                return Math.max(
                  this.options.minZoom,
                  Math.min(Math.floor(+U), this.options.maxZoom + 1)
                );
              }
              _cluster(U, $) {
                const {
                    radius: ne,
                    extent: ce,
                    reduce: me,
                    minPoints: ve,
                  } = this.options,
                  ye = ne / (ce * Math.pow(2, $)),
                  fe = U.data,
                  Se = [],
                  Ye = this.stride;
                for (let Qe = 0; Qe < fe.length; Qe += Ye) {
                  if (fe[Qe + 2] <= $) continue;
                  fe[Qe + 2] = $;
                  const We = fe[Qe],
                    Pt = fe[Qe + 1],
                    Bt = U.within(fe[Qe], fe[Qe + 1], ye),
                    Et = fe[Qe + 5];
                  let Gt = Et;
                  for (const tn of Bt) {
                    const Gn = tn * Ye;
                    fe[Gn + 2] > $ && (Gt += fe[Gn + 5]);
                  }
                  if (Gt > Et && Gt >= ve) {
                    let tn,
                      Gn = We * Et,
                      ui = Pt * Et,
                      Xi = -1;
                    const wi =
                      (((Qe / Ye) | 0) << 5) + ($ + 1) + this.points.length;
                    for (const zo of Bt) {
                      const qn = zo * Ye;
                      if (fe[qn + 2] <= $) continue;
                      fe[qn + 2] = $;
                      const fr = fe[qn + 5];
                      (Gn += fe[qn] * fr),
                        (ui += fe[qn + 1] * fr),
                        (fe[qn + 4] = wi),
                        me &&
                          (tn ||
                            ((tn = this._map(fe, Qe, !0)),
                            (Xi = this.clusterProps.length),
                            this.clusterProps.push(tn)),
                          me(tn, this._map(fe, qn)));
                    }
                    (fe[Qe + 4] = wi),
                      Se.push(Gn / Gt, ui / Gt, 1 / 0, wi, -1, Gt),
                      me && Se.push(Xi);
                  } else {
                    for (let tn = 0; tn < Ye; tn++) Se.push(fe[Qe + tn]);
                    if (Gt > 1)
                      for (const tn of Bt) {
                        const Gn = tn * Ye;
                        if (!(fe[Gn + 2] <= $)) {
                          fe[Gn + 2] = $;
                          for (let ui = 0; ui < Ye; ui++) Se.push(fe[Gn + ui]);
                        }
                      }
                  }
                }
                return Se;
              }
              _getOriginId(U) {
                return (U - this.points.length) >> 5;
              }
              _getOriginZoom(U) {
                return (U - this.points.length) % 32;
              }
              _map(U, $, ne) {
                if (U[$ + 5] > 1) {
                  const ve = this.clusterProps[U[$ + 6]];
                  return ne ? Object.assign({}, ve) : ve;
                }
                const ce = this.points[U[$ + 3]].properties,
                  me = this.options.map(ce);
                return ne && me === ce ? Object.assign({}, me) : me;
              }
            }
            function Os(se, U, $) {
              return {
                type: "Feature",
                id: se[U + 3],
                properties: rs(se, U, $),
                geometry: {
                  type: "Point",
                  coordinates: [
                    ((ne = se[U]), 360 * (ne - 0.5)),
                    Fs(se[U + 1]),
                  ],
                },
              };
              var ne;
            }
            function rs(se, U, $) {
              const ne = se[U + 5],
                ce =
                  ne >= 1e4
                    ? `${Math.round(ne / 1e3)}k`
                    : ne >= 1e3
                    ? Math.round(ne / 100) / 10 + "k"
                    : ne,
                me = se[U + 6],
                ve = -1 === me ? {} : Object.assign({}, $[me]);
              return Object.assign(ve, {
                cluster: !0,
                cluster_id: se[U + 3],
                point_count: ne,
                point_count_abbreviated: ce,
              });
            }
            function os(se) {
              return se / 360 + 0.5;
            }
            function ss(se) {
              const U = Math.sin((se * Math.PI) / 180),
                $ = 0.5 - (0.25 * Math.log((1 + U) / (1 - U))) / Math.PI;
              return $ < 0 ? 0 : $ > 1 ? 1 : $;
            }
            function Fs(se) {
              const U = ((180 - 360 * se) * Math.PI) / 180;
              return (360 * Math.atan(Math.exp(U))) / Math.PI - 90;
            }
            function No(se, U, $, ne) {
              for (
                var ce,
                  me = ne,
                  ve = ($ - U) >> 1,
                  ye = $ - U,
                  fe = se[U],
                  Se = se[U + 1],
                  Ye = se[$],
                  Qe = se[$ + 1],
                  We = U + 3;
                We < $;
                We += 3
              ) {
                var Pt = xl(se[We], se[We + 1], fe, Se, Ye, Qe);
                if (Pt > me) (ce = We), (me = Pt);
                else if (Pt === me) {
                  var Bt = Math.abs(We - ve);
                  Bt < ye && ((ce = We), (ye = Bt));
                }
              }
              me > ne &&
                (ce - U > 3 && No(se, U, ce, ne),
                (se[ce + 2] = me),
                $ - ce > 3 && No(se, ce, $, ne));
            }
            function xl(se, U, $, ne, ce, me) {
              var ve = ce - $,
                ye = me - ne;
              if (0 !== ve || 0 !== ye) {
                var fe = ((se - $) * ve + (U - ne) * ye) / (ve * ve + ye * ye);
                fe > 1
                  ? (($ = ce), (ne = me))
                  : fe > 0 && (($ += ve * fe), (ne += ye * fe));
              }
              return (ve = se - $) * ve + (ye = U - ne) * ye;
            }
            function en(se, U, $, ne) {
              var ce = {
                id: void 0 === se ? null : se,
                type: U,
                geometry: $,
                tags: ne,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0,
              };
              return (
                (function (me) {
                  var ve = me.geometry,
                    ye = me.type;
                  if (
                    "Point" === ye ||
                    "MultiPoint" === ye ||
                    "LineString" === ye
                  )
                    Ns(me, ve);
                  else if ("Polygon" === ye || "MultiLineString" === ye)
                    for (var fe = 0; fe < ve.length; fe++) Ns(me, ve[fe]);
                  else if ("MultiPolygon" === ye)
                    for (fe = 0; fe < ve.length; fe++)
                      for (var Se = 0; Se < ve[fe].length; Se++)
                        Ns(me, ve[fe][Se]);
                })(ce),
                ce
              );
            }
            function Ns(se, U) {
              for (var $ = 0; $ < U.length; $ += 3)
                (se.minX = Math.min(se.minX, U[$])),
                  (se.minY = Math.min(se.minY, U[$ + 1])),
                  (se.maxX = Math.max(se.maxX, U[$])),
                  (se.maxY = Math.max(se.maxY, U[$ + 1]));
            }
            function jr(se, U, $, ne) {
              if (U.geometry) {
                var ce = U.geometry.coordinates,
                  me = U.geometry.type,
                  ve = Math.pow($.tolerance / ((1 << $.maxZoom) * $.extent), 2),
                  ye = [],
                  fe = U.id;
                if (
                  ($.promoteId
                    ? (fe = U.properties[$.promoteId])
                    : $.generateId && (fe = ne || 0),
                  "Point" === me)
                )
                  Aa(ce, ye);
                else if ("MultiPoint" === me)
                  for (var Se = 0; Se < ce.length; Se++) Aa(ce[Se], ye);
                else if ("LineString" === me) Hn(ce, ye, ve, !1);
                else if ("MultiLineString" === me) {
                  if ($.lineMetrics) {
                    for (Se = 0; Se < ce.length; Se++)
                      Hn(ce[Se], (ye = []), ve, !1),
                        se.push(en(fe, "LineString", ye, U.properties));
                    return;
                  }
                  to(ce, ye, ve, !1);
                } else if ("Polygon" === me) to(ce, ye, ve, !0);
                else {
                  if ("MultiPolygon" !== me) {
                    if ("GeometryCollection" === me) {
                      for (Se = 0; Se < U.geometry.geometries.length; Se++)
                        jr(
                          se,
                          {
                            id: fe,
                            geometry: U.geometry.geometries[Se],
                            properties: U.properties,
                          },
                          $,
                          ne
                        );
                      return;
                    }
                    throw new Error(
                      "Input data is not a valid GeoJSON object."
                    );
                  }
                  for (Se = 0; Se < ce.length; Se++) {
                    var Ye = [];
                    to(ce[Se], Ye, ve, !0), ye.push(Ye);
                  }
                }
                se.push(en(fe, me, ye, U.properties));
              }
            }
            function Aa(se, U) {
              U.push(lu(se[0])), U.push(zs(se[1])), U.push(0);
            }
            function Hn(se, U, $, ne) {
              for (var ce, me, ve = 0, ye = 0; ye < se.length; ye++) {
                var fe = lu(se[ye][0]),
                  Se = zs(se[ye][1]);
                U.push(fe),
                  U.push(Se),
                  U.push(0),
                  ye > 0 &&
                    (ve += ne
                      ? (ce * Se - fe * me) / 2
                      : Math.sqrt(Math.pow(fe - ce, 2) + Math.pow(Se - me, 2))),
                  (ce = fe),
                  (me = Se);
              }
              var Ye = U.length - 3;
              (U[2] = 1),
                No(U, 0, Ye, $),
                (U[Ye + 2] = 1),
                (U.size = Math.abs(ve)),
                (U.start = 0),
                (U.end = U.size);
            }
            function to(se, U, $, ne) {
              for (var ce = 0; ce < se.length; ce++) {
                var me = [];
                Hn(se[ce], me, $, ne), U.push(me);
              }
            }
            function lu(se) {
              return se / 360 + 0.5;
            }
            function zs(se) {
              var U = Math.sin((se * Math.PI) / 180),
                $ = 0.5 - (0.25 * Math.log((1 + U) / (1 - U))) / Math.PI;
              return $ < 0 ? 0 : $ > 1 ? 1 : $;
            }
            function no(se, U, $, ne, ce, me, ve, ye) {
              if (((ne /= U), me >= ($ /= U) && ve < ne)) return se;
              if (ve < $ || me >= ne) return null;
              for (var fe = [], Se = 0; Se < se.length; Se++) {
                var Ye = se[Se],
                  Qe = Ye.geometry,
                  We = Ye.type,
                  Pt = 0 === ce ? Ye.minX : Ye.minY,
                  Bt = 0 === ce ? Ye.maxX : Ye.maxY;
                if (Pt >= $ && Bt < ne) fe.push(Ye);
                else if (!(Bt < $ || Pt >= ne)) {
                  var Et = [];
                  if ("Point" === We || "MultiPoint" === We)
                    cu(Qe, Et, $, ne, ce);
                  else if ("LineString" === We)
                    lc(Qe, Et, $, ne, ce, !1, ye.lineMetrics);
                  else if ("MultiLineString" === We) as(Qe, Et, $, ne, ce, !1);
                  else if ("Polygon" === We) as(Qe, Et, $, ne, ce, !0);
                  else if ("MultiPolygon" === We)
                    for (var Gt = 0; Gt < Qe.length; Gt++) {
                      var tn = [];
                      as(Qe[Gt], tn, $, ne, ce, !0), tn.length && Et.push(tn);
                    }
                  if (Et.length) {
                    if (ye.lineMetrics && "LineString" === We) {
                      for (Gt = 0; Gt < Et.length; Gt++)
                        fe.push(en(Ye.id, We, Et[Gt], Ye.tags));
                      continue;
                    }
                    ("LineString" !== We && "MultiLineString" !== We) ||
                      (1 === Et.length
                        ? ((We = "LineString"), (Et = Et[0]))
                        : (We = "MultiLineString")),
                      ("Point" !== We && "MultiPoint" !== We) ||
                        (We = 3 === Et.length ? "Point" : "MultiPoint"),
                      fe.push(en(Ye.id, We, Et, Ye.tags));
                  }
                }
              }
              return fe.length ? fe : null;
            }
            function cu(se, U, $, ne, ce) {
              for (var me = 0; me < se.length; me += 3) {
                var ve = se[me + ce];
                ve >= $ &&
                  ve <= ne &&
                  (U.push(se[me]), U.push(se[me + 1]), U.push(se[me + 2]));
              }
            }
            function lc(se, U, $, ne, ce, me, ve) {
              for (
                var ye,
                  fe,
                  Se = cc(se),
                  Ye = 0 === ce ? wl : uu,
                  Qe = se.start,
                  We = 0;
                We < se.length - 3;
                We += 3
              ) {
                var Pt = se[We],
                  Bt = se[We + 1],
                  Et = se[We + 2],
                  Gt = se[We + 3],
                  tn = se[We + 4],
                  Gn = 0 === ce ? Pt : Bt,
                  ui = 0 === ce ? Gt : tn,
                  Xi = !1;
                ve &&
                  (ye = Math.sqrt(Math.pow(Pt - Gt, 2) + Math.pow(Bt - tn, 2))),
                  Gn < $
                    ? ui > $ &&
                      ((fe = Ye(Se, Pt, Bt, Gt, tn, $)),
                      ve && (Se.start = Qe + ye * fe))
                    : Gn > ne
                    ? ui < ne &&
                      ((fe = Ye(Se, Pt, Bt, Gt, tn, ne)),
                      ve && (Se.start = Qe + ye * fe))
                    : bl(Se, Pt, Bt, Et),
                  ui < $ &&
                    Gn >= $ &&
                    ((fe = Ye(Se, Pt, Bt, Gt, tn, $)), (Xi = !0)),
                  ui > ne &&
                    Gn <= ne &&
                    ((fe = Ye(Se, Pt, Bt, Gt, tn, ne)), (Xi = !0)),
                  !me &&
                    Xi &&
                    (ve && (Se.end = Qe + ye * fe), U.push(Se), (Se = cc(se))),
                  ve && (Qe += ye);
              }
              var wi = se.length - 3;
              (Pt = se[wi]),
                (Bt = se[wi + 1]),
                (Et = se[wi + 2]),
                (Gn = 0 === ce ? Pt : Bt) >= $ &&
                  Gn <= ne &&
                  bl(Se, Pt, Bt, Et),
                (wi = Se.length - 3),
                me &&
                  wi >= 3 &&
                  (Se[wi] !== Se[0] || Se[wi + 1] !== Se[1]) &&
                  bl(Se, Se[0], Se[1], Se[2]),
                Se.length && U.push(Se);
            }
            function cc(se) {
              var U = [];
              return (
                (U.size = se.size), (U.start = se.start), (U.end = se.end), U
              );
            }
            function as(se, U, $, ne, ce, me) {
              for (var ve = 0; ve < se.length; ve++)
                lc(se[ve], U, $, ne, ce, me, !1);
            }
            function bl(se, U, $, ne) {
              se.push(U), se.push($), se.push(ne);
            }
            function wl(se, U, $, ne, ce, me) {
              var ve = (me - U) / (ne - U);
              return se.push(me), se.push($ + (ce - $) * ve), se.push(1), ve;
            }
            function uu(se, U, $, ne, ce, me) {
              var ve = (me - $) / (ce - $);
              return se.push(U + (ne - U) * ve), se.push(me), se.push(1), ve;
            }
            function Cr(se, U) {
              for (var $ = [], ne = 0; ne < se.length; ne++) {
                var ce,
                  me = se[ne],
                  ve = me.type;
                if (
                  "Point" === ve ||
                  "MultiPoint" === ve ||
                  "LineString" === ve
                )
                  ce = ls(me.geometry, U);
                else if ("MultiLineString" === ve || "Polygon" === ve) {
                  ce = [];
                  for (var ye = 0; ye < me.geometry.length; ye++)
                    ce.push(ls(me.geometry[ye], U));
                } else if ("MultiPolygon" === ve)
                  for (ce = [], ye = 0; ye < me.geometry.length; ye++) {
                    for (var fe = [], Se = 0; Se < me.geometry[ye].length; Se++)
                      fe.push(ls(me.geometry[ye][Se], U));
                    ce.push(fe);
                  }
                $.push(en(me.id, ve, ce, me.tags));
              }
              return $;
            }
            function ls(se, U) {
              var $ = [];
              ($.size = se.size),
                void 0 !== se.start && (($.start = se.start), ($.end = se.end));
              for (var ne = 0; ne < se.length; ne += 3)
                $.push(se[ne] + U, se[ne + 1], se[ne + 2]);
              return $;
            }
            function uc(se, U) {
              if (se.transformed) return se;
              var $,
                ne,
                ce,
                me = 1 << se.z,
                ve = se.x,
                ye = se.y;
              for ($ = 0; $ < se.features.length; $++) {
                var fe = se.features[$],
                  Se = fe.geometry,
                  Ye = fe.type;
                if (((fe.geometry = []), 1 === Ye))
                  for (ne = 0; ne < Se.length; ne += 2)
                    fe.geometry.push(Pa(Se[ne], Se[ne + 1], U, me, ve, ye));
                else
                  for (ne = 0; ne < Se.length; ne++) {
                    var Qe = [];
                    for (ce = 0; ce < Se[ne].length; ce += 2)
                      Qe.push(Pa(Se[ne][ce], Se[ne][ce + 1], U, me, ve, ye));
                    fe.geometry.push(Qe);
                  }
              }
              return (se.transformed = !0), se;
            }
            function Pa(se, U, $, ne, ce, me) {
              return [
                Math.round($ * (se * ne - ce)),
                Math.round($ * (U * ne - me)),
              ];
            }
            function El(se, U, $, ne, ce) {
              for (
                var me =
                    U === ce.maxZoom
                      ? 0
                      : ce.tolerance / ((1 << U) * ce.extent),
                  ve = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: 0,
                    source: null,
                    x: $,
                    y: ne,
                    z: U,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0,
                  },
                  ye = 0;
                ye < se.length;
                ye++
              ) {
                ve.numFeatures++, io(ve, se[ye], me, ce);
                var fe = se[ye].minX,
                  Se = se[ye].minY,
                  Ye = se[ye].maxX,
                  Qe = se[ye].maxY;
                fe < ve.minX && (ve.minX = fe),
                  Se < ve.minY && (ve.minY = Se),
                  Ye > ve.maxX && (ve.maxX = Ye),
                  Qe > ve.maxY && (ve.maxY = Qe);
              }
              return ve;
            }
            function io(se, U, $, ne) {
              var ce = U.geometry,
                me = U.type,
                ve = [];
              if ("Point" === me || "MultiPoint" === me)
                for (var ye = 0; ye < ce.length; ye += 3)
                  ve.push(ce[ye]),
                    ve.push(ce[ye + 1]),
                    se.numPoints++,
                    se.numSimplified++;
              else if ("LineString" === me) Bs(ve, ce, se, $, !1, !1);
              else if ("MultiLineString" === me || "Polygon" === me)
                for (ye = 0; ye < ce.length; ye++)
                  Bs(ve, ce[ye], se, $, "Polygon" === me, 0 === ye);
              else if ("MultiPolygon" === me)
                for (var fe = 0; fe < ce.length; fe++) {
                  var Se = ce[fe];
                  for (ye = 0; ye < Se.length; ye++)
                    Bs(ve, Se[ye], se, $, !0, 0 === ye);
                }
              if (ve.length) {
                var Ye = U.tags || null;
                if ("LineString" === me && ne.lineMetrics) {
                  for (var Qe in ((Ye = {}), U.tags)) Ye[Qe] = U.tags[Qe];
                  (Ye.mapbox_clip_start = ce.start / ce.size),
                    (Ye.mapbox_clip_end = ce.end / ce.size);
                }
                var We = {
                  geometry: ve,
                  type:
                    "Polygon" === me || "MultiPolygon" === me
                      ? 3
                      : "LineString" === me || "MultiLineString" === me
                      ? 2
                      : 1,
                  tags: Ye,
                };
                null !== U.id && (We.id = U.id), se.features.push(We);
              }
            }
            function Bs(se, U, $, ne, ce, me) {
              var ve = ne * ne;
              if (ne > 0 && U.size < (ce ? ve : ne))
                $.numPoints += U.length / 3;
              else {
                for (var ye = [], fe = 0; fe < U.length; fe += 3)
                  (0 === ne || U[fe + 2] > ve) &&
                    ($.numSimplified++, ye.push(U[fe]), ye.push(U[fe + 1])),
                    $.numPoints++;
                ce &&
                  (function (Se, Ye) {
                    for (
                      var Qe = 0, We = 0, Pt = Se.length, Bt = Pt - 2;
                      We < Pt;
                      Bt = We, We += 2
                    )
                      Qe += (Se[We] - Se[Bt]) * (Se[We + 1] + Se[Bt + 1]);
                    if (Qe > 0 === Ye)
                      for (We = 0, Pt = Se.length; We < Pt / 2; We += 2) {
                        var Et = Se[We],
                          Gt = Se[We + 1];
                        (Se[We] = Se[Pt - 2 - We]),
                          (Se[We + 1] = Se[Pt - 1 - We]),
                          (Se[Pt - 2 - We] = Et),
                          (Se[Pt - 1 - We] = Gt);
                      }
                  })(ye, me),
                  se.push(ye);
              }
            }
            function Vs(se, U) {
              var $ = (U = this.options =
                (function (ce, me) {
                  for (var ve in me) ce[ve] = me[ve];
                  return ce;
                })(Object.create(this.options), U)).debug;
              if (
                ($ && console.time("preprocess data"),
                U.maxZoom < 0 || U.maxZoom > 24)
              )
                throw new Error("maxZoom should be in the 0-24 range");
              if (U.promoteId && U.generateId)
                throw new Error(
                  "promoteId and generateId cannot be used together."
                );
              var ce,
                me,
                ve,
                ye,
                fe,
                Se,
                ne = (function (ce, me) {
                  var ve = [];
                  if ("FeatureCollection" === ce.type)
                    for (var ye = 0; ye < ce.features.length; ye++)
                      jr(ve, ce.features[ye], me, ye);
                  else
                    jr(ve, "Feature" === ce.type ? ce : { geometry: ce }, me);
                  return ve;
                })(se, U);
              (this.tiles = {}),
                (this.tileCoords = []),
                $ &&
                  (console.timeEnd("preprocess data"),
                  console.log(
                    "index: maxZoom: %d, maxPoints: %d",
                    U.indexMaxZoom,
                    U.indexMaxPoints
                  ),
                  console.time("generate tiles"),
                  (this.stats = {}),
                  (this.total = 0)),
                (ye = ce = ne),
                (fe = no(
                  ce,
                  1,
                  -1 - (ve = (me = U).buffer / me.extent),
                  ve,
                  0,
                  -1,
                  2,
                  me
                )),
                (Se = no(ce, 1, 1 - ve, 2 + ve, 0, -1, 2, me)),
                (fe || Se) &&
                  ((ye = no(ce, 1, -ve, 1 + ve, 0, -1, 2, me) || []),
                  fe && (ye = Cr(fe, 1).concat(ye)),
                  Se && (ye = ye.concat(Cr(Se, -1)))),
                (ne = ye).length && this.splitTile(ne, 0, 0, 0),
                $ &&
                  (ne.length &&
                    console.log(
                      "features: %d, points: %d",
                      this.tiles[0].numFeatures,
                      this.tiles[0].numPoints
                    ),
                  console.timeEnd("generate tiles"),
                  console.log(
                    "tiles generated:",
                    this.total,
                    JSON.stringify(this.stats)
                  ));
            }
            function js(se, U, $) {
              return 32 * ((1 << se) * $ + U) + se;
            }
            function La(se, U) {
              const $ = se.tileID.canonical;
              if (!this._geoJSONIndex) return U(null, null);
              const ne = this._geoJSONIndex.getTile($.z, $.x, $.y);
              if (!ne) return U(null, null);
              const ce = new (class {
                constructor(ve) {
                  (this.layers = { _geojsonTileLayer: this }),
                    (this.name = "_geojsonTileLayer"),
                    (this.extent = d.EXTENT),
                    (this.length = ve.length),
                    (this._features = ve);
                }
                feature(ve) {
                  return new (class {
                    constructor(ye) {
                      (this._feature = ye),
                        (this.extent = d.EXTENT),
                        (this.type = ye.type),
                        (this.properties = ye.tags),
                        "id" in ye &&
                          !isNaN(ye.id) &&
                          (this.id = parseInt(ye.id, 10));
                    }
                    loadGeometry() {
                      if (1 === this._feature.type) {
                        const ye = [];
                        for (const fe of this._feature.geometry)
                          ye.push([new d.Point(fe[0], fe[1])]);
                        return ye;
                      }
                      {
                        const ye = [];
                        for (const fe of this._feature.geometry) {
                          const Se = [];
                          for (const Ye of fe)
                            Se.push(new d.Point(Ye[0], Ye[1]));
                          ye.push(Se);
                        }
                        return ye;
                      }
                    }
                    toGeoJSON(ye, fe, Se) {
                      return Fo.call(this, ye, fe, Se);
                    }
                  })(this._features[ve]);
                }
              })(ne.features);
              let me = Ca(ce);
              (0 === me.byteOffset && me.byteLength === me.buffer.byteLength) ||
                (me = new Uint8Array(me)),
                U(null, { vectorTile: ce, rawData: me.buffer });
            }
            (Vs.prototype.options = {
              maxZoom: 14,
              indexMaxZoom: 5,
              indexMaxPoints: 1e5,
              tolerance: 3,
              extent: 4096,
              buffer: 64,
              lineMetrics: !1,
              promoteId: null,
              generateId: !1,
              debug: 0,
            }),
              (Vs.prototype.splitTile = function (se, U, $, ne, ce, me, ve) {
                for (
                  var ye = [se, U, $, ne], fe = this.options, Se = fe.debug;
                  ye.length;

                ) {
                  (ne = ye.pop()),
                    ($ = ye.pop()),
                    (U = ye.pop()),
                    (se = ye.pop());
                  var Ye = 1 << U,
                    Qe = js(U, $, ne),
                    We = this.tiles[Qe];
                  if (
                    !We &&
                    (Se > 1 && console.time("creation"),
                    (We = this.tiles[Qe] = El(se, U, $, ne, fe)),
                    this.tileCoords.push({ z: U, x: $, y: ne }),
                    Se)
                  ) {
                    Se > 1 &&
                      (console.log(
                        "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
                        U,
                        $,
                        ne,
                        We.numFeatures,
                        We.numPoints,
                        We.numSimplified
                      ),
                      console.timeEnd("creation"));
                    var Pt = "z" + U;
                    (this.stats[Pt] = (this.stats[Pt] || 0) + 1), this.total++;
                  }
                  if (((We.source = se), ce)) {
                    if (U === fe.maxZoom || U === ce) continue;
                    var Bt = 1 << (ce - U);
                    if ($ !== Math.floor(me / Bt) || ne !== Math.floor(ve / Bt))
                      continue;
                  } else if (
                    U === fe.indexMaxZoom ||
                    We.numPoints <= fe.indexMaxPoints
                  )
                    continue;
                  if (((We.source = null), 0 !== se.length)) {
                    Se > 1 && console.time("clipping");
                    var Et,
                      Gt,
                      tn,
                      Gn,
                      ui,
                      Xi,
                      wi = (0.5 * fe.buffer) / fe.extent,
                      zo = 0.5 - wi,
                      qn = 0.5 + wi,
                      fr = 1 + wi;
                    (Et = Gt = tn = Gn = null),
                      (ui = no(
                        se,
                        Ye,
                        $ - wi,
                        $ + qn,
                        0,
                        We.minX,
                        We.maxX,
                        fe
                      )),
                      (Xi = no(
                        se,
                        Ye,
                        $ + zo,
                        $ + fr,
                        0,
                        We.minX,
                        We.maxX,
                        fe
                      )),
                      (se = null),
                      ui &&
                        ((Et = no(
                          ui,
                          Ye,
                          ne - wi,
                          ne + qn,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (Gt = no(
                          ui,
                          Ye,
                          ne + zo,
                          ne + fr,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (ui = null)),
                      Xi &&
                        ((tn = no(
                          Xi,
                          Ye,
                          ne - wi,
                          ne + qn,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (Gn = no(
                          Xi,
                          Ye,
                          ne + zo,
                          ne + fr,
                          1,
                          We.minY,
                          We.maxY,
                          fe
                        )),
                        (Xi = null)),
                      Se > 1 && console.timeEnd("clipping"),
                      ye.push(Et || [], U + 1, 2 * $, 2 * ne),
                      ye.push(Gt || [], U + 1, 2 * $, 2 * ne + 1),
                      ye.push(tn || [], U + 1, 2 * $ + 1, 2 * ne),
                      ye.push(Gn || [], U + 1, 2 * $ + 1, 2 * ne + 1);
                  }
                }
              }),
              (Vs.prototype.getTile = function (se, U, $) {
                var ne = this.options,
                  ce = ne.extent,
                  me = ne.debug;
                if (se < 0 || se > 24) return null;
                var ve = 1 << se,
                  ye = js(se, (U = ((U % ve) + ve) % ve), $);
                if (this.tiles[ye]) return uc(this.tiles[ye], ce);
                me > 1 && console.log("drilling down to z%d-%d-%d", se, U, $);
                for (var fe, Se = se, Ye = U, Qe = $; !fe && Se > 0; )
                  Se--,
                    (Ye = Math.floor(Ye / 2)),
                    (Qe = Math.floor(Qe / 2)),
                    (fe = this.tiles[js(Se, Ye, Qe)]);
                return fe && fe.source
                  ? (me > 1 &&
                      console.log("found parent tile z%d-%d-%d", Se, Ye, Qe),
                    me > 1 && console.time("drilling down"),
                    this.splitTile(fe.source, Se, Ye, Qe, se, U, $),
                    me > 1 && console.timeEnd("drilling down"),
                    this.tiles[ye] ? uc(this.tiles[ye], ce) : null)
                  : null;
              });
            class Tl extends d.VectorTileWorkerSource {
              constructor(U, $, ne, ce, me) {
                super(U, $, ne, ce, La), me && (this.loadGeoJSON = me);
              }
              loadData(U, $) {
                const ne = U && U.request,
                  ce = ne && ne.collectResourceTiming;
                this.loadGeoJSON(U, (me, ve) => {
                  if (me || !ve) return $(me);
                  if ("object" != typeof ve)
                    return $(
                      new Error(
                        `Input data given to '${U.source}' is not a valid GeoJSON object.`
                      )
                    );
                  {
                    pr(ve, !0);
                    try {
                      if (U.filter) {
                        const fe = d.createExpression(U.filter, {
                          type: "boolean",
                          "property-type": "data-driven",
                          overridable: !1,
                          transition: !1,
                        });
                        if ("error" === fe.result)
                          throw new Error(
                            fe.value
                              .map((Ye) => `${Ye.key}: ${Ye.message}`)
                              .join(", ")
                          );
                        const Se = ve.features.filter((Ye) =>
                          fe.value.evaluate({ zoom: 0 }, Ye)
                        );
                        ve = { type: "FeatureCollection", features: Se };
                      }
                      this._geoJSONIndex = U.cluster
                        ? new ci(
                            (function ({
                              superclusterOptions: fe,
                              clusterProperties: Se,
                            }) {
                              if (!Se || !fe) return fe;
                              const Ye = {},
                                Qe = {},
                                We = { accumulated: null, zoom: 0 },
                                Pt = { properties: null },
                                Bt = Object.keys(Se);
                              for (const Et of Bt) {
                                const [Gt, tn] = Se[Et],
                                  Gn = d.createExpression(tn),
                                  ui = d.createExpression(
                                    "string" == typeof Gt
                                      ? [Gt, ["accumulated"], ["get", Et]]
                                      : Gt
                                  );
                                (Ye[Et] = Gn.value), (Qe[Et] = ui.value);
                              }
                              return (
                                (fe.map = (Et) => {
                                  Pt.properties = Et;
                                  const Gt = {};
                                  for (const tn of Bt)
                                    Gt[tn] = Ye[tn].evaluate(We, Pt);
                                  return Gt;
                                }),
                                (fe.reduce = (Et, Gt) => {
                                  Pt.properties = Gt;
                                  for (const tn of Bt)
                                    (We.accumulated = Et[tn]),
                                      (Et[tn] = Qe[tn].evaluate(We, Pt));
                                }),
                                fe
                              );
                            })(U)
                          ).load(ve.features)
                        : new Vs((fe = ve), U.geojsonVtOptions);
                    } catch (fe) {
                      return $(fe);
                    }
                    this.loaded = {};
                    const ye = {};
                    if (ce) {
                      const fe = d.getPerformanceMeasurement(ne);
                      fe &&
                        ((ye.resourceTiming = {}),
                        (ye.resourceTiming[U.source] = JSON.parse(
                          JSON.stringify(fe)
                        )));
                    }
                    $(null, ye);
                  }
                  var fe;
                });
              }
              reloadTile(U, $) {
                const ne = this.loaded;
                return ne && ne[U.uid]
                  ? super.reloadTile(U, $)
                  : this.loadTile(U, $);
              }
              loadGeoJSON(U, $) {
                if (U.request) d.getJSON(U.request, $);
                else {
                  if ("string" != typeof U.data)
                    return $(
                      new Error(
                        `Input data given to '${U.source}' is not a valid GeoJSON object.`
                      )
                    );
                  try {
                    return $(null, JSON.parse(U.data));
                  } catch {
                    return $(
                      new Error(
                        `Input data given to '${U.source}' is not a valid GeoJSON object.`
                      )
                    );
                  }
                }
              }
              getClusterExpansionZoom(U, $) {
                try {
                  $(
                    null,
                    this._geoJSONIndex.getClusterExpansionZoom(U.clusterId)
                  );
                } catch (ne) {
                  $(ne);
                }
              }
              getClusterChildren(U, $) {
                try {
                  $(null, this._geoJSONIndex.getChildren(U.clusterId));
                } catch (ne) {
                  $(ne);
                }
              }
              getClusterLeaves(U, $) {
                try {
                  $(
                    null,
                    this._geoJSONIndex.getLeaves(U.clusterId, U.limit, U.offset)
                  );
                } catch (ne) {
                  $(ne);
                }
              }
            }
            class hu {
              constructor(U) {
                (this.self = U),
                  (this.actor = new d.Actor(U, this)),
                  (this.layerIndexes = {}),
                  (this.availableImages = {}),
                  (this.isSpriteLoaded = {}),
                  (this.projections = {}),
                  (this.defaultProjection = d.getProjection({
                    name: "mercator",
                  })),
                  (this.workerSourceTypes = {
                    vector: d.VectorTileWorkerSource,
                    geojson: Tl,
                  }),
                  (this.workerSources = {}),
                  (this.demWorkerSources = {}),
                  (this.self.registerWorkerSource = ($, ne) => {
                    if (this.workerSourceTypes[$])
                      throw new Error(
                        `Worker source with name "${$}" already registered.`
                      );
                    this.workerSourceTypes[$] = ne;
                  }),
                  (this.self.registerRTLTextPlugin = ($) => {
                    if (d.plugin.isParsed())
                      throw new Error("RTL text plugin already registered.");
                    (d.plugin.applyArabicShaping = $.applyArabicShaping),
                      (d.plugin.processBidirectionalText =
                        $.processBidirectionalText),
                      (d.plugin.processStyledBidirectionalText =
                        $.processStyledBidirectionalText);
                  });
              }
              clearCaches(U, $, ne) {
                delete this.layerIndexes[U],
                  delete this.availableImages[U],
                  delete this.workerSources[U],
                  delete this.demWorkerSources[U],
                  ne();
              }
              checkIfReady(U, $, ne) {
                ne();
              }
              setReferrer(U, $) {
                this.referrer = $;
              }
              spriteLoaded(U, $) {
                this.isSpriteLoaded[U] = $;
                for (const ne in this.workerSources[U]) {
                  const ce = this.workerSources[U][ne];
                  for (const me in ce)
                    ce[me] instanceof d.VectorTileWorkerSource &&
                      ((ce[me].isSpriteLoaded = $),
                      ce[me].fire(new d.Event("isSpriteLoaded")));
                }
              }
              setImages(U, $, ne) {
                this.availableImages[U] = $;
                for (const ce in this.workerSources[U]) {
                  const me = this.workerSources[U][ce];
                  for (const ve in me) me[ve].availableImages = $;
                }
                ne();
              }
              enableTerrain(U, $, ne) {
                (this.terrain = $), ne();
              }
              setProjection(U, $) {
                this.projections[U] = d.getProjection($);
              }
              setLayers(U, $, ne) {
                this.getLayerIndex(U).replace($), ne();
              }
              updateLayers(U, $, ne) {
                this.getLayerIndex(U).update($.layers, $.removedIds), ne();
              }
              loadTile(U, $, ne) {
                const ce = this.enableTerrain
                  ? d.extend({ enableTerrain: this.terrain }, $)
                  : $;
                (ce.projection = this.projections[U] || this.defaultProjection),
                  this.getWorkerSource(U, $.type, $.source).loadTile(ce, ne);
              }
              loadDEMTile(U, $, ne) {
                const ce = this.enableTerrain
                  ? d.extend({ buildQuadTree: this.terrain }, $)
                  : $;
                this.getDEMWorkerSource(U, $.source).loadTile(ce, ne);
              }
              reloadTile(U, $, ne) {
                const ce = this.enableTerrain
                  ? d.extend({ enableTerrain: this.terrain }, $)
                  : $;
                (ce.projection = this.projections[U] || this.defaultProjection),
                  this.getWorkerSource(U, $.type, $.source).reloadTile(ce, ne);
              }
              abortTile(U, $, ne) {
                this.getWorkerSource(U, $.type, $.source).abortTile($, ne);
              }
              removeTile(U, $, ne) {
                this.getWorkerSource(U, $.type, $.source).removeTile($, ne);
              }
              removeSource(U, $, ne) {
                if (
                  !this.workerSources[U] ||
                  !this.workerSources[U][$.type] ||
                  !this.workerSources[U][$.type][$.source]
                )
                  return;
                const ce = this.workerSources[U][$.type][$.source];
                delete this.workerSources[U][$.type][$.source],
                  void 0 !== ce.removeSource ? ce.removeSource($, ne) : ne();
              }
              loadWorkerSource(U, $, ne) {
                try {
                  this.self.importScripts($.url), ne();
                } catch (ce) {
                  ne(ce.toString());
                }
              }
              syncRTLPluginState(U, $, ne) {
                try {
                  d.plugin.setState($);
                  const ce = d.plugin.getPluginURL();
                  if (
                    d.plugin.isLoaded() &&
                    !d.plugin.isParsed() &&
                    null != ce
                  ) {
                    this.self.importScripts(ce);
                    const me = d.plugin.isParsed();
                    ne(
                      me
                        ? void 0
                        : new Error(
                            `RTL Text Plugin failed to import scripts from ${ce}`
                          ),
                      me
                    );
                  }
                } catch (ce) {
                  ne(ce.toString());
                }
              }
              getAvailableImages(U) {
                let $ = this.availableImages[U];
                return $ || ($ = []), $;
              }
              getLayerIndex(U) {
                let $ = this.layerIndexes[U];
                return $ || ($ = this.layerIndexes[U] = new Jr()), $;
              }
              getWorkerSource(U, $, ne) {
                return (
                  this.workerSources[U] || (this.workerSources[U] = {}),
                  this.workerSources[U][$] || (this.workerSources[U][$] = {}),
                  this.workerSources[U][$][ne] ||
                    (this.workerSources[U][$][ne] = new this.workerSourceTypes[
                      $
                    ](
                      {
                        send: (me, ve, ye, fe, Se, Ye) => {
                          this.actor.send(me, ve, ye, U, Se, Ye);
                        },
                        scheduler: this.actor.scheduler,
                      },
                      this.getLayerIndex(U),
                      this.getAvailableImages(U),
                      this.isSpriteLoaded[U]
                    )),
                  this.workerSources[U][$][ne]
                );
              }
              getDEMWorkerSource(U, $) {
                return (
                  this.demWorkerSources[U] || (this.demWorkerSources[U] = {}),
                  this.demWorkerSources[U][$] ||
                    (this.demWorkerSources[U][$] = new zt()),
                  this.demWorkerSources[U][$]
                );
              }
              enforceCacheSizeLimit(U, $) {
                d.enforceCacheSizeLimit($);
              }
              getWorkerPerformanceMetrics(U, $, ne) {
                ne(void 0, void 0);
              }
            }
            return (
              typeof WorkerGlobalScope < "u" &&
                typeof self < "u" &&
                self instanceof WorkerGlobalScope &&
                (self.worker = new hu(self)),
              hu
            );
          }),
          rp(0, function (d) {
            function Be(f, a) {
              if (Array.isArray(f)) {
                if (!Array.isArray(a) || f.length !== a.length) return !1;
                for (let u = 0; u < f.length; u++)
                  if (!Be(f[u], a[u])) return !1;
                return !0;
              }
              if ("object" == typeof f && null !== f && null !== a) {
                if (
                  "object" != typeof a ||
                  Object.keys(f).length !== Object.keys(a).length
                )
                  return !1;
                for (const u in f) if (!Be(f[u], a[u])) return !1;
                return !0;
              }
              return f === a;
            }
            var Oo = Jr;
            function Jr(f) {
              return (
                (a = f),
                !(
                  typeof window > "u" ||
                  typeof document > "u" ||
                  !(
                    Array.prototype &&
                    Array.prototype.every &&
                    Array.prototype.filter &&
                    Array.prototype.forEach &&
                    Array.prototype.indexOf &&
                    Array.prototype.lastIndexOf &&
                    Array.prototype.map &&
                    Array.prototype.some &&
                    Array.prototype.reduce &&
                    Array.prototype.reduceRight &&
                    Array.isArray
                  ) ||
                  !Function.prototype ||
                  !Function.prototype.bind ||
                  !(
                    Object.keys &&
                    Object.create &&
                    Object.getPrototypeOf &&
                    Object.getOwnPropertyNames &&
                    Object.isSealed &&
                    Object.isFrozen &&
                    Object.isExtensible &&
                    Object.getOwnPropertyDescriptor &&
                    Object.defineProperty &&
                    Object.defineProperties &&
                    Object.seal &&
                    Object.freeze &&
                    Object.preventExtensions
                  ) ||
                  !(
                    "JSON" in window &&
                    "parse" in JSON &&
                    "stringify" in JSON
                  ) ||
                  !(function () {
                    if (
                      !(
                        "Worker" in window &&
                        "Blob" in window &&
                        "URL" in window
                      )
                    )
                      return !1;
                    var g,
                      v,
                      b = new Blob([""], { type: "text/javascript" }),
                      D = URL.createObjectURL(b);
                    try {
                      (v = new Worker(D)), (g = !0);
                    } catch {
                      g = !1;
                    }
                    return v && v.terminate(), URL.revokeObjectURL(D), g;
                  })() ||
                  !("Uint8ClampedArray" in window) ||
                  !ArrayBuffer.isView ||
                  !(function () {
                    var g = document.createElement("canvas");
                    g.width = g.height = 1;
                    var v = g.getContext("2d");
                    if (!v) return !1;
                    var b = v.getImageData(0, 0, 1, 1);
                    return b && b.width === g.width;
                  })() ||
                  (void 0 === zt[(u = a && a.failIfMajorPerformanceCaveat)] &&
                    (zt[u] = (function (g) {
                      var v,
                        D,
                        I,
                        M,
                        b =
                          ((D = g),
                          (I = document.createElement("canvas")),
                          ((M = Object.create(
                            Jr.webGLContextAttributes
                          )).failIfMajorPerformanceCaveat = D),
                          I.getContext("webgl", M) ||
                            I.getContext("experimental-webgl", M));
                      if (!b) return !1;
                      try {
                        v = b.createShader(b.VERTEX_SHADER);
                      } catch {
                        return !1;
                      }
                      return (
                        !(!v || b.isContextLost()) &&
                        (b.shaderSource(v, "void main() {}"),
                        b.compileShader(v),
                        !0 === b.getShaderParameter(v, b.COMPILE_STATUS))
                      );
                    })(u)),
                  !zt[u] || document.documentMode)
                )
              );
              var a, u;
            }
            var zt = {};
            function Ot(f, a, u) {
              const g = d.window.document.createElement(f);
              return (
                void 0 !== a && (g.className = a), u && u.appendChild(g), g
              );
            }
            function Ii(f, a, u) {
              const g = d.window.document.createElementNS(
                "http://www.w3.org/2000/svg",
                f
              );
              for (const v of Object.keys(a)) g.setAttributeNS(null, v, a[v]);
              return u && u.appendChild(g), g;
            }
            Jr.webGLContextAttributes = {
              antialias: !1,
              alpha: !0,
              stencil: !0,
              depth: !0,
            };
            const pr =
                d.window.document && d.window.document.documentElement.style,
              Fo =
                pr && void 0 !== pr.userSelect
                  ? "userSelect"
                  : "WebkitUserSelect";
            let ns;
            function oc() {
              pr && Fo && ((ns = pr[Fo]), (pr[Fo] = "none"));
            }
            function vl() {
              pr && Fo && (pr[Fo] = ns);
            }
            function Vr(f) {
              f.preventDefault(),
                f.stopPropagation(),
                d.window.removeEventListener("click", Vr, !0);
            }
            function eo() {
              d.window.addEventListener("click", Vr, !0),
                d.window.setTimeout(() => {
                  d.window.removeEventListener("click", Vr, !0);
                }, 0);
            }
            function Ir(f, a) {
              const u = f.getBoundingClientRect();
              return mo(f, u, a);
            }
            function Sa(f, a) {
              const u = f.getBoundingClientRect(),
                g = [];
              for (let v = 0; v < a.length; v++) g.push(mo(f, u, a[v]));
              return g;
            }
            function is(f) {
              return void 0 !== d.window.InstallTrigger &&
                2 === f.button &&
                f.ctrlKey &&
                d.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0
                ? 0
                : f.button;
            }
            function mo(f, a, u) {
              const g = f.offsetWidth === a.width ? 1 : f.offsetWidth / a.width;
              return new d.Point(
                (u.clientX - a.left) * g,
                (u.clientY - a.top) * g
              );
            }
            function et(f, a) {
              var u = a[0],
                g = a[1],
                v = a[2],
                b = a[3],
                D = u * b - v * g;
              return D
                ? ((f[0] = b * (D = 1 / D)),
                  (f[1] = -g * D),
                  (f[2] = -v * D),
                  (f[3] = u * D),
                  f)
                : null;
            }
            function Dh(f) {
              const { userImage: a } = f;
              return (
                !!(a && a.render && a.render()) &&
                (f.data.replace(new Uint8Array(a.data.buffer)), !0)
              );
            }
            class Ia extends d.Evented {
              constructor() {
                super(),
                  (this.images = {}),
                  (this.updatedImages = {}),
                  (this.callbackDispatchedThisFrame = {}),
                  (this.loaded = !1),
                  (this.requestors = []),
                  (this.patterns = {}),
                  (this.atlasImage = new d.RGBAImage({ width: 1, height: 1 })),
                  (this.dirty = !0);
              }
              isLoaded() {
                return this.loaded;
              }
              setLoaded(a) {
                if (this.loaded !== a && ((this.loaded = a), a)) {
                  for (const { ids: u, callback: g } of this.requestors)
                    this._notify(u, g);
                  this.requestors = [];
                }
              }
              hasImage(a) {
                return !!this.getImage(a);
              }
              getImage(a) {
                return this.images[a];
              }
              addImage(a, u) {
                this._validate(a, u) && (this.images[a] = u);
              }
              _validate(a, u) {
                let g = !0;
                return (
                  this._validateStretch(u.stretchX, u.data && u.data.width) ||
                    (this.fire(
                      new d.ErrorEvent(
                        new Error(`Image "${a}" has invalid "stretchX" value`)
                      )
                    ),
                    (g = !1)),
                  this._validateStretch(u.stretchY, u.data && u.data.height) ||
                    (this.fire(
                      new d.ErrorEvent(
                        new Error(`Image "${a}" has invalid "stretchY" value`)
                      )
                    ),
                    (g = !1)),
                  this._validateContent(u.content, u) ||
                    (this.fire(
                      new d.ErrorEvent(
                        new Error(`Image "${a}" has invalid "content" value`)
                      )
                    ),
                    (g = !1)),
                  g
                );
              }
              _validateStretch(a, u) {
                if (!a) return !0;
                let g = 0;
                for (const v of a) {
                  if (v[0] < g || v[1] < v[0] || u < v[1]) return !1;
                  g = v[1];
                }
                return !0;
              }
              _validateContent(a, u) {
                return !(
                  a &&
                  (4 !== a.length ||
                    a[0] < 0 ||
                    u.data.width < a[0] ||
                    a[1] < 0 ||
                    u.data.height < a[1] ||
                    a[2] < 0 ||
                    u.data.width < a[2] ||
                    a[3] < 0 ||
                    u.data.height < a[3] ||
                    a[2] < a[0] ||
                    a[3] < a[1])
                );
              }
              updateImage(a, u) {
                (u.version = this.images[a].version + 1),
                  (this.images[a] = u),
                  (this.updatedImages[a] = !0);
              }
              removeImage(a) {
                const u = this.images[a];
                delete this.images[a],
                  delete this.patterns[a],
                  u.userImage && u.userImage.onRemove && u.userImage.onRemove();
              }
              listImages() {
                return Object.keys(this.images);
              }
              getImages(a, u) {
                let g = !0;
                if (!this.isLoaded())
                  for (const v of a) this.images[v] || (g = !1);
                this.isLoaded() || g
                  ? this._notify(a, u)
                  : this.requestors.push({ ids: a, callback: u });
              }
              _notify(a, u) {
                const g = {};
                for (const v of a) {
                  this.images[v] ||
                    this.fire(new d.Event("styleimagemissing", { id: v }));
                  const b = this.images[v];
                  b
                    ? (g[v] = {
                        data: b.data.clone(),
                        pixelRatio: b.pixelRatio,
                        sdf: b.sdf,
                        version: b.version,
                        stretchX: b.stretchX,
                        stretchY: b.stretchY,
                        content: b.content,
                        hasRenderCallback: Boolean(
                          b.userImage && b.userImage.render
                        ),
                      })
                    : d.warnOnce(
                        `Image "${v}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`
                      );
                }
                u(null, g);
              }
              getPixelSize() {
                const { width: a, height: u } = this.atlasImage;
                return { width: a, height: u };
              }
              getPattern(a) {
                const u = this.patterns[a],
                  g = this.getImage(a);
                if (!g) return null;
                if (u && u.position.version === g.version) return u.position;
                if (u) u.position.version = g.version;
                else {
                  const v = {
                      w: g.data.width + 2,
                      h: g.data.height + 2,
                      x: 0,
                      y: 0,
                    },
                    b = new d.ImagePosition(v, g);
                  this.patterns[a] = { bin: v, position: b };
                }
                return this._updatePatternAtlas(), this.patterns[a].position;
              }
              bind(a) {
                const u = a.gl;
                this.atlasTexture
                  ? this.dirty &&
                    (this.atlasTexture.update(this.atlasImage),
                    (this.dirty = !1))
                  : (this.atlasTexture = new d.Texture(
                      a,
                      this.atlasImage,
                      u.RGBA
                    )),
                  this.atlasTexture &&
                    this.atlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE);
              }
              _updatePatternAtlas() {
                const a = [];
                for (const b in this.patterns) a.push(this.patterns[b].bin);
                const { w: u, h: g } = d.potpack(a),
                  v = this.atlasImage;
                v.resize({ width: u || 1, height: g || 1 });
                for (const b in this.patterns) {
                  const { bin: D } = this.patterns[b],
                    I = D.x + 1,
                    M = D.y + 1,
                    R = this.images[b].data,
                    k = R.width,
                    z = R.height;
                  d.RGBAImage.copy(
                    R,
                    v,
                    { x: 0, y: 0 },
                    { x: I, y: M },
                    { width: k, height: z }
                  ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: 0, y: z - 1 },
                      { x: I, y: M - 1 },
                      { width: k, height: 1 }
                    ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: 0, y: 0 },
                      { x: I, y: M + z },
                      { width: k, height: 1 }
                    ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: k - 1, y: 0 },
                      { x: I - 1, y: M },
                      { width: 1, height: z }
                    ),
                    d.RGBAImage.copy(
                      R,
                      v,
                      { x: 0, y: 0 },
                      { x: I + k, y: M },
                      { width: 1, height: z }
                    );
                }
                this.dirty = !0;
              }
              beginFrame() {
                this.callbackDispatchedThisFrame = {};
              }
              dispatchRenderCallbacks(a) {
                for (const u of a) {
                  if (this.callbackDispatchedThisFrame[u]) continue;
                  this.callbackDispatchedThisFrame[u] = !0;
                  const g = this.images[u];
                  Dh(g) && this.updateImage(u, g);
                }
              }
            }
            const Xt = new d.Properties({
              anchor: new d.DataConstantProperty(d.spec.light.anchor),
              position: new (class {
                constructor() {
                  this.specification = d.spec.light.position;
                }
                possiblyEvaluate(f, a) {
                  return (function ([u, g, v]) {
                    const b = d.degToRad(g + 90),
                      D = d.degToRad(v);
                    return {
                      x: u * Math.cos(b) * Math.sin(D),
                      y: u * Math.sin(b) * Math.sin(D),
                      z: u * Math.cos(D),
                      azimuthal: g,
                      polar: v,
                    };
                  })(f.expression.evaluate(a));
                }
                interpolate(f, a, u) {
                  return {
                    x: d.number(f.x, a.x, u),
                    y: d.number(f.y, a.y, u),
                    z: d.number(f.z, a.z, u),
                    azimuthal: d.number(f.azimuthal, a.azimuthal, u),
                    polar: d.number(f.polar, a.polar, u),
                  };
                }
              })(),
              color: new d.DataConstantProperty(d.spec.light.color),
              intensity: new d.DataConstantProperty(d.spec.light.intensity),
            });
            class Oi extends d.Evented {
              constructor(a) {
                super(),
                  (this._transitionable = new d.Transitionable(Xt)),
                  this.setLight(a),
                  (this._transitioning = this._transitionable.untransitioned());
              }
              getLight() {
                return this._transitionable.serialize();
              }
              setLight(a, u = {}) {
                if (!this._validate(d.validateLight, a, u))
                  for (const g in a) {
                    const v = a[g];
                    d.endsWith(g, "-transition")
                      ? this._transitionable.setTransition(g.slice(0, -11), v)
                      : this._transitionable.setValue(g, v);
                  }
              }
              updateTransitions(a) {
                this._transitioning = this._transitionable.transitioned(
                  a,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(a) {
                this.properties = this._transitioning.possiblyEvaluate(a);
              }
              _validate(a, u, g) {
                return (
                  (!g || !1 !== g.validate) &&
                  d.emitValidationErrors(
                    this,
                    a.call(
                      d.validateStyle,
                      d.extend({
                        value: u,
                        style: { glyphs: !0, sprite: !0 },
                        styleSpec: d.spec,
                      })
                    )
                  )
                );
              }
            }
            const sc = new d.Properties({
              source: new d.DataConstantProperty(d.spec.terrain.source),
              exaggeration: new d.DataConstantProperty(
                d.spec.terrain.exaggeration
              ),
            });
            let au = class extends d.Evented {
              constructor(f, a) {
                super(),
                  (this._transitionable = new d.Transitionable(sc)),
                  this.set(f),
                  (this._transitioning = this._transitionable.untransitioned()),
                  (this.drapeRenderMode = a);
              }
              get() {
                return this._transitionable.serialize();
              }
              set(f) {
                for (const a in f) {
                  const u = f[a];
                  d.endsWith(a, "-transition")
                    ? this._transitionable.setTransition(a.slice(0, -11), u)
                    : this._transitionable.setValue(a, u);
                }
              }
              updateTransitions(f) {
                this._transitioning = this._transitionable.transitioned(
                  f,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(f) {
                this.properties = this._transitioning.possiblyEvaluate(f);
              }
            };
            function Ca(f, a, u, g) {
              const v = d.smoothstep(45, 65, u),
                [b, D] = ac(f, g),
                I = d.length(a);
              let M = 1 - Math.min(1, Math.exp(((I - b) / (D - b)) * -6));
              return (
                (M *= M * M), (M = Math.min(1, 1.00747 * M)), M * v * f.alpha
              );
            }
            function ac(f, a) {
              const u = 0.5 / Math.tan(0.5 * a);
              return [f.range[0] + u, f.range[1] + u];
            }
            const Qt = new d.Properties({
              range: new d.DataConstantProperty(d.spec.fog.range),
              color: new d.DataConstantProperty(d.spec.fog.color),
              "high-color": new d.DataConstantProperty(
                d.spec.fog["high-color"]
              ),
              "space-color": new d.DataConstantProperty(
                d.spec.fog["space-color"]
              ),
              "horizon-blend": new d.DataConstantProperty(
                d.spec.fog["horizon-blend"]
              ),
              "star-intensity": new d.DataConstantProperty(
                d.spec.fog["star-intensity"]
              ),
            });
            class Ma extends d.Evented {
              constructor(a, u) {
                super(),
                  (this._transitionable = new d.Transitionable(Qt)),
                  this.set(a),
                  (this._transitioning = this._transitionable.untransitioned()),
                  (this._transform = u);
              }
              get state() {
                const a = this._transform,
                  u = "globe" === a.projection.name,
                  g = d.globeToMercatorTransition(a.zoom),
                  v = this.properties.get("range"),
                  b = [0.5, 3];
                return {
                  range: u
                    ? [d.number(b[0], v[0], g), d.number(b[1], v[1], g)]
                    : v,
                  horizonBlend: this.properties.get("horizon-blend"),
                  alpha: this.properties.get("color").a,
                };
              }
              get() {
                return this._transitionable.serialize();
              }
              set(a, u = {}) {
                if (!this._validate(d.validateFog, a, u)) {
                  for (const g of Object.keys(d.spec.fog))
                    a && void 0 === a[g] && (a[g] = d.spec.fog[g].default);
                  for (const g in a) {
                    const v = a[g];
                    d.endsWith(g, "-transition")
                      ? this._transitionable.setTransition(g.slice(0, -11), v)
                      : this._transitionable.setValue(g, v);
                  }
                }
              }
              getOpacity(a) {
                if (!this._transform.projection.supportsFog) return 0;
                const u =
                  (this.properties && this.properties.get("color")) || 1;
                return (
                  ("globe" === this._transform.projection.name
                    ? 1
                    : d.smoothstep(45, 65, a)) * u.a
                );
              }
              getOpacityAtLatLng(a, u) {
                return this._transform.projection.supportsFog
                  ? (function (g, v, b) {
                      const D = d.MercatorCoordinate.fromLngLat(v),
                        I = b.elevation ? b.elevation.getAtPointOrZero(D) : 0,
                        M = [D.x, D.y, I];
                      return (
                        d.transformMat4(M, M, b.mercatorFogMatrix),
                        Ca(g, M, b.pitch, b._fov)
                      );
                    })(this.state, a, u)
                  : 0;
              }
              getFovAdjustedRange(a) {
                return this._transform.projection.supportsFog
                  ? ac(this.state, a)
                  : [0, 1];
              }
              updateTransitions(a) {
                this._transitioning = this._transitionable.transitioned(
                  a,
                  this._transitioning
                );
              }
              hasTransition() {
                return this._transitioning.hasTransition();
              }
              recalculate(a) {
                this.properties = this._transitioning.possiblyEvaluate(a);
              }
              _validate(a, u, g) {
                return (
                  (!g || !1 !== g.validate) &&
                  d.emitValidationErrors(
                    this,
                    a.call(
                      d.validateStyle,
                      d.extend({
                        value: u,
                        style: { glyphs: !0, sprite: !0 },
                        styleSpec: d.spec,
                      })
                    )
                  )
                );
              }
            }
            class bn {
              constructor(a, u) {
                (this.workerPool = a),
                  (this.actors = []),
                  (this.currentActor = 0),
                  (this.id = d.uniqueId());
                const g = this.workerPool.acquire(this.id);
                for (let v = 0; v < g.length; v++) {
                  const b = new bn.Actor(g[v], u, this.id);
                  (b.name = `Worker ${v}`), this.actors.push(b);
                }
                (this.ready = !1),
                  this.broadcast("checkIfReady", null, () => {
                    this.ready = !0;
                  });
              }
              broadcast(a, u, g) {
                d.asyncAll(
                  this.actors,
                  (v, b) => {
                    v.send(a, u, b);
                  },
                  (g = g || function () {})
                );
              }
              getActor() {
                return (
                  (this.currentActor =
                    (this.currentActor + 1) % this.actors.length),
                  this.actors[this.currentActor]
                );
              }
              remove() {
                this.actors.forEach((a) => {
                  a.remove();
                }),
                  (this.actors = []),
                  this.workerPool.release(this.id);
              }
            }
            function Ci(f, a, u) {
              return (
                a *
                (d.EXTENT /
                  (f.tileSize * Math.pow(2, u - f.tileID.overscaledZ)))
              );
            }
            bn.Actor = d.Actor;
            class Rs {
              constructor(a, u, g, v) {
                (this.screenBounds = a),
                  (this.cameraPoint = u),
                  (this._screenRaycastCache = {}),
                  (this._cameraRaycastCache = {}),
                  (this.isAboveHorizon = g),
                  (this.screenGeometry = this.bufferedScreenGeometry(0)),
                  (this.screenGeometryMercator = this._bufferedScreenMercator(
                    0,
                    v
                  ));
              }
              static createFromScreenPoints(a, u) {
                let g, v;
                if (a instanceof d.Point || "number" == typeof a[0]) {
                  const b = d.Point.convert(a);
                  (g = [b]), (v = u.isPointAboveHorizon(b));
                } else {
                  const b = d.Point.convert(a[0]),
                    D = d.Point.convert(a[1]);
                  (g = [b, D]),
                    (v = d
                      .polygonizeBounds(b, D)
                      .every((I) => u.isPointAboveHorizon(I)));
                }
                return new Rs(g, u.getCameraPoint(), v, u);
              }
              isPointQuery() {
                return 1 === this.screenBounds.length;
              }
              bufferedScreenGeometry(a) {
                return d.polygonizeBounds(
                  this.screenBounds[0],
                  1 === this.screenBounds.length
                    ? this.screenBounds[0]
                    : this.screenBounds[1],
                  a
                );
              }
              bufferedCameraGeometry(a) {
                const u = this.screenBounds[0],
                  g =
                    1 === this.screenBounds.length
                      ? this.screenBounds[0].add(new d.Point(1, 1))
                      : this.screenBounds[1],
                  v = d.polygonizeBounds(u, g, 0, !1);
                return (
                  this.cameraPoint.y > g.y &&
                    (this.cameraPoint.x > u.x && this.cameraPoint.x < g.x
                      ? v.splice(3, 0, this.cameraPoint)
                      : this.cameraPoint.x >= g.x
                      ? (v[2] = this.cameraPoint)
                      : this.cameraPoint.x <= u.x && (v[3] = this.cameraPoint)),
                  d.bufferConvexPolygon(v, a)
                );
              }
              bufferedCameraGeometryGlobe(a) {
                const u = this.screenBounds[0],
                  g =
                    1 === this.screenBounds.length
                      ? this.screenBounds[0].add(new d.Point(1, 1))
                      : this.screenBounds[1],
                  v = d.polygonizeBounds(u, g, a),
                  b = this.cameraPoint.clone();
                switch (
                  3 * ((b.y > u.y) + (b.y > g.y)) +
                  ((b.x > u.x) + (b.x > g.x))
                ) {
                  case 0:
                    (v[0] = b), (v[4] = b.clone());
                    break;
                  case 1:
                    v.splice(1, 0, b);
                    break;
                  case 2:
                    v[1] = b;
                    break;
                  case 3:
                    v.splice(4, 0, b);
                    break;
                  case 5:
                    v.splice(2, 0, b);
                    break;
                  case 6:
                    v[3] = b;
                    break;
                  case 7:
                    v.splice(3, 0, b);
                    break;
                  case 8:
                    v[2] = b;
                }
                return v;
              }
              containsTile(a, u, g, v = 0) {
                const b = a.queryPadding / u._pixelsPerMercatorPixel + 1,
                  D = g
                    ? this._bufferedCameraMercator(b, u)
                    : this._bufferedScreenMercator(b, u);
                let I = a.tileID.wrap + (D.unwrapped ? v : 0);
                const M = D.polygon.map((Y) =>
                  d.getTilePoint(a.tileTransform, Y, I)
                );
                if (!d.polygonIntersectsBox(M, 0, 0, d.EXTENT, d.EXTENT))
                  return;
                I =
                  a.tileID.wrap +
                  (this.screenGeometryMercator.unwrapped ? v : 0);
                const R = this.screenGeometryMercator.polygon.map((Y) =>
                    d.getTileVec3(a.tileTransform, Y, I)
                  ),
                  k = R.map((Y) => new d.Point(Y[0], Y[1])),
                  z =
                    u.getFreeCameraOptions().position ||
                    new d.MercatorCoordinate(0, 0, 0),
                  H = d.getTileVec3(a.tileTransform, z, I),
                  q = R.map((Y) => {
                    const B = d.sub(Y, Y, H);
                    return d.normalize(B, B), new d.Ray(H, B);
                  }),
                  X = Ci(a, 1, u.zoom) * u._pixelsPerMercatorPixel;
                return {
                  queryGeometry: this,
                  tilespaceGeometry: k,
                  tilespaceRays: q,
                  bufferedTilespaceGeometry: M,
                  bufferedTilespaceBounds:
                    ((Z = d.getBounds(M)),
                    (Z.min.x = d.clamp(Z.min.x, 0, d.EXTENT)),
                    (Z.min.y = d.clamp(Z.min.y, 0, d.EXTENT)),
                    (Z.max.x = d.clamp(Z.max.x, 0, d.EXTENT)),
                    (Z.max.y = d.clamp(Z.max.y, 0, d.EXTENT)),
                    Z),
                  tile: a,
                  tileID: a.tileID,
                  pixelToTileUnitsFactor: X,
                };
                var Z;
              }
              _bufferedScreenMercator(a, u) {
                const g = rs(a);
                if (this._screenRaycastCache[g])
                  return this._screenRaycastCache[g];
                {
                  let v;
                  return (
                    (v =
                      "globe" === u.projection.name
                        ? this._projectAndResample(
                            this.bufferedScreenGeometry(a),
                            u
                          )
                        : {
                            polygon: this.bufferedScreenGeometry(a).map((b) =>
                              u.pointCoordinate3D(b)
                            ),
                            unwrapped: !0,
                          }),
                    (this._screenRaycastCache[g] = v),
                    v
                  );
                }
              }
              _bufferedCameraMercator(a, u) {
                const g = rs(a);
                if (this._cameraRaycastCache[g])
                  return this._cameraRaycastCache[g];
                {
                  let v;
                  return (
                    (v =
                      "globe" === u.projection.name
                        ? this._projectAndResample(
                            this.bufferedCameraGeometryGlobe(a),
                            u
                          )
                        : {
                            polygon: this.bufferedCameraGeometry(a).map((b) =>
                              u.pointCoordinate3D(b)
                            ),
                            unwrapped: !0,
                          }),
                    (this._cameraRaycastCache[g] = v),
                    v
                  );
                }
              }
              _projectAndResample(a, u) {
                const g = (function (b, D) {
                  const I = d.multiply([], D.pixelMatrix, D.globeMatrix),
                    M = [0, -d.GLOBE_RADIUS, 0, 1],
                    R = [0, d.GLOBE_RADIUS, 0, 1],
                    k = [0, 0, 0, 1];
                  d.transformMat4$1(M, M, I),
                    d.transformMat4$1(R, R, I),
                    d.transformMat4$1(k, k, I);
                  const z = new d.Point(M[0] / M[3], M[1] / M[3]),
                    H = new d.Point(R[0] / R[3], R[1] / R[3]),
                    q = d.polygonContainsPoint(b, z) && M[3] < k[3],
                    X = d.polygonContainsPoint(b, H) && R[3] < k[3];
                  if (!q && !X) return null;
                  const Z = (function (ue, _e, ge) {
                    for (let Te = 1; Te < ue.length; Te++) {
                      const Ge = Os(_e.pointCoordinate3D(ue[Te - 1]).x),
                        be = Os(_e.pointCoordinate3D(ue[Te]).x);
                      if (ge < 0) {
                        if (Ge < be) return { idx: Te, t: -Ge / (be - 1 - Ge) };
                      } else if (be < Ge)
                        return { idx: Te, t: (1 - Ge) / (be + 1 - Ge) };
                    }
                    return null;
                  })(b, D, q ? -1 : 1);
                  if (!Z) return null;
                  const { idx: Y, t: B } = Z;
                  let W = Y > 1 ? ci(b.slice(0, Y), D) : [],
                    ee = Y < b.length ? ci(b.slice(Y), D) : [];
                  (W = W.map((ue) => new d.Point(Os(ue.x), ue.y))),
                    (ee = ee.map((ue) => new d.Point(Os(ue.x), ue.y)));
                  const te = [...W];
                  0 === te.length && te.push(ee[ee.length - 1]);
                  const he = d.number(
                    te[te.length - 1].y,
                    (0 === ee.length ? W[0] : ee[0]).y,
                    B
                  );
                  let de;
                  return (
                    (de = q
                      ? [
                          new d.Point(0, he),
                          new d.Point(0, 0),
                          new d.Point(1, 0),
                          new d.Point(1, he),
                        ]
                      : [
                          new d.Point(1, he),
                          new d.Point(1, 1),
                          new d.Point(0, 1),
                          new d.Point(0, he),
                        ]),
                    te.push(...de),
                    0 === ee.length ? te.push(W[0]) : te.push(...ee),
                    {
                      polygon: te.map(
                        (ue) => new d.MercatorCoordinate(ue.x, ue.y)
                      ),
                      unwrapped: !1,
                    }
                  );
                })(a, u);
                if (g) return g;
                const v = (function (b, D) {
                  let I = !1,
                    M = -1 / 0,
                    R = 0;
                  for (let z = 0; z < b.length - 1; z++)
                    b[z].x > M && ((M = b[z].x), (R = z));
                  for (let z = 0; z < b.length - 1; z++) {
                    const H = (R + z) % (b.length - 1),
                      q = b[H],
                      X = b[H + 1];
                    Math.abs(q.x - X.x) > 0.5 &&
                      (q.x < X.x
                        ? ((q.x += 1), 0 === H && (b[b.length - 1].x += 1))
                        : ((X.x += 1), H + 1 === b.length - 1 && (b[0].x += 1)),
                      (I = !0));
                  }
                  const k = d.mercatorXfromLng(D.center.lng);
                  return (
                    I &&
                      k < Math.abs(k - 1) &&
                      b.forEach((z) => {
                        z.x -= 1;
                      }),
                    { polygon: b, unwrapped: I }
                  );
                })(
                  ci(a, u).map((b) => new d.Point(Os(b.x), b.y)),
                  u
                );
                return {
                  polygon: v.polygon.map(
                    (b) => new d.MercatorCoordinate(b.x, b.y)
                  ),
                  unwrapped: v.unwrapped,
                };
              }
            }
            function ci(f, a) {
              return d.resample(
                f,
                (u) => {
                  const g = a.pointCoordinate3D(u);
                  (u.x = g.x), (u.y = g.y);
                },
                1 / 256
              );
            }
            function Os(f) {
              return f < 0 ? 1 + (f % 1) : f % 1;
            }
            function rs(f) {
              return (100 * f) | 0;
            }
            function os(f, a, u, g, v) {
              const b = function (D, I) {
                if (D) return v(D);
                if (I) {
                  f.url && I.tiles && f.tiles && delete f.tiles;
                  const M = d.pick(d.extend(I, f), [
                    "tiles",
                    "minzoom",
                    "maxzoom",
                    "attribution",
                    "mapbox_logo",
                    "bounds",
                    "scheme",
                    "tileSize",
                    "encoding",
                  ]);
                  I.vector_layers &&
                    ((M.vectorLayers = I.vector_layers),
                    (M.vectorLayerIds = M.vectorLayers.map((R) => R.id))),
                    (M.tiles = a.canonicalizeTileset(M, f.url)),
                    v(null, M);
                }
              };
              return f.url
                ? d.getJSON(
                    a.transformRequest(
                      a.normalizeSourceURL(f.url, null, u, g),
                      d.ResourceType.Source
                    ),
                    b
                  )
                : d.exported.frame(() => b(null, f));
            }
            class ss {
              constructor(a, u, g) {
                (this.bounds = d.LngLatBounds.convert(this.validateBounds(a))),
                  (this.minzoom = u || 0),
                  (this.maxzoom = g || 24);
              }
              validateBounds(a) {
                return Array.isArray(a) && 4 === a.length
                  ? [
                      Math.max(-180, a[0]),
                      Math.max(-90, a[1]),
                      Math.min(180, a[2]),
                      Math.min(90, a[3]),
                    ]
                  : [-180, -90, 180, 90];
              }
              contains(a) {
                const u = Math.pow(2, a.z),
                  g = Math.floor(d.mercatorXfromLng(this.bounds.getWest()) * u),
                  v = Math.floor(
                    d.mercatorYfromLat(this.bounds.getNorth()) * u
                  ),
                  b = Math.ceil(d.mercatorXfromLng(this.bounds.getEast()) * u),
                  D = Math.ceil(d.mercatorYfromLat(this.bounds.getSouth()) * u);
                return a.x >= g && a.x < b && a.y >= v && a.y < D;
              }
            }
            class Fs {
              constructor(a, u, g) {
                this.context = a;
                const v = a.gl;
                (this.buffer = v.createBuffer()),
                  (this.dynamicDraw = Boolean(g)),
                  this.context.unbindVAO(),
                  a.bindElementBuffer.set(this.buffer),
                  v.bufferData(
                    v.ELEMENT_ARRAY_BUFFER,
                    u.arrayBuffer,
                    this.dynamicDraw ? v.DYNAMIC_DRAW : v.STATIC_DRAW
                  ),
                  this.dynamicDraw || u.destroy();
              }
              bind() {
                this.context.bindElementBuffer.set(this.buffer);
              }
              updateData(a) {
                const u = this.context.gl;
                this.context.unbindVAO(),
                  this.bind(),
                  u.bufferSubData(u.ELEMENT_ARRAY_BUFFER, 0, a.arrayBuffer);
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            const No = {
              Int8: "BYTE",
              Uint8: "UNSIGNED_BYTE",
              Int16: "SHORT",
              Uint16: "UNSIGNED_SHORT",
              Int32: "INT",
              Uint32: "UNSIGNED_INT",
              Float32: "FLOAT",
            };
            class xl {
              constructor(a, u, g, v) {
                (this.length = u.length),
                  (this.attributes = g),
                  (this.itemSize = u.bytesPerElement),
                  (this.dynamicDraw = v),
                  (this.context = a);
                const b = a.gl;
                (this.buffer = b.createBuffer()),
                  a.bindVertexBuffer.set(this.buffer),
                  b.bufferData(
                    b.ARRAY_BUFFER,
                    u.arrayBuffer,
                    this.dynamicDraw ? b.DYNAMIC_DRAW : b.STATIC_DRAW
                  ),
                  this.dynamicDraw || u.destroy();
              }
              bind() {
                this.context.bindVertexBuffer.set(this.buffer);
              }
              updateData(a) {
                const u = this.context.gl;
                this.bind(), u.bufferSubData(u.ARRAY_BUFFER, 0, a.arrayBuffer);
              }
              enableAttributes(a, u) {
                for (let g = 0; g < this.attributes.length; g++) {
                  const v = u.attributes[this.attributes[g].name];
                  void 0 !== v && a.enableVertexAttribArray(v);
                }
              }
              setVertexAttribPointers(a, u, g) {
                for (let v = 0; v < this.attributes.length; v++) {
                  const b = this.attributes[v],
                    D = u.attributes[b.name];
                  void 0 !== D &&
                    a.vertexAttribPointer(
                      D,
                      b.components,
                      a[No[b.type]],
                      !1,
                      this.itemSize,
                      b.offset + this.itemSize * (g || 0)
                    );
                }
              }
              destroy() {
                this.buffer &&
                  (this.context.gl.deleteBuffer(this.buffer),
                  delete this.buffer);
              }
            }
            class en {
              constructor(a) {
                (this.gl = a.gl),
                  (this.default = this.getDefault()),
                  (this.current = this.default),
                  (this.dirty = !1);
              }
              get() {
                return this.current;
              }
              set(a) {}
              getDefault() {
                return this.default;
              }
              setDefault() {
                this.set(this.default);
              }
            }
            class Ns extends en {
              getDefault() {
                return d.Color.transparent;
              }
              set(a) {
                const u = this.current;
                (a.r !== u.r ||
                  a.g !== u.g ||
                  a.b !== u.b ||
                  a.a !== u.a ||
                  this.dirty) &&
                  (this.gl.clearColor(a.r, a.g, a.b, a.a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class jr extends en {
              getDefault() {
                return 1;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.clearDepth(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Aa extends en {
              getDefault() {
                return 0;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.clearStencil(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Hn extends en {
              getDefault() {
                return [!0, !0, !0, !0];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] ||
                  a[1] !== u[1] ||
                  a[2] !== u[2] ||
                  a[3] !== u[3] ||
                  this.dirty) &&
                  (this.gl.colorMask(a[0], a[1], a[2], a[3]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class to extends en {
              getDefault() {
                return !0;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.depthMask(a), (this.current = a), (this.dirty = !1));
              }
            }
            class lu extends en {
              getDefault() {
                return 255;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.stencilMask(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class zs extends en {
              getDefault() {
                return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
              }
              set(a) {
                const u = this.current;
                (a.func !== u.func ||
                  a.ref !== u.ref ||
                  a.mask !== u.mask ||
                  this.dirty) &&
                  (this.gl.stencilFunc(a.func, a.ref, a.mask),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class no extends en {
              getDefault() {
                const a = this.gl;
                return [a.KEEP, a.KEEP, a.KEEP];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] ||
                  a[1] !== u[1] ||
                  a[2] !== u[2] ||
                  this.dirty) &&
                  (this.gl.stencilOp(a[0], a[1], a[2]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class cu extends en {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.STENCIL_TEST) : u.disable(u.STENCIL_TEST),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class lc extends en {
              getDefault() {
                return [0, 1];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] || a[1] !== u[1] || this.dirty) &&
                  (this.gl.depthRange(a[0], a[1]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class cc extends en {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.DEPTH_TEST) : u.disable(u.DEPTH_TEST),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class as extends en {
              getDefault() {
                return this.gl.LESS;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.depthFunc(a), (this.current = a), (this.dirty = !1));
              }
            }
            class bl extends en {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.BLEND) : u.disable(u.BLEND),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class wl extends en {
              getDefault() {
                const a = this.gl;
                return [a.ONE, a.ZERO];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] || a[1] !== u[1] || this.dirty) &&
                  (this.gl.blendFunc(a[0], a[1]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class uu extends en {
              getDefault() {
                return d.Color.transparent;
              }
              set(a) {
                const u = this.current;
                (a.r !== u.r ||
                  a.g !== u.g ||
                  a.b !== u.b ||
                  a.a !== u.a ||
                  this.dirty) &&
                  (this.gl.blendColor(a.r, a.g, a.b, a.a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Cr extends en {
              getDefault() {
                return this.gl.FUNC_ADD;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.blendEquation(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class ls extends en {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                a ? u.enable(u.CULL_FACE) : u.disable(u.CULL_FACE),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class uc extends en {
              getDefault() {
                return this.gl.BACK;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.cullFace(a), (this.current = a), (this.dirty = !1));
              }
            }
            class Pa extends en {
              getDefault() {
                return this.gl.CCW;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.frontFace(a), (this.current = a), (this.dirty = !1));
              }
            }
            let El,
              io = class extends en {
                getDefault() {
                  return null;
                }
                set(f) {
                  (f !== this.current || this.dirty) &&
                    (this.gl.useProgram(f),
                    (this.current = f),
                    (this.dirty = !1));
                }
              };
            class Bs extends en {
              getDefault() {
                return this.gl.TEXTURE0;
              }
              set(a) {
                (a !== this.current || this.dirty) &&
                  (this.gl.activeTexture(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class Vs extends en {
              getDefault() {
                const a = this.gl;
                return [0, 0, a.drawingBufferWidth, a.drawingBufferHeight];
              }
              set(a) {
                const u = this.current;
                (a[0] !== u[0] ||
                  a[1] !== u[1] ||
                  a[2] !== u[2] ||
                  a[3] !== u[3] ||
                  this.dirty) &&
                  (this.gl.viewport(a[0], a[1], a[2], a[3]),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class js extends en {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindFramebuffer(u.FRAMEBUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class La extends en {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindRenderbuffer(u.RENDERBUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class Tl extends en {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindTexture(u.TEXTURE_2D, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class hu extends en {
              getDefault() {
                return null;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.bindBuffer(u.ARRAY_BUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class se extends en {
              getDefault() {
                return null;
              }
              set(a) {
                const u = this.gl;
                u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class U extends en {
              constructor(a) {
                super(a), (this.vao = a.extVertexArrayObject);
              }
              getDefault() {
                return null;
              }
              set(a) {
                this.vao &&
                  (a !== this.current || this.dirty) &&
                  (this.vao.bindVertexArrayOES(a),
                  (this.current = a),
                  (this.dirty = !1));
              }
            }
            class $ extends en {
              getDefault() {
                return 4;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.pixelStorei(u.UNPACK_ALIGNMENT, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class ne extends en {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class ce extends en {
              getDefault() {
                return !1;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                const u = this.gl;
                u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, a),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class me extends en {
              constructor(a, u) {
                super(a), (this.context = a), (this.parent = u);
              }
              getDefault() {
                return null;
              }
            }
            class ve extends me {
              setDirty() {
                this.dirty = !0;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const u = this.gl;
                u.framebufferTexture2D(
                  u.FRAMEBUFFER,
                  u.COLOR_ATTACHMENT0,
                  u.TEXTURE_2D,
                  a,
                  0
                ),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class ye extends me {
              attachment() {
                return this.gl.DEPTH_ATTACHMENT;
              }
              set(a) {
                if (a === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const u = this.gl;
                u.framebufferRenderbuffer(
                  u.FRAMEBUFFER,
                  this.attachment(),
                  u.RENDERBUFFER,
                  a
                ),
                  (this.current = a),
                  (this.dirty = !1);
              }
            }
            class fe extends ye {
              attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
              }
            }
            class Se {
              constructor(a, u, g, v) {
                (this.context = a), (this.width = u), (this.height = g);
                const b = (this.framebuffer = a.gl.createFramebuffer());
                (this.colorAttachment = new ve(a, b)),
                  v && (this.depthAttachment = new ye(a, b));
              }
              destroy() {
                const a = this.context.gl,
                  u = this.colorAttachment.get();
                if ((u && a.deleteTexture(u), this.depthAttachment)) {
                  const g = this.depthAttachment.get();
                  g && a.deleteRenderbuffer(g);
                }
                a.deleteFramebuffer(this.framebuffer);
              }
            }
            class Ye {
              constructor(a, u = !1) {
                if (
                  ((this.gl = a),
                  (this.isWebGL2 = u),
                  (this.extVertexArrayObject = this.gl.getExtension(
                    "OES_vertex_array_object"
                  )),
                  u)
                ) {
                  const g = a;
                  this.extVertexArrayObject = {
                    createVertexArrayOES: g.createVertexArray.bind(a),
                    deleteVertexArrayOES: g.deleteVertexArray.bind(a),
                    bindVertexArrayOES: g.bindVertexArray.bind(a),
                  };
                }
                (this.clearColor = new Ns(this)),
                  (this.clearDepth = new jr(this)),
                  (this.clearStencil = new Aa(this)),
                  (this.colorMask = new Hn(this)),
                  (this.depthMask = new to(this)),
                  (this.stencilMask = new lu(this)),
                  (this.stencilFunc = new zs(this)),
                  (this.stencilOp = new no(this)),
                  (this.stencilTest = new cu(this)),
                  (this.depthRange = new lc(this)),
                  (this.depthTest = new cc(this)),
                  (this.depthFunc = new as(this)),
                  (this.blend = new bl(this)),
                  (this.blendFunc = new wl(this)),
                  (this.blendColor = new uu(this)),
                  (this.blendEquation = new Cr(this)),
                  (this.cullFace = new ls(this)),
                  (this.cullFaceSide = new uc(this)),
                  (this.frontFace = new Pa(this)),
                  (this.program = new io(this)),
                  (this.activeTexture = new Bs(this)),
                  (this.viewport = new Vs(this)),
                  (this.bindFramebuffer = new js(this)),
                  (this.bindRenderbuffer = new La(this)),
                  (this.bindTexture = new Tl(this)),
                  (this.bindVertexBuffer = new hu(this)),
                  (this.bindElementBuffer = new se(this)),
                  (this.bindVertexArrayOES =
                    this.extVertexArrayObject && new U(this)),
                  (this.pixelStoreUnpack = new $(this)),
                  (this.pixelStoreUnpackPremultiplyAlpha = new ne(this)),
                  (this.pixelStoreUnpackFlipY = new ce(this)),
                  (this.extTextureFilterAnisotropic =
                    a.getExtension("EXT_texture_filter_anisotropic") ||
                    a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                    a.getExtension("WEBKIT_EXT_texture_filter_anisotropic")),
                  this.extTextureFilterAnisotropic &&
                    (this.extTextureFilterAnisotropicMax = a.getParameter(
                      this.extTextureFilterAnisotropic
                        .MAX_TEXTURE_MAX_ANISOTROPY_EXT
                    )),
                  (this.extTextureFilterAnisotropicForceOff = !1),
                  (this.extStandardDerivativesForceOff = !1),
                  (this.extDebugRendererInfo = a.getExtension(
                    "WEBGL_debug_renderer_info"
                  )),
                  this.extDebugRendererInfo &&
                    ((this.renderer = a.getParameter(
                      this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL
                    )),
                    (this.vendor = a.getParameter(
                      this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL
                    ))),
                  u ||
                    (this.extTextureHalfFloat = a.getExtension(
                      "OES_texture_half_float"
                    )),
                  (u ||
                    (this.extTextureHalfFloat &&
                      a.getExtension("OES_texture_half_float_linear"))) &&
                    (this.extRenderToTextureHalfFloat = a.getExtension(
                      "EXT_color_buffer_half_float"
                    )),
                  (this.extStandardDerivatives =
                    u || a.getExtension("OES_standard_derivatives")),
                  (this.extTimerQuery = a.getExtension(
                    "EXT_disjoint_timer_query"
                  )),
                  (this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE));
              }
              setDefault() {
                this.unbindVAO(),
                  this.clearColor.setDefault(),
                  this.clearDepth.setDefault(),
                  this.clearStencil.setDefault(),
                  this.colorMask.setDefault(),
                  this.depthMask.setDefault(),
                  this.stencilMask.setDefault(),
                  this.stencilFunc.setDefault(),
                  this.stencilOp.setDefault(),
                  this.stencilTest.setDefault(),
                  this.depthRange.setDefault(),
                  this.depthTest.setDefault(),
                  this.depthFunc.setDefault(),
                  this.blend.setDefault(),
                  this.blendFunc.setDefault(),
                  this.blendColor.setDefault(),
                  this.blendEquation.setDefault(),
                  this.cullFace.setDefault(),
                  this.cullFaceSide.setDefault(),
                  this.frontFace.setDefault(),
                  this.program.setDefault(),
                  this.activeTexture.setDefault(),
                  this.bindFramebuffer.setDefault(),
                  this.pixelStoreUnpack.setDefault(),
                  this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.pixelStoreUnpackFlipY.setDefault();
              }
              setDirty() {
                (this.clearColor.dirty = !0),
                  (this.clearDepth.dirty = !0),
                  (this.clearStencil.dirty = !0),
                  (this.colorMask.dirty = !0),
                  (this.depthMask.dirty = !0),
                  (this.stencilMask.dirty = !0),
                  (this.stencilFunc.dirty = !0),
                  (this.stencilOp.dirty = !0),
                  (this.stencilTest.dirty = !0),
                  (this.depthRange.dirty = !0),
                  (this.depthTest.dirty = !0),
                  (this.depthFunc.dirty = !0),
                  (this.blend.dirty = !0),
                  (this.blendFunc.dirty = !0),
                  (this.blendColor.dirty = !0),
                  (this.blendEquation.dirty = !0),
                  (this.cullFace.dirty = !0),
                  (this.cullFaceSide.dirty = !0),
                  (this.frontFace.dirty = !0),
                  (this.program.dirty = !0),
                  (this.activeTexture.dirty = !0),
                  (this.viewport.dirty = !0),
                  (this.bindFramebuffer.dirty = !0),
                  (this.bindRenderbuffer.dirty = !0),
                  (this.bindTexture.dirty = !0),
                  (this.bindVertexBuffer.dirty = !0),
                  (this.bindElementBuffer.dirty = !0),
                  this.extVertexArrayObject &&
                    (this.bindVertexArrayOES.dirty = !0),
                  (this.pixelStoreUnpack.dirty = !0),
                  (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
                  (this.pixelStoreUnpackFlipY.dirty = !0);
              }
              createIndexBuffer(a, u) {
                return new Fs(this, a, u);
              }
              createVertexBuffer(a, u, g) {
                return new xl(this, a, u, g);
              }
              createRenderbuffer(a, u, g) {
                const v = this.gl,
                  b = v.createRenderbuffer();
                return (
                  this.bindRenderbuffer.set(b),
                  v.renderbufferStorage(v.RENDERBUFFER, a, u, g),
                  this.bindRenderbuffer.set(null),
                  b
                );
              }
              createFramebuffer(a, u, g) {
                return new Se(this, a, u, g);
              }
              clear({ color: a, depth: u, stencil: g }) {
                const v = this.gl;
                let b = 0;
                a &&
                  ((b |= v.COLOR_BUFFER_BIT),
                  this.clearColor.set(a),
                  this.colorMask.set([!0, !0, !0, !0])),
                  void 0 !== u &&
                    ((b |= v.DEPTH_BUFFER_BIT),
                    this.depthRange.set([0, 1]),
                    this.clearDepth.set(u),
                    this.depthMask.set(!0)),
                  void 0 !== g &&
                    ((b |= v.STENCIL_BUFFER_BIT),
                    this.clearStencil.set(g),
                    this.stencilMask.set(255)),
                  v.clear(b);
              }
              setCullFace(a) {
                !1 === a.enable
                  ? this.cullFace.set(!1)
                  : (this.cullFace.set(!0),
                    this.cullFaceSide.set(a.mode),
                    this.frontFace.set(a.frontFace));
              }
              setDepthMode(a) {
                a.func !== this.gl.ALWAYS || a.mask
                  ? (this.depthTest.set(!0),
                    this.depthFunc.set(a.func),
                    this.depthMask.set(a.mask),
                    this.depthRange.set(a.range))
                  : this.depthTest.set(!1);
              }
              setStencilMode(a) {
                a.test.func !== this.gl.ALWAYS || a.mask
                  ? (this.stencilTest.set(!0),
                    this.stencilMask.set(a.mask),
                    this.stencilOp.set([a.fail, a.depthFail, a.pass]),
                    this.stencilFunc.set({
                      func: a.test.func,
                      ref: a.ref,
                      mask: a.test.mask,
                    }))
                  : this.stencilTest.set(!1);
              }
              setColorMode(a) {
                Be(a.blendFunction, d.ColorMode.Replace)
                  ? this.blend.set(!1)
                  : (this.blend.set(!0),
                    this.blendFunc.set(a.blendFunction),
                    this.blendColor.set(a.blendColor)),
                  this.colorMask.set(a.mask);
              }
              unbindVAO() {
                this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
              }
            }
            class Qe extends d.Evented {
              constructor(a, u, g, v) {
                if (
                  (super(),
                  (this.id = a),
                  (this.dispatcher = g),
                  (this.type = "vector"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.scheme = "xyz"),
                  (this.tileSize = 512),
                  (this.reparseOverscaled = !0),
                  (this.isTileClipped = !0),
                  (this._loaded = !1),
                  d.extend(
                    this,
                    d.pick(u, ["url", "scheme", "tileSize", "promoteId"])
                  ),
                  (this._options = d.extend({ type: "vector" }, u)),
                  (this._collectResourceTiming = u.collectResourceTiming),
                  512 !== this.tileSize)
                )
                  throw new Error(
                    "vector tile sources must have a tileSize of 512"
                  );
                this.setEventedParent(v),
                  (this._tileWorkers = {}),
                  (this._deduped = new d.DedupedRequest());
              }
              load(a) {
                (this._loaded = !1),
                  this.fire(new d.Event("dataloading", { dataType: "source" }));
                const u = Array.isArray(this.map._language)
                    ? this.map._language.join()
                    : this.map._language,
                  g = this.map._worldview;
                this._tileJSONRequest = os(
                  this._options,
                  this.map._requestManager,
                  u,
                  g,
                  (v, b) => {
                    (this._tileJSONRequest = null),
                      (this._loaded = !0),
                      v
                        ? (u &&
                            console.warn(
                              `Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${u}`
                            ),
                          g &&
                            2 !== g.length &&
                            console.warn(
                              `Requested worldview strings must be a valid ISO alpha-2 code. Found: ${g}`
                            ),
                          this.fire(new d.ErrorEvent(v)))
                        : b &&
                          (d.extend(this, b),
                          b.bounds &&
                            (this.tileBounds = new ss(
                              b.bounds,
                              this.minzoom,
                              this.maxzoom
                            )),
                          d.postTurnstileEvent(
                            b.tiles,
                            this.map._requestManager._customAccessToken
                          ),
                          this.fire(
                            new d.Event("data", {
                              dataType: "source",
                              sourceDataType: "metadata",
                            })
                          ),
                          this.fire(
                            new d.Event("data", {
                              dataType: "source",
                              sourceDataType: "content",
                            })
                          )),
                      a && a(v);
                  }
                );
              }
              loaded() {
                return this._loaded;
              }
              hasTile(a) {
                return (
                  !this.tileBounds || this.tileBounds.contains(a.canonical)
                );
              }
              onAdd(a) {
                (this.map = a), this.load();
              }
              reload() {
                this.cancelTileJSONRequest(),
                  this.load(() => this.map.style._clearSource(this.id));
              }
              setTiles(a) {
                return (this._options.tiles = a), this.reload(), this;
              }
              setUrl(a) {
                return (
                  (this.url = a), (this._options.url = a), this.reload(), this
                );
              }
              onRemove() {
                this.cancelTileJSONRequest();
              }
              serialize() {
                return d.extend({}, this._options);
              }
              loadTile(a, u) {
                const g = this.map._requestManager.normalizeTileURL(
                    a.tileID.canonical.url(this.tiles, this.scheme)
                  ),
                  v = {
                    request: this.map._requestManager.transformRequest(
                      g,
                      d.ResourceType.Tile
                    ),
                    data: void 0,
                    uid: a.uid,
                    tileID: a.tileID,
                    tileZoom: a.tileZoom,
                    zoom: a.tileID.overscaledZ,
                    tileSize: this.tileSize * a.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    pixelRatio: d.exported.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: a.isSymbolTile,
                  };
                if (
                  ((v.request.collectResourceTiming =
                    this._collectResourceTiming),
                  a.actor && "expired" !== a.state)
                )
                  "loading" === a.state
                    ? (a.reloadCallback = u)
                    : (a.request = a.actor.send("reloadTile", v, b.bind(this)));
                else if (
                  ((a.actor = this._tileWorkers[g] =
                    this._tileWorkers[g] || this.dispatcher.getActor()),
                  this.dispatcher.ready)
                )
                  a.request = a.actor.send(
                    "loadTile",
                    v,
                    b.bind(this),
                    void 0,
                    !0
                  );
                else {
                  const D = d.loadVectorTile.call(
                    { deduped: this._deduped },
                    v,
                    (I, M) => {
                      I || !M
                        ? b.call(this, I)
                        : ((v.data = {
                            cacheControl: M.cacheControl,
                            expires: M.expires,
                            rawData: M.rawData.slice(0),
                          }),
                          a.actor &&
                            a.actor.send(
                              "loadTile",
                              v,
                              b.bind(this),
                              void 0,
                              !0
                            ));
                    },
                    !0
                  );
                  a.request = { cancel: D };
                }
                function b(D, I) {
                  return (
                    delete a.request,
                    a.aborted
                      ? u(null)
                      : D && 404 !== D.status
                      ? u(D)
                      : (I &&
                          I.resourceTiming &&
                          (a.resourceTiming = I.resourceTiming),
                        this.map._refreshExpiredTiles &&
                          I &&
                          a.setExpiryData(I),
                        a.loadVectorData(I, this.map.painter),
                        d.cacheEntryPossiblyAdded(this.dispatcher),
                        u(null),
                        void (
                          a.reloadCallback &&
                          (this.loadTile(a, a.reloadCallback),
                          (a.reloadCallback = null))
                        ))
                  );
                }
              }
              abortTile(a) {
                a.request && (a.request.cancel(), delete a.request),
                  a.actor &&
                    a.actor.send("abortTile", {
                      uid: a.uid,
                      type: this.type,
                      source: this.id,
                    });
              }
              unloadTile(a) {
                a.unloadVectorData(),
                  a.actor &&
                    a.actor.send("removeTile", {
                      uid: a.uid,
                      type: this.type,
                      source: this.id,
                    });
              }
              hasTransition() {
                return !1;
              }
              afterUpdate() {
                this._tileWorkers = {};
              }
              cancelTileJSONRequest() {
                this._tileJSONRequest &&
                  (this._tileJSONRequest.cancel(),
                  (this._tileJSONRequest = null));
              }
            }
            class We extends d.Evented {
              constructor(a, u, g, v) {
                super(),
                  (this.id = a),
                  (this.dispatcher = g),
                  this.setEventedParent(v),
                  (this.type = "raster"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.roundZoom = !0),
                  (this.scheme = "xyz"),
                  (this.tileSize = 512),
                  (this._loaded = !1),
                  (this._options = d.extend({ type: "raster" }, u)),
                  d.extend(this, d.pick(u, ["url", "scheme", "tileSize"]));
              }
              load(a) {
                (this._loaded = !1),
                  this.fire(new d.Event("dataloading", { dataType: "source" })),
                  (this._tileJSONRequest = os(
                    this._options,
                    this.map._requestManager,
                    null,
                    null,
                    (u, g) => {
                      (this._tileJSONRequest = null),
                        (this._loaded = !0),
                        u
                          ? this.fire(new d.ErrorEvent(u))
                          : g &&
                            (d.extend(this, g),
                            g.bounds &&
                              (this.tileBounds = new ss(
                                g.bounds,
                                this.minzoom,
                                this.maxzoom
                              )),
                            d.postTurnstileEvent(g.tiles),
                            this.fire(
                              new d.Event("data", {
                                dataType: "source",
                                sourceDataType: "metadata",
                              })
                            ),
                            this.fire(
                              new d.Event("data", {
                                dataType: "source",
                                sourceDataType: "content",
                              })
                            )),
                        a && a(u);
                    }
                  ));
              }
              loaded() {
                return this._loaded;
              }
              onAdd(a) {
                (this.map = a), this.load();
              }
              reload() {
                this.cancelTileJSONRequest(),
                  this.load(() => this.map.style._clearSource(this.id));
              }
              setTiles(a) {
                return (this._options.tiles = a), this.reload(), this;
              }
              setUrl(a) {
                return (
                  (this.url = a), (this._options.url = a), this.reload(), this
                );
              }
              onRemove() {
                this.cancelTileJSONRequest();
              }
              serialize() {
                return d.extend({}, this._options);
              }
              hasTile(a) {
                return (
                  !this.tileBounds || this.tileBounds.contains(a.canonical)
                );
              }
              loadTile(a, u) {
                const g = d.exported.devicePixelRatio >= 2,
                  v = this.map._requestManager.normalizeTileURL(
                    a.tileID.canonical.url(this.tiles, this.scheme),
                    g,
                    this.tileSize
                  );
                a.request = d.getImage(
                  this.map._requestManager.transformRequest(
                    v,
                    d.ResourceType.Tile
                  ),
                  (b, D, I, M) => (
                    delete a.request,
                    a.aborted
                      ? ((a.state = "unloaded"), u(null))
                      : b
                      ? ((a.state = "errored"), u(b))
                      : D
                      ? (this.map._refreshExpiredTiles &&
                          a.setExpiryData({ cacheControl: I, expires: M }),
                        a.setTexture(D, this.map.painter),
                        (a.state = "loaded"),
                        d.cacheEntryPossiblyAdded(this.dispatcher),
                        void u(null))
                      : u(null)
                  )
                );
              }
              static loadTileData(a, u, g) {
                a.setTexture(u, g);
              }
              static unloadTileData(a, u) {
                a.texture && u.saveTileTexture(a.texture);
              }
              abortTile(a, u) {
                a.request && (a.request.cancel(), delete a.request), u();
              }
              unloadTile(a, u) {
                a.texture && this.map.painter.saveTileTexture(a.texture), u();
              }
              hasTransition() {
                return !1;
              }
              cancelTileJSONRequest() {
                this._tileJSONRequest &&
                  (this._tileJSONRequest.cancel(),
                  (this._tileJSONRequest = null));
              }
            }
            function Pt(f, a, u, g, v, b, D, I) {
              const M = [f, u, v, a, g, b, 1, 1, 1],
                R = [D, I, 1],
                k = d.adjoint([], M),
                [z, H, q] = d.transformMat3(R, R, d.transpose(k, k));
              return d.multiply$1(M, [z, 0, 0, 0, H, 0, 0, 0, q], M);
            }
            class Bt extends d.Evented {
              constructor(a, u, g, v) {
                super(),
                  (this.id = a),
                  (this.dispatcher = g),
                  (this.coordinates = u.coordinates),
                  (this.type = "image"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.tileSize = 512),
                  (this.tiles = {}),
                  (this._loaded = !1),
                  this.setEventedParent(v),
                  (this.options = u),
                  (this._dirty = !1);
              }
              load(a, u) {
                (this._loaded = u || !1),
                  this.fire(new d.Event("dataloading", { dataType: "source" })),
                  (this.url = this.options.url),
                  (this._imageRequest = d.getImage(
                    this.map._requestManager.transformRequest(
                      this.url,
                      d.ResourceType.Image
                    ),
                    (g, v) => {
                      if (((this._imageRequest = null), (this._loaded = !0), g))
                        this.fire(new d.ErrorEvent(g));
                      else if (v) {
                        const { HTMLImageElement: b } = d.window;
                        (this.image =
                          v instanceof b ? d.exported.getImageData(v) : v),
                          (this._dirty = !0),
                          (this.width = this.image.width),
                          (this.height = this.image.height),
                          a && (this.coordinates = a),
                          this._finishLoading();
                      }
                    }
                  ));
              }
              loaded() {
                return this._loaded;
              }
              updateImage(a) {
                return this.image && a.url
                  ? (this._imageRequest &&
                      a.url !== this.options.url &&
                      (this._imageRequest.cancel(),
                      (this._imageRequest = null)),
                    (this.options.url = a.url),
                    this.load(a.coordinates, this._loaded),
                    this)
                  : this;
              }
              _finishLoading() {
                this.map &&
                  (this.setCoordinates(this.coordinates),
                  this.fire(
                    new d.Event("data", {
                      dataType: "source",
                      sourceDataType: "metadata",
                    })
                  ));
              }
              onAdd(a) {
                (this.map = a), this.load();
              }
              onRemove() {
                this._imageRequest &&
                  (this._imageRequest.cancel(), (this._imageRequest = null)),
                  this.texture && this.texture.destroy();
              }
              setCoordinates(a) {
                (this.coordinates = a), (this._boundsArray = void 0);
                const u = a.map(d.MercatorCoordinate.fromLngLat);
                return (
                  (this.tileID = (function (g) {
                    let v = 1 / 0,
                      b = 1 / 0,
                      D = -1 / 0,
                      I = -1 / 0;
                    for (const z of g)
                      (v = Math.min(v, z.x)),
                        (b = Math.min(b, z.y)),
                        (D = Math.max(D, z.x)),
                        (I = Math.max(I, z.y));
                    const M = Math.max(D - v, I - b),
                      R = Math.max(0, Math.floor(-Math.log(M) / Math.LN2)),
                      k = Math.pow(2, R);
                    return new d.CanonicalTileID(
                      R,
                      Math.floor(((v + D) / 2) * k),
                      Math.floor(((b + I) / 2) * k)
                    );
                  })(u)),
                  (this.minzoom = this.maxzoom = this.tileID.z),
                  this.fire(
                    new d.Event("data", {
                      dataType: "source",
                      sourceDataType: "content",
                    })
                  ),
                  this
                );
              }
              _clear() {
                this._boundsArray = void 0;
              }
              _prepareData(a) {
                for (const M in this.tiles) {
                  const R = this.tiles[M];
                  "loaded" !== R.state &&
                    ((R.state = "loaded"), (R.texture = this.texture));
                }
                if (this._boundsArray) return;
                const u = d.tileTransform(
                    this.tileID,
                    this.map.transform.projection
                  ),
                  [g, v, b, D] = this.coordinates.map((M) => {
                    const R = u.projection.project(M[0], M[1]);
                    return d.getTilePoint(u, R)._round();
                  });
                this.perspectiveTransform = (function (
                  M,
                  R,
                  k,
                  z,
                  H,
                  q,
                  X,
                  Z,
                  Y,
                  B
                ) {
                  const W = Pt(0, 0, M, 0, 0, R, M, R),
                    ee = Pt(k, z, H, q, X, Z, Y, B);
                  return (
                    d.multiply$1(ee, d.adjoint(W, W), ee),
                    [
                      ((ee[6] / ee[8]) * M) / d.EXTENT,
                      ((ee[7] / ee[8]) * R) / d.EXTENT,
                    ]
                  );
                })(
                  this.width,
                  this.height,
                  g.x,
                  g.y,
                  v.x,
                  v.y,
                  D.x,
                  D.y,
                  b.x,
                  b.y
                );
                const I = (this._boundsArray = new d.StructArrayLayout4i8());
                I.emplaceBack(g.x, g.y, 0, 0),
                  I.emplaceBack(v.x, v.y, d.EXTENT, 0),
                  I.emplaceBack(D.x, D.y, 0, d.EXTENT),
                  I.emplaceBack(b.x, b.y, d.EXTENT, d.EXTENT),
                  this.boundsBuffer && this.boundsBuffer.destroy(),
                  (this.boundsBuffer = a.createVertexBuffer(
                    I,
                    d.boundsAttributes.members
                  )),
                  (this.boundsSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
              }
              prepare() {
                if (0 === Object.keys(this.tiles).length || !this.image) return;
                const a = this.map.painter.context,
                  u = a.gl;
                this._dirty &&
                  (this.texture
                    ? this.texture.update(this.image)
                    : ((this.texture = new d.Texture(a, this.image, u.RGBA)),
                      this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE)),
                  (this._dirty = !1)),
                  this._prepareData(a);
              }
              loadTile(a, u) {
                this.tileID && this.tileID.equals(a.tileID.canonical)
                  ? ((this.tiles[String(a.tileID.wrap)] = a),
                    (a.buckets = {}),
                    u(null))
                  : ((a.state = "errored"), u(null));
              }
              serialize() {
                return {
                  type: "image",
                  url: this.options.url,
                  coordinates: this.coordinates,
                };
              }
              hasTransition() {
                return !1;
              }
            }
            const Et = {
                vector: Qe,
                raster: We,
                "raster-dem": class extends We {
                  constructor(f, a, u, g) {
                    super(f, a, u, g),
                      (this.type = "raster-dem"),
                      (this.maxzoom = 22),
                      (this._options = d.extend({ type: "raster-dem" }, a)),
                      (this.encoding = a.encoding || "mapbox");
                  }
                  loadTile(f, a) {
                    const u = this.map._requestManager.normalizeTileURL(
                      f.tileID.canonical.url(this.tiles, this.scheme),
                      !1,
                      this.tileSize
                    );
                    function g(v, b) {
                      v && ((f.state = "errored"), a(v)),
                        b &&
                          ((f.dem = b),
                          f.dem.onDeserialize(),
                          (f.needsHillshadePrepare = !0),
                          (f.needsDEMTextureUpload = !0),
                          (f.state = "loaded"),
                          a(null));
                    }
                    f.request = d.getImage(
                      this.map._requestManager.transformRequest(
                        u,
                        d.ResourceType.Tile
                      ),
                      function (v, b, D, I) {
                        if ((delete f.request, f.aborted))
                          (f.state = "unloaded"), a(null);
                        else if (v) (f.state = "errored"), a(v);
                        else if (b) {
                          this.map._refreshExpiredTiles &&
                            f.setExpiryData({ cacheControl: D, expires: I });
                          const M =
                              d.window.ImageBitmap &&
                              b instanceof d.window.ImageBitmap &&
                              (null == El &&
                                (El =
                                  d.window.OffscreenCanvas &&
                                  new d.window.OffscreenCanvas(1, 1).getContext(
                                    "2d"
                                  ) &&
                                  "function" ==
                                    typeof d.window.createImageBitmap),
                              El),
                            R = 1 - (b.width - d.prevPowerOfTwo(b.width)) / 2;
                          R < 1 ||
                            f.neighboringTiles ||
                            (f.neighboringTiles = this._getNeighboringTiles(
                              f.tileID
                            ));
                          const k = M ? b : d.exported.getImageData(b, R),
                            z = {
                              uid: f.uid,
                              coord: f.tileID,
                              source: this.id,
                              rawImageData: k,
                              encoding: this.encoding,
                              padding: R,
                            };
                          (f.actor && "expired" !== f.state) ||
                            ((f.actor = this.dispatcher.getActor()),
                            f.actor.send(
                              "loadDEMTile",
                              z,
                              g.bind(this),
                              void 0,
                              !0
                            ));
                        }
                      }.bind(this)
                    );
                  }
                  _getNeighboringTiles(f) {
                    const a = f.canonical,
                      u = Math.pow(2, a.z),
                      g = (a.x - 1 + u) % u,
                      v = 0 === a.x ? f.wrap - 1 : f.wrap,
                      b = (a.x + 1 + u) % u,
                      D = a.x + 1 === u ? f.wrap + 1 : f.wrap,
                      I = {};
                    return (
                      (I[
                        new d.OverscaledTileID(
                          f.overscaledZ,
                          v,
                          a.z,
                          g,
                          a.y
                        ).key
                      ] = { backfilled: !1 }),
                      (I[
                        new d.OverscaledTileID(
                          f.overscaledZ,
                          D,
                          a.z,
                          b,
                          a.y
                        ).key
                      ] = { backfilled: !1 }),
                      a.y > 0 &&
                        ((I[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            v,
                            a.z,
                            g,
                            a.y - 1
                          ).key
                        ] = { backfilled: !1 }),
                        (I[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            f.wrap,
                            a.z,
                            a.x,
                            a.y - 1
                          ).key
                        ] = { backfilled: !1 }),
                        (I[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            D,
                            a.z,
                            b,
                            a.y - 1
                          ).key
                        ] = { backfilled: !1 })),
                      a.y + 1 < u &&
                        ((I[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            v,
                            a.z,
                            g,
                            a.y + 1
                          ).key
                        ] = { backfilled: !1 }),
                        (I[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            f.wrap,
                            a.z,
                            a.x,
                            a.y + 1
                          ).key
                        ] = { backfilled: !1 }),
                        (I[
                          new d.OverscaledTileID(
                            f.overscaledZ,
                            D,
                            a.z,
                            b,
                            a.y + 1
                          ).key
                        ] = { backfilled: !1 })),
                      I
                    );
                  }
                  unloadTile(f) {
                    f.demTexture &&
                      this.map.painter.saveTileTexture(f.demTexture),
                      f.fbo && (f.fbo.destroy(), delete f.fbo),
                      f.dem && delete f.dem,
                      delete f.neighboringTiles,
                      (f.state = "unloaded");
                  }
                },
                geojson: class extends d.Evented {
                  constructor(f, a, u, g) {
                    super(),
                      (this.id = f),
                      (this.type = "geojson"),
                      (this.minzoom = 0),
                      (this.maxzoom = 18),
                      (this.tileSize = 512),
                      (this.isTileClipped = !0),
                      (this.reparseOverscaled = !0),
                      (this._loaded = !1),
                      (this.actor = u.getActor()),
                      this.setEventedParent(g),
                      (this._data = a.data),
                      (this._options = d.extend({}, a)),
                      (this._collectResourceTiming = a.collectResourceTiming),
                      void 0 !== a.maxzoom && (this.maxzoom = a.maxzoom),
                      a.type && (this.type = a.type),
                      a.attribution && (this.attribution = a.attribution),
                      (this.promoteId = a.promoteId);
                    const v = d.EXTENT / this.tileSize;
                    this.workerOptions = d.extend(
                      {
                        source: this.id,
                        cluster: a.cluster || !1,
                        geojsonVtOptions: {
                          buffer: (void 0 !== a.buffer ? a.buffer : 128) * v,
                          tolerance:
                            (void 0 !== a.tolerance ? a.tolerance : 0.375) * v,
                          extent: d.EXTENT,
                          maxZoom: this.maxzoom,
                          lineMetrics: a.lineMetrics || !1,
                          generateId: a.generateId || !1,
                        },
                        superclusterOptions: {
                          maxZoom:
                            void 0 !== a.clusterMaxZoom
                              ? a.clusterMaxZoom
                              : this.maxzoom - 1,
                          minPoints: Math.max(2, a.clusterMinPoints || 2),
                          extent: d.EXTENT,
                          radius:
                            (void 0 !== a.clusterRadius
                              ? a.clusterRadius
                              : 50) * v,
                          log: !1,
                          generateId: a.generateId || !1,
                        },
                        clusterProperties: a.clusterProperties,
                        filter: a.filter,
                      },
                      a.workerOptions
                    );
                  }
                  onAdd(f) {
                    (this.map = f), this.setData(this._data);
                  }
                  setData(f) {
                    return (this._data = f), this._updateWorkerData(), this;
                  }
                  getClusterExpansionZoom(f, a) {
                    return (
                      this.actor.send(
                        "geojson.getClusterExpansionZoom",
                        { clusterId: f, source: this.id },
                        a
                      ),
                      this
                    );
                  }
                  getClusterChildren(f, a) {
                    return (
                      this.actor.send(
                        "geojson.getClusterChildren",
                        { clusterId: f, source: this.id },
                        a
                      ),
                      this
                    );
                  }
                  getClusterLeaves(f, a, u, g) {
                    return (
                      this.actor.send(
                        "geojson.getClusterLeaves",
                        { source: this.id, clusterId: f, limit: a, offset: u },
                        g
                      ),
                      this
                    );
                  }
                  _updateWorkerData() {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(
                      new d.Event("dataloading", { dataType: "source" })
                    ),
                      (this._loaded = !1);
                    const f = d.extend({}, this.workerOptions),
                      a = this._data;
                    "string" == typeof a
                      ? ((f.request = this.map._requestManager.transformRequest(
                          d.exported.resolveURL(a),
                          d.ResourceType.Source
                        )),
                        (f.request.collectResourceTiming =
                          this._collectResourceTiming))
                      : (f.data = JSON.stringify(a)),
                      (this._pendingLoad = this.actor.send(
                        `${this.type}.loadData`,
                        f,
                        (u, g) => {
                          if (
                            ((this._loaded = !0), (this._pendingLoad = null), u)
                          )
                            this.fire(new d.ErrorEvent(u));
                          else {
                            const v = {
                              dataType: "source",
                              sourceDataType: this._metadataFired
                                ? "content"
                                : "metadata",
                            };
                            this._collectResourceTiming &&
                              g &&
                              g.resourceTiming &&
                              g.resourceTiming[this.id] &&
                              (v.resourceTiming = g.resourceTiming[this.id]),
                              this.fire(new d.Event("data", v)),
                              (this._metadataFired = !0);
                          }
                          this._coalesce &&
                            (this._updateWorkerData(), (this._coalesce = !1));
                        }
                      ));
                  }
                  loaded() {
                    return this._loaded;
                  }
                  loadTile(f, a) {
                    const u = f.actor ? "reloadTile" : "loadTile";
                    (f.actor = this.actor),
                      (f.request = this.actor.send(
                        u,
                        {
                          type: this.type,
                          uid: f.uid,
                          tileID: f.tileID,
                          tileZoom: f.tileZoom,
                          zoom: f.tileID.overscaledZ,
                          maxZoom: this.maxzoom,
                          tileSize: this.tileSize,
                          source: this.id,
                          pixelRatio: d.exported.devicePixelRatio,
                          showCollisionBoxes: this.map.showCollisionBoxes,
                          promoteId: this.promoteId,
                        },
                        (g, v) => (
                          delete f.request,
                          f.unloadVectorData(),
                          f.aborted
                            ? a(null)
                            : g
                            ? a(g)
                            : (f.loadVectorData(
                                v,
                                this.map.painter,
                                "reloadTile" === u
                              ),
                              a(null))
                        ),
                        void 0,
                        "loadTile" === u
                      ));
                  }
                  abortTile(f) {
                    f.request && (f.request.cancel(), delete f.request),
                      (f.aborted = !0);
                  }
                  unloadTile(f) {
                    f.unloadVectorData(),
                      this.actor.send("removeTile", {
                        uid: f.uid,
                        type: this.type,
                        source: this.id,
                      });
                  }
                  onRemove() {
                    this._pendingLoad && this._pendingLoad.cancel();
                  }
                  serialize() {
                    return d.extend({}, this._options, {
                      type: this.type,
                      data: this._data,
                    });
                  }
                  hasTransition() {
                    return !1;
                  }
                },
                video: class extends Bt {
                  constructor(f, a, u, g) {
                    super(f, a, u, g),
                      (this.roundZoom = !0),
                      (this.type = "video"),
                      (this.options = a);
                  }
                  load() {
                    this._loaded = !1;
                    const f = this.options;
                    this.urls = [];
                    for (const a of f.urls)
                      this.urls.push(
                        this.map._requestManager.transformRequest(
                          a,
                          d.ResourceType.Source
                        ).url
                      );
                    d.getVideo(this.urls, (a, u) => {
                      (this._loaded = !0),
                        a
                          ? this.fire(new d.ErrorEvent(a))
                          : u &&
                            ((this.video = u),
                            (this.video.loop = !0),
                            this.video.setAttribute("playsinline", ""),
                            this.video.addEventListener("playing", () => {
                              this.map.triggerRepaint();
                            }),
                            this.map && this.video.play(),
                            this._finishLoading());
                    });
                  }
                  pause() {
                    this.video && this.video.pause();
                  }
                  play() {
                    this.video && this.video.play();
                  }
                  seek(f) {
                    if (this.video) {
                      const a = this.video.seekable;
                      f < a.start(0) || f > a.end(0)
                        ? this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${this.id}`,
                                null,
                                `Playback for this video can be set only between the ${a.start(
                                  0
                                )} and ${a.end(0)}-second mark.`
                              )
                            )
                          )
                        : (this.video.currentTime = f);
                    }
                  }
                  getVideo() {
                    return this.video;
                  }
                  onAdd(f) {
                    this.map ||
                      ((this.map = f),
                      this.load(),
                      this.video &&
                        (this.video.play(),
                        this.setCoordinates(this.coordinates)));
                  }
                  prepare() {
                    if (
                      0 === Object.keys(this.tiles).length ||
                      this.video.readyState < 2
                    )
                      return;
                    const f = this.map.painter.context,
                      a = f.gl;
                    this.texture
                      ? this.video.paused ||
                        (this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE),
                        a.texSubImage2D(
                          a.TEXTURE_2D,
                          0,
                          0,
                          0,
                          a.RGBA,
                          a.UNSIGNED_BYTE,
                          this.video
                        ))
                      : ((this.texture = new d.Texture(f, this.video, a.RGBA)),
                        this.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE),
                        (this.width = this.video.videoWidth),
                        (this.height = this.video.videoHeight)),
                      this._prepareData(f);
                  }
                  serialize() {
                    return {
                      type: "video",
                      urls: this.urls,
                      coordinates: this.coordinates,
                    };
                  }
                  hasTransition() {
                    return this.video && !this.video.paused;
                  }
                },
                image: Bt,
                canvas: class extends Bt {
                  constructor(f, a, u, g) {
                    super(f, a, u, g),
                      a.coordinates
                        ? (Array.isArray(a.coordinates) &&
                            4 === a.coordinates.length &&
                            !a.coordinates.some(
                              (v) =>
                                !Array.isArray(v) ||
                                2 !== v.length ||
                                v.some((b) => "number" != typeof b)
                            )) ||
                          this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                '"coordinates" property must be an array of 4 longitude/latitude array pairs'
                              )
                            )
                          )
                        : this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                'missing required property "coordinates"'
                              )
                            )
                          ),
                      a.animate &&
                        "boolean" != typeof a.animate &&
                        this.fire(
                          new d.ErrorEvent(
                            new d.ValidationError(
                              `sources.${f}`,
                              null,
                              'optional "animate" property must be a boolean value'
                            )
                          )
                        ),
                      a.canvas
                        ? "string" == typeof a.canvas ||
                          a.canvas instanceof d.window.HTMLCanvasElement ||
                          this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'
                              )
                            )
                          )
                        : this.fire(
                            new d.ErrorEvent(
                              new d.ValidationError(
                                `sources.${f}`,
                                null,
                                'missing required property "canvas"'
                              )
                            )
                          ),
                      (this.options = a),
                      (this.animate = void 0 === a.animate || a.animate);
                  }
                  load() {
                    (this._loaded = !0),
                      this.canvas ||
                        (this.canvas =
                          this.options.canvas instanceof
                          d.window.HTMLCanvasElement
                            ? this.options.canvas
                            : d.window.document.getElementById(
                                this.options.canvas
                              )),
                      (this.width = this.canvas.width),
                      (this.height = this.canvas.height),
                      this._hasInvalidDimensions()
                        ? this.fire(
                            new d.ErrorEvent(
                              new Error(
                                "Canvas dimensions cannot be less than or equal to zero."
                              )
                            )
                          )
                        : ((this.play = function () {
                            (this._playing = !0), this.map.triggerRepaint();
                          }),
                          (this.pause = function () {
                            this._playing &&
                              (this.prepare(), (this._playing = !1));
                          }),
                          this._finishLoading());
                  }
                  getCanvas() {
                    return this.canvas;
                  }
                  onAdd(f) {
                    (this.map = f),
                      this.load(),
                      this.canvas && this.animate && this.play();
                  }
                  onRemove() {
                    this.pause();
                  }
                  prepare() {
                    let f = !1;
                    if (
                      (this.canvas.width !== this.width &&
                        ((this.width = this.canvas.width), (f = !0)),
                      this.canvas.height !== this.height &&
                        ((this.height = this.canvas.height), (f = !0)),
                      this._hasInvalidDimensions() ||
                        0 === Object.keys(this.tiles).length)
                    )
                      return;
                    const a = this.map.painter.context;
                    this.texture
                      ? (f || this._playing) &&
                        this.texture.update(this.canvas, { premultiply: !0 })
                      : (this.texture = new d.Texture(
                          a,
                          this.canvas,
                          a.gl.RGBA,
                          { premultiply: !0 }
                        )),
                      this._prepareData(a);
                  }
                  serialize() {
                    return { type: "canvas", coordinates: this.coordinates };
                  }
                  hasTransition() {
                    return this._playing;
                  }
                  _hasInvalidDimensions() {
                    for (const f of [this.canvas.width, this.canvas.height])
                      if (isNaN(f) || f <= 0) return !0;
                    return !1;
                  }
                },
                custom: class extends d.Evented {
                  constructor(f, a, u, g) {
                    super(),
                      (this.id = f),
                      (this.type = "custom"),
                      (this._dataType = "raster"),
                      (this._dispatcher = u),
                      (this._implementation = a),
                      this.setEventedParent(g),
                      (this.scheme = "xyz"),
                      (this.minzoom = 0),
                      (this.maxzoom = 22),
                      (this.tileSize = 512),
                      (this._loaded = !1),
                      (this.roundZoom = !0),
                      this._implementation ||
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              `Missing implementation for ${this.id} custom source`
                            )
                          )
                        ),
                      this._implementation.loadTile ||
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              `Missing loadTile implementation for ${this.id} custom source`
                            )
                          )
                        ),
                      this._implementation.bounds &&
                        (this.tileBounds = new ss(
                          this._implementation.bounds,
                          this.minzoom,
                          this.maxzoom
                        )),
                      (a.update = this._update.bind(this)),
                      (a.clearTiles = this._clearTiles.bind(this)),
                      (a.coveringTiles = this._coveringTiles.bind(this)),
                      d.extend(
                        this,
                        d.pick(a, [
                          "dataType",
                          "scheme",
                          "minzoom",
                          "maxzoom",
                          "tileSize",
                          "attribution",
                          "minTileCacheSize",
                          "maxTileCacheSize",
                        ])
                      );
                  }
                  serialize() {
                    return d.pick(this, [
                      "type",
                      "scheme",
                      "minzoom",
                      "maxzoom",
                      "tileSize",
                      "attribution",
                    ]);
                  }
                  load() {
                    (this._loaded = !0),
                      this.fire(
                        new d.Event("data", {
                          dataType: "source",
                          sourceDataType: "metadata",
                        })
                      ),
                      this.fire(
                        new d.Event("data", {
                          dataType: "source",
                          sourceDataType: "content",
                        })
                      );
                  }
                  loaded() {
                    return this._loaded;
                  }
                  onAdd(f) {
                    (this._map = f),
                      (this._loaded = !1),
                      this.fire(
                        new d.Event("dataloading", { dataType: "source" })
                      ),
                      this._implementation.onAdd &&
                        this._implementation.onAdd(f),
                      this.load();
                  }
                  onRemove(f) {
                    this._implementation.onRemove &&
                      this._implementation.onRemove(f);
                  }
                  hasTile(f) {
                    if (this._implementation.hasTile) {
                      const { x: a, y: u, z: g } = f.canonical;
                      return this._implementation.hasTile({ x: a, y: u, z: g });
                    }
                    return (
                      !this.tileBounds || this.tileBounds.contains(f.canonical)
                    );
                  }
                  loadTile(f, a) {
                    const { x: u, y: g, z: v } = f.tileID.canonical,
                      b = new d.window.AbortController();
                    (f.request = Promise.resolve(
                      this._implementation.loadTile(
                        { x: u, y: g, z: v },
                        { signal: b.signal }
                      )
                    )
                      .then(
                        function (D) {
                          return (
                            delete f.request,
                            f.aborted
                              ? ((f.state = "unloaded"), a(null))
                              : void 0 === D
                              ? ((f.state = "errored"), a(null))
                              : null === D
                              ? (this.loadTileData(f, {
                                  width: this.tileSize,
                                  height: this.tileSize,
                                  data: null,
                                }),
                                (f.state = "loaded"),
                                a(null))
                              : (I = D) instanceof d.window.ImageData ||
                                I instanceof d.window.HTMLCanvasElement ||
                                I instanceof d.window.ImageBitmap ||
                                I instanceof d.window.HTMLImageElement
                              ? (this.loadTileData(f, D),
                                (f.state = "loaded"),
                                void a(null))
                              : ((f.state = "errored"),
                                a(
                                  new Error(
                                    `Can't infer data type for ${this.id}, only raster data supported at the moment`
                                  )
                                ))
                          );
                          var I;
                        }.bind(this)
                      )
                      .catch((D) => {
                        20 !== D.code && ((f.state = "errored"), a(D));
                      })),
                      (f.request.cancel = () => b.abort());
                  }
                  loadTileData(f, a) {
                    We.loadTileData(f, a, this._map.painter);
                  }
                  unloadTileData(f) {
                    We.unloadTileData(f, this._map.painter);
                  }
                  unloadTile(f, a) {
                    if (
                      (this.unloadTileData(f), this._implementation.unloadTile)
                    ) {
                      const { x: u, y: g, z: v } = f.tileID.canonical;
                      this._implementation.unloadTile({ x: u, y: g, z: v });
                    }
                    a();
                  }
                  abortTile(f, a) {
                    f.request &&
                      f.request.cancel &&
                      (f.request.cancel(), delete f.request),
                      a();
                  }
                  hasTransition() {
                    return !1;
                  }
                  _coveringTiles() {
                    return this._map.transform
                      .coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom,
                      })
                      .map((f) => ({
                        x: f.canonical.x,
                        y: f.canonical.y,
                        z: f.canonical.z,
                      }));
                  }
                  _clearTiles() {
                    this._map.style._clearSource(this.id);
                  }
                  _update() {
                    this.fire(
                      new d.Event("data", {
                        dataType: "source",
                        sourceDataType: "content",
                      })
                    );
                  }
                },
              },
              Gt = function (f, a, u, g) {
                const v = new Et[a.type](f, a, u, g);
                if (v.id !== f)
                  throw new Error(
                    `Expected Source id to be ${f} instead of ${v.id}`
                  );
                return (
                  d.bindAll(
                    ["load", "abort", "unload", "serialize", "prepare"],
                    v
                  ),
                  v
                );
              };
            function tn(f, a) {
              const u = d.identity([]);
              return (
                d.scale(u, u, [0.5 * f.width, 0.5 * -f.height, 1]),
                d.translate(u, u, [1, -1, 0]),
                d.multiply(u, u, f.calculateProjMatrix(a.toUnwrapped())),
                Float32Array.from(u)
              );
            }
            function Gn(f, a, u, g, v, b, D, I = !1) {
              const M = f.tilesIn(g, D, I);
              M.sort(Xi);
              const R = [];
              for (const z of M)
                R.push({
                  wrappedTileID: z.tile.tileID.wrapped().key,
                  queryResults: z.tile.queryRenderedFeatures(
                    a,
                    u,
                    f._state,
                    z,
                    v,
                    b,
                    tn(f.transform, z.tile.tileID),
                    I
                  ),
                });
              const k = (function (z) {
                const H = {},
                  q = {};
                for (const X of z) {
                  const Z = X.queryResults,
                    Y = X.wrappedTileID,
                    B = (q[Y] = q[Y] || {});
                  for (const W in Z) {
                    const ee = Z[W],
                      te = (B[W] = B[W] || {}),
                      he = (H[W] = H[W] || []);
                    for (const de of ee)
                      te[de.featureIndex] ||
                        ((te[de.featureIndex] = !0), he.push(de));
                  }
                }
                return H;
              })(R);
              for (const z in k)
                k[z].forEach((H) => {
                  const q = H.feature,
                    X = q.layer;
                  X &&
                    "background" !== X.type &&
                    "sky" !== X.type &&
                    ((q.source = X.source),
                    X["source-layer"] && (q.sourceLayer = X["source-layer"]),
                    (q.state =
                      void 0 !== q.id
                        ? f.getFeatureState(X["source-layer"], q.id)
                        : {}));
                });
              return k;
            }
            function ui(f, a) {
              const u = f.getRenderableIds().map((b) => f.getTileByID(b)),
                g = [],
                v = {};
              for (let b = 0; b < u.length; b++) {
                const D = u[b],
                  I = D.tileID.canonical.key;
                v[I] || ((v[I] = !0), D.querySourceFeatures(g, a));
              }
              return g;
            }
            function Xi(f, a) {
              const u = f.tileID,
                g = a.tileID;
              return (
                u.overscaledZ - g.overscaledZ ||
                u.canonical.y - g.canonical.y ||
                u.wrap - g.wrap ||
                u.canonical.x - g.canonical.x
              );
            }
            function wi() {
              return null != qa.workerClass
                ? new qa.workerClass()
                : new d.window.Worker(qa.workerUrl);
            }
            const zo = "mapboxgl_preloaded_worker_pool";
            class qn {
              constructor() {
                this.active = {};
              }
              acquire(a) {
                if (!this.workers)
                  for (
                    this.workers = [];
                    this.workers.length < qn.workerCount;

                  )
                    this.workers.push(new wi());
                return (this.active[a] = !0), this.workers.slice();
              }
              release(a) {
                delete this.active[a],
                  0 === this.numActive() &&
                    (this.workers.forEach((u) => {
                      u.terminate();
                    }),
                    (this.workers = null));
              }
              isPreloaded() {
                return !!this.active[zo];
              }
              numActive() {
                return Object.keys(this.active).length;
              }
            }
            let fr;
            function ka() {
              return fr || (fr = new qn()), fr;
            }
            function Lf(f, a) {
              const u = {};
              for (const g in f) "ref" !== g && (u[g] = f[g]);
              return (
                d.refProperties.forEach((g) => {
                  g in a && (u[g] = a[g]);
                }),
                u
              );
            }
            function Sh(f) {
              f = f.slice();
              const a = Object.create(null);
              for (let u = 0; u < f.length; u++) a[f[u].id] = f[u];
              for (let u = 0; u < f.length; u++)
                "ref" in f[u] && (f[u] = Lf(f[u], a[f[u].ref]));
              return f;
            }
            qn.workerCount = 2;
            const _n = {
              setStyle: "setStyle",
              addLayer: "addLayer",
              removeLayer: "removeLayer",
              setPaintProperty: "setPaintProperty",
              setLayoutProperty: "setLayoutProperty",
              setFilter: "setFilter",
              addSource: "addSource",
              removeSource: "removeSource",
              setGeoJSONSourceData: "setGeoJSONSourceData",
              setLayerZoomRange: "setLayerZoomRange",
              setLayerProperty: "setLayerProperty",
              setCenter: "setCenter",
              setZoom: "setZoom",
              setBearing: "setBearing",
              setPitch: "setPitch",
              setSprite: "setSprite",
              setGlyphs: "setGlyphs",
              setTransition: "setTransition",
              setLight: "setLight",
              setTerrain: "setTerrain",
              setFog: "setFog",
              setProjection: "setProjection",
            };
            function Ih(f, a, u) {
              u.push({ command: _n.addSource, args: [f, a[f]] });
            }
            function hc(f, a, u) {
              a.push({ command: _n.removeSource, args: [f] }), (u[f] = !0);
            }
            function dc(f, a, u, g) {
              hc(f, u, g), Ih(f, a, u);
            }
            function Ch(f, a, u) {
              let g;
              for (g in f[u])
                if (
                  f[u].hasOwnProperty(g) &&
                  "data" !== g &&
                  !Be(f[u][g], a[u][g])
                )
                  return !1;
              for (g in a[u])
                if (
                  a[u].hasOwnProperty(g) &&
                  "data" !== g &&
                  !Be(f[u][g], a[u][g])
                )
                  return !1;
              return !0;
            }
            function Bo(f, a, u, g, v, b) {
              let D;
              for (D in ((a = a || {}), (f = f || {})))
                f.hasOwnProperty(D) &&
                  (Be(f[D], a[D]) ||
                    u.push({ command: b, args: [g, D, a[D], v] }));
              for (D in a)
                a.hasOwnProperty(D) &&
                  !f.hasOwnProperty(D) &&
                  (Be(f[D], a[D]) ||
                    u.push({ command: b, args: [g, D, a[D], v] }));
            }
            function cs(f) {
              return f.id;
            }
            function du(f, a) {
              return (f[a.id] = a), f;
            }
            class pu {
              constructor(a, u) {
                this.reset(a, u);
              }
              reset(a, u) {
                (this.points = a || []), (this._distances = [0]);
                for (let g = 1; g < this.points.length; g++)
                  this._distances[g] =
                    this._distances[g - 1] +
                    this.points[g].dist(this.points[g - 1]);
                (this.length = this._distances[this._distances.length - 1]),
                  (this.padding = Math.min(u || 0, 0.5 * this.length)),
                  (this.paddedLength = this.length - 2 * this.padding);
              }
              lerp(a) {
                if (1 === this.points.length) return this.points[0];
                a = d.clamp(a, 0, 1);
                let u = 1,
                  g = this._distances[u];
                const v = a * this.paddedLength + this.padding;
                for (; g < v && u < this._distances.length; )
                  g = this._distances[++u];
                const b = u - 1,
                  D = this._distances[b],
                  I = g - D,
                  M = I > 0 ? (v - D) / I : 0;
                return this.points[b].mult(1 - M).add(this.points[u].mult(M));
              }
            }
            class Ra {
              constructor(a, u, g) {
                const v = (this.boxCells = []),
                  b = (this.circleCells = []);
                (this.xCellCount = Math.ceil(a / g)),
                  (this.yCellCount = Math.ceil(u / g));
                for (let D = 0; D < this.xCellCount * this.yCellCount; D++)
                  v.push([]), b.push([]);
                (this.circleKeys = []),
                  (this.boxKeys = []),
                  (this.bboxes = []),
                  (this.circles = []),
                  (this.width = a),
                  (this.height = u),
                  (this.xScale = this.xCellCount / a),
                  (this.yScale = this.yCellCount / u),
                  (this.boxUid = 0),
                  (this.circleUid = 0);
              }
              keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
              }
              insert(a, u, g, v, b) {
                this._forEachCell(
                  u,
                  g,
                  v,
                  b,
                  this._insertBoxCell,
                  this.boxUid++
                ),
                  this.boxKeys.push(a),
                  this.bboxes.push(u),
                  this.bboxes.push(g),
                  this.bboxes.push(v),
                  this.bboxes.push(b);
              }
              insertCircle(a, u, g, v) {
                this._forEachCell(
                  u - v,
                  g - v,
                  u + v,
                  g + v,
                  this._insertCircleCell,
                  this.circleUid++
                ),
                  this.circleKeys.push(a),
                  this.circles.push(u),
                  this.circles.push(g),
                  this.circles.push(v);
              }
              _insertBoxCell(a, u, g, v, b, D) {
                this.boxCells[b].push(D);
              }
              _insertCircleCell(a, u, g, v, b, D) {
                this.circleCells[b].push(D);
              }
              _query(a, u, g, v, b, D) {
                if (g < 0 || a > this.width || v < 0 || u > this.height)
                  return !b && [];
                const I = [];
                if (a <= 0 && u <= 0 && this.width <= g && this.height <= v) {
                  if (b) return !0;
                  for (let M = 0; M < this.boxKeys.length; M++)
                    I.push({
                      key: this.boxKeys[M],
                      x1: this.bboxes[4 * M],
                      y1: this.bboxes[4 * M + 1],
                      x2: this.bboxes[4 * M + 2],
                      y2: this.bboxes[4 * M + 3],
                    });
                  for (let M = 0; M < this.circleKeys.length; M++) {
                    const R = this.circles[3 * M],
                      k = this.circles[3 * M + 1],
                      z = this.circles[3 * M + 2];
                    I.push({
                      key: this.circleKeys[M],
                      x1: R - z,
                      y1: k - z,
                      x2: R + z,
                      y2: k + z,
                    });
                  }
                  return D ? I.filter(D) : I;
                }
                return (
                  this._forEachCell(
                    a,
                    u,
                    g,
                    v,
                    this._queryCell,
                    I,
                    { hitTest: b, seenUids: { box: {}, circle: {} } },
                    D
                  ),
                  b ? I.length > 0 : I
                );
              }
              _queryCircle(a, u, g, v, b) {
                const D = a - g,
                  I = a + g,
                  M = u - g,
                  R = u + g;
                if (I < 0 || D > this.width || R < 0 || M > this.height)
                  return !v && [];
                const k = [];
                return (
                  this._forEachCell(
                    D,
                    M,
                    I,
                    R,
                    this._queryCellCircle,
                    k,
                    {
                      hitTest: v,
                      circle: { x: a, y: u, radius: g },
                      seenUids: { box: {}, circle: {} },
                    },
                    b
                  ),
                  v ? k.length > 0 : k
                );
              }
              query(a, u, g, v, b) {
                return this._query(a, u, g, v, !1, b);
              }
              hitTest(a, u, g, v, b) {
                return this._query(a, u, g, v, !0, b);
              }
              hitTestCircle(a, u, g, v) {
                return this._queryCircle(a, u, g, !0, v);
              }
              _queryCell(a, u, g, v, b, D, I, M) {
                const R = I.seenUids,
                  k = this.boxCells[b];
                if (null !== k) {
                  const H = this.bboxes;
                  for (const q of k)
                    if (!R.box[q]) {
                      R.box[q] = !0;
                      const X = 4 * q;
                      if (
                        a <= H[X + 2] &&
                        u <= H[X + 3] &&
                        g >= H[X + 0] &&
                        v >= H[X + 1] &&
                        (!M || M(this.boxKeys[q]))
                      ) {
                        if (I.hitTest) return D.push(!0), !0;
                        D.push({
                          key: this.boxKeys[q],
                          x1: H[X],
                          y1: H[X + 1],
                          x2: H[X + 2],
                          y2: H[X + 3],
                        });
                      }
                    }
                }
                const z = this.circleCells[b];
                if (null !== z) {
                  const H = this.circles;
                  for (const q of z)
                    if (!R.circle[q]) {
                      R.circle[q] = !0;
                      const X = 3 * q;
                      if (
                        this._circleAndRectCollide(
                          H[X],
                          H[X + 1],
                          H[X + 2],
                          a,
                          u,
                          g,
                          v
                        ) &&
                        (!M || M(this.circleKeys[q]))
                      ) {
                        if (I.hitTest) return D.push(!0), !0;
                        {
                          const Z = H[X],
                            Y = H[X + 1],
                            B = H[X + 2];
                          D.push({
                            key: this.circleKeys[q],
                            x1: Z - B,
                            y1: Y - B,
                            x2: Z + B,
                            y2: Y + B,
                          });
                        }
                      }
                    }
                }
              }
              _queryCellCircle(a, u, g, v, b, D, I, M) {
                const R = I.circle,
                  k = I.seenUids,
                  z = this.boxCells[b];
                if (null !== z) {
                  const q = this.bboxes;
                  for (const X of z)
                    if (!k.box[X]) {
                      k.box[X] = !0;
                      const Z = 4 * X;
                      if (
                        this._circleAndRectCollide(
                          R.x,
                          R.y,
                          R.radius,
                          q[Z + 0],
                          q[Z + 1],
                          q[Z + 2],
                          q[Z + 3]
                        ) &&
                        (!M || M(this.boxKeys[X]))
                      )
                        return D.push(!0), !0;
                    }
                }
                const H = this.circleCells[b];
                if (null !== H) {
                  const q = this.circles;
                  for (const X of H)
                    if (!k.circle[X]) {
                      k.circle[X] = !0;
                      const Z = 3 * X;
                      if (
                        this._circlesCollide(
                          q[Z],
                          q[Z + 1],
                          q[Z + 2],
                          R.x,
                          R.y,
                          R.radius
                        ) &&
                        (!M || M(this.circleKeys[X]))
                      )
                        return D.push(!0), !0;
                    }
                }
              }
              _forEachCell(a, u, g, v, b, D, I, M) {
                const R = this._convertToXCellCoord(a),
                  k = this._convertToYCellCoord(u),
                  z = this._convertToXCellCoord(g),
                  H = this._convertToYCellCoord(v);
                for (let q = R; q <= z; q++)
                  for (let X = k; X <= H; X++)
                    if (
                      b.call(this, a, u, g, v, this.xCellCount * X + q, D, I, M)
                    )
                      return;
              }
              _convertToXCellCoord(a) {
                return Math.max(
                  0,
                  Math.min(this.xCellCount - 1, Math.floor(a * this.xScale))
                );
              }
              _convertToYCellCoord(a) {
                return Math.max(
                  0,
                  Math.min(this.yCellCount - 1, Math.floor(a * this.yScale))
                );
              }
              _circlesCollide(a, u, g, v, b, D) {
                const I = v - a,
                  M = b - u,
                  R = g + D;
                return R * R > I * I + M * M;
              }
              _circleAndRectCollide(a, u, g, v, b, D, I) {
                const M = (D - v) / 2,
                  R = Math.abs(a - (v + M));
                if (R > M + g) return !1;
                const k = (I - b) / 2,
                  z = Math.abs(u - (b + k));
                if (z > k + g) return !1;
                if (R <= M || z <= k) return !0;
                const H = R - M,
                  q = z - k;
                return H * H + q * q <= g * g;
              }
            }
            const us_unknown = 0,
              us_flipRequired = 1,
              us_flipNotRequired = 2,
              pc = Math.tan((85 * Math.PI) / 180);
            function Ae(f, a, u, g, v, b, D) {
              const I = d.create();
              if (u)
                if ("globe" === b.name) {
                  const M = d.calculateGlobeLabelMatrix(v, a);
                  d.multiply(I, I, M);
                } else {
                  const M = et([], D);
                  (I[0] = M[0]),
                    (I[1] = M[1]),
                    (I[4] = M[2]),
                    (I[5] = M[3]),
                    g || d.rotateZ(I, I, v.angle);
                }
              else d.multiply(I, v.labelPlaneMatrix, f);
              return I;
            }
            function Vo(f, a, u, g, v, b, D) {
              const I = Ae(f, a, u, g, v, b, D);
              return (
                ("globe" === b.name && u) || (I[2] = I[6] = I[10] = I[14] = 0),
                I
              );
            }
            function hi(f, a, u, g, v, b, D) {
              if (u) {
                if ("globe" === b.name) {
                  const I = Ae(f, a, u, g, v, b, D);
                  return d.invert(I, I), d.multiply(I, f, I), I;
                }
                {
                  const I = d.clone(f),
                    M = d.identity([]);
                  return (
                    (M[0] = D[0]),
                    (M[1] = D[1]),
                    (M[4] = D[2]),
                    (M[5] = D[3]),
                    d.multiply(I, I, M),
                    g || d.rotateZ(I, I, -v.angle),
                    I
                  );
                }
              }
              return v.glCoordMatrix;
            }
            function Fi(f, a, u, g) {
              const v = [f, a, u, 1];
              u ? d.transformMat4$1(v, v, g) : tt(v, v, g);
              const b = v[3];
              return (v[0] /= b), (v[1] /= b), (v[2] /= b), v;
            }
            function op(f, a) {
              return Math.min(0.5 + (f / a) * 0.5, 1.5);
            }
            function jo(f, a) {
              const u = f[0] / f[3],
                g = f[1] / f[3];
              return u >= -a[0] && u <= a[0] && g >= -a[1] && g <= a[1];
            }
            function Mh(f, a, u, g, v, b, D, I, M, R) {
              const k = u.transform,
                z = g ? f.textSizeData : f.iconSizeData,
                H = d.evaluateSizeForZoom(z, u.transform.zoom),
                q = "globe" === k.projection.name,
                X = [(256 / u.width) * 2 + 1, (256 / u.height) * 2 + 1],
                Z = g
                  ? f.text.dynamicLayoutVertexArray
                  : f.icon.dynamicLayoutVertexArray;
              Z.clear();
              let Y = null;
              q &&
                (Y = g
                  ? f.text.globeExtVertexArray
                  : f.icon.globeExtVertexArray);
              const B = f.lineVertexArray,
                W = g ? f.text.placedSymbolArray : f.icon.placedSymbolArray,
                ee = u.transform.width / u.transform.height;
              let te,
                he = !1;
              for (let de = 0; de < W.length; de++) {
                const ue = W.get(de),
                  { numGlyphs: _e, writingMode: ge } = ue;
                if (
                  (ge !== d.WritingMode.vertical ||
                    he ||
                    te === d.WritingMode.horizontal ||
                    (he = !0),
                  (te = ge),
                  (ue.hidden || ge === d.WritingMode.vertical) && !he)
                ) {
                  Mr(_e, Z);
                  continue;
                }
                he = !1;
                const Te = new d.Point(ue.tileAnchorX, ue.tileAnchorY);
                let {
                  x: Ge,
                  y: be,
                  z: Le,
                } = k.projection.projectTilePoint(Te.x, Te.y, R.canonical);
                if (M) {
                  const [Dt, ct, wt] = M(Te);
                  (Ge += Dt), (be += ct), (Le += wt);
                }
                const Ie = [Ge, be, Le, 1];
                if ((d.transformMat4$1(Ie, Ie, a), !jo(Ie, X))) {
                  Mr(_e, Z);
                  continue;
                }
                const je = op(u.transform.cameraToCenterDistance, Ie[3]),
                  we = d.evaluateSizeForFeature(z, H, ue),
                  ke = D ? we / je : we * je,
                  He = Fi(Ge, be, Le, v);
                if (He[3] <= 0) {
                  Mr(_e, Z);
                  continue;
                }
                let Ne = {};
                const Xe = D ? null : M,
                  dt = it(
                    ue,
                    ke,
                    !1,
                    I,
                    a,
                    v,
                    b,
                    f.glyphOffsetArray,
                    B,
                    Z,
                    Y,
                    He,
                    Te,
                    Ne,
                    ee,
                    Xe,
                    k.projection,
                    R,
                    D
                  );
                (he = dt.useVertical),
                  Xe && dt.needsFlipping && (Ne = {}),
                  (dt.notEnoughRoom ||
                    he ||
                    (dt.needsFlipping &&
                      it(
                        ue,
                        ke,
                        !0,
                        I,
                        a,
                        v,
                        b,
                        f.glyphOffsetArray,
                        B,
                        Z,
                        Y,
                        He,
                        Te,
                        Ne,
                        ee,
                        Xe,
                        k.projection,
                        R,
                        D
                      ).notEnoughRoom)) &&
                    Mr(_e, Z);
              }
              g
                ? (f.text.dynamicLayoutVertexBuffer.updateData(Z),
                  Y && f.text.globeExtVertexBuffer.updateData(Y))
                : (f.icon.dynamicLayoutVertexBuffer.updateData(Z),
                  Y && f.icon.globeExtVertexBuffer.updateData(Y));
            }
            function fu(f, a, u, g, v, b, D, I, M, R, k, z, H, q, X, Z) {
              const { lineStartIndex: Y, glyphStartIndex: B, segment: W } = I,
                ee = B + I.numGlyphs,
                te = Y + I.lineLength,
                he = a.getoffsetX(B),
                de = a.getoffsetX(ee - 1),
                ue = Ur(
                  f * he,
                  u,
                  g,
                  v,
                  b,
                  D,
                  W,
                  Y,
                  te,
                  M,
                  R,
                  k,
                  z,
                  H,
                  !0,
                  q,
                  X,
                  Z
                );
              if (!ue) return null;
              const _e = Ur(
                f * de,
                u,
                g,
                v,
                b,
                D,
                W,
                Y,
                te,
                M,
                R,
                k,
                z,
                H,
                !0,
                q,
                X,
                Z
              );
              return _e ? { first: ue, last: _e } : null;
            }
            function wn(f, a, u, g) {
              return f === d.WritingMode.horizontal && Math.abs(g) > Math.abs(u)
                ? { useVertical: !0 }
                : f === d.WritingMode.vertical
                ? g > 0
                  ? { needsFlipping: !0 }
                  : null
                : a !== us_unknown && (0 === (v = u) || Math.abs(g / v) > pc)
                ? a === us_flipRequired
                  ? { needsFlipping: !0 }
                  : null
                : u < 0
                ? { needsFlipping: !0 }
                : null;
              var v;
            }
            function it(
              f,
              a,
              u,
              g,
              v,
              b,
              D,
              I,
              M,
              R,
              k,
              z,
              H,
              q,
              X,
              Z,
              Y,
              B,
              W
            ) {
              const ee = a / 24,
                te = f.lineOffsetX * ee,
                he = f.lineOffsetY * ee,
                {
                  lineStartIndex: de,
                  glyphStartIndex: ue,
                  numGlyphs: _e,
                  segment: ge,
                  writingMode: Te,
                  flipState: Ge,
                } = f,
                be = de + f.lineLength,
                Le = (Ie) => {
                  if (k) {
                    const [He, Ne, Xe] = Ie.up,
                      dt = R.length;
                    d.updateGlobeVertexNormal(k, dt + 0, He, Ne, Xe),
                      d.updateGlobeVertexNormal(k, dt + 1, He, Ne, Xe),
                      d.updateGlobeVertexNormal(k, dt + 2, He, Ne, Xe),
                      d.updateGlobeVertexNormal(k, dt + 3, He, Ne, Xe);
                  }
                  const [je, we, ke] = Ie.point;
                  d.addDynamicAttributes(R, je, we, ke, Ie.angle);
                };
              if (_e > 1) {
                const Ie = fu(
                  ee,
                  I,
                  te,
                  he,
                  u,
                  z,
                  H,
                  f,
                  M,
                  b,
                  q,
                  Z,
                  !1,
                  Y,
                  B,
                  W
                );
                if (!Ie) return { notEnoughRoom: !0 };
                if (g && !u) {
                  let [je, we, ke] = Ie.first.point,
                    [He, Ne, Xe] = Ie.last.point;
                  ([je, we] = Fi(je, we, ke, D)),
                    ([He, Ne] = Fi(He, Ne, Xe, D));
                  const dt = wn(Te, Ge, (He - je) * X, Ne - we);
                  if (
                    ((f.flipState =
                      dt && dt.needsFlipping
                        ? us_flipRequired
                        : us_flipNotRequired),
                    dt)
                  )
                    return dt;
                }
                Le(Ie.first);
                for (let je = ue + 1; je < ue + _e - 1; je++) {
                  const we = Ur(
                    ee * I.getoffsetX(je),
                    te,
                    he,
                    u,
                    z,
                    H,
                    ge,
                    de,
                    be,
                    M,
                    b,
                    q,
                    Z,
                    !1,
                    !1,
                    Y,
                    B,
                    W
                  );
                  if (!we)
                    return (R.length -= 4 * (je - ue)), { notEnoughRoom: !0 };
                  Le(we);
                }
                Le(Ie.last);
              } else {
                if (g && !u) {
                  const je = Fi(H.x, H.y, 0, v),
                    we = de + ge + 1,
                    ke = new d.Point(M.getx(we), M.gety(we)),
                    He = Fi(ke.x, ke.y, 0, v),
                    Ne =
                      He[3] > 0
                        ? He
                        : Vt(H, ke, je, 1, v, void 0, Y, B.canonical),
                    Xe = wn(Te, Ge, (Ne[0] - je[0]) * X, Ne[1] - je[1]);
                  if (
                    ((f.flipState =
                      Xe && Xe.needsFlipping
                        ? us_flipRequired
                        : us_flipNotRequired),
                    Xe)
                  )
                    return Xe;
                }
                const Ie = Ur(
                  ee * I.getoffsetX(ue),
                  te,
                  he,
                  u,
                  z,
                  H,
                  ge,
                  de,
                  be,
                  M,
                  b,
                  q,
                  Z,
                  !1,
                  !1,
                  Y,
                  B,
                  W
                );
                if (!Ie) return { notEnoughRoom: !0 };
                Le(Ie);
              }
              return {};
            }
            function _t(f, a, u, g, v) {
              const { x: b, y: D, z: I } = g.projectTilePoint(f.x, f.y, a);
              if (!v) return Fi(b, D, I, u);
              const [M, R, k] = v(f);
              return Fi(b + M, D + R, I + k, u);
            }
            function Vt(f, a, u, g, v, b, D, I) {
              const M = _t(f.sub(a)._unit()._add(f), I, v, D, b);
              return (
                d.sub(M, u, M), d.normalize(M, M), d.scaleAndAdd(M, u, M, g)
              );
            }
            function Ur(f, a, u, g, v, b, D, I, M, R, k, z, H, q, X, Z, Y, B) {
              const W = g ? f - a : f + a;
              let ee = W > 0 ? 1 : -1,
                te = 0;
              g && ((ee *= -1), (te = Math.PI)), ee < 0 && (te += Math.PI);
              let he = (I + D + (ee > 0 ? 0 : 1)) | 0,
                de = v,
                ue = v,
                _e = 0,
                ge = 0;
              const Te = Math.abs(W),
                Ge = [],
                be = [];
              let Le = b,
                Ie = Le;
              const je = () =>
                Vt(Ie, Le, ue, Te - _e + 1, k, H, Z, Y.canonical);
              for (; _e + ge <= Te; ) {
                if (((he += ee), he < I || he >= M)) return null;
                if (
                  ((ue = de),
                  (Ie = Le),
                  Ge.push(ue),
                  q && be.push(Ie),
                  (Le = new d.Point(R.getx(he), R.gety(he))),
                  (de = z[he]),
                  !de)
                ) {
                  const wt = _t(Le, Y.canonical, k, Z, H);
                  de = wt[3] > 0 ? (z[he] = wt) : je();
                }
                (_e += ge), (ge = d.distance(ue, de));
              }
              X &&
                H &&
                (z[he] && ((de = je()), (ge = d.distance(ue, de))),
                (z[he] = de));
              const we = (Te - _e) / ge,
                ke = Le.sub(Ie)._mult(we)._add(Ie),
                He = d.sub([], de, ue),
                Ne = d.scaleAndAdd([], ue, He, we);
              let Xe = [0, 0, 1],
                dt = He[0],
                Dt = He[1];
              if (
                B &&
                ((Xe = Z.upVector(Y.canonical, ke.x, ke.y)),
                0 !== Xe[0] || 0 !== Xe[1] || 1 !== Xe[2])
              ) {
                const wt = [Xe[2], 0, -Xe[0]],
                  Wt = d.cross([], Xe, wt);
                d.normalize(wt, wt),
                  d.normalize(Wt, Wt),
                  (dt = d.dot(He, wt)),
                  (Dt = d.dot(He, Wt));
              }
              if (u) {
                const wt = d.cross([], Xe, He);
                d.normalize(wt, wt), d.scaleAndAdd(Ne, Ne, wt, u * ee);
              }
              const ct = te + Math.atan2(Dt, dt);
              return (
                Ge.push(Ne),
                q && be.push(ke),
                { point: Ne, angle: ct, path: Ge, tilePath: be, up: Xe }
              );
            }
            function Mr(f, a) {
              const u = a.length,
                g = u + 4 * f;
              a.resize(g), a.float32.fill(-1 / 0, 4 * u, 4 * g);
            }
            function tt(f, a, u) {
              const g = a[0],
                v = a[1];
              return (
                (f[0] = u[0] * g + u[4] * v + u[12]),
                (f[1] = u[1] * g + u[5] * v + u[13]),
                (f[3] = u[3] * g + u[7] * v + u[15]),
                f
              );
            }
            const mr = 100;
            class mu {
              constructor(
                a,
                u,
                g = new Ra(a.width + 200, a.height + 200, 25),
                v = new Ra(a.width + 200, a.height + 200, 25)
              ) {
                (this.transform = a),
                  (this.grid = g),
                  (this.ignoredGrid = v),
                  (this.pitchfactor =
                    Math.cos(a._pitch) * a.cameraToCenterDistance),
                  (this.screenRightBoundary = a.width + mr),
                  (this.screenBottomBoundary = a.height + mr),
                  (this.gridRightBoundary = a.width + 200),
                  (this.gridBottomBoundary = a.height + 200),
                  (this.fogState = u);
              }
              placeCollisionBox(a, u, g, v, b, D, I, M) {
                let R = g.projectedAnchorX,
                  k = g.projectedAnchorY,
                  z = g.projectedAnchorZ;
                const H = g.elevation,
                  q = g.tileID,
                  X = a.getProjection();
                if (H && q) {
                  const [de, ue, _e] = X.upVector(
                      q.canonical,
                      g.tileAnchorX,
                      g.tileAnchorY
                    ),
                    ge = X.upVectorScale(
                      q.canonical,
                      this.transform.center.lat,
                      this.transform.worldSize
                    ).metersToTile;
                  (R += de * H * ge), (k += ue * H * ge), (z += _e * H * ge);
                }
                const Z = this.projectAndGetPerspectiveRatio(
                    I,
                    R,
                    k,
                    z,
                    g.tileID,
                    "globe" === X.name || !!H || this.transform.pitch > 0,
                    X
                  ),
                  Y = D * Z.perspectiveRatio,
                  B = (g.x1 * u + v.x - g.padding) * Y + Z.point.x,
                  W = (g.y1 * u + v.y - g.padding) * Y + Z.point.y,
                  ee = (g.x2 * u + v.x + g.padding) * Y + Z.point.x,
                  te = (g.y2 * u + v.y + g.padding) * Y + Z.point.y,
                  he = Z.perspectiveRatio <= 0.55 || Z.occluded;
                return !this.isInsideGrid(B, W, ee, te) ||
                  (!b && this.grid.hitTest(B, W, ee, te, M)) ||
                  he
                  ? { box: [], offscreen: !1, occluded: Z.occluded }
                  : {
                      box: [B, W, ee, te],
                      offscreen: this.isOffscreen(B, W, ee, te),
                      occluded: !1,
                    };
              }
              placeCollisionCircles(
                a,
                u,
                g,
                v,
                b,
                D,
                I,
                M,
                R,
                k,
                z,
                H,
                q,
                X,
                Z
              ) {
                const Y = [],
                  B = this.transform.elevation,
                  W = a.getProjection(),
                  ee = B
                    ? B.getAtTileOffsetFunc(
                        Z,
                        this.transform.center.lat,
                        this.transform.worldSize,
                        W
                      )
                    : null,
                  te = new d.Point(g.tileAnchorX, g.tileAnchorY);
                let {
                  x: he,
                  y: de,
                  z: ue,
                } = W.projectTilePoint(te.x, te.y, Z.canonical);
                if (ee) {
                  const [ke, He, Ne] = ee(te);
                  (he += ke), (de += He), (ue += Ne);
                }
                const _e = "globe" === W.name,
                  ge = this.projectAndGetPerspectiveRatio(
                    I,
                    he,
                    de,
                    ue,
                    Z,
                    _e || !!B || this.transform.pitch > 0,
                    W
                  ),
                  { perspectiveRatio: Te } = ge,
                  Ge = (z ? D / Te : D * Te) / d.ONE_EM,
                  be = Fi(he, de, ue, M),
                  Le =
                    ge.signedDistanceFromCamera > 0
                      ? fu(
                          Ge,
                          b,
                          g.lineOffsetX * Ge,
                          g.lineOffsetY * Ge,
                          !1,
                          be,
                          te,
                          g,
                          v,
                          M,
                          {},
                          B && !z ? ee : null,
                          z && !!B,
                          W,
                          Z,
                          z
                        )
                      : null;
                let Ie = !1,
                  je = !1,
                  we = !0;
                if (Le && !ge.occluded) {
                  const ke = 0.5 * q * Te + X,
                    He = new d.Point(-100, -100),
                    Ne = new d.Point(
                      this.screenRightBoundary,
                      this.screenBottomBoundary
                    ),
                    Xe = new pu(),
                    { first: dt, last: Dt } = Le,
                    ct = dt.path.length;
                  let wt = [];
                  for (let ft = ct - 1; ft >= 1; ft--) wt.push(dt.path[ft]);
                  for (let ft = 1; ft < Dt.path.length; ft++)
                    wt.push(Dt.path[ft]);
                  const Wt = 2.5 * ke;
                  R &&
                    ((wt = wt.map(
                      ([ft, Yt, kn], fn) => (
                        ee &&
                          !_e &&
                          (kn = ee(
                            fn < ct - 1
                              ? dt.tilePath[ct - 1 - fn]
                              : Dt.tilePath[fn - ct + 2]
                          )[2]),
                        Fi(ft, Yt, kn, R)
                      )
                    )),
                    wt.some((ft) => ft[3] <= 0) && (wt = []));
                  let jt = [];
                  if (wt.length > 0) {
                    let ft = 1 / 0,
                      Yt = -1 / 0,
                      kn = 1 / 0,
                      fn = -1 / 0;
                    for (const Tn of wt)
                      (ft = Math.min(ft, Tn[0])),
                        (kn = Math.min(kn, Tn[1])),
                        (Yt = Math.max(Yt, Tn[0])),
                        (fn = Math.max(fn, Tn[1]));
                    Yt >= He.x &&
                      ft <= Ne.x &&
                      fn >= He.y &&
                      kn <= Ne.y &&
                      ((jt = [wt.map((Tn) => new d.Point(Tn[0], Tn[1]))]),
                      (ft < He.x || Yt > Ne.x || kn < He.y || fn > Ne.y) &&
                        (jt = d.clipLine(jt, He.x, He.y, Ne.x, Ne.y)));
                  }
                  for (const ft of jt) {
                    Xe.reset(ft, 0.25 * ke);
                    let Yt = 0;
                    Yt =
                      Xe.length <= 0.5 * ke
                        ? 1
                        : Math.ceil(Xe.paddedLength / Wt) + 1;
                    for (let kn = 0; kn < Yt; kn++) {
                      const fn = kn / Math.max(Yt - 1, 1),
                        Tn = Xe.lerp(fn),
                        ji = Tn.x + mr,
                        mi = Tn.y + mr;
                      Y.push(ji, mi, ke, 0);
                      const br = ji - ke,
                        Ko = mi - ke,
                        Un = ji + ke,
                        Cn = mi + ke;
                      if (
                        ((we = we && this.isOffscreen(br, Ko, Un, Cn)),
                        (je = je || this.isInsideGrid(br, Ko, Un, Cn)),
                        !u &&
                          this.grid.hitTestCircle(ji, mi, ke, H) &&
                          ((Ie = !0), !k))
                      )
                        return {
                          circles: [],
                          offscreen: !1,
                          collisionDetected: Ie,
                          occluded: !1,
                        };
                    }
                  }
                }
                return {
                  circles: (!k && Ie) || !je ? [] : Y,
                  offscreen: we,
                  collisionDetected: Ie,
                  occluded: ge.occluded,
                };
              }
              queryRenderedSymbols(a) {
                if (
                  0 === a.length ||
                  (0 === this.grid.keysLength() &&
                    0 === this.ignoredGrid.keysLength())
                )
                  return {};
                const u = [];
                let g = 1 / 0,
                  v = 1 / 0,
                  b = -1 / 0,
                  D = -1 / 0;
                for (const k of a) {
                  const z = new d.Point(k.x + mr, k.y + mr);
                  (g = Math.min(g, z.x)),
                    (v = Math.min(v, z.y)),
                    (b = Math.max(b, z.x)),
                    (D = Math.max(D, z.y)),
                    u.push(z);
                }
                const I = this.grid
                    .query(g, v, b, D)
                    .concat(this.ignoredGrid.query(g, v, b, D)),
                  M = {},
                  R = {};
                for (const k of I) {
                  const z = k.key;
                  if (
                    (void 0 === M[z.bucketInstanceId] &&
                      (M[z.bucketInstanceId] = {}),
                    M[z.bucketInstanceId][z.featureIndex])
                  )
                    continue;
                  const H = [
                    new d.Point(k.x1, k.y1),
                    new d.Point(k.x2, k.y1),
                    new d.Point(k.x2, k.y2),
                    new d.Point(k.x1, k.y2),
                  ];
                  d.polygonIntersectsPolygon(u, H) &&
                    ((M[z.bucketInstanceId][z.featureIndex] = !0),
                    void 0 === R[z.bucketInstanceId] &&
                      (R[z.bucketInstanceId] = []),
                    R[z.bucketInstanceId].push(z.featureIndex));
                }
                return R;
              }
              insertCollisionBox(a, u, g, v, b) {
                (u ? this.ignoredGrid : this.grid).insert(
                  { bucketInstanceId: g, featureIndex: v, collisionGroupID: b },
                  a[0],
                  a[1],
                  a[2],
                  a[3]
                );
              }
              insertCollisionCircles(a, u, g, v, b) {
                const D = u ? this.ignoredGrid : this.grid,
                  I = {
                    bucketInstanceId: g,
                    featureIndex: v,
                    collisionGroupID: b,
                  };
                for (let M = 0; M < a.length; M += 4)
                  D.insertCircle(I, a[M], a[M + 1], a[M + 2]);
              }
              projectAndGetPerspectiveRatio(a, u, g, v, b, D, I) {
                const M = [u, g, v, 1];
                let R = !1;
                v || this.transform.pitch > 0
                  ? (d.transformMat4$1(M, M, a),
                    this.fogState &&
                      b &&
                      "globe" !== I.name &&
                      (R =
                        (function (H, q, X, Z, Y, B) {
                          const W = B.calculateFogTileMatrix(Y),
                            ee = [q, X, Z];
                          return (
                            d.transformMat4(ee, ee, W),
                            Ca(H, ee, B.pitch, B._fov)
                          );
                        })(
                          this.fogState,
                          u,
                          g,
                          v,
                          b.toUnwrapped(),
                          this.transform
                        ) > 0.9))
                  : tt(M, M, a);
                const k = M[3];
                return {
                  point: new d.Point(
                    ((M[0] / k + 1) / 2) * this.transform.width + mr,
                    ((-M[1] / k + 1) / 2) * this.transform.height + mr
                  ),
                  perspectiveRatio: Math.min(
                    0.5 +
                      (this.transform.getCameraToCenterDistance(I) / k) * 0.5,
                    1.5
                  ),
                  signedDistanceFromCamera: k,
                  occluded: (D && M[2] > k) || R,
                };
              }
              isOffscreen(a, u, g, v) {
                return (
                  g < mr ||
                  a >= this.screenRightBoundary ||
                  v < mr ||
                  u > this.screenBottomBoundary
                );
              }
              isInsideGrid(a, u, g, v) {
                return (
                  g >= 0 &&
                  a < this.gridRightBoundary &&
                  v >= 0 &&
                  u < this.gridBottomBoundary
                );
              }
              getViewportMatrix() {
                const a = d.identity([]);
                return d.translate(a, a, [-100, -100, 0]), a;
              }
            }
            function rt(f, a, u) {
              const g = a.createTileMatrix(f, f.worldSize, u.toUnwrapped());
              return d.multiply(new Float32Array(16), f.projMatrix, g);
            }
            function gr(f, a, u) {
              if (a.projection.name === u.projection.name) return f.projMatrix;
              const g = u.clone();
              return g.setProjection(a.projection), rt(g, a.getProjection(), f);
            }
            function pt(f, a, u) {
              return a.name === u.projection.name ? f.projMatrix : rt(u, a, f);
            }
            class En {
              constructor(a, u, g, v) {
                (this.opacity = a
                  ? Math.max(0, Math.min(1, a.opacity + (a.placed ? u : -u)))
                  : v && g
                  ? 1
                  : 0),
                  (this.placed = g);
              }
              isHidden() {
                return 0 === this.opacity && !this.placed;
              }
            }
            class hs {
              constructor(a, u, g, v, b, D = !1) {
                (this.text = new En(a ? a.text : null, u, g, b)),
                  (this.icon = new En(a ? a.icon : null, u, v, b)),
                  (this.clipped = D);
              }
              isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
              }
            }
            class gu {
              constructor(a, u, g, v = !1) {
                (this.text = a),
                  (this.icon = u),
                  (this.skipFade = g),
                  (this.clipped = v);
              }
            }
            class fc {
              constructor() {
                (this.invProjMatrix = d.create()),
                  (this.viewportMatrix = d.create()),
                  (this.circles = []);
              }
            }
            class Dl {
              constructor(a, u, g, v, b) {
                (this.bucketInstanceId = a),
                  (this.featureIndex = u),
                  (this.sourceLayerIndex = g),
                  (this.bucketIndex = v),
                  (this.tileID = b);
              }
            }
            class Ar {
              constructor(a) {
                (this.crossSourceCollisions = a),
                  (this.maxGroupID = 0),
                  (this.collisionGroups = {});
              }
              get(a) {
                if (this.crossSourceCollisions)
                  return { ID: 0, predicate: null };
                if (!this.collisionGroups[a]) {
                  const u = ++this.maxGroupID;
                  this.collisionGroups[a] = {
                    ID: u,
                    predicate: (g) => g.collisionGroupID === u,
                  };
                }
                return this.collisionGroups[a];
              }
            }
            function _u(f, a, u, g, v) {
              const { horizontalAlign: b, verticalAlign: D } =
                  d.getAnchorAlignment(f),
                I = -(b - 0.5) * a,
                M = -(D - 0.5) * u,
                R = d.evaluateVariableOffset(f, g);
              return new d.Point(I + R[0] * v, M + R[1] * v);
            }
            function mc(f, a, u, g, v) {
              const b = new d.Point(f, a);
              return u && b._rotate(g ? v : -v), b;
            }
            class Ah {
              constructor(a, u, g, v, b) {
                (this.transform = a.clone()),
                  (this.projection = a.projection.name),
                  (this.collisionIndex = new mu(this.transform, b)),
                  (this.placements = {}),
                  (this.opacities = {}),
                  (this.variableOffsets = {}),
                  (this.stale = !1),
                  (this.commitTime = 0),
                  (this.fadeDuration = u),
                  (this.retainedQueryData = {}),
                  (this.collisionGroups = new Ar(g)),
                  (this.collisionCircleArrays = {}),
                  (this.prevPlacement = v),
                  v && (v.prevPlacement = void 0),
                  (this.placedOrientations = {});
              }
              getBucketParts(a, u, g, v) {
                const b = g.getBucket(u),
                  D = g.latestFeatureIndex;
                if (!b || !D || u.id !== b.layerIds[0]) return;
                const I = b.layers[0].layout,
                  M = g.collisionBoxArray,
                  R = Math.pow(2, this.transform.zoom - g.tileID.overscaledZ),
                  k = g.tileSize / d.EXTENT,
                  z = g.tileID.toUnwrapped();
                this.transform.setProjection(b.projection);
                const H =
                  ((q = g.tileID),
                  (X = b.getProjection()),
                  (Z = this.transform),
                  X.name === this.projection
                    ? Z.calculateProjMatrix(q.toUnwrapped())
                    : rt(Z, X, q));
                var q, X, Z;
                const Y = "map" === I.get("text-pitch-alignment"),
                  B = "map" === I.get("text-rotation-alignment");
                u.compileFilter();
                const W = u.dynamicFilter(),
                  ee = u.dynamicFilterNeedsFeature(),
                  te = this.transform.calculatePixelsToTileUnitsMatrix(g),
                  he = Vo(
                    H,
                    g.tileID.canonical,
                    Y,
                    B,
                    this.transform,
                    b.getProjection(),
                    te
                  );
                let de = null;
                if (Y) {
                  const ge = hi(
                    H,
                    g.tileID.canonical,
                    Y,
                    B,
                    this.transform,
                    b.getProjection(),
                    te
                  );
                  de = d.multiply([], this.transform.labelPlaneMatrix, ge);
                }
                let ue = null;
                W &&
                  g.latestFeatureIndex &&
                  (ue = {
                    unwrappedTileID: z,
                    dynamicFilter: W,
                    dynamicFilterNeedsFeature: ee,
                    featureIndex: g.latestFeatureIndex,
                  }),
                  (this.retainedQueryData[b.bucketInstanceId] = new Dl(
                    b.bucketInstanceId,
                    D,
                    b.sourceLayerIndex,
                    b.index,
                    g.tileID
                  ));
                const _e = {
                  bucket: b,
                  layout: I,
                  posMatrix: H,
                  textLabelPlaneMatrix: he,
                  labelToScreenMatrix: de,
                  clippingData: ue,
                  scale: R,
                  textPixelRatio: k,
                  holdingForFade: g.holdingForFade(),
                  collisionBoxArray: M,
                  partiallyEvaluatedTextSize: d.evaluateSizeForZoom(
                    b.textSizeData,
                    this.transform.zoom
                  ),
                  partiallyEvaluatedIconSize: d.evaluateSizeForZoom(
                    b.iconSizeData,
                    this.transform.zoom
                  ),
                  collisionGroup: this.collisionGroups.get(b.sourceID),
                };
                if (v)
                  for (const ge of b.sortKeyRanges) {
                    const {
                      sortKey: Te,
                      symbolInstanceStart: Ge,
                      symbolInstanceEnd: be,
                    } = ge;
                    a.push({
                      sortKey: Te,
                      symbolInstanceStart: Ge,
                      symbolInstanceEnd: be,
                      parameters: _e,
                    });
                  }
                else
                  a.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: b.symbolInstances.length,
                    parameters: _e,
                  });
              }
              attemptAnchorPlacement(
                a,
                u,
                g,
                v,
                b,
                D,
                I,
                M,
                R,
                k,
                z,
                H,
                q,
                X,
                Z,
                Y,
                B,
                W
              ) {
                const { textOffset0: ee, textOffset1: te, crossTileID: he } = H,
                  de = [ee, te],
                  ue = _u(a, g, v, de, b),
                  _e = this.collisionIndex.placeCollisionBox(
                    X,
                    b,
                    u,
                    mc(ue.x, ue.y, D, I, this.transform.angle),
                    z,
                    M,
                    R,
                    k.predicate
                  );
                if (Y) {
                  const ge = X.getSymbolInstanceIconSize(
                    W,
                    this.transform.zoom,
                    H.placedIconSymbolIndex
                  );
                  if (
                    0 ===
                    this.collisionIndex.placeCollisionBox(
                      X,
                      ge,
                      Y,
                      mc(ue.x, ue.y, D, I, this.transform.angle),
                      z,
                      M,
                      R,
                      k.predicate
                    ).box.length
                  )
                    return;
                }
                if (_e.box.length > 0) {
                  let ge;
                  return (
                    this.prevPlacement &&
                      this.prevPlacement.variableOffsets[he] &&
                      this.prevPlacement.placements[he] &&
                      this.prevPlacement.placements[he].text &&
                      (ge = this.prevPlacement.variableOffsets[he].anchor),
                    (this.variableOffsets[he] = {
                      textOffset: de,
                      width: g,
                      height: v,
                      anchor: a,
                      textScale: b,
                      prevAnchor: ge,
                    }),
                    this.markUsedJustification(X, a, H, Z),
                    X.allowVerticalPlacement &&
                      (this.markUsedOrientation(X, Z, H),
                      (this.placedOrientations[he] = Z)),
                    { shift: ue, placedGlyphBoxes: _e }
                  );
                }
              }
              placeLayerBucketPart(a, u, g, v) {
                const {
                    bucket: b,
                    layout: D,
                    posMatrix: I,
                    textLabelPlaneMatrix: M,
                    labelToScreenMatrix: R,
                    clippingData: k,
                    textPixelRatio: z,
                    holdingForFade: H,
                    collisionBoxArray: q,
                    partiallyEvaluatedTextSize: X,
                    partiallyEvaluatedIconSize: Z,
                    collisionGroup: Y,
                  } = a.parameters,
                  B = D.get("text-optional"),
                  W = D.get("icon-optional"),
                  ee = D.get("text-allow-overlap"),
                  te = D.get("icon-allow-overlap"),
                  he = "map" === D.get("text-rotation-alignment"),
                  de = "map" === D.get("text-pitch-alignment"),
                  ue = "none" !== D.get("icon-text-fit"),
                  _e = "viewport-y" === D.get("symbol-z-order");
                this.transform.setProjection(b.projection);
                let ge = ee && (te || !b.hasIconData() || W),
                  Te = te && (ee || !b.hasTextData() || B);
                !b.collisionArrays && q && b.deserializeCollisionBoxes(q),
                  g &&
                    v &&
                    b.updateCollisionDebugBuffers(this.transform.zoom, q);
                const Ge = (be, Le, Ie) => {
                  const { crossTileID: je, numVerticalGlyphVertices: we } = be;
                  if (k) {
                    const Un = {
                      zoom: this.transform.zoom,
                      pitch: this.transform.pitch,
                    };
                    let Cn = null;
                    if (k.dynamicFilterNeedsFeature) {
                      const ln = this.retainedQueryData[b.bucketInstanceId];
                      Cn = k.featureIndex.loadFeature({
                        featureIndex: be.featureIndex,
                        bucketIndex: ln.bucketIndex,
                        sourceLayerIndex: ln.sourceLayerIndex,
                        layoutVertexArrayOffset: 0,
                      });
                    }
                    if (
                      !(0, k.dynamicFilter)(
                        Un,
                        Cn,
                        this.retainedQueryData[b.bucketInstanceId].tileID
                          .canonical,
                        new d.Point(be.tileAnchorX, be.tileAnchorY),
                        this.transform.calculateDistanceTileData(
                          k.unwrappedTileID
                        )
                      )
                    )
                      return (
                        (this.placements[je] = new gu(!1, !1, !1, !0)),
                        void u.add(je)
                      );
                  }
                  if (u.has(je)) return;
                  if (H) return void (this.placements[je] = new gu(!1, !1, !1));
                  let ke = !1,
                    He = !1,
                    Ne = !0,
                    Xe = !1,
                    dt = !1,
                    Dt = null,
                    ct = { box: null, offscreen: null, occluded: null },
                    wt = { box: null, offscreen: null, occluded: null },
                    Wt = null,
                    jt = null,
                    ft = null,
                    Yt = 0,
                    kn = 0,
                    fn = 0;
                  Ie.textFeatureIndex
                    ? (Yt = Ie.textFeatureIndex)
                    : be.useRuntimeCollisionCircles && (Yt = be.featureIndex),
                    Ie.verticalTextFeatureIndex &&
                      (kn = Ie.verticalTextFeatureIndex);
                  const Tn = (Un) => {
                      Un.tileID =
                        this.retainedQueryData[b.bucketInstanceId].tileID;
                      const Cn = this.transform.elevation;
                      (Cn || Un.elevation) &&
                        (Un.elevation = Cn
                          ? Cn.getAtTileOffset(
                              Un.tileID,
                              Un.tileAnchorX,
                              Un.tileAnchorY
                            )
                          : 0);
                    },
                    ji = Ie.textBox;
                  if (ji) {
                    Tn(ji);
                    const Un = (ln) => {
                        let ni = d.WritingMode.horizontal;
                        if (
                          b.allowVerticalPlacement &&
                          !ln &&
                          this.prevPlacement
                        ) {
                          const wr = this.prevPlacement.placedOrientations[je];
                          wr &&
                            ((this.placedOrientations[je] = wr),
                            (ni = wr),
                            this.markUsedOrientation(b, ni, be));
                        }
                        return ni;
                      },
                      Cn = (ln, ni) => {
                        if (
                          b.allowVerticalPlacement &&
                          we > 0 &&
                          Ie.verticalTextBox
                        ) {
                          for (const wr of b.writingModes)
                            if (
                              (wr === d.WritingMode.vertical
                                ? ((ct = ni()), (wt = ct))
                                : (ct = ln()),
                              ct && ct.box && ct.box.length)
                            )
                              break;
                        } else ct = ln();
                      };
                    if (D.get("text-variable-anchor")) {
                      let ln = D.get("text-variable-anchor");
                      if (
                        this.prevPlacement &&
                        this.prevPlacement.variableOffsets[je]
                      ) {
                        const Rn = this.prevPlacement.variableOffsets[je];
                        ln.indexOf(Rn.anchor) > 0 &&
                          ((ln = ln.filter((Ui) => Ui !== Rn.anchor)),
                          ln.unshift(Rn.anchor));
                      }
                      const ni = (Rn, Ui, Fu) => {
                        const ta = b.getSymbolInstanceTextSize(
                            X,
                            be,
                            this.transform.zoom,
                            Le
                          ),
                          Bl = (Rn.x2 - Rn.x1) * ta + 2 * Rn.padding,
                          Or = (Rn.y2 - Rn.y1) * ta + 2 * Rn.padding,
                          na = ue && !te ? Ui : null;
                        na && Tn(na);
                        let Wa = { box: [], offscreen: !1, occluded: !1 };
                        const Vl = ee ? 2 * ln.length : ln.length;
                        for (let Ac = 0; Ac < Vl; ++Ac) {
                          const Nu = this.attemptAnchorPlacement(
                            ln[Ac % ln.length],
                            Rn,
                            Bl,
                            Or,
                            ta,
                            he,
                            de,
                            z,
                            I,
                            Y,
                            Ac >= ln.length,
                            be,
                            Le,
                            b,
                            Fu,
                            na,
                            X,
                            Z
                          );
                          if (
                            Nu &&
                            ((Wa = Nu.placedGlyphBoxes),
                            Wa && Wa.box && Wa.box.length)
                          ) {
                            (ke = !0), (Dt = Nu.shift);
                            break;
                          }
                        }
                        return Wa;
                      };
                      Cn(
                        () => ni(ji, Ie.iconBox, d.WritingMode.horizontal),
                        () => {
                          const Rn = Ie.verticalTextBox;
                          return (
                            Rn && Tn(Rn),
                            b.allowVerticalPlacement &&
                            !(ct && ct.box && ct.box.length) &&
                            we > 0 &&
                            Rn
                              ? ni(
                                  Rn,
                                  Ie.verticalIconBox,
                                  d.WritingMode.vertical
                                )
                              : { box: null, offscreen: null, occluded: null }
                          );
                        }
                      ),
                        ct &&
                          ((ke = ct.box),
                          (Ne = ct.offscreen),
                          (Xe = ct.occluded));
                      const wr = Un(!(!ct || !ct.box));
                      if (!ke && this.prevPlacement) {
                        const Rn = this.prevPlacement.variableOffsets[je];
                        Rn &&
                          ((this.variableOffsets[je] = Rn),
                          this.markUsedJustification(b, Rn.anchor, be, wr));
                      }
                    } else {
                      const ln = (ni, wr) => {
                        const Rn = b.getSymbolInstanceTextSize(
                            X,
                            be,
                            this.transform.zoom,
                            Le
                          ),
                          Ui = this.collisionIndex.placeCollisionBox(
                            b,
                            Rn,
                            ni,
                            new d.Point(0, 0),
                            ee,
                            z,
                            I,
                            Y.predicate
                          );
                        return (
                          Ui &&
                            Ui.box &&
                            Ui.box.length &&
                            (this.markUsedOrientation(b, wr, be),
                            (this.placedOrientations[je] = wr)),
                          Ui
                        );
                      };
                      Cn(
                        () => ln(ji, d.WritingMode.horizontal),
                        () => {
                          const ni = Ie.verticalTextBox;
                          return b.allowVerticalPlacement && we > 0 && ni
                            ? (Tn(ni), ln(ni, d.WritingMode.vertical))
                            : { box: null, offscreen: null, occluded: null };
                        }
                      ),
                        Un(!!(ct && ct.box && ct.box.length));
                    }
                  }
                  if (
                    ((Wt = ct),
                    (ke = Wt && Wt.box && Wt.box.length > 0),
                    (Ne = Wt && Wt.offscreen),
                    (Xe = Wt && Wt.occluded),
                    be.useRuntimeCollisionCircles)
                  ) {
                    const Un = b.text.placedSymbolArray.get(
                        be.centerJustifiedTextSymbolIndex >= 0
                          ? be.centerJustifiedTextSymbolIndex
                          : be.verticalPlacedTextSymbolIndex
                      ),
                      Cn = d.evaluateSizeForFeature(b.textSizeData, X, Un),
                      ln = D.get("text-padding");
                    (jt = this.collisionIndex.placeCollisionCircles(
                      b,
                      ee,
                      Un,
                      b.lineVertexArray,
                      b.glyphOffsetArray,
                      Cn,
                      I,
                      M,
                      R,
                      g,
                      de,
                      Y.predicate,
                      (be.collisionCircleDiameter * Cn) / d.ONE_EM,
                      ln,
                      this.retainedQueryData[b.bucketInstanceId].tileID
                    )),
                      (ke =
                        ee || (jt.circles.length > 0 && !jt.collisionDetected)),
                      (Ne = Ne && jt.offscreen),
                      (Xe = jt.occluded);
                  }
                  if (
                    (Ie.iconFeatureIndex && (fn = Ie.iconFeatureIndex),
                    Ie.iconBox)
                  ) {
                    const Un = (Cn) => {
                      Tn(Cn);
                      const ln =
                          ue && Dt
                            ? mc(Dt.x, Dt.y, he, de, this.transform.angle)
                            : new d.Point(0, 0),
                        ni = b.getSymbolInstanceIconSize(
                          Z,
                          this.transform.zoom,
                          be.placedIconSymbolIndex
                        );
                      return this.collisionIndex.placeCollisionBox(
                        b,
                        ni,
                        Cn,
                        ln,
                        te,
                        z,
                        I,
                        Y.predicate
                      );
                    };
                    wt && wt.box && wt.box.length && Ie.verticalIconBox
                      ? ((ft = Un(Ie.verticalIconBox)),
                        (He = ft.box.length > 0))
                      : ((ft = Un(Ie.iconBox)), (He = ft.box.length > 0)),
                      (Ne = Ne && ft.offscreen),
                      (dt = ft.occluded);
                  }
                  const mi =
                      B || (0 === be.numHorizontalGlyphVertices && 0 === we),
                    br = W || 0 === be.numIconVertices;
                  if (
                    (mi || br
                      ? br
                        ? mi || (He = He && ke)
                        : (ke = He && ke)
                      : (He = ke = He && ke),
                    ke &&
                      Wt &&
                      Wt.box &&
                      this.collisionIndex.insertCollisionBox(
                        Wt.box,
                        D.get("text-ignore-placement"),
                        b.bucketInstanceId,
                        wt && wt.box && kn ? kn : Yt,
                        Y.ID
                      ),
                    He &&
                      ft &&
                      this.collisionIndex.insertCollisionBox(
                        ft.box,
                        D.get("icon-ignore-placement"),
                        b.bucketInstanceId,
                        fn,
                        Y.ID
                      ),
                    jt &&
                      (ke &&
                        this.collisionIndex.insertCollisionCircles(
                          jt.circles,
                          D.get("text-ignore-placement"),
                          b.bucketInstanceId,
                          Yt,
                          Y.ID
                        ),
                      g))
                  ) {
                    const Un = b.bucketInstanceId;
                    let Cn = this.collisionCircleArrays[Un];
                    void 0 === Cn &&
                      (Cn = this.collisionCircleArrays[Un] = new fc());
                    for (let ln = 0; ln < jt.circles.length; ln += 4)
                      Cn.circles.push(jt.circles[ln + 0]),
                        Cn.circles.push(jt.circles[ln + 1]),
                        Cn.circles.push(jt.circles[ln + 2]),
                        Cn.circles.push(jt.collisionDetected ? 1 : 0);
                  }
                  const Ko = "globe" !== b.projection.name;
                  (ge = ge && (Ko || !Xe)),
                    (Te = Te && (Ko || !dt)),
                    (this.placements[je] = new gu(
                      ke || ge,
                      He || Te,
                      Ne || b.justReloaded
                    )),
                    u.add(je);
                };
                if (_e) {
                  const be = b.getSortedSymbolIndexes(this.transform.angle);
                  for (let Le = be.length - 1; Le >= 0; --Le) {
                    const Ie = be[Le];
                    Ge(b.symbolInstances.get(Ie), Ie, b.collisionArrays[Ie]);
                  }
                } else for (let be = a.symbolInstanceStart; be < a.symbolInstanceEnd; be++) Ge(b.symbolInstances.get(be), be, b.collisionArrays[be]);
                if (g && b.bucketInstanceId in this.collisionCircleArrays) {
                  const be = this.collisionCircleArrays[b.bucketInstanceId];
                  d.invert(be.invProjMatrix, I),
                    (be.viewportMatrix =
                      this.collisionIndex.getViewportMatrix());
                }
                b.justReloaded = !1;
              }
              markUsedJustification(a, u, g, v) {
                const {
                    leftJustifiedTextSymbolIndex: b,
                    centerJustifiedTextSymbolIndex: D,
                    rightJustifiedTextSymbolIndex: I,
                    verticalPlacedTextSymbolIndex: M,
                    crossTileID: R,
                  } = g,
                  k = d.getAnchorJustification(u),
                  z =
                    v === d.WritingMode.vertical
                      ? M
                      : "left" === k
                      ? b
                      : "center" === k
                      ? D
                      : "right" === k
                      ? I
                      : -1;
                b >= 0 &&
                  (a.text.placedSymbolArray.get(b).crossTileID =
                    z >= 0 && b !== z ? 0 : R),
                  D >= 0 &&
                    (a.text.placedSymbolArray.get(D).crossTileID =
                      z >= 0 && D !== z ? 0 : R),
                  I >= 0 &&
                    (a.text.placedSymbolArray.get(I).crossTileID =
                      z >= 0 && I !== z ? 0 : R),
                  M >= 0 &&
                    (a.text.placedSymbolArray.get(M).crossTileID =
                      z >= 0 && M !== z ? 0 : R);
              }
              markUsedOrientation(a, u, g) {
                const v =
                    u === d.WritingMode.horizontal ||
                    u === d.WritingMode.horizontalOnly
                      ? u
                      : 0,
                  b = u === d.WritingMode.vertical ? u : 0,
                  {
                    leftJustifiedTextSymbolIndex: D,
                    centerJustifiedTextSymbolIndex: I,
                    rightJustifiedTextSymbolIndex: M,
                    verticalPlacedTextSymbolIndex: R,
                  } = g,
                  k = a.text.placedSymbolArray;
                D >= 0 && (k.get(D).placedOrientation = v),
                  I >= 0 && (k.get(I).placedOrientation = v),
                  M >= 0 && (k.get(M).placedOrientation = v),
                  R >= 0 && (k.get(R).placedOrientation = b);
              }
              commit(a) {
                (this.commitTime = a),
                  (this.zoomAtLastRecencyCheck = this.transform.zoom);
                const u = this.prevPlacement;
                let g = !1;
                this.prevZoomAdjustment = u
                  ? u.zoomAdjustment(this.transform.zoom)
                  : 0;
                const v = u ? u.symbolFadeChange(a) : 1,
                  b = u ? u.opacities : {},
                  D = u ? u.variableOffsets : {},
                  I = u ? u.placedOrientations : {};
                for (const M in this.placements) {
                  const R = this.placements[M],
                    k = b[M];
                  k
                    ? ((this.opacities[M] = new hs(
                        k,
                        v,
                        R.text,
                        R.icon,
                        null,
                        R.clipped
                      )),
                      (g =
                        g ||
                        R.text !== k.text.placed ||
                        R.icon !== k.icon.placed))
                    : ((this.opacities[M] = new hs(
                        null,
                        v,
                        R.text,
                        R.icon,
                        R.skipFade,
                        R.clipped
                      )),
                      (g = g || R.text || R.icon));
                }
                for (const M in b) {
                  const R = b[M];
                  if (!this.opacities[M]) {
                    const k = new hs(R, v, !1, !1);
                    k.isHidden() ||
                      ((this.opacities[M] = k),
                      (g = g || R.text.placed || R.icon.placed));
                  }
                }
                for (const M in D)
                  this.variableOffsets[M] ||
                    !this.opacities[M] ||
                    this.opacities[M].isHidden() ||
                    (this.variableOffsets[M] = D[M]);
                for (const M in I)
                  this.placedOrientations[M] ||
                    !this.opacities[M] ||
                    this.opacities[M].isHidden() ||
                    (this.placedOrientations[M] = I[M]);
                g
                  ? (this.lastPlacementChangeTime = a)
                  : "number" != typeof this.lastPlacementChangeTime &&
                    (this.lastPlacementChangeTime = u
                      ? u.lastPlacementChangeTime
                      : a);
              }
              updateLayerOpacities(a, u) {
                const g = new Set();
                for (const v of u) {
                  const b = v.getBucket(a);
                  b &&
                    v.latestFeatureIndex &&
                    a.id === b.layerIds[0] &&
                    this.updateBucketOpacities(b, g, v.collisionBoxArray);
                }
              }
              updateBucketOpacities(a, u, g) {
                a.hasTextData() && a.text.opacityVertexArray.clear(),
                  a.hasIconData() && a.icon.opacityVertexArray.clear(),
                  a.hasIconCollisionBoxData() &&
                    a.iconCollisionBox.collisionVertexArray.clear(),
                  a.hasTextCollisionBoxData() &&
                    a.textCollisionBox.collisionVertexArray.clear();
                const v = a.layers[0].layout,
                  b = !!a.layers[0].dynamicFilter(),
                  D = new hs(null, 0, !1, !1, !0),
                  I = v.get("text-allow-overlap"),
                  M = v.get("icon-allow-overlap"),
                  R = v.get("text-variable-anchor"),
                  k = "map" === v.get("text-rotation-alignment"),
                  z = "map" === v.get("text-pitch-alignment"),
                  H = "none" !== v.get("icon-text-fit"),
                  q = new hs(
                    null,
                    0,
                    I && (M || !a.hasIconData() || v.get("icon-optional")),
                    M && (I || !a.hasTextData() || v.get("text-optional")),
                    !0
                  );
                !a.collisionArrays &&
                  g &&
                  (a.hasIconCollisionBoxData() ||
                    a.hasTextCollisionBoxData()) &&
                  a.deserializeCollisionBoxes(g);
                const X = (Y, B, W) => {
                  for (let ee = 0; ee < B / 4; ee++)
                    Y.opacityVertexArray.emplaceBack(W);
                };
                let Z = 0;
                for (let Y = 0; Y < a.symbolInstances.length; Y++) {
                  const B = a.symbolInstances.get(Y),
                    {
                      numHorizontalGlyphVertices: W,
                      numVerticalGlyphVertices: ee,
                      crossTileID: te,
                      numIconVertices: he,
                    } = B,
                    de = u.has(te);
                  let ue = this.opacities[te];
                  de ? (ue = D) : ue || ((ue = q), (this.opacities[te] = ue)),
                    u.add(te);
                  const _e = W > 0 || ee > 0,
                    ge = he > 0,
                    Te = this.placedOrientations[te],
                    Ge = Te === d.WritingMode.vertical,
                    be =
                      Te === d.WritingMode.horizontal ||
                      Te === d.WritingMode.horizontalOnly;
                  if (((!_e && !ge) || ue.isHidden() || Z++, _e)) {
                    const Le = yu(ue.text);
                    X(a.text, W, Ge ? un : Le), X(a.text, ee, be ? un : Le);
                    const Ie = ue.text.isHidden(),
                      {
                        leftJustifiedTextSymbolIndex: je,
                        centerJustifiedTextSymbolIndex: we,
                        rightJustifiedTextSymbolIndex: ke,
                        verticalPlacedTextSymbolIndex: He,
                      } = B,
                      Ne = a.text.placedSymbolArray,
                      Xe = Ie || Ge ? 1 : 0;
                    je >= 0 && (Ne.get(je).hidden = Xe),
                      we >= 0 && (Ne.get(we).hidden = Xe),
                      ke >= 0 && (Ne.get(ke).hidden = Xe),
                      He >= 0 && (Ne.get(He).hidden = Ie || be ? 1 : 0);
                    const dt = this.variableOffsets[te];
                    dt && this.markUsedJustification(a, dt.anchor, B, Te);
                    const Dt = this.placedOrientations[te];
                    Dt &&
                      (this.markUsedJustification(a, "left", B, Dt),
                      this.markUsedOrientation(a, Dt, B));
                  }
                  if (ge) {
                    const Le = yu(ue.icon),
                      {
                        placedIconSymbolIndex: Ie,
                        verticalPlacedIconSymbolIndex: je,
                      } = B,
                      we = a.icon.placedSymbolArray,
                      ke = ue.icon.isHidden() ? 1 : 0;
                    Ie >= 0 &&
                      (X(a.icon, he, Ge ? un : Le), (we.get(Ie).hidden = ke)),
                      je >= 0 &&
                        (X(a.icon, B.numVerticalIconVertices, be ? un : Le),
                        (we.get(je).hidden = ke));
                  }
                  if (
                    a.hasIconCollisionBoxData() ||
                    a.hasTextCollisionBoxData()
                  ) {
                    const Le = a.collisionArrays[Y];
                    if (Le) {
                      let Ie = new d.Point(0, 0),
                        je = !0;
                      if (Le.textBox || Le.verticalTextBox) {
                        if (R) {
                          const ke = this.variableOffsets[te];
                          ke
                            ? ((Ie = _u(
                                ke.anchor,
                                ke.width,
                                ke.height,
                                ke.textOffset,
                                ke.textScale
                              )),
                              k &&
                                Ie._rotate(
                                  z
                                    ? this.transform.angle
                                    : -this.transform.angle
                                ))
                            : (je = !1);
                        }
                        b && (je = !ue.clipped),
                          Le.textBox &&
                            Pr(
                              a.textCollisionBox.collisionVertexArray,
                              ue.text.placed,
                              !je || Ge,
                              Ie.x,
                              Ie.y
                            ),
                          Le.verticalTextBox &&
                            Pr(
                              a.textCollisionBox.collisionVertexArray,
                              ue.text.placed,
                              !je || be,
                              Ie.x,
                              Ie.y
                            );
                      }
                      const we = je && Boolean(!be && Le.verticalIconBox);
                      Le.iconBox &&
                        Pr(
                          a.iconCollisionBox.collisionVertexArray,
                          ue.icon.placed,
                          we,
                          H ? Ie.x : 0,
                          H ? Ie.y : 0
                        ),
                        Le.verticalIconBox &&
                          Pr(
                            a.iconCollisionBox.collisionVertexArray,
                            ue.icon.placed,
                            !we,
                            H ? Ie.x : 0,
                            H ? Ie.y : 0
                          );
                    }
                  }
                }
                if (
                  ((a.fullyClipped = 0 === Z),
                  a.sortFeatures(this.transform.angle),
                  this.retainedQueryData[a.bucketInstanceId] &&
                    (this.retainedQueryData[
                      a.bucketInstanceId
                    ].featureSortOrder = a.featureSortOrder),
                  a.hasTextData() &&
                    a.text.opacityVertexBuffer &&
                    a.text.opacityVertexBuffer.updateData(
                      a.text.opacityVertexArray
                    ),
                  a.hasIconData() &&
                    a.icon.opacityVertexBuffer &&
                    a.icon.opacityVertexBuffer.updateData(
                      a.icon.opacityVertexArray
                    ),
                  a.hasIconCollisionBoxData() &&
                    a.iconCollisionBox.collisionVertexBuffer &&
                    a.iconCollisionBox.collisionVertexBuffer.updateData(
                      a.iconCollisionBox.collisionVertexArray
                    ),
                  a.hasTextCollisionBoxData() &&
                    a.textCollisionBox.collisionVertexBuffer &&
                    a.textCollisionBox.collisionVertexBuffer.updateData(
                      a.textCollisionBox.collisionVertexArray
                    ),
                  a.bucketInstanceId in this.collisionCircleArrays)
                ) {
                  const Y = this.collisionCircleArrays[a.bucketInstanceId];
                  (a.placementInvProjMatrix = Y.invProjMatrix),
                    (a.placementViewportMatrix = Y.viewportMatrix),
                    (a.collisionCircleArray = Y.circles),
                    delete this.collisionCircleArrays[a.bucketInstanceId];
                }
              }
              symbolFadeChange(a) {
                return 0 === this.fadeDuration
                  ? 1
                  : (a - this.commitTime) / this.fadeDuration +
                      this.prevZoomAdjustment;
              }
              zoomAdjustment(a) {
                return Math.max(0, (this.transform.zoom - a) / 1.5);
              }
              hasTransitions(a) {
                return (
                  this.stale ||
                  a - this.lastPlacementChangeTime < this.fadeDuration
                );
              }
              stillRecent(a, u) {
                const g =
                  this.zoomAtLastRecencyCheck === u
                    ? 1 - this.zoomAdjustment(u)
                    : 1;
                return (
                  (this.zoomAtLastRecencyCheck = u),
                  this.commitTime + this.fadeDuration * g > a
                );
              }
              setStale() {
                this.stale = !0;
              }
            }
            function Pr(f, a, u, g, v) {
              f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0),
                f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0),
                f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0),
                f.emplaceBack(a ? 1 : 0, u ? 1 : 0, g || 0, v || 0);
            }
            const $r = Math.pow(2, 25),
              di = Math.pow(2, 24),
              sp = Math.pow(2, 17),
              ap = Math.pow(2, 16),
              Lr = Math.pow(2, 9),
              go = Math.pow(2, 8),
              lp = Math.pow(2, 1);
            function yu(f) {
              if (0 === f.opacity && !f.placed) return 0;
              if (1 === f.opacity && f.placed) return 4294967295;
              const a = f.placed ? 1 : 0,
                u = Math.floor(127 * f.opacity);
              return (
                u * $r + a * di + u * sp + a * ap + u * Lr + a * go + u * lp + a
              );
            }
            const un = 0;
            class pn {
              constructor(a) {
                (this._sortAcrossTiles =
                  "viewport-y" !== a.layout.get("symbol-z-order") &&
                  void 0 !== a.layout.get("symbol-sort-key").constantOr(1)),
                  (this._currentTileIndex = 0),
                  (this._currentPartIndex = 0),
                  (this._seenCrossTileIDs = new Set()),
                  (this._bucketParts = []);
              }
              continuePlacement(a, u, g, v, b) {
                const D = this._bucketParts;
                for (; this._currentTileIndex < a.length; )
                  if (
                    (u.getBucketParts(
                      D,
                      v,
                      a[this._currentTileIndex],
                      this._sortAcrossTiles
                    ),
                    this._currentTileIndex++,
                    b())
                  )
                    return !0;
                for (
                  this._sortAcrossTiles &&
                  ((this._sortAcrossTiles = !1),
                  D.sort((I, M) => I.sortKey - M.sortKey));
                  this._currentPartIndex < D.length;

                ) {
                  const I = D[this._currentPartIndex];
                  if (
                    (u.placeLayerBucketPart(
                      I,
                      this._seenCrossTileIDs,
                      g,
                      0 === I.symbolInstanceStart
                    ),
                    this._currentPartIndex++,
                    b())
                  )
                    return !0;
                }
                return !1;
              }
            }
            class cp {
              constructor(a, u, g, v, b, D, I, M) {
                (this.placement = new Ah(a, b, D, I, M)),
                  (this._currentPlacementIndex = u.length - 1),
                  (this._forceFullPlacement = g),
                  (this._showCollisionBoxes = v),
                  (this._done = !1);
              }
              isDone() {
                return this._done;
              }
              continuePlacement(a, u, g) {
                const v = d.exported.now(),
                  b = () => {
                    const D = d.exported.now() - v;
                    return !this._forceFullPlacement && D > 2;
                  };
                for (; this._currentPlacementIndex >= 0; ) {
                  const D = u[a[this._currentPlacementIndex]],
                    I = this.placement.collisionIndex.transform.zoom;
                  if (
                    "symbol" === D.type &&
                    (!D.minzoom || D.minzoom <= I) &&
                    (!D.maxzoom || D.maxzoom > I)
                  ) {
                    if (
                      (this._inProgressLayer ||
                        (this._inProgressLayer = new pn(D)),
                      this._inProgressLayer.continuePlacement(
                        g[D.source],
                        this.placement,
                        this._showCollisionBoxes,
                        D,
                        b
                      ))
                    )
                      return;
                    delete this._inProgressLayer;
                  }
                  this._currentPlacementIndex--;
                }
                this._done = !0;
              }
              commit(a) {
                return this.placement.commit(a), this.placement;
              }
            }
            const Sl = 512 / d.EXTENT / 2;
            class ir {
              constructor(a, u, g) {
                (this.tileID = a),
                  (this.bucketInstanceId = g),
                  (this.index = new d.KDBush(u.length, 16, Int32Array)),
                  (this.keys = []),
                  (this.crossTileIDs = []);
                const v = a.canonical.x * d.EXTENT,
                  b = a.canonical.y * d.EXTENT;
                for (let D = 0; D < u.length; D++) {
                  const {
                      key: I,
                      crossTileID: M,
                      tileAnchorX: R,
                      tileAnchorY: k,
                    } = u.get(D),
                    z = Math.floor((v + R) * Sl),
                    H = Math.floor((b + k) * Sl);
                  this.index.add(z, H),
                    this.keys.push(I),
                    this.crossTileIDs.push(M);
                }
                this.index.finish();
              }
              findMatches(a, u, g) {
                const v =
                    this.tileID.canonical.z < u.canonical.z
                      ? 1
                      : Math.pow(2, this.tileID.canonical.z - u.canonical.z),
                  b = Sl / Math.pow(2, u.canonical.z - this.tileID.canonical.z),
                  D = u.canonical.x * d.EXTENT,
                  I = u.canonical.y * d.EXTENT;
                for (let M = 0; M < a.length; M++) {
                  const R = a.get(M);
                  if (R.crossTileID) continue;
                  const { key: k, tileAnchorX: z, tileAnchorY: H } = R,
                    q = Math.floor((D + z) * b),
                    X = Math.floor((I + H) * b),
                    Z = this.index.range(q - v, X - v, q + v, X + v);
                  for (const Y of Z) {
                    const B = this.crossTileIDs[Y];
                    if (this.keys[Y] === k && !g.has(B)) {
                      g.add(B), (R.crossTileID = B);
                      break;
                    }
                  }
                }
              }
            }
            class Sn {
              constructor() {
                this.maxCrossTileID = 0;
              }
              generate() {
                return ++this.maxCrossTileID;
              }
            }
            class up {
              constructor() {
                (this.indexes = {}),
                  (this.usedCrossTileIDs = {}),
                  (this.lng = 0);
              }
              handleWrapJump(a) {
                const u = Math.round((a - this.lng) / 360);
                if (0 !== u)
                  for (const g in this.indexes) {
                    const v = this.indexes[g],
                      b = {};
                    for (const D in v) {
                      const I = v[D];
                      (I.tileID = I.tileID.unwrapTo(I.tileID.wrap + u)),
                        (b[I.tileID.key] = I);
                    }
                    this.indexes[g] = b;
                  }
                this.lng = a;
              }
              addBucket(a, u, g) {
                if (
                  this.indexes[a.overscaledZ] &&
                  this.indexes[a.overscaledZ][a.key]
                ) {
                  if (
                    this.indexes[a.overscaledZ][a.key].bucketInstanceId ===
                    u.bucketInstanceId
                  )
                    return !1;
                  this.removeBucketCrossTileIDs(
                    a.overscaledZ,
                    this.indexes[a.overscaledZ][a.key]
                  );
                }
                for (let b = 0; b < u.symbolInstances.length; b++)
                  u.symbolInstances.get(b).crossTileID = 0;
                this.usedCrossTileIDs[a.overscaledZ] ||
                  (this.usedCrossTileIDs[a.overscaledZ] = new Set());
                const v = this.usedCrossTileIDs[a.overscaledZ];
                for (const b in this.indexes) {
                  const D = this.indexes[b];
                  if (Number(b) > a.overscaledZ)
                    for (const I in D) {
                      const M = D[I];
                      M.tileID.isChildOf(a) &&
                        M.findMatches(u.symbolInstances, a, v);
                    }
                  else {
                    const I = D[a.scaledTo(Number(b)).key];
                    I && I.findMatches(u.symbolInstances, a, v);
                  }
                }
                for (let b = 0; b < u.symbolInstances.length; b++) {
                  const D = u.symbolInstances.get(b);
                  D.crossTileID ||
                    ((D.crossTileID = g.generate()), v.add(D.crossTileID));
                }
                return (
                  void 0 === this.indexes[a.overscaledZ] &&
                    (this.indexes[a.overscaledZ] = {}),
                  (this.indexes[a.overscaledZ][a.key] = new ir(
                    a,
                    u.symbolInstances,
                    u.bucketInstanceId
                  )),
                  !0
                );
              }
              removeBucketCrossTileIDs(a, u) {
                for (const g of u.crossTileIDs)
                  this.usedCrossTileIDs[a].delete(g);
              }
              removeStaleBuckets(a) {
                let u = !1;
                for (const g in this.indexes) {
                  const v = this.indexes[g];
                  for (const b in v)
                    a[v[b].bucketInstanceId] ||
                      (this.removeBucketCrossTileIDs(g, v[b]),
                      delete v[b],
                      (u = !0));
                }
                return u;
              }
            }
            class Jn {
              constructor() {
                (this.layerIndexes = {}),
                  (this.crossTileIDs = new Sn()),
                  (this.maxBucketInstanceId = 0),
                  (this.bucketsInCurrentPlacement = {});
              }
              addLayer(a, u, g, v) {
                let b = this.layerIndexes[a.id];
                void 0 === b && (b = this.layerIndexes[a.id] = new up());
                let D = !1;
                const I = {};
                "globe" !== v.name && b.handleWrapJump(g);
                for (const M of u) {
                  const R = M.getBucket(a);
                  R &&
                    a.id === R.layerIds[0] &&
                    (R.bucketInstanceId ||
                      (R.bucketInstanceId = ++this.maxBucketInstanceId),
                    b.addBucket(M.tileID, R, this.crossTileIDs) && (D = !0),
                    (I[R.bucketInstanceId] = !0));
                }
                return b.removeStaleBuckets(I) && (D = !0), D;
              }
              pruneUnusedLayers(a) {
                const u = {};
                a.forEach((g) => {
                  u[g] = !0;
                });
                for (const g in this.layerIndexes)
                  u[g] || delete this.layerIndexes[g];
              }
            }
            const _o = (f, a) =>
                d.emitValidationErrors(
                  f,
                  a && a.filter((u) => "source.canvas" !== u.identifier)
                ),
              Ph = d.pick(_n, [
                "addLayer",
                "removeLayer",
                "setPaintProperty",
                "setLayoutProperty",
                "setFilter",
                "addSource",
                "removeSource",
                "setLayerZoomRange",
                "setLight",
                "setTransition",
                "setGeoJSONSourceData",
                "setTerrain",
                "setFog",
                "setProjection",
              ]),
              hp = d.pick(_n, [
                "setCenter",
                "setZoom",
                "setBearing",
                "setPitch",
              ]),
              Lh = { version: 8, layers: [], sources: {} },
              Il = {
                fill: !0,
                line: !0,
                background: !0,
                hillshade: !0,
                raster: !0,
              };
            class yo extends d.Evented {
              constructor(a, u = {}) {
                super(),
                  (this.map = a),
                  (this.dispatcher = new bn(ka(), this)),
                  (this.imageManager = new Ia()),
                  this.imageManager.setEventedParent(this),
                  (this.glyphManager = new d.GlyphManager(
                    a._requestManager,
                    u.localFontFamily
                      ? d.LocalGlyphMode.all
                      : u.localIdeographFontFamily
                      ? d.LocalGlyphMode.ideographs
                      : d.LocalGlyphMode.none,
                    u.localFontFamily || u.localIdeographFontFamily
                  )),
                  (this.crossTileSymbolIndex = new Jn()),
                  (this._layers = {}),
                  (this._num3DLayers = 0),
                  (this._numSymbolLayers = 0),
                  (this._numCircleLayers = 0),
                  (this._serializedLayers = {}),
                  (this._sourceCaches = {}),
                  (this._otherSourceCaches = {}),
                  (this._symbolSourceCaches = {}),
                  (this._loaded = !1),
                  (this._availableImages = []),
                  (this._order = []),
                  (this._drapedFirstOrder = []),
                  (this._markersNeedUpdate = !1),
                  this._resetUpdates(),
                  this.dispatcher.broadcast("setReferrer", d.getReferrer());
                const g = this;
                (this._rtlTextPluginCallback = yo.registerForPluginStateChange(
                  (v) => {
                    g.dispatcher.broadcast(
                      "syncRTLPluginState",
                      { pluginStatus: v.pluginStatus, pluginURL: v.pluginURL },
                      (b, D) => {
                        if (
                          (d.triggerPluginCompletionEvent(b),
                          D && D.every((I) => I))
                        )
                          for (const I in g._sourceCaches) {
                            const M = g._sourceCaches[I],
                              R = M.getSource().type;
                            ("vector" !== R && "geojson" !== R) || M.reload();
                          }
                      }
                    );
                  }
                )),
                  this.on("data", (v) => {
                    if (
                      "source" !== v.dataType ||
                      "metadata" !== v.sourceDataType
                    )
                      return;
                    const b = this.getSource(v.sourceId);
                    if (b && b.vectorLayerIds)
                      for (const D in this._layers) {
                        const I = this._layers[D];
                        I.source === b.id && this._validateLayer(I);
                      }
                  });
              }
              loadURL(a, u = {}) {
                this.fire(new d.Event("dataloading", { dataType: "style" }));
                const g =
                  "boolean" == typeof u.validate
                    ? u.validate
                    : !d.isMapboxURL(a);
                a = this.map._requestManager.normalizeStyleURL(
                  a,
                  u.accessToken
                );
                const v = this.map._requestManager.transformRequest(
                  a,
                  d.ResourceType.Style
                );
                this._request = d.getJSON(v, (b, D) => {
                  (this._request = null),
                    b ? this.fire(new d.ErrorEvent(b)) : D && this._load(D, g);
                });
              }
              loadJSON(a, u = {}) {
                this.fire(new d.Event("dataloading", { dataType: "style" })),
                  (this._request = d.exported.frame(() => {
                    (this._request = null), this._load(a, !1 !== u.validate);
                  }));
              }
              loadEmpty() {
                this.fire(new d.Event("dataloading", { dataType: "style" })),
                  this._load(Lh, !1);
              }
              _updateLayerCount(a, u) {
                const g = u ? 1 : -1;
                a.is3D() && (this._num3DLayers += g),
                  "circle" === a.type && (this._numCircleLayers += g),
                  "symbol" === a.type && (this._numSymbolLayers += g);
              }
              _load(a, u) {
                if (u && _o(this, d.validateStyle(a))) return;
                (this._loaded = !0),
                  (this.stylesheet = d.clone$1(a)),
                  this._updateMapProjection();
                for (const v in a.sources)
                  this.addSource(v, a.sources[v], { validate: !1 });
                (this._changed = !1),
                  a.sprite
                    ? this._loadSprite(a.sprite)
                    : (this.imageManager.setLoaded(!0),
                      this.dispatcher.broadcast("spriteLoaded", !0)),
                  this.glyphManager.setURL(a.glyphs);
                const g = Sh(this.stylesheet.layers);
                (this._order = g.map((v) => v.id)),
                  (this._layers = {}),
                  (this._serializedLayers = {});
                for (const v of g) {
                  const b = d.createStyleLayer(v);
                  b.setEventedParent(this, { layer: { id: b.id } }),
                    (this._layers[b.id] = b),
                    (this._serializedLayers[b.id] = b.serialize()),
                    this._updateLayerCount(b, !0);
                }
                this.dispatcher.broadcast(
                  "setLayers",
                  this._serializeLayers(this._order)
                ),
                  (this.light = new Oi(this.stylesheet.light)),
                  this.stylesheet.terrain &&
                    !this.terrainSetForDrapingOnly() &&
                    this._createTerrain(this.stylesheet.terrain, 1),
                  this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                  this._updateDrapeFirstLayers(),
                  this.fire(new d.Event("data", { dataType: "style" })),
                  this.fire(new d.Event("style.load"));
              }
              terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
              }
              setProjection(a) {
                a
                  ? (this.stylesheet.projection = a)
                  : delete this.stylesheet.projection,
                  this._updateMapProjection();
              }
              applyProjectionUpdate() {
                this._loaded &&
                  (this.dispatcher.broadcast(
                    "setProjection",
                    this.map.transform.projectionOptions
                  ),
                  this.map.transform.projection.requiresDraping
                    ? this.getTerrain() ||
                      this.stylesheet.terrain ||
                      this.setTerrainForDraping()
                    : this.terrainSetForDrapingOnly() && this.setTerrain(null));
              }
              _updateMapProjection() {
                this.map._useExplicitProjection
                  ? this.applyProjectionUpdate()
                  : this.map._prioritizeAndUpdateProjection(
                      null,
                      this.stylesheet.projection
                    );
              }
              _loadSprite(a) {
                this._spriteRequest = (function (u, g, v) {
                  let b, D, I;
                  const M = d.exported.devicePixelRatio > 1 ? "@2x" : "";
                  let R = d.getJSON(
                      g.transformRequest(
                        g.normalizeSpriteURL(u, M, ".json"),
                        d.ResourceType.SpriteJSON
                      ),
                      (H, q) => {
                        (R = null), I || ((I = H), (b = q), z());
                      }
                    ),
                    k = d.getImage(
                      g.transformRequest(
                        g.normalizeSpriteURL(u, M, ".png"),
                        d.ResourceType.SpriteImage
                      ),
                      (H, q) => {
                        (k = null), I || ((I = H), (D = q), z());
                      }
                    );
                  function z() {
                    if (I) v(I);
                    else if (b && D) {
                      const H = d.exported.getImageData(D),
                        q = {};
                      for (const X in b) {
                        const {
                            width: Z,
                            height: Y,
                            x: B,
                            y: W,
                            sdf: ee,
                            pixelRatio: te,
                            stretchX: he,
                            stretchY: de,
                            content: ue,
                          } = b[X],
                          _e = new d.RGBAImage({ width: Z, height: Y });
                        d.RGBAImage.copy(
                          H,
                          _e,
                          { x: B, y: W },
                          { x: 0, y: 0 },
                          { width: Z, height: Y }
                        ),
                          (q[X] = {
                            data: _e,
                            pixelRatio: te,
                            sdf: ee,
                            stretchX: he,
                            stretchY: de,
                            content: ue,
                          });
                      }
                      v(null, q);
                    }
                  }
                  return {
                    cancel() {
                      R && (R.cancel(), (R = null)),
                        k && (k.cancel(), (k = null));
                    },
                  };
                })(a, this.map._requestManager, (u, g) => {
                  if (((this._spriteRequest = null), u))
                    this.fire(new d.ErrorEvent(u));
                  else if (g)
                    for (const v in g) this.imageManager.addImage(v, g[v]);
                  this.imageManager.setLoaded(!0),
                    (this._availableImages = this.imageManager.listImages()),
                    this.dispatcher.broadcast(
                      "setImages",
                      this._availableImages
                    ),
                    this.dispatcher.broadcast("spriteLoaded", !0),
                    this.fire(new d.Event("data", { dataType: "style" }));
                });
              }
              _validateLayer(a) {
                const u = this.getSource(a.source);
                if (!u) return;
                const g = a.sourceLayer;
                g &&
                  ("geojson" === u.type ||
                    (u.vectorLayerIds && -1 === u.vectorLayerIds.indexOf(g))) &&
                  this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Source layer "${g}" does not exist on source "${u.id}" as specified by style layer "${a.id}"`
                      )
                    )
                  );
              }
              loaded() {
                if (!this._loaded || Object.keys(this._updatedSources).length)
                  return !1;
                for (const a in this._sourceCaches)
                  if (!this._sourceCaches[a].loaded()) return !1;
                return !!this.imageManager.isLoaded();
              }
              _serializeLayers(a) {
                const u = [];
                for (const g of a) {
                  const v = this._layers[g];
                  "custom" !== v.type && u.push(v.serialize());
                }
                return u;
              }
              hasTransitions() {
                if (
                  (this.light && this.light.hasTransition()) ||
                  (this.fog && this.fog.hasTransition())
                )
                  return !0;
                for (const a in this._sourceCaches)
                  if (this._sourceCaches[a].hasTransition()) return !0;
                for (const a in this._layers)
                  if (this._layers[a].hasTransition()) return !0;
                return !1;
              }
              get order() {
                return this.map._optimizeForTerrain && this.terrain
                  ? this._drapedFirstOrder
                  : this._order;
              }
              isLayerDraped(a) {
                return (
                  !!this.terrain &&
                  ("function" == typeof a.isLayerDraped
                    ? a.isLayerDraped()
                    : Il[a.type])
                );
              }
              _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
              }
              update(a) {
                if (!this._loaded) return;
                const u = this._changed;
                if (this._changed) {
                  const v = Object.keys(this._updatedLayers),
                    b = Object.keys(this._removedLayers);
                  (v.length || b.length) && this._updateWorkerLayers(v, b);
                  for (const D in this._updatedSources) {
                    const I = this._updatedSources[D];
                    "reload" === I
                      ? this._reloadSource(D)
                      : "clear" === I && this._clearSource(D);
                  }
                  this._updateTilesForChangedImages();
                  for (const D in this._updatedPaintProps)
                    this._layers[D].updateTransitions(a);
                  this.light.updateTransitions(a),
                    this.fog && this.fog.updateTransitions(a),
                    this._resetUpdates();
                }
                const g = {};
                for (const v in this._sourceCaches) {
                  const b = this._sourceCaches[v];
                  (g[v] = b.used), (b.used = !1);
                }
                for (const v of this._order) {
                  const b = this._layers[v];
                  if (
                    (b.recalculate(a, this._availableImages),
                    !b.isHidden(a.zoom))
                  ) {
                    const I = this._getLayerSourceCache(b);
                    I && (I.used = !0);
                  }
                  const D = this.map.painter;
                  if (D) {
                    const I = b.getProgramIds();
                    if (!I) continue;
                    const M = b.getProgramConfiguration(a.zoom);
                    for (const R of I) D.useProgram(R, M);
                  }
                }
                for (const v in g) {
                  const b = this._sourceCaches[v];
                  g[v] !== b.used &&
                    b
                      .getSource()
                      .fire(
                        new d.Event("data", {
                          sourceDataType: "visibility",
                          dataType: "source",
                          sourceId: b.getSource().id,
                        })
                      );
                }
                this.light.recalculate(a),
                  this.terrain && this.terrain.recalculate(a),
                  this.fog && this.fog.recalculate(a),
                  (this.z = a.zoom),
                  this._markersNeedUpdate &&
                    (this._updateMarkersOpacity(),
                    (this._markersNeedUpdate = !1)),
                  u && this.fire(new d.Event("data", { dataType: "style" }));
              }
              _updateTilesForChangedImages() {
                const a = Object.keys(this._changedImages);
                if (a.length) {
                  for (const u in this._sourceCaches)
                    this._sourceCaches[u].reloadTilesForDependencies(
                      ["icons", "patterns"],
                      a
                    );
                  this._changedImages = {};
                }
              }
              _updateWorkerLayers(a, u) {
                this.dispatcher.broadcast("updateLayers", {
                  layers: this._serializeLayers(a),
                  removedIds: u,
                });
              }
              _resetUpdates() {
                (this._changed = !1),
                  (this._updatedLayers = {}),
                  (this._removedLayers = {}),
                  (this._updatedSources = {}),
                  (this._updatedPaintProps = {}),
                  (this._changedImages = {});
              }
              setState(a) {
                if ((this._checkLoaded(), _o(this, d.validateStyle(a))))
                  return !1;
                (a = d.clone$1(a)).layers = Sh(a.layers);
                const u = (function (v, b) {
                  if (!v) return [{ command: _n.setStyle, args: [b] }];
                  let D = [];
                  try {
                    if (!Be(v.version, b.version))
                      return [{ command: _n.setStyle, args: [b] }];
                    Be(v.center, b.center) ||
                      D.push({ command: _n.setCenter, args: [b.center] }),
                      Be(v.zoom, b.zoom) ||
                        D.push({ command: _n.setZoom, args: [b.zoom] }),
                      Be(v.bearing, b.bearing) ||
                        D.push({ command: _n.setBearing, args: [b.bearing] }),
                      Be(v.pitch, b.pitch) ||
                        D.push({ command: _n.setPitch, args: [b.pitch] }),
                      Be(v.sprite, b.sprite) ||
                        D.push({ command: _n.setSprite, args: [b.sprite] }),
                      Be(v.glyphs, b.glyphs) ||
                        D.push({ command: _n.setGlyphs, args: [b.glyphs] }),
                      Be(v.transition, b.transition) ||
                        D.push({
                          command: _n.setTransition,
                          args: [b.transition],
                        }),
                      Be(v.light, b.light) ||
                        D.push({ command: _n.setLight, args: [b.light] }),
                      Be(v.fog, b.fog) ||
                        D.push({ command: _n.setFog, args: [b.fog] }),
                      Be(v.projection, b.projection) ||
                        D.push({
                          command: _n.setProjection,
                          args: [b.projection],
                        });
                    const I = {},
                      M = [];
                    !(function (z, H, q, X) {
                      let Z;
                      for (Z in ((H = H || {}), (z = z || {})))
                        z.hasOwnProperty(Z) &&
                          (H.hasOwnProperty(Z) || hc(Z, q, X));
                      for (Z in H) {
                        if (!H.hasOwnProperty(Z)) continue;
                        const Y = H[Z];
                        z.hasOwnProperty(Z)
                          ? Be(z[Z], Y) ||
                            ("geojson" === z[Z].type &&
                            "geojson" === Y.type &&
                            Ch(z, H, Z)
                              ? q.push({
                                  command: _n.setGeoJSONSourceData,
                                  args: [Z, Y.data],
                                })
                              : dc(Z, H, q, X))
                          : Ih(Z, H, q);
                      }
                    })(v.sources, b.sources, M, I);
                    const R = [];
                    v.layers &&
                      v.layers.forEach((z) => {
                        z.source && I[z.source]
                          ? D.push({ command: _n.removeLayer, args: [z.id] })
                          : R.push(z);
                      });
                    let k = v.terrain;
                    k &&
                      I[k.source] &&
                      (D.push({ command: _n.setTerrain, args: [void 0] }),
                      (k = void 0)),
                      (D = D.concat(M)),
                      Be(k, b.terrain) ||
                        D.push({ command: _n.setTerrain, args: [b.terrain] }),
                      (function (z, H, q) {
                        H = H || [];
                        const X = (z = z || []).map(cs),
                          Z = H.map(cs),
                          Y = z.reduce(du, {}),
                          B = H.reduce(du, {}),
                          W = X.slice(),
                          ee = Object.create(null);
                        let te, he, de, ue, _e, ge, Te;
                        for (te = 0, he = 0; te < X.length; te++)
                          (de = X[te]),
                            B.hasOwnProperty(de)
                              ? he++
                              : (q.push({
                                  command: _n.removeLayer,
                                  args: [de],
                                }),
                                W.splice(W.indexOf(de, he), 1));
                        for (te = 0, he = 0; te < Z.length; te++)
                          (de = Z[Z.length - 1 - te]),
                            W[W.length - 1 - te] !== de &&
                              (Y.hasOwnProperty(de)
                                ? (q.push({
                                    command: _n.removeLayer,
                                    args: [de],
                                  }),
                                  W.splice(W.lastIndexOf(de, W.length - he), 1))
                                : he++,
                              (ge = W[W.length - te]),
                              q.push({
                                command: _n.addLayer,
                                args: [B[de], ge],
                              }),
                              W.splice(W.length - te, 0, de),
                              (ee[de] = !0));
                        for (te = 0; te < Z.length; te++)
                          if (
                            ((de = Z[te]),
                            (ue = Y[de]),
                            (_e = B[de]),
                            !ee[de] && !Be(ue, _e))
                          )
                            if (
                              Be(ue.source, _e.source) &&
                              Be(ue["source-layer"], _e["source-layer"]) &&
                              Be(ue.type, _e.type)
                            ) {
                              for (Te in (Bo(
                                ue.layout,
                                _e.layout,
                                q,
                                de,
                                null,
                                _n.setLayoutProperty
                              ),
                              Bo(
                                ue.paint,
                                _e.paint,
                                q,
                                de,
                                null,
                                _n.setPaintProperty
                              ),
                              Be(ue.filter, _e.filter) ||
                                q.push({
                                  command: _n.setFilter,
                                  args: [de, _e.filter],
                                }),
                              (Be(ue.minzoom, _e.minzoom) &&
                                Be(ue.maxzoom, _e.maxzoom)) ||
                                q.push({
                                  command: _n.setLayerZoomRange,
                                  args: [de, _e.minzoom, _e.maxzoom],
                                }),
                              ue))
                                ue.hasOwnProperty(Te) &&
                                  "layout" !== Te &&
                                  "paint" !== Te &&
                                  "filter" !== Te &&
                                  "metadata" !== Te &&
                                  "minzoom" !== Te &&
                                  "maxzoom" !== Te &&
                                  (0 === Te.indexOf("paint.")
                                    ? Bo(
                                        ue[Te],
                                        _e[Te],
                                        q,
                                        de,
                                        Te.slice(6),
                                        _n.setPaintProperty
                                      )
                                    : Be(ue[Te], _e[Te]) ||
                                      q.push({
                                        command: _n.setLayerProperty,
                                        args: [de, Te, _e[Te]],
                                      }));
                              for (Te in _e)
                                _e.hasOwnProperty(Te) &&
                                  !ue.hasOwnProperty(Te) &&
                                  "layout" !== Te &&
                                  "paint" !== Te &&
                                  "filter" !== Te &&
                                  "metadata" !== Te &&
                                  "minzoom" !== Te &&
                                  "maxzoom" !== Te &&
                                  (0 === Te.indexOf("paint.")
                                    ? Bo(
                                        ue[Te],
                                        _e[Te],
                                        q,
                                        de,
                                        Te.slice(6),
                                        _n.setPaintProperty
                                      )
                                    : Be(ue[Te], _e[Te]) ||
                                      q.push({
                                        command: _n.setLayerProperty,
                                        args: [de, Te, _e[Te]],
                                      }));
                            } else
                              q.push({ command: _n.removeLayer, args: [de] }),
                                (ge = W[W.lastIndexOf(de) + 1]),
                                q.push({
                                  command: _n.addLayer,
                                  args: [_e, ge],
                                });
                      })(R, b.layers, D);
                  } catch (I) {
                    console.warn("Unable to compute style diff:", I),
                      (D = [{ command: _n.setStyle, args: [b] }]);
                  }
                  return D;
                })(this.serialize(), a).filter((v) => !(v.command in hp));
                if (0 === u.length) return !1;
                const g = u.filter((v) => !(v.command in Ph));
                if (g.length > 0)
                  throw new Error(
                    `Unimplemented: ${g.map((v) => v.command).join(", ")}.`
                  );
                return (
                  u.forEach((v) => {
                    "setTransition" !== v.command &&
                      "setProjection" !== v.command &&
                      this[v.command].apply(this, v.args);
                  }),
                  (this.stylesheet = a),
                  this._updateMapProjection(),
                  !0
                );
              }
              addImage(a, u) {
                return this.getImage(a)
                  ? this.fire(
                      new d.ErrorEvent(
                        new Error("An image with this name already exists.")
                      )
                    )
                  : (this.imageManager.addImage(a, u),
                    this._afterImageUpdated(a),
                    this);
              }
              updateImage(a, u) {
                this.imageManager.updateImage(a, u);
              }
              getImage(a) {
                return this.imageManager.getImage(a);
              }
              removeImage(a) {
                return this.getImage(a)
                  ? (this.imageManager.removeImage(a),
                    this._afterImageUpdated(a),
                    this)
                  : this.fire(
                      new d.ErrorEvent(
                        new Error("No image with this name exists.")
                      )
                    );
              }
              _afterImageUpdated(a) {
                (this._availableImages = this.imageManager.listImages()),
                  (this._changedImages[a] = !0),
                  (this._changed = !0),
                  this.dispatcher.broadcast("setImages", this._availableImages),
                  this.fire(new d.Event("data", { dataType: "style" }));
              }
              listImages() {
                return this._checkLoaded(), this._availableImages.slice();
              }
              addSource(a, u, g = {}) {
                if ((this._checkLoaded(), void 0 !== this.getSource(a)))
                  throw new Error("There is already a source with this ID");
                if (!u.type)
                  throw new Error(
                    `The type property must be defined, but only the following properties were given: ${Object.keys(
                      u
                    ).join(", ")}.`
                  );
                if (
                  ["vector", "raster", "geojson", "video", "image"].indexOf(
                    u.type
                  ) >= 0 &&
                  this._validate(d.validateSource, `sources.${a}`, u, null, g)
                )
                  return;
                this.map &&
                  this.map._collectResourceTiming &&
                  (u.collectResourceTiming = !0);
                const v = Gt(a, u, this.dispatcher, this);
                v.setEventedParent(this, () => ({
                  isSourceLoaded: this._isSourceCacheLoaded(a),
                  source: v.serialize(),
                  sourceId: a,
                }));
                const b = (D) => {
                  const I = (D ? "symbol:" : "other:") + a,
                    M = (this._sourceCaches[I] = new d.SourceCache(I, v, D));
                  ((D ? this._symbolSourceCaches : this._otherSourceCaches)[a] =
                    M),
                    (M.style = this),
                    M.onAdd(this.map);
                };
                b(!1),
                  ("vector" !== u.type && "geojson" !== u.type) || b(!0),
                  v.onAdd && v.onAdd(this.map),
                  (this._changed = !0);
              }
              removeSource(a) {
                this._checkLoaded();
                const u = this.getSource(a);
                if (!u) throw new Error("There is no source with this ID");
                for (const v in this._layers)
                  if (this._layers[v].source === a)
                    return this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `Source "${a}" cannot be removed while layer "${v}" is using it.`
                        )
                      )
                    );
                if (this.terrain && this.terrain.get().source === a)
                  return this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Source "${a}" cannot be removed while terrain is using it.`
                      )
                    )
                  );
                const g = this._getSourceCaches(a);
                for (const v of g)
                  delete this._sourceCaches[v.id],
                    delete this._updatedSources[v.id],
                    v.fire(
                      new d.Event("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: v.getSource().id,
                      })
                    ),
                    v.setEventedParent(null),
                    v.clearTiles();
                return (
                  delete this._otherSourceCaches[a],
                  delete this._symbolSourceCaches[a],
                  u.setEventedParent(null),
                  u.onRemove && u.onRemove(this.map),
                  (this._changed = !0),
                  this
                );
              }
              setGeoJSONSourceData(a, u) {
                this._checkLoaded(),
                  this.getSource(a).setData(u),
                  (this._changed = !0);
              }
              getSource(a) {
                const u = this._getSourceCache(a);
                return u && u.getSource();
              }
              _getSources() {
                const a = [];
                for (const u in this._otherSourceCaches) {
                  const g = this._getSourceCache(u);
                  g && a.push(g.getSource());
                }
                return a;
              }
              addLayer(a, u, g = {}) {
                this._checkLoaded();
                const v = a.id;
                if (this.getLayer(v))
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Layer with id "${v}" already exists on this map`
                      )
                    )
                  );
                let b;
                if ("custom" === a.type) {
                  if (_o(this, d.validateCustomStyleLayer(a))) return;
                  b = d.createStyleLayer(a);
                } else {
                  if (
                    ("object" == typeof a.source &&
                      (this.addSource(v, a.source),
                      (a = d.clone$1(a)),
                      (a = d.extend(a, { source: v }))),
                    this._validate(
                      d.validateLayer,
                      `layers.${v}`,
                      a,
                      { arrayIndex: -1 },
                      g
                    ))
                  )
                    return;
                  (b = d.createStyleLayer(a)),
                    this._validateLayer(b),
                    b.setEventedParent(this, { layer: { id: v } }),
                    (this._serializedLayers[b.id] = b.serialize()),
                    this._updateLayerCount(b, !0);
                }
                const D = u ? this._order.indexOf(u) : this._order.length;
                if (u && -1 === D)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `Layer with id "${u}" does not exist on this map.`
                      )
                    )
                  );
                this._order.splice(D, 0, v),
                  (this._layerOrderChanged = !0),
                  (this._layers[v] = b);
                const I = this._getLayerSourceCache(b);
                if (
                  this._removedLayers[v] &&
                  b.source &&
                  I &&
                  "custom" !== b.type
                ) {
                  const M = this._removedLayers[v];
                  delete this._removedLayers[v],
                    M.type !== b.type
                      ? (this._updatedSources[b.source] = "clear")
                      : ((this._updatedSources[b.source] = "reload"),
                        I.pause());
                }
                this._updateLayer(b),
                  b.onAdd && b.onAdd(this.map),
                  this._updateDrapeFirstLayers();
              }
              moveLayer(a, u) {
                if (
                  (this._checkLoaded(), (this._changed = !0), !this._layers[a])
                )
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The layer '${a}' does not exist in the map's style and cannot be moved.`
                      )
                    )
                  );
                if (a === u) return;
                const g = this._order.indexOf(a);
                this._order.splice(g, 1);
                const v = u ? this._order.indexOf(u) : this._order.length;
                u && -1 === v
                  ? this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `Layer with id "${u}" does not exist on this map.`
                        )
                      )
                    )
                  : (this._order.splice(v, 0, a),
                    (this._layerOrderChanged = !0),
                    this._updateDrapeFirstLayers());
              }
              removeLayer(a) {
                this._checkLoaded();
                const u = this._layers[a];
                if (!u)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The layer '${a}' does not exist in the map's style and cannot be removed.`
                      )
                    )
                  );
                u.setEventedParent(null), this._updateLayerCount(u, !1);
                const g = this._order.indexOf(a);
                this._order.splice(g, 1),
                  (this._layerOrderChanged = !0),
                  (this._changed = !0),
                  (this._removedLayers[a] = u),
                  delete this._layers[a],
                  delete this._serializedLayers[a],
                  delete this._updatedLayers[a],
                  delete this._updatedPaintProps[a],
                  u.onRemove && u.onRemove(this.map),
                  this._updateDrapeFirstLayers();
              }
              getLayer(a) {
                return this._layers[a];
              }
              hasLayer(a) {
                return a in this._layers;
              }
              hasLayerType(a) {
                for (const u in this._layers)
                  if (this._layers[u].type === a) return !0;
                return !1;
              }
              setLayerZoomRange(a, u, g) {
                this._checkLoaded();
                const v = this.getLayer(a);
                v
                  ? (v.minzoom === u && v.maxzoom === g) ||
                    (null != u && (v.minzoom = u),
                    null != g && (v.maxzoom = g),
                    this._updateLayer(v))
                  : this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `The layer '${a}' does not exist in the map's style and cannot have zoom extent.`
                        )
                      )
                    );
              }
              setFilter(a, u, g = {}) {
                this._checkLoaded();
                const v = this.getLayer(a);
                if (v) {
                  if (!Be(v.filter, u))
                    return null == u
                      ? ((v.filter = void 0), void this._updateLayer(v))
                      : void (
                          this._validate(
                            d.validateFilter,
                            `layers.${v.id}.filter`,
                            u,
                            { layerType: v.type },
                            g
                          ) || ((v.filter = d.clone$1(u)), this._updateLayer(v))
                        );
                } else this.fire(new d.ErrorEvent(new Error(`The layer '${a}' does not exist in the map's style and cannot be filtered.`)));
              }
              getFilter(a) {
                const u = this.getLayer(a);
                return u && d.clone$1(u.filter);
              }
              setLayoutProperty(a, u, g, v = {}) {
                this._checkLoaded();
                const b = this.getLayer(a);
                b
                  ? Be(b.getLayoutProperty(u), g) ||
                    (b.setLayoutProperty(u, g, v), this._updateLayer(b))
                  : this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `The layer '${a}' does not exist in the map's style and cannot be styled.`
                        )
                      )
                    );
              }
              getLayoutProperty(a, u) {
                const g = this.getLayer(a);
                if (g) return g.getLayoutProperty(u);
                this.fire(
                  new d.ErrorEvent(
                    new Error(
                      `The layer '${a}' does not exist in the map's style.`
                    )
                  )
                );
              }
              setPaintProperty(a, u, g, v = {}) {
                this._checkLoaded();
                const b = this.getLayer(a);
                b
                  ? Be(b.getPaintProperty(u), g) ||
                    (b.setPaintProperty(u, g, v) && this._updateLayer(b),
                    (this._changed = !0),
                    (this._updatedPaintProps[a] = !0))
                  : this.fire(
                      new d.ErrorEvent(
                        new Error(
                          `The layer '${a}' does not exist in the map's style and cannot be styled.`
                        )
                      )
                    );
              }
              getPaintProperty(a, u) {
                const g = this.getLayer(a);
                return g && g.getPaintProperty(u);
              }
              setFeatureState(a, u) {
                this._checkLoaded();
                const g = a.source,
                  v = a.sourceLayer,
                  b = this.getSource(g);
                if (!b)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The source '${g}' does not exist in the map's style.`
                      )
                    )
                  );
                const D = b.type;
                if ("geojson" === D && v)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "GeoJSON sources cannot have a sourceLayer parameter."
                      )
                    )
                  );
                if ("vector" === D && !v)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                void 0 === a.id &&
                  this.fire(
                    new d.ErrorEvent(
                      new Error("The feature id parameter must be provided.")
                    )
                  );
                const I = this._getSourceCaches(g);
                for (const M of I) M.setFeatureState(v, a.id, u);
              }
              removeFeatureState(a, u) {
                this._checkLoaded();
                const g = a.source,
                  v = this.getSource(g);
                if (!v)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        `The source '${g}' does not exist in the map's style.`
                      )
                    )
                  );
                const b = v.type,
                  D = "vector" === b ? a.sourceLayer : void 0;
                if ("vector" === b && !D)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                if (u && "string" != typeof a.id && "number" != typeof a.id)
                  return void this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "A feature id is required to remove its specific state property."
                      )
                    )
                  );
                const I = this._getSourceCaches(g);
                for (const M of I) M.removeFeatureState(D, a.id, u);
              }
              getFeatureState(a) {
                this._checkLoaded();
                const u = a.source,
                  g = a.sourceLayer,
                  v = this.getSource(u);
                if (v) {
                  if ("vector" !== v.type || g)
                    return (
                      void 0 === a.id &&
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              "The feature id parameter must be provided."
                            )
                          )
                        ),
                      this._getSourceCaches(u)[0].getFeatureState(g, a.id)
                    );
                  this.fire(
                    new d.ErrorEvent(
                      new Error(
                        "The sourceLayer parameter must be provided for vector source types."
                      )
                    )
                  );
                } else this.fire(new d.ErrorEvent(new Error(`The source '${u}' does not exist in the map's style.`)));
              }
              getTransition() {
                return d.extend(
                  { duration: 300, delay: 0 },
                  this.stylesheet && this.stylesheet.transition
                );
              }
              serialize() {
                const a = {};
                for (const u in this._sourceCaches) {
                  const g = this._sourceCaches[u].getSource();
                  a[g.id] || (a[g.id] = g.serialize());
                }
                return d.filterObject(
                  {
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    light: this.stylesheet.light,
                    terrain: this.getTerrain() || void 0,
                    fog: this.stylesheet.fog,
                    center: this.stylesheet.center,
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: a,
                    layers: this._serializeLayers(this._order),
                  },
                  (u) => void 0 !== u
                );
              }
              _updateLayer(a) {
                this._updatedLayers[a.id] = !0;
                const u = this._getLayerSourceCache(a);
                a.source &&
                  !this._updatedSources[a.source] &&
                  u &&
                  "raster" !== u.getSource().type &&
                  ((this._updatedSources[a.source] = "reload"), u.pause()),
                  (this._changed = !0),
                  a.invalidateCompiledFilter();
              }
              _flattenAndSortRenderedFeatures(a) {
                const u = (D) => "fill-extrusion" === this._layers[D].type,
                  g = {},
                  v = [];
                for (let D = this._order.length - 1; D >= 0; D--) {
                  const I = this._order[D];
                  if (u(I)) {
                    g[I] = D;
                    for (const M of a) {
                      const R = M[I];
                      if (R) for (const k of R) v.push(k);
                    }
                  }
                }
                v.sort((D, I) => I.intersectionZ - D.intersectionZ);
                const b = [];
                for (let D = this._order.length - 1; D >= 0; D--) {
                  const I = this._order[D];
                  if (u(I))
                    for (let M = v.length - 1; M >= 0; M--) {
                      const R = v[M].feature;
                      if (g[R.layer.id] < D) break;
                      b.push(R), v.pop();
                    }
                  else
                    for (const M of a) {
                      const R = M[I];
                      if (R) for (const k of R) b.push(k.feature);
                    }
                }
                return b;
              }
              queryRenderedFeatures(a, u, g) {
                u &&
                  u.filter &&
                  this._validate(
                    d.validateFilter,
                    "queryRenderedFeatures.filter",
                    u.filter,
                    null,
                    u
                  );
                const v = {};
                if (u && u.layers) {
                  if (!Array.isArray(u.layers))
                    return (
                      this.fire(
                        new d.ErrorEvent(
                          new Error("parameters.layers must be an Array.")
                        )
                      ),
                      []
                    );
                  for (const M of u.layers) {
                    const R = this._layers[M];
                    if (!R)
                      return (
                        this.fire(
                          new d.ErrorEvent(
                            new Error(
                              `The layer '${M}' does not exist in the map's style and cannot be queried for features.`
                            )
                          )
                        ),
                        []
                      );
                    v[R.source] = !0;
                  }
                }
                const b = [];
                u.availableImages = this._availableImages;
                const D =
                    u && u.layers
                      ? u.layers.some((M) => {
                          const R = this.getLayer(M);
                          return R && R.is3D();
                        })
                      : this.has3DLayers(),
                  I = Rs.createFromScreenPoints(a, g);
                for (const M in this._sourceCaches) {
                  const R = this._sourceCaches[M].getSource().id;
                  (u.layers && !v[R]) ||
                    b.push(
                      Gn(
                        this._sourceCaches[M],
                        this._layers,
                        this._serializedLayers,
                        I,
                        u,
                        g,
                        D,
                        !!this.map._showQueryGeometry
                      )
                    );
                }
                return (
                  this.placement &&
                    b.push(
                      (function (M, R, k, z, H, q, X) {
                        const Z = {},
                          Y = q.queryRenderedSymbols(z),
                          B = [];
                        for (const W of Object.keys(Y).map(Number))
                          B.push(X[W]);
                        B.sort(Xi);
                        for (const W of B) {
                          const ee = W.featureIndex.lookupSymbolFeatures(
                            Y[W.bucketInstanceId],
                            R,
                            W.bucketIndex,
                            W.sourceLayerIndex,
                            H.filter,
                            H.layers,
                            H.availableImages,
                            M
                          );
                          for (const te in ee) {
                            const he = (Z[te] = Z[te] || []),
                              de = ee[te];
                            de.sort((ue, _e) => {
                              const ge = W.featureSortOrder;
                              if (ge) {
                                const Te = ge.indexOf(ue.featureIndex);
                                return ge.indexOf(_e.featureIndex) - Te;
                              }
                              return _e.featureIndex - ue.featureIndex;
                            });
                            for (const ue of de) he.push(ue);
                          }
                        }
                        for (const W in Z)
                          Z[W].forEach((ee) => {
                            const te = ee.feature,
                              he = k(M[W]);
                            if (!he) return;
                            const de = he.getFeatureState(
                              te.layer["source-layer"],
                              te.id
                            );
                            (te.source = te.layer.source),
                              te.layer["source-layer"] &&
                                (te.sourceLayer = te.layer["source-layer"]),
                              (te.state = de);
                          });
                        return Z;
                      })(
                        this._layers,
                        this._serializedLayers,
                        this._getLayerSourceCache.bind(this),
                        I.screenGeometry,
                        u,
                        this.placement.collisionIndex,
                        this.placement.retainedQueryData
                      )
                    ),
                  this._flattenAndSortRenderedFeatures(b)
                );
              }
              querySourceFeatures(a, u) {
                u &&
                  u.filter &&
                  this._validate(
                    d.validateFilter,
                    "querySourceFeatures.filter",
                    u.filter,
                    null,
                    u
                  );
                const g = this._getSourceCaches(a);
                let v = [];
                for (const b of g) v = v.concat(ui(b, u));
                return v;
              }
              addSourceType(a, u, g) {
                return yo.getSourceType(a)
                  ? g(new Error(`A source type called "${a}" already exists.`))
                  : (yo.setSourceType(a, u),
                    u.workerSourceURL
                      ? void this.dispatcher.broadcast(
                          "loadWorkerSource",
                          { name: a, url: u.workerSourceURL },
                          g
                        )
                      : g(null, null));
              }
              getLight() {
                return this.light.getLight();
              }
              setLight(a, u = {}) {
                this._checkLoaded();
                const g = this.light.getLight();
                let v = !1;
                for (const D in a)
                  if (!Be(a[D], g[D])) {
                    v = !0;
                    break;
                  }
                if (!v) return;
                const b = this._setTransitionParameters({
                  duration: 300,
                  delay: 0,
                });
                this.light.setLight(a, u), this.light.updateTransitions(b);
              }
              getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode
                  ? this.terrain.get()
                  : null;
              }
              setTerrainForDraping() {
                this.setTerrain({ source: "", exaggeration: 0 }, 0);
              }
              setTerrain(a, u = 1) {
                if ((this._checkLoaded(), !a))
                  return (
                    delete this.terrain,
                    delete this.stylesheet.terrain,
                    this.dispatcher.broadcast("enableTerrain", !1),
                    this._force3DLayerUpdate(),
                    void (this._markersNeedUpdate = !0)
                  );
                let g = a;
                if (1 === u) {
                  if ("object" == typeof g.source) {
                    const v = "terrain-dem-src";
                    this.addSource(v, g.source),
                      (g = d.clone$1(g)),
                      (g = d.extend(g, { source: v }));
                  }
                  if (this._validate(d.validateTerrain, "terrain", g)) return;
                }
                if (
                  !this.terrain ||
                  (this.terrain && u !== this.terrain.drapeRenderMode)
                ) {
                  if (!g) return;
                  this._createTerrain(g, u);
                } else {
                  const v = this.terrain,
                    b = v.get();
                  for (const D of Object.keys(d.spec.terrain))
                    !g.hasOwnProperty(D) &&
                      d.spec.terrain[D].default &&
                      (g[D] = d.spec.terrain[D].default);
                  for (const D in g)
                    if (!Be(g[D], b[D])) {
                      v.set(g), (this.stylesheet.terrain = g);
                      const I = this._setTransitionParameters({ duration: 0 });
                      v.updateTransitions(I);
                      break;
                    }
                }
                this._updateDrapeFirstLayers(), (this._markersNeedUpdate = !0);
              }
              _createFog(a) {
                const u = (this.fog = new Ma(a, this.map.transform));
                this.stylesheet.fog = a;
                const g = this._setTransitionParameters({ duration: 0 });
                u.updateTransitions(g);
              }
              _updateMarkersOpacity() {
                0 !== this.map._markers.length &&
                  this.map._requestDomTask(() => {
                    for (const a of this.map._markers) a._evaluateOpacity();
                  });
              }
              getFog() {
                return this.fog ? this.fog.get() : null;
              }
              setFog(a) {
                if ((this._checkLoaded(), !a))
                  return (
                    delete this.fog,
                    delete this.stylesheet.fog,
                    void (this._markersNeedUpdate = !0)
                  );
                if (this.fog) {
                  const u = this.fog,
                    g = u.get();
                  0 === Object.keys(a).length && u.set(a);
                  for (const v in a)
                    if (!Be(a[v], g[v])) {
                      u.set(a), (this.stylesheet.fog = a);
                      const b = this._setTransitionParameters({ duration: 0 });
                      u.updateTransitions(b);
                      break;
                    }
                } else this._createFog(a);
                this._markersNeedUpdate = !0;
              }
              _setTransitionParameters(a) {
                return {
                  now: d.exported.now(),
                  transition: d.extend(a, this.stylesheet.transition),
                };
              }
              _updateDrapeFirstLayers() {
                if (!this.map._optimizeForTerrain || !this.terrain) return;
                const a = this._order.filter((g) =>
                    this.isLayerDraped(this._layers[g])
                  ),
                  u = this._order.filter(
                    (g) => !this.isLayerDraped(this._layers[g])
                  );
                (this._drapedFirstOrder = []),
                  this._drapedFirstOrder.push(...a),
                  this._drapedFirstOrder.push(...u);
              }
              _createTerrain(a, u) {
                const g = (this.terrain = new au(a, u));
                (this.stylesheet.terrain = a),
                  this.dispatcher.broadcast(
                    "enableTerrain",
                    !this.terrainSetForDrapingOnly()
                  ),
                  this._force3DLayerUpdate();
                const v = this._setTransitionParameters({ duration: 0 });
                g.updateTransitions(v);
              }
              _force3DLayerUpdate() {
                for (const a in this._layers) {
                  const u = this._layers[a];
                  "fill-extrusion" === u.type && this._updateLayer(u);
                }
              }
              _forceSymbolLayerUpdate() {
                for (const a in this._layers) {
                  const u = this._layers[a];
                  "symbol" === u.type && this._updateLayer(u);
                }
              }
              _validate(a, u, g, v, b = {}) {
                return (
                  (!b || !1 !== b.validate) &&
                  _o(
                    this,
                    a.call(
                      d.validateStyle,
                      d.extend(
                        {
                          key: u,
                          style: this.serialize(),
                          value: g,
                          styleSpec: d.spec,
                        },
                        v
                      )
                    )
                  )
                );
              }
              _remove() {
                this._request &&
                  (this._request.cancel(), (this._request = null)),
                  this._spriteRequest &&
                    (this._spriteRequest.cancel(),
                    (this._spriteRequest = null)),
                  d.evented.off(
                    "pluginStateChange",
                    this._rtlTextPluginCallback
                  );
                for (const a in this._layers)
                  this._layers[a].setEventedParent(null);
                for (const a in this._sourceCaches)
                  this._sourceCaches[a].clearTiles(),
                    this._sourceCaches[a].setEventedParent(null);
                this.imageManager.setEventedParent(null),
                  this.setEventedParent(null),
                  this.dispatcher.remove();
              }
              _clearSource(a) {
                const u = this._getSourceCaches(a);
                for (const g of u) g.clearTiles();
              }
              _reloadSource(a) {
                const u = this._getSourceCaches(a);
                for (const g of u) g.resume(), g.reload();
              }
              _reloadSources() {
                for (const a of this._getSources()) a.reload && a.reload();
              }
              _updateSources(a) {
                for (const u in this._sourceCaches)
                  this._sourceCaches[u].update(a);
              }
              _generateCollisionBoxes() {
                for (const a in this._sourceCaches) {
                  const u = this._sourceCaches[a];
                  u.resume(), u.reload();
                }
              }
              _updatePlacement(a, u, g, v, b = !1) {
                let D = !1,
                  I = !1;
                const M = {};
                for (const R of this._order) {
                  const k = this._layers[R];
                  if ("symbol" !== k.type) continue;
                  if (!M[k.source]) {
                    const H = this._getLayerSourceCache(k);
                    if (!H) continue;
                    M[k.source] = H.getRenderableIds(!0)
                      .map((q) => H.getTileByID(q))
                      .sort(
                        (q, X) =>
                          X.tileID.overscaledZ - q.tileID.overscaledZ ||
                          (q.tileID.isLessThan(X.tileID) ? -1 : 1)
                      );
                  }
                  const z = this.crossTileSymbolIndex.addLayer(
                    k,
                    M[k.source],
                    a.center.lng,
                    a.projection
                  );
                  D = D || z;
                }
                if (
                  (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                  (b = b || this._layerOrderChanged || 0 === g),
                  this._layerOrderChanged && this.fire(new d.Event("neworder")),
                  (b ||
                    !this.pauseablePlacement ||
                    (this.pauseablePlacement.isDone() &&
                      !this.placement.stillRecent(d.exported.now(), a.zoom))) &&
                    ((this.pauseablePlacement = new cp(
                      a,
                      this._order,
                      b,
                      u,
                      g,
                      v,
                      this.placement,
                      this.fog && a.projection.supportsFog
                        ? this.fog.state
                        : null
                    )),
                    (this._layerOrderChanged = !1)),
                  this.pauseablePlacement.isDone()
                    ? this.placement.setStale()
                    : (this.pauseablePlacement.continuePlacement(
                        this._order,
                        this._layers,
                        M
                      ),
                      this.pauseablePlacement.isDone() &&
                        ((this.placement = this.pauseablePlacement.commit(
                          d.exported.now()
                        )),
                        (I = !0)),
                      D && this.pauseablePlacement.placement.setStale()),
                  I || D)
                )
                  for (const R of this._order) {
                    const k = this._layers[R];
                    "symbol" === k.type &&
                      this.placement.updateLayerOpacities(k, M[k.source]);
                  }
                return (
                  !this.pauseablePlacement.isDone() ||
                  this.placement.hasTransitions(d.exported.now())
                );
              }
              _releaseSymbolFadeTiles() {
                for (const a in this._sourceCaches)
                  this._sourceCaches[a].releaseSymbolFadeTiles();
              }
              getImages(a, u, g) {
                this.imageManager.getImages(u.icons, g),
                  this._updateTilesForChangedImages();
                const v = (b) => {
                  b && b.setDependencies(u.tileID.key, u.type, u.icons);
                };
                v(this._otherSourceCaches[u.source]),
                  v(this._symbolSourceCaches[u.source]);
              }
              getGlyphs(a, u, g) {
                this.glyphManager.getGlyphs(u.stacks, g);
              }
              getResource(a, u, g) {
                return d.makeRequest(u, g);
              }
              _getSourceCache(a) {
                return this._otherSourceCaches[a];
              }
              _getLayerSourceCache(a) {
                return "symbol" === a.type
                  ? this._symbolSourceCaches[a.source]
                  : this._otherSourceCaches[a.source];
              }
              _getSourceCaches(a) {
                const u = [];
                return (
                  this._otherSourceCaches[a] &&
                    u.push(this._otherSourceCaches[a]),
                  this._symbolSourceCaches[a] &&
                    u.push(this._symbolSourceCaches[a]),
                  u
                );
              }
              _isSourceCacheLoaded(a) {
                const u = this._getSourceCaches(a);
                return 0 === u.length
                  ? (this.fire(
                      new d.ErrorEvent(
                        new Error(`There is no source with ID '${a}'`)
                      )
                    ),
                    !1)
                  : u.every((g) => g.loaded());
              }
              has3DLayers() {
                return this._num3DLayers > 0;
              }
              hasSymbolLayers() {
                return this._numSymbolLayers > 0;
              }
              hasCircleLayers() {
                return this._numCircleLayers > 0;
              }
              _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
              }
              destroy() {
                this._clearWorkerCaches(),
                  this.terrainSetForDrapingOnly() &&
                    (delete this.terrain, delete this.stylesheet.terrain);
              }
            }
            (yo.getSourceType = function (f) {
              return Et[f];
            }),
              (yo.setSourceType = function (f, a) {
                Et[f] = a;
              }),
              (yo.registerForPluginStateChange =
                d.registerForPluginStateChange);
            var Cl =
                "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0",
              ds =
                "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",
              Uo =
                "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif",
              gc =
                "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif",
              Tt =
                "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
            let Ml = {},
              Al = {};
            const rr = [];
            _c(Cl, rr),
              _c(Uo, rr),
              _c(gc, rr),
              _c(Tt, rr),
              (Ml = yn("", Uo)),
              (Al = yn(Tt, gc));
            const kh = yn(
                "\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}",
                "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."
              ),
              Rh = Cl,
              $o =
                "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
            var Hr = {
              background: yn(
                "uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              backgroundPattern: yn(
                "uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              circle: yn(
                "varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"
              ),
              clippingMask: yn(
                "void main() {gl_FragColor=vec4(1.0);}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"
              ),
              heatmap: yn(
                "uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              heatmapTexture: yn(
                "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}",
                "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"
              ),
              collisionBox: yn(
                "varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}",
                "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"
              ),
              collisionCircle: yn(
                "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}",
                "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"
              ),
              debug: yn(
                "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}",
                "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"
              ),
              fill: yn(
                "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillOutline: yn(
                "varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillOutlinePattern: yn(
                "uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillPattern: yn(
                "uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              fillExtrusion: yn(
                "varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              fillExtrusionPattern: yn(
                "uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"
              ),
              hillshadePrepare: yn(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"
              ),
              hillshade: yn(
                "uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              line: yn(
                "uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              linePattern: yn(
                "uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"
              ),
              raster: yn(
                "uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"
              ),
              symbolIcon: yn(
                "uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"
              ),
              symbolSDF: yn(
                "#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"
              ),
              symbolTextAndIcon: yn(
                "#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"
              ),
              terrainRaster: yn(
                "uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"
              ),
              terrainDepth: yn(
                "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}",
                "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"
              ),
              skybox: yn(
                "\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                ds
              ),
              skyboxGradient: yn(
                "varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                ds
              ),
              skyboxCapture: yn(
                "\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}",
                "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"
              ),
              globeRaster: yn(
                "uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}",
                "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"
              ),
              globeAtmosphere: yn(
                "uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}",
                "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"
              ),
            };
            function _c(f, a) {
              const u = f.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
              for (let g of u)
                if (
                  ((g = g.trim()),
                  "#" === g[0] && g.includes("if") && !g.includes("endif"))
                ) {
                  g = g
                    .replace("#", "")
                    .replace(/ifdef|ifndef|elif|if/g, "")
                    .replace(/!|defined|\(|\)|\|\||&&/g, "")
                    .replace(/\s+/g, " ")
                    .trim();
                  const v = g.split(" ");
                  for (const b of v) a.includes(b) || a.push(b);
                }
            }
            function yn(f, a) {
              const u = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
                g = a.match(
                  /attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g
                ),
                v = {},
                b = [...rr];
              return (
                _c(f, b),
                _c(a, b),
                {
                  fragmentSource: (f = f.replace(
                    u,
                    (D, I, M, R, k) => (
                      (v[k] = !0),
                      "define" === I
                        ? `\n#ifndef HAS_UNIFORM_u_${k}\nvarying ${M} ${R} ${k};\n#else\nuniform ${M} ${R} u_${k};\n#endif\n`
                        : `\n#ifdef HAS_UNIFORM_u_${k}\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                    )
                  )),
                  vertexSource: (a = a.replace(u, (D, I, M, R, k) => {
                    const z = "float" === R ? "vec2" : "vec4",
                      H = k.match(/color/) ? "color" : z;
                    return v[k]
                      ? "define" === I
                        ? `\n#ifndef HAS_UNIFORM_u_${k}\nuniform lowp float u_${k}_t;\nattribute ${M} ${z} a_${k};\nvarying ${M} ${R} ${k};\n#else\nuniform ${M} ${R} u_${k};\n#endif\n`
                        : "vec4" === H
                        ? `\n#ifndef HAS_UNIFORM_u_${k}\n    ${k} = a_${k};\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                        : `\n#ifndef HAS_UNIFORM_u_${k}\n    ${k} = unpack_mix_${H}(a_${k}, u_${k}_t);\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                      : "define" === I
                      ? `\n#ifndef HAS_UNIFORM_u_${k}\nuniform lowp float u_${k}_t;\nattribute ${M} ${z} a_${k};\n#else\nuniform ${M} ${R} u_${k};\n#endif\n`
                      : "vec4" === H
                      ? `\n#ifndef HAS_UNIFORM_u_${k}\n    ${M} ${R} ${k} = a_${k};\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`
                      : `\n#ifndef HAS_UNIFORM_u_${k}\n    ${M} ${R} ${k} = unpack_mix_${H}(a_${k}, u_${k}_t);\n#else\n    ${M} ${R} ${k} = u_${k};\n#endif\n`;
                  })),
                  staticAttributes: g,
                  usedDefines: b,
                }
              );
            }
            class vo {
              constructor() {
                (this.boundProgram = null),
                  (this.boundLayoutVertexBuffer = null),
                  (this.boundPaintVertexBuffers = []),
                  (this.boundIndexBuffer = null),
                  (this.boundVertexOffset = null),
                  (this.boundDynamicVertexBuffers = []),
                  (this.vao = null);
              }
              bind(a, u, g, v, b, D, I) {
                this.context = a;
                let M = this.boundPaintVertexBuffers.length !== v.length;
                for (let k = 0; !M && k < v.length; k++)
                  this.boundPaintVertexBuffers[k] !== v[k] && (M = !0);
                let R = this.boundDynamicVertexBuffers.length !== I.length;
                for (let k = 0; !R && k < I.length; k++)
                  this.boundDynamicVertexBuffers[k] !== I[k] && (R = !0);
                if (
                  !a.extVertexArrayObject ||
                  !this.vao ||
                  this.boundProgram !== u ||
                  this.boundLayoutVertexBuffer !== g ||
                  M ||
                  R ||
                  this.boundIndexBuffer !== b ||
                  this.boundVertexOffset !== D
                )
                  this.freshBind(u, g, v, b, D, I);
                else {
                  a.bindVertexArrayOES.set(this.vao);
                  for (const k of I) k && k.bind();
                  b && b.dynamicDraw && b.bind();
                }
              }
              freshBind(a, u, g, v, b, D) {
                let I;
                const M = a.numAttributes,
                  R = this.context,
                  k = R.gl;
                if (R.extVertexArrayObject)
                  this.vao && this.destroy(),
                    (this.vao = R.extVertexArrayObject.createVertexArrayOES()),
                    R.bindVertexArrayOES.set(this.vao),
                    (I = 0),
                    (this.boundProgram = a),
                    (this.boundLayoutVertexBuffer = u),
                    (this.boundPaintVertexBuffers = g),
                    (this.boundIndexBuffer = v),
                    (this.boundVertexOffset = b),
                    (this.boundDynamicVertexBuffers = D);
                else {
                  I = R.currentNumAttributes || 0;
                  for (let z = M; z < I; z++) k.disableVertexAttribArray(z);
                }
                u.enableAttributes(k, a),
                  u.bind(),
                  u.setVertexAttribPointers(k, a, b);
                for (const z of g)
                  z.enableAttributes(k, a),
                    z.bind(),
                    z.setVertexAttribPointers(k, a, b);
                for (const z of D)
                  z &&
                    (z.enableAttributes(k, a),
                    z.bind(),
                    z.setVertexAttribPointers(k, a, b));
                v && v.bind(), (R.currentNumAttributes = M);
              }
              destroy() {
                this.vao &&
                  (this.context.extVertexArrayObject.deleteVertexArrayOES(
                    this.vao
                  ),
                  (this.vao = null));
              }
            }
            function jn(f, a) {
              const u = Math.pow(2, a.canonical.z),
                g = a.canonical.y;
              return [
                new d.MercatorCoordinate(0, g / u).toLngLat().lat,
                new d.MercatorCoordinate(0, (g + 1) / u).toLngLat().lat,
              ];
            }
            function kf(f, a, u, g, v, b, D) {
              const I = f.context,
                M = I.gl,
                R = u.fbo;
              if (!R) return;
              f.prepareDrawTile();
              const k = f.useProgram("hillshade");
              I.activeTexture.set(M.TEXTURE0),
                M.bindTexture(M.TEXTURE_2D, R.colorAttachment.get());
              const z = ((Z, Y, B, W) => {
                const ee = B.paint.get("hillshade-shadow-color"),
                  te = B.paint.get("hillshade-highlight-color"),
                  he = B.paint.get("hillshade-accent-color");
                let de =
                  B.paint.get("hillshade-illumination-direction") *
                  (Math.PI / 180);
                "viewport" === B.paint.get("hillshade-illumination-anchor") &&
                  (de -= Z.transform.angle);
                const ue = !Z.options.moving;
                return {
                  u_matrix:
                    W ||
                    Z.transform.calculateProjMatrix(Y.tileID.toUnwrapped(), ue),
                  u_image: 0,
                  u_latrange: jn(0, Y.tileID),
                  u_light: [B.paint.get("hillshade-exaggeration"), de],
                  u_shadow: ee,
                  u_highlight: te,
                  u_accent: he,
                };
              })(f, u, g, f.terrain ? a.projMatrix : null);
              f.prepareDrawProgram(I, k, a.toUnwrapped());
              const {
                tileBoundsBuffer: H,
                tileBoundsIndexBuffer: q,
                tileBoundsSegments: X,
              } = f.getTileBoundsBuffers(u);
              k.draw(
                I,
                M.TRIANGLES,
                v,
                b,
                D,
                d.CullFaceMode.disabled,
                z,
                g.id,
                H,
                q,
                X
              );
            }
            function dp(f, a, u) {
              if (!a.needsDEMTextureUpload) return;
              const g = f.context,
                v = g.gl;
              g.pixelStoreUnpackPremultiplyAlpha.set(!1),
                (a.demTexture = a.demTexture || f.getTileTexture(u.stride));
              const b = u.getPixels();
              a.demTexture
                ? a.demTexture.update(b, { premultiply: !1 })
                : (a.demTexture = new d.Texture(g, b, v.RGBA, {
                    premultiply: !1,
                  })),
                (a.needsDEMTextureUpload = !1);
            }
            function Oa(f, a, u, g, v, b) {
              const D = f.context,
                I = D.gl;
              if (!a.dem) return;
              const M = a.dem;
              if ((D.activeTexture.set(I.TEXTURE1), dp(f, a, M), !a.demTexture))
                return;
              a.demTexture.bind(I.NEAREST, I.CLAMP_TO_EDGE);
              const R = M.dim;
              D.activeTexture.set(I.TEXTURE0);
              let k = a.fbo;
              if (!k) {
                const X = new d.Texture(
                  D,
                  { width: R, height: R, data: null },
                  I.RGBA
                );
                X.bind(I.LINEAR, I.CLAMP_TO_EDGE),
                  (k = a.fbo = D.createFramebuffer(R, R, !0)),
                  k.colorAttachment.set(X.texture);
              }
              D.bindFramebuffer.set(k.framebuffer),
                D.viewport.set([0, 0, R, R]);
              const {
                tileBoundsBuffer: z,
                tileBoundsIndexBuffer: H,
                tileBoundsSegments: q,
              } = f.getMercatorTileBoundsBuffers();
              f.useProgram("hillshadePrepare").draw(
                D,
                I.TRIANGLES,
                g,
                v,
                b,
                d.CullFaceMode.disabled,
                ((X, Z) => {
                  const Y = Z.stride,
                    B = d.create();
                  return (
                    d.ortho(B, 0, d.EXTENT, -d.EXTENT, 0, 0, 1),
                    d.translate(B, B, [0, -d.EXTENT, 0]),
                    {
                      u_matrix: B,
                      u_image: 1,
                      u_dimension: [Y, Y],
                      u_zoom: X.overscaledZ,
                      u_unpack: Z.unpackVector,
                    }
                  );
                })(a.tileID, M),
                u.id,
                z,
                H,
                q
              ),
                (a.needsHillshadePrepare = !1);
            }
            const vn = (f) => ({
                u_matrix: new d.UniformMatrix4f(f),
                u_image0: new d.Uniform1i(f),
                u_skirt_height: new d.Uniform1f(f),
              }),
              ps = (f, a) => ({ u_matrix: f, u_image0: 0, u_skirt_height: a }),
              Pl = (f, a, u, g, v, b, D, I, M, R, k, z, H, q, X) => ({
                u_proj_matrix: Float32Array.from(f),
                u_globe_matrix: a,
                u_normalize_matrix: Float32Array.from(g),
                u_merc_matrix: u,
                u_zoom_transition: v,
                u_merc_center: b,
                u_image0: 0,
                u_frustum_tl: D,
                u_frustum_tr: I,
                u_frustum_br: M,
                u_frustum_bl: R,
                u_globe_pos: k,
                u_globe_radius: z,
                u_viewport: H,
                u_grid_matrix: X ? Float32Array.from(X) : new Float32Array(9),
                u_skirt_height: q,
              });
            function Us(f, a) {
              return (
                null != f &&
                null != a &&
                !(!f.hasData() || !a.hasData()) &&
                null != f.demTexture &&
                null != a.demTexture &&
                f.tileID.key !== a.tileID.key
              );
            }
            const Ho = new (class {
                constructor() {
                  this.operations = {};
                }
                newMorphing(f, a, u, g, v) {
                  if (f in this.operations) {
                    const b = this.operations[f];
                    b.to.tileID.key !== u.tileID.key && (b.queued = u);
                  } else
                    this.operations[f] = {
                      startTime: g,
                      phase: 0,
                      duration: v,
                      from: a,
                      to: u,
                      queued: null,
                    };
                }
                getMorphValuesForProxy(f) {
                  if (!(f in this.operations)) return null;
                  const a = this.operations[f];
                  return { from: a.from, to: a.to, phase: a.phase };
                }
                update(f) {
                  for (const a in this.operations) {
                    const u = this.operations[a];
                    for (
                      u.phase = (f - u.startTime) / u.duration;
                      u.phase >= 1 || !this._validOp(u);

                    )
                      if (!this._nextOp(u, f)) {
                        delete this.operations[a];
                        break;
                      }
                  }
                }
                _nextOp(f, a) {
                  return (
                    !!f.queued &&
                    ((f.from = f.to),
                    (f.to = f.queued),
                    (f.queued = null),
                    (f.phase = 0),
                    (f.startTime = a),
                    !0)
                  );
                }
                _validOp(f) {
                  return f.from.hasData() && f.to.hasData();
                }
              })(),
              _r = {
                0: null,
                1: "TERRAIN_VERTEX_MORPHING",
                2: "TERRAIN_WIREFRAME",
              };
            function $s(f) {
              return 6 * Math.pow(1.5, 22 - f);
            }
            function pp(f, a) {
              const u = 1 << f.z;
              return (
                (!a && (0 === f.x || f.x === u - 1)) ||
                0 === f.y ||
                f.y === u - 1
              );
            }
            const xo = (f) => ({ u_matrix: f });
            function Oh(f, a, u, g, v) {
              if (v > 0) {
                const b = d.exported.now(),
                  D = (b - f.timeAdded) / v,
                  I = a ? (b - a.timeAdded) / v : -1,
                  M = u.getSource(),
                  R = g.coveringZoomLevel({
                    tileSize: M.tileSize,
                    roundZoom: M.roundZoom,
                  }),
                  k =
                    !a ||
                    Math.abs(a.tileID.overscaledZ - R) >
                      Math.abs(f.tileID.overscaledZ - R),
                  z =
                    k && f.refreshedUponExpiration
                      ? 1
                      : d.clamp(k ? D : 1 - I, 0, 1);
                return (
                  f.refreshedUponExpiration &&
                    D >= 1 &&
                    (f.refreshedUponExpiration = !1),
                  a ? { opacity: 1, mix: 1 - z } : { opacity: z, mix: 0 }
                );
              }
              return { opacity: 1, mix: 0 };
            }
            class vu extends d.SourceCache {
              constructor(a) {
                const u = { type: "raster-dem", maxzoom: a.transform.maxZoom },
                  g = new bn(ka(), null),
                  v = Gt("mock-dem", u, g, a.style);
                super("mock-dem", v, !1),
                  v.setEventedParent(this),
                  (this._sourceLoaded = !0);
              }
              _loadTile(a, u) {
                (a.state = "loaded"), u(null);
              }
            }
            class yc extends d.SourceCache {
              constructor(a) {
                const u = Gt(
                  "proxy",
                  { type: "geojson", maxzoom: a.transform.maxZoom },
                  new bn(ka(), null),
                  a.style
                );
                super("proxy", u, !1),
                  u.setEventedParent(this),
                  (this.map = this.getSource().map = a),
                  (this.used = this._sourceLoaded = !0),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
              update(a, u, g) {
                if (a.freezeTileCoverage) return;
                this.transform = a;
                const v = a
                  .coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled,
                  })
                  .reduce((b, D) => {
                    if (((b[D.key] = ""), !this._tiles[D.key])) {
                      const I = new d.Tile(
                        D,
                        this._source.tileSize * D.overscaleFactor(),
                        a.tileZoom
                      );
                      (I.state = "loaded"), (this._tiles[D.key] = I);
                    }
                    return b;
                  }, {});
                for (const b in this._tiles)
                  b in v ||
                    (this.freeFBO(b),
                    this._tiles[b].unloadVectorData(),
                    delete this._tiles[b]);
              }
              freeFBO(a) {
                const u = this.proxyCachedFBO[a];
                if (void 0 !== u) {
                  const g = Object.values(u);
                  this.renderCachePool.push(...g),
                    delete this.proxyCachedFBO[a];
                }
              }
              deallocRenderCache() {
                this.renderCache.forEach((a) => a.fb.destroy()),
                  (this.renderCache = []),
                  (this.renderCachePool = []),
                  (this.proxyCachedFBO = {});
              }
            }
            class or extends d.OverscaledTileID {
              constructor(a, u, g) {
                super(
                  a.overscaledZ,
                  a.wrap,
                  a.canonical.z,
                  a.canonical.x,
                  a.canonical.y
                ),
                  (this.proxyTileKey = u),
                  (this.projMatrix = g);
              }
            }
            class Fh extends d.Elevation {
              constructor(a, u) {
                super(),
                  (this.painter = a),
                  (this.terrainTileForTile = {}),
                  (this.prevTerrainTileForTile = {});
                const [g, v, b] = (function (M) {
                    const R = new d.StructArrayLayout2i4(),
                      k = new d.StructArrayLayout3ui6(),
                      z = 131;
                    R.reserve(17161), k.reserve(33800);
                    const H = d.EXTENT / 128,
                      q = d.EXTENT + H / 2,
                      X = q + H;
                    for (let Y = -H; Y < X; Y += H)
                      for (let B = -H; B < X; B += H) {
                        const W = B < 0 || B > q || Y < 0 || Y > q ? 24575 : 0,
                          ee = d.clamp(Math.round(B), 0, d.EXTENT),
                          te = d.clamp(Math.round(Y), 0, d.EXTENT);
                        R.emplaceBack(ee + W, te);
                      }
                    const Z = (Y, B) => {
                      const W = B * z + Y;
                      k.emplaceBack(W + 1, W, W + z),
                        k.emplaceBack(W + z, W + z + 1, W + 1);
                    };
                    for (let Y = 1; Y < 129; Y++)
                      for (let B = 1; B < 129; B++) Z(B, Y);
                    return (
                      [0, 129].forEach((Y) => {
                        for (let B = 0; B < 130; B++) Z(B, Y), Z(Y, B);
                      }),
                      [R, k, 32768]
                    );
                  })(),
                  D = a.context;
                (this.gridBuffer = D.createVertexBuffer(
                  g,
                  d.posAttributes.members
                )),
                  (this.gridIndexBuffer = D.createIndexBuffer(v)),
                  (this.gridSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    g.length,
                    v.length
                  )),
                  (this.gridNoSkirtSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    g.length,
                    b
                  )),
                  (this.proxyCoords = []),
                  (this.proxiedCoords = {}),
                  (this._visibleDemTiles = []),
                  (this._drapedRenderBatches = []),
                  (this._sourceTilesOverlap = {}),
                  (this.proxySourceCache = new yc(u.map)),
                  (this.orthoMatrix = d.create()),
                  d.ortho(
                    this.orthoMatrix,
                    "globe" === this.painter.transform.projection.name
                      ? 0.015
                      : 0,
                    d.EXTENT,
                    0,
                    d.EXTENT,
                    0,
                    1
                  );
                const I = D.gl;
                (this._overlapStencilMode = new d.StencilMode(
                  { func: I.GEQUAL, mask: 255 },
                  0,
                  255,
                  I.KEEP,
                  I.KEEP,
                  I.REPLACE
                )),
                  (this._previousZoom = a.transform.zoom),
                  (this.pool = []),
                  (this._findCoveringTileCache = {}),
                  (this._tilesDirty = {}),
                  (this.style = u),
                  (this._useVertexMorphing = !0),
                  (this._exaggeration = 1),
                  (this._mockSourceCache = new vu(u.map));
              }
              set style(a) {
                a.on("data", this._onStyleDataEvent.bind(this)),
                  a.on("neworder", this._checkRenderCacheEfficiency.bind(this)),
                  (this._style = a),
                  this._checkRenderCacheEfficiency(),
                  this._style.map.on("moveend", () => {
                    this._clearLineLayersFromRenderCache();
                  });
              }
              update(a, u, g) {
                if (a && a.terrain) {
                  this._style !== a && (this.style = a), (this.enabled = !0);
                  const v = a.terrain.properties;
                  (this.sourceCache =
                    0 === a.terrain.drapeRenderMode
                      ? this._mockSourceCache
                      : a._getSourceCache(v.get("source"))),
                    (this._exaggeration = v.get("exaggeration"));
                  const b = () => {
                    this.sourceCache.used &&
                      d.warnOnce(
                        `Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`
                      );
                    const D = this.getScaledDemTileSize();
                    this.sourceCache.update(u, D, !0),
                      this.resetTileLookupCache(this.sourceCache.id);
                  };
                  this.sourceCache.usedForTerrain ||
                    (this.resetTileLookupCache(this.sourceCache.id),
                    (this.sourceCache.usedForTerrain = !0),
                    b(),
                    (this._initializing = !0)),
                    b(),
                    u.updateElevation(!0, g),
                    this.resetTileLookupCache(this.proxySourceCache.id),
                    this.proxySourceCache.update(u),
                    (this._emptyDEMTextureDirty = !0);
                } else this._disable();
              }
              resetTileLookupCache(a) {
                this._findCoveringTileCache[a] = {};
              }
              getScaledDemTileSize() {
                return (
                  (this.sourceCache.getSource().tileSize / 128) *
                  this.proxySourceCache.getSource().tileSize
                );
              }
              _checkRenderCacheEfficiency() {
                const a = this.renderCacheEfficiency(this._style);
                this._style.map._optimizeForTerrain ||
                  (100 !== a.efficiency &&
                    d.warnOnce(
                      `Terrain render cache efficiency is not optimal (${a.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${a.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`
                    ));
              }
              _onStyleDataEvent(a) {
                a.coord && "source" === a.dataType
                  ? this._clearRenderCacheForTile(a.sourceCacheId, a.coord)
                  : "style" === a.dataType &&
                    (this._invalidateRenderCache = !0);
              }
              _disable() {
                if (
                  this.enabled &&
                  ((this.enabled = !1),
                  (this._sharedDepthStencil = void 0),
                  this.proxySourceCache.deallocRenderCache(),
                  this._style)
                )
                  for (const a in this._style._sourceCaches)
                    this._style._sourceCaches[a].usedForTerrain = !1;
              }
              destroy() {
                this._disable(),
                  this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                  this._emptyDepthBufferTexture &&
                    this._emptyDepthBufferTexture.destroy(),
                  this.pool.forEach((a) => a.fb.destroy()),
                  (this.pool = []),
                  this._depthFBO &&
                    (this._depthFBO.destroy(),
                    (this._depthFBO = void 0),
                    (this._depthTexture = void 0));
              }
              _source() {
                return this.enabled ? this.sourceCache : null;
              }
              isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
              }
              exaggeration() {
                return this._exaggeration;
              }
              get visibleDemTiles() {
                return this._visibleDemTiles;
              }
              get drapeBufferSize() {
                const a = 2 * this.proxySourceCache.getSource().tileSize;
                return [a, a];
              }
              set useVertexMorphing(a) {
                this._useVertexMorphing = a;
              }
              updateTileBinding(a) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const u = this.proxySourceCache,
                  g = this.painter.transform;
                this._initializing &&
                  ((this._initializing =
                    0 === g._centerAltitude &&
                    -1 ===
                      this.getAtPointOrZero(
                        d.MercatorCoordinate.fromLngLat(g.center),
                        -1
                      )),
                  (this._emptyDEMTextureDirty = !this._initializing));
                const v = (this.proxyCoords = u.getIds().map((M) => {
                  const R = u.getTileByID(M).tileID;
                  return (
                    (R.projMatrix = g.calculateProjMatrix(R.toUnwrapped())), R
                  );
                }));
                (function (M, R) {
                  const k = R.transform.pointCoordinate(
                      R.transform.getCameraPoint()
                    ),
                    z = new d.Point(k.x, k.y);
                  M.sort((H, q) => {
                    if (q.overscaledZ - H.overscaledZ)
                      return q.overscaledZ - H.overscaledZ;
                    const X = new d.Point(
                        H.canonical.x + (1 << H.canonical.z) * H.wrap,
                        H.canonical.y
                      ),
                      Z = new d.Point(
                        q.canonical.x + (1 << q.canonical.z) * q.wrap,
                        q.canonical.y
                      ),
                      Y = z.mult(1 << H.canonical.z);
                    return (
                      (Y.x -= 0.5), (Y.y -= 0.5), Y.distSqr(X) - Y.distSqr(Z)
                    );
                  });
                })(v, this.painter),
                  (this._previousZoom = g.zoom);
                const b = this.proxyToSource || {};
                (this.proxyToSource = {}),
                  v.forEach((M) => {
                    this.proxyToSource[M.key] = {};
                  }),
                  (this.terrainTileForTile = {});
                const D = this._style._sourceCaches;
                for (const M in D) {
                  const R = D[M];
                  if (
                    !R.used ||
                    (R !== this.sourceCache && this.resetTileLookupCache(R.id),
                    this._setupProxiedCoordsForOrtho(R, a[M], b),
                    R.usedForTerrain)
                  )
                    continue;
                  const k = a[M];
                  R.getSource().reparseOverscaled &&
                    this._assignTerrainTiles(k);
                }
                (this.proxiedCoords[u.id] = v.map(
                  (M) => new or(M, M.key, this.orthoMatrix)
                )),
                  this._assignTerrainTiles(v),
                  this._prepareDEMTextures(),
                  this._setupDrapedRenderBatches(),
                  this._initFBOPool(),
                  this._setupRenderCache(b),
                  (this.renderingToTexture = !1),
                  (this._updateTimestamp = d.exported.now());
                const I = {};
                this._visibleDemTiles = [];
                for (const M of this.proxyCoords) {
                  const R = this.terrainTileForTile[M.key];
                  if (!R) continue;
                  const k = R.tileID.key;
                  k in I || (this._visibleDemTiles.push(R), (I[k] = k));
                }
              }
              _assignTerrainTiles(a) {
                this._initializing ||
                  a.forEach((u) => {
                    if (this.terrainTileForTile[u.key]) return;
                    const g = this._findTileCoveringTileID(u, this.sourceCache);
                    g && (this.terrainTileForTile[u.key] = g);
                  });
              }
              _prepareDEMTextures() {
                const a = this.painter.context,
                  u = a.gl;
                for (const g in this.terrainTileForTile) {
                  const v = this.terrainTileForTile[g],
                    b = v.dem;
                  !b ||
                    (v.demTexture && !v.needsDEMTextureUpload) ||
                    (a.activeTexture.set(u.TEXTURE1), dp(this.painter, v, b));
                }
              }
              _prepareDemTileUniforms(a, u, g, v) {
                if (!u || null == u.demTexture) return !1;
                const b = a.tileID.canonical,
                  D = Math.pow(2, u.tileID.canonical.z - b.z),
                  I = v || "";
                return (
                  (g[`u_dem_tl${I}`] = [(b.x * D) % 1, (b.y * D) % 1]),
                  (g[`u_dem_scale${I}`] = D),
                  !0
                );
              }
              get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture
                  ? this._emptyDEMTexture
                  : this._updateEmptyDEMTexture();
              }
              get emptyDepthBufferTexture() {
                const a = this.painter.context,
                  u = a.gl;
                if (!this._emptyDepthBufferTexture) {
                  const g = new d.RGBAImage(
                    { width: 1, height: 1 },
                    Uint8Array.of(255, 255, 255, 255)
                  );
                  this._emptyDepthBufferTexture = new d.Texture(a, g, u.RGBA, {
                    premultiply: !1,
                  });
                }
                return this._emptyDepthBufferTexture;
              }
              _getLoadedAreaMinimum() {
                let a = 0;
                const u = this._visibleDemTiles.reduce((g, v) => {
                  if (!v.dem) return g;
                  const b = v.dem.tree.minimums[0];
                  return b > 0 && a++, g + b;
                }, 0);
                return a ? u / a : 0;
              }
              _updateEmptyDEMTexture() {
                const a = this.painter.context,
                  u = a.gl;
                a.activeTexture.set(u.TEXTURE2);
                const g = this._getLoadedAreaMinimum(),
                  v = new d.RGBAImage(
                    { width: 1, height: 1 },
                    new Uint8Array(
                      d.DEMData.pack(g, this.sourceCache.getSource().encoding)
                    )
                  );
                this._emptyDEMTextureDirty = !1;
                let b = this._emptyDEMTexture;
                return (
                  b
                    ? b.update(v, { premultiply: !1 })
                    : (b = this._emptyDEMTexture =
                        new d.Texture(a, v, u.RGBA, { premultiply: !1 })),
                  b
                );
              }
              setupElevationDraw(a, u, g) {
                const v = this.painter.context,
                  b = v.gl,
                  D =
                    ((I = this.sourceCache.getSource().encoding),
                    {
                      u_dem: 2,
                      u_dem_prev: 4,
                      u_dem_unpack: d.DEMData.getUnpackVector(I),
                      u_dem_tl: [0, 0],
                      u_dem_tl_prev: [0, 0],
                      u_dem_scale: 0,
                      u_dem_scale_prev: 0,
                      u_dem_size: 0,
                      u_dem_lerp: 1,
                      u_depth: 3,
                      u_depth_size_inv: [0, 0],
                      u_exaggeration: 0,
                    });
                var I;
                (D.u_dem_size = this.sourceCache.getSource().tileSize),
                  (D.u_exaggeration = this.exaggeration());
                let M = null,
                  R = null,
                  k = 1;
                if (g && g.morphing && this._useVertexMorphing) {
                  const z = g.morphing.srcDemTile,
                    H = g.morphing.dstDemTile;
                  (k = g.morphing.phase),
                    z &&
                      H &&
                      (this._prepareDemTileUniforms(a, z, D, "_prev") &&
                        (R = z),
                      this._prepareDemTileUniforms(a, H, D) && (M = H));
                }
                if (
                  (R && M
                    ? (v.activeTexture.set(b.TEXTURE2),
                      M.demTexture.bind(b.NEAREST, b.CLAMP_TO_EDGE, b.NEAREST),
                      v.activeTexture.set(b.TEXTURE4),
                      R.demTexture.bind(b.NEAREST, b.CLAMP_TO_EDGE, b.NEAREST),
                      (D.u_dem_lerp = k))
                    : ((M = this.terrainTileForTile[a.tileID.key]),
                      v.activeTexture.set(b.TEXTURE2),
                      (this._prepareDemTileUniforms(a, M, D)
                        ? M.demTexture
                        : this.emptyDEMTexture
                      ).bind(b.NEAREST, b.CLAMP_TO_EDGE)),
                  v.activeTexture.set(b.TEXTURE3),
                  g && g.useDepthForOcclusion
                    ? (this._depthTexture &&
                        this._depthTexture.bind(b.NEAREST, b.CLAMP_TO_EDGE),
                      this._depthFBO &&
                        (D.u_depth_size_inv = [
                          1 / this._depthFBO.width,
                          1 / this._depthFBO.height,
                        ]))
                    : (this.emptyDepthBufferTexture.bind(
                        b.NEAREST,
                        b.CLAMP_TO_EDGE
                      ),
                      (D.u_depth_size_inv = [1, 1])),
                  g && g.useMeterToDem && M)
                ) {
                  const z =
                    (1 << M.tileID.canonical.z) *
                    d.mercatorZfromAltitude(
                      1,
                      this.painter.transform.center.lat
                    ) *
                    this.sourceCache.getSource().tileSize;
                  D.u_meter_to_dem = z;
                }
                if (
                  (g &&
                    g.labelPlaneMatrixInv &&
                    (D.u_label_plane_matrix_inv = g.labelPlaneMatrixInv),
                  u.setTerrainUniformValues(v, D),
                  "globe" === this.painter.transform.projection.name)
                ) {
                  const z = this.globeUniformValues(
                    this.painter.transform,
                    a.tileID.canonical,
                    g && g.useDenormalizedUpVectorScale
                  );
                  u.setGlobeUniformValues(v, z);
                }
              }
              globeUniformValues(a, u, g) {
                const v = a.projection;
                return {
                  u_tile_tl_up: v.upVector(u, 0, 0),
                  u_tile_tr_up: v.upVector(u, d.EXTENT, 0),
                  u_tile_br_up: v.upVector(u, d.EXTENT, d.EXTENT),
                  u_tile_bl_up: v.upVector(u, 0, d.EXTENT),
                  u_tile_up_scale: g
                    ? d.globeMetersToEcef(1)
                    : v.upVectorScale(u, a.center.lat, a.worldSize)
                        .metersToTile,
                };
              }
              renderToBackBuffer(a) {
                const u = this.painter,
                  g = this.painter.context;
                0 !== a.length &&
                  (g.bindFramebuffer.set(null),
                  g.viewport.set([0, 0, u.width, u.height]),
                  u.gpuTimingDeferredRenderStart(),
                  (this.renderingToTexture = !1),
                  (function (v, b, D, I, M) {
                    if ("globe" === v.transform.projection.name)
                      !(function (R, k, z, H, q) {
                        const X = R.context,
                          Z = X.gl;
                        let Y, B;
                        const W = R.options.showTerrainWireframe ? 2 : 0,
                          ee = R.transform,
                          te = d.globeUseCustomAntiAliasing(R, X, ee),
                          he = (je, we) => {
                            if (B === je) return;
                            const ke = [_r[je], "PROJECTION_GLOBE_VIEW"];
                            te && ke.push("CUSTOM_ANTIALIASING"),
                              we && ke.push(_r[W]),
                              (Y = R.useProgram("globeRaster", null, ke)),
                              (B = je);
                          },
                          de = R.colorModeForRenderPass(),
                          ue = new d.DepthMode(
                            Z.LEQUAL,
                            d.DepthMode.ReadWrite,
                            R.depthRangeFor3D
                          );
                        Ho.update(q);
                        const _e = d.calculateGlobeMercatorMatrix(ee),
                          ge = [
                            d.mercatorXfromLng(ee.center.lng),
                            d.mercatorYfromLat(ee.center.lat),
                          ],
                          Te = W ? [!1, !0] : [!1],
                          Ge = R.globeSharedBuffers,
                          be = [
                            ee.width * d.exported.devicePixelRatio,
                            ee.height * d.exported.devicePixelRatio,
                          ],
                          Le = Float32Array.from(ee.globeMatrix),
                          Ie = { useDenormalizedUpVectorScale: !0 };
                        if (
                          (Te.forEach((je) => {
                            const we = R.transform,
                              ke = $s(we.zoom) * k.exaggeration();
                            B = -1;
                            const He = je ? Z.LINES : Z.TRIANGLES;
                            for (const Ne of H) {
                              const Xe = z.getTile(Ne),
                                dt = d.StencilMode.disabled,
                                Dt = k.prevTerrainTileForTile[Ne.key],
                                ct = k.terrainTileForTile[Ne.key];
                              Us(Dt, ct) &&
                                Ho.newMorphing(Ne.key, Dt, ct, q, 250),
                                X.activeTexture.set(Z.TEXTURE0),
                                Xe.texture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE);
                              const wt = Ho.getMorphValuesForProxy(Ne.key),
                                Wt = wt ? 1 : 0;
                              wt &&
                                d.extend$1(Ie, {
                                  morphing: {
                                    srcDemTile: wt.from,
                                    dstDemTile: wt.to,
                                    phase: d.easeCubicInOut(wt.phase),
                                  },
                                });
                              const jt = d.tileCornersToBounds(Ne.canonical),
                                ft = d.getLatitudinalLod(jt.getCenter().lat),
                                Yt = d.getGridMatrix(
                                  Ne.canonical,
                                  jt,
                                  ft,
                                  we.worldSize / we._pixelsPerMercatorPixel
                                ),
                                kn = d.globeNormalizeECEF(
                                  d.globeTileBounds(Ne.canonical)
                                ),
                                fn = Pl(
                                  we.projMatrix,
                                  Le,
                                  _e,
                                  kn,
                                  d.globeToMercatorTransition(we.zoom),
                                  ge,
                                  we.frustumCorners.TL,
                                  we.frustumCorners.TR,
                                  we.frustumCorners.BR,
                                  we.frustumCorners.BL,
                                  we.globeCenterInViewSpace,
                                  we.globeRadius,
                                  be,
                                  ke,
                                  Yt
                                );
                              if (
                                (he(Wt, je),
                                k.setupElevationDraw(Xe, Y, Ie),
                                R.prepareDrawProgram(X, Y, Ne.toUnwrapped()),
                                Ge)
                              ) {
                                const [Tn, ji, mi] = je
                                  ? Ge.getWirefameBuffers(R.context, ft)
                                  : Ge.getGridBuffers(ft, 0 !== ke);
                                Y.draw(
                                  X,
                                  He,
                                  ue,
                                  dt,
                                  de,
                                  d.CullFaceMode.backCCW,
                                  fn,
                                  "globe_raster",
                                  Tn,
                                  ji,
                                  mi
                                );
                              }
                            }
                          }),
                          Ge)
                        ) {
                          const je = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                          te && je.push("CUSTOM_ANTIALIASING"),
                            (Y = R.useProgram("globeRaster", null, je));
                          for (const we of H) {
                            const { x: ke, y: He, z: Ne } = we.canonical,
                              Xe = 0 === He,
                              dt = He === (1 << Ne) - 1,
                              [Dt, ct, wt, Wt] = Ge.getPoleBuffers(Ne);
                            if (Wt && (Xe || dt)) {
                              const jt = z.getTile(we);
                              X.activeTexture.set(Z.TEXTURE0),
                                jt.texture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE);
                              let ft = d.globePoleMatrixForTile(Ne, ke, ee);
                              const Yt = d.globeNormalizeECEF(
                                  d.globeTileBounds(we.canonical)
                                ),
                                kn = (fn, Tn) =>
                                  fn.draw(
                                    X,
                                    Z.TRIANGLES,
                                    ue,
                                    d.StencilMode.disabled,
                                    de,
                                    d.CullFaceMode.disabled,
                                    Pl(
                                      ee.projMatrix,
                                      ft,
                                      ft,
                                      Yt,
                                      0,
                                      ge,
                                      ee.frustumCorners.TL,
                                      ee.frustumCorners.TR,
                                      ee.frustumCorners.BR,
                                      ee.frustumCorners.BL,
                                      ee.globeCenterInViewSpace,
                                      ee.globeRadius,
                                      be,
                                      0
                                    ),
                                    "globe_pole_raster",
                                    Tn,
                                    wt,
                                    Wt
                                  );
                              k.setupElevationDraw(jt, Y, Ie),
                                R.prepareDrawProgram(X, Y, we.toUnwrapped()),
                                Xe && kn(Y, Dt),
                                dt &&
                                  ((ft = d.scale(d.create(), ft, [1, -1, 1])),
                                  kn(Y, ct));
                            }
                          }
                        }
                      })(v, b, D, I, M);
                    else {
                      const R = v.context,
                        k = R.gl;
                      let z, H;
                      const q = v.options.showTerrainWireframe ? 2 : 0,
                        X = (ee, te) => {
                          if (H === ee) return;
                          const he = [_r[ee]];
                          te && he.push(_r[q]),
                            (z = v.useProgram("terrainRaster", null, he)),
                            (H = ee);
                        },
                        Z = v.colorModeForRenderPass(),
                        Y = new d.DepthMode(
                          k.LEQUAL,
                          d.DepthMode.ReadWrite,
                          v.depthRangeFor3D
                        );
                      Ho.update(M);
                      const B = v.transform,
                        W = $s(B.zoom) * b.exaggeration();
                      (q ? [!1, !0] : [!1]).forEach((ee) => {
                        H = -1;
                        const te = ee ? k.LINES : k.TRIANGLES,
                          [he, de] = ee
                            ? b.getWirefameBuffer()
                            : [b.gridIndexBuffer, b.gridSegments];
                        for (const ue of I) {
                          const _e = D.getTile(ue),
                            ge = d.StencilMode.disabled,
                            Te = b.prevTerrainTileForTile[ue.key],
                            Ge = b.terrainTileForTile[ue.key];
                          Us(Te, Ge) && Ho.newMorphing(ue.key, Te, Ge, M, 250),
                            R.activeTexture.set(k.TEXTURE0),
                            _e.texture.bind(
                              k.LINEAR,
                              k.CLAMP_TO_EDGE,
                              k.LINEAR_MIPMAP_NEAREST
                            );
                          const be = Ho.getMorphValuesForProxy(ue.key),
                            Le = be ? 1 : 0;
                          let Ie;
                          be &&
                            (Ie = {
                              morphing: {
                                srcDemTile: be.from,
                                dstDemTile: be.to,
                                phase: d.easeCubicInOut(be.phase),
                              },
                            });
                          const je = ps(
                            ue.projMatrix,
                            pp(ue.canonical, B.renderWorldCopies) ? W / 10 : W
                          );
                          X(Le, ee),
                            b.setupElevationDraw(_e, z, Ie),
                            v.prepareDrawProgram(R, z, ue.toUnwrapped()),
                            z.draw(
                              R,
                              te,
                              Y,
                              ge,
                              Z,
                              d.CullFaceMode.backCCW,
                              je,
                              "terrain_raster",
                              b.gridBuffer,
                              he,
                              de
                            );
                        }
                      });
                    }
                  })(u, this, this.proxySourceCache, a, this._updateTimestamp),
                  (this.renderingToTexture = !0),
                  u.gpuTimingDeferredRenderEnd(),
                  a.splice(0, a.length));
              }
              renderBatch(a) {
                if (0 === this._drapedRenderBatches.length) return a + 1;
                this.renderingToTexture = !0;
                const u = this.painter,
                  g = this.painter.context,
                  v = this.proxySourceCache,
                  b = this.proxiedCoords[v.id],
                  D = this._drapedRenderBatches.shift(),
                  I = [],
                  M = u.style.order;
                let R = 0;
                for (const k of b) {
                  const z = v.getTileByID(k.proxyTileKey),
                    H = v.proxyCachedFBO[k.key]
                      ? v.proxyCachedFBO[k.key][a]
                      : void 0,
                    q = void 0 !== H ? v.renderCache[H] : this.pool[R++],
                    X = void 0 !== H;
                  if (((z.texture = q.tex), X && !q.dirty)) {
                    I.push(z.tileID);
                    continue;
                  }
                  let Z;
                  g.bindFramebuffer.set(q.fb.framebuffer),
                    (this.renderedToTile = !1),
                    q.dirty &&
                      (g.clear({ color: d.Color.transparent, stencil: 0 }),
                      (q.dirty = !1));
                  for (let Y = D.start; Y <= D.end; ++Y) {
                    const B = u.style._layers[M[Y]];
                    if (B.isHidden(u.transform.zoom)) continue;
                    const W = u.style._getLayerSourceCache(B),
                      ee = W ? this.proxyToSource[k.key][W.id] : [k];
                    if (!ee) continue;
                    const te = ee;
                    g.viewport.set([0, 0, q.fb.width, q.fb.height]),
                      Z !== (W ? W.id : null) &&
                        (this._setupStencil(q, ee, B, W),
                        (Z = W ? W.id : null)),
                      u.renderLayer(u, W, B, te);
                  }
                  this.renderedToTile
                    ? ((q.dirty = !0), I.push(z.tileID))
                    : X || --R,
                    5 === R && ((R = 0), this.renderToBackBuffer(I));
                }
                return (
                  this.renderToBackBuffer(I),
                  (this.renderingToTexture = !1),
                  g.bindFramebuffer.set(null),
                  g.viewport.set([0, 0, u.width, u.height]),
                  D.end + 1
                );
              }
              postRender() {}
              renderCacheEfficiency(a) {
                const u = a.order.length;
                if (0 === u) return { efficiency: 100 };
                let g,
                  v = 0,
                  b = 0,
                  D = !1;
                for (let I = 0; I < u; ++I) {
                  const M = a._layers[a.order[I]];
                  this._style.isLayerDraped(M)
                    ? (D && ++v, ++b)
                    : D || ((D = !0), (g = M.id));
                }
                return 0 === b
                  ? { efficiency: 100 }
                  : { efficiency: 100 * (1 - v / b), firstUndrapedLayer: g };
              }
              getMinElevationBelowMSL() {
                let a = 0;
                return (
                  this._visibleDemTiles
                    .filter((u) => u.dem)
                    .forEach((u) => {
                      a = Math.min(a, u.dem.tree.minimums[0]);
                    }),
                  0 === a ? a : (a - 30) * this._exaggeration
                );
              }
              raycast(a, u, g) {
                if (!this._visibleDemTiles) return null;
                const v = this._visibleDemTiles
                  .filter((b) => b.dem)
                  .map((b) => {
                    const D = b.tileID,
                      I = 1 << D.overscaledZ,
                      { x: M, y: R } = D.canonical,
                      k = M / I,
                      z = (M + 1) / I,
                      H = R / I,
                      q = (R + 1) / I;
                    return {
                      minx: k,
                      miny: H,
                      maxx: z,
                      maxy: q,
                      t: b.dem.tree.raycastRoot(k, H, z, q, a, u, g),
                      tile: b,
                    };
                  });
                v.sort(
                  (b, D) =>
                    (null !== b.t ? b.t : Number.MAX_VALUE) -
                    (null !== D.t ? D.t : Number.MAX_VALUE)
                );
                for (const b of v) {
                  if (null == b.t) return null;
                  const D = b.tile.dem.tree.raycast(
                    b.minx,
                    b.miny,
                    b.maxx,
                    b.maxy,
                    a,
                    u,
                    g
                  );
                  if (null != D) return D;
                }
                return null;
              }
              _createFBO() {
                const a = this.painter.context,
                  u = a.gl,
                  g = this.drapeBufferSize;
                a.activeTexture.set(u.TEXTURE0);
                const v = new d.Texture(
                  a,
                  { width: g[0], height: g[1], data: null },
                  u.RGBA
                );
                v.bind(u.LINEAR, u.CLAMP_TO_EDGE);
                const b = a.createFramebuffer(g[0], g[1], !1);
                return (
                  b.colorAttachment.set(v.texture),
                  (b.depthAttachment = new fe(a, b.framebuffer)),
                  void 0 === this._sharedDepthStencil
                    ? ((this._sharedDepthStencil = a.createRenderbuffer(
                        a.gl.DEPTH_STENCIL,
                        g[0],
                        g[1]
                      )),
                      (this._stencilRef = 0),
                      b.depthAttachment.set(this._sharedDepthStencil),
                      a.clear({ stencil: 0 }))
                    : b.depthAttachment.set(this._sharedDepthStencil),
                  a.extTextureFilterAnisotropic &&
                    !a.extTextureFilterAnisotropicForceOff &&
                    u.texParameterf(
                      u.TEXTURE_2D,
                      a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                      a.extTextureFilterAnisotropicMax
                    ),
                  { fb: b, tex: v, dirty: !1 }
                );
              }
              _initFBOPool() {
                for (
                  ;
                  this.pool.length < Math.min(5, this.proxyCoords.length);

                )
                  this.pool.push(this._createFBO());
              }
              _shouldDisableRenderCache() {
                if (this._style.light && this._style.light.hasTransition())
                  return !0;
                for (const a in this._style._sourceCaches)
                  if (this._style._sourceCaches[a].hasTransition()) return !0;
                return this._style.order.some((a) => {
                  const u = this._style._layers[a],
                    g = u.isHidden(this.painter.transform.zoom);
                  return "custom" === u.type
                    ? !g && u.shouldRedrape()
                    : !g && u.hasTransition();
                });
              }
              _clearLineLayersFromRenderCache() {
                let a = !1;
                for (const g of this._style._getSources())
                  if (g instanceof Qe) {
                    a = !0;
                    break;
                  }
                if (!a) return;
                const u = {};
                for (let g = 0; g < this._style.order.length; ++g) {
                  const v = this._style._layers[this._style.order[g]],
                    b = this._style._getLayerSourceCache(v);
                  if (
                    b &&
                    !u[b.id] &&
                    !v.isHidden(this.painter.transform.zoom) &&
                    "line" === v.type &&
                    v.widthExpression() instanceof d.ZoomDependentExpression
                  ) {
                    u[b.id] = !0;
                    for (const D of this.proxyCoords) {
                      const I = this.proxyToSource[D.key][b.id];
                      if (I)
                        for (const M of I)
                          this._clearRenderCacheForTile(b.id, M);
                    }
                  }
                }
              }
              _clearRasterLayersFromRenderCache() {
                let a = !1;
                for (const g in this._style._sourceCaches)
                  if (this._style._sourceCaches[g]._source instanceof We) {
                    a = !0;
                    break;
                  }
                if (!a) return;
                const u = {};
                for (let g = 0; g < this._style.order.length; ++g) {
                  const v = this._style._layers[this._style.order[g]],
                    b = this._style._getLayerSourceCache(v);
                  if (
                    !b ||
                    u[b.id] ||
                    v.isHidden(this.painter.transform.zoom) ||
                    "raster" !== v.type
                  )
                    continue;
                  const D = v.paint.get("raster-fade-duration");
                  for (const I of this.proxyCoords) {
                    const M = this.proxyToSource[I.key][b.id];
                    if (M)
                      for (const R of M) {
                        const k = Oh(
                          b.getTile(R),
                          b.findLoadedParent(R, 0),
                          b,
                          this.painter.transform,
                          D
                        );
                        (1 !== k.opacity || 0 !== k.mix) &&
                          this._clearRenderCacheForTile(b.id, R);
                      }
                  }
                }
              }
              _setupDrapedRenderBatches() {
                const a = this._style.order,
                  u = a.length;
                if (0 === u) return;
                const g = [];
                let v,
                  b = 0,
                  D = this._style._layers[a[b]];
                for (
                  ;
                  !this._style.isLayerDraped(D) &&
                  D.isHidden(this.painter.transform.zoom) &&
                  ++b < u;

                )
                  D = this._style._layers[a[b]];
                for (; b < u; ++b) {
                  const I = this._style._layers[a[b]];
                  I.isHidden(this.painter.transform.zoom) ||
                    (this._style.isLayerDraped(I)
                      ? void 0 === v && (v = b)
                      : void 0 !== v &&
                        (g.push({ start: v, end: b - 1 }), (v = void 0)));
                }
                void 0 !== v && g.push({ start: v, end: b - 1 }),
                  (this._drapedRenderBatches = g);
              }
              _setupRenderCache(a) {
                const u = this.proxySourceCache;
                if (
                  this._shouldDisableRenderCache() ||
                  this._invalidateRenderCache
                ) {
                  if (
                    ((this._invalidateRenderCache = !1),
                    u.renderCache.length > u.renderCachePool.length)
                  ) {
                    const D = Object.values(u.proxyCachedFBO);
                    u.proxyCachedFBO = {};
                    for (let I = 0; I < D.length; ++I) {
                      const M = Object.values(D[I]);
                      u.renderCachePool.push(...M);
                    }
                  }
                  return;
                }
                this._clearRasterLayersFromRenderCache();
                const g = this.proxyCoords,
                  v = this._tilesDirty;
                for (let D = g.length - 1; D >= 0; D--) {
                  const I = g[D];
                  if (
                    (u.getTileByID(I.key), void 0 !== u.proxyCachedFBO[I.key])
                  ) {
                    const M = a[I.key],
                      R = this.proxyToSource[I.key];
                    let k = 0;
                    for (const z in R) {
                      const H = R[z],
                        q = M[z];
                      if (
                        !q ||
                        q.length !== H.length ||
                        H.some(
                          (X, Z) =>
                            X !== q[Z] || (v[z] && v[z].hasOwnProperty(X.key))
                        )
                      ) {
                        k = -1;
                        break;
                      }
                      ++k;
                    }
                    for (const z in u.proxyCachedFBO[I.key])
                      u.renderCache[u.proxyCachedFBO[I.key][z]].dirty =
                        k < 0 || k !== Object.values(M).length;
                  }
                }
                const b = [...this._drapedRenderBatches];
                b.sort((D, I) => I.end - I.start - (D.end - D.start));
                for (const D of b)
                  for (const I of g) {
                    if (u.proxyCachedFBO[I.key]) continue;
                    let M = u.renderCachePool.pop();
                    void 0 === M &&
                      u.renderCache.length < 50 &&
                      ((M = u.renderCache.length),
                      u.renderCache.push(this._createFBO())),
                      void 0 !== M &&
                        ((u.proxyCachedFBO[I.key] = {}),
                        (u.proxyCachedFBO[I.key][D.start] = M),
                        (u.renderCache[M].dirty = !0));
                  }
                this._tilesDirty = {};
              }
              _setupStencil(a, u, g, v) {
                if (!v || !this._sourceTilesOverlap[v.id])
                  return void (
                    this._overlapStencilType && (this._overlapStencilType = !1)
                  );
                const b = this.painter.context,
                  D = b.gl;
                if (u.length <= 1) return void (this._overlapStencilType = !1);
                let I;
                if (g.isTileClipped())
                  (I = u.length),
                    (this._overlapStencilMode.test = {
                      func: D.EQUAL,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Clip");
                else {
                  if (!(u[0].overscaledZ > u[u.length - 1].overscaledZ))
                    return void (this._overlapStencilType = !1);
                  (I = 1),
                    (this._overlapStencilMode.test = {
                      func: D.GREATER,
                      mask: 255,
                    }),
                    (this._overlapStencilType = "Mask");
                }
                this._stencilRef + I > 255 &&
                  (b.clear({ stencil: 0 }), (this._stencilRef = 0)),
                  (this._stencilRef += I),
                  (this._overlapStencilMode.ref = this._stencilRef),
                  g.isTileClipped() &&
                    this._renderTileClippingMasks(
                      u,
                      this._overlapStencilMode.ref
                    );
              }
              clipOrMaskOverlapStencilType() {
                return (
                  "Clip" === this._overlapStencilType ||
                  "Mask" === this._overlapStencilType
                );
              }
              stencilModeForRTTOverlap(a) {
                return this.renderingToTexture && this._overlapStencilType
                  ? ("Clip" === this._overlapStencilType &&
                      (this._overlapStencilMode.ref =
                        this.painter._tileClippingMaskIDs[a.key]),
                    this._overlapStencilMode)
                  : d.StencilMode.disabled;
              }
              _renderTileClippingMasks(a, u) {
                const g = this.painter,
                  v = this.painter.context,
                  b = v.gl;
                (g._tileClippingMaskIDs = {}),
                  v.setColorMode(d.ColorMode.disabled),
                  v.setDepthMode(d.DepthMode.disabled);
                const D = g.useProgram("clippingMask");
                for (const I of a) {
                  const M = (g._tileClippingMaskIDs[I.key] = --u);
                  D.draw(
                    v,
                    b.TRIANGLES,
                    d.DepthMode.disabled,
                    new d.StencilMode(
                      { func: b.ALWAYS, mask: 0 },
                      M,
                      255,
                      b.KEEP,
                      b.KEEP,
                      b.REPLACE
                    ),
                    d.ColorMode.disabled,
                    d.CullFaceMode.disabled,
                    xo(I.projMatrix),
                    "$clipping",
                    g.tileExtentBuffer,
                    g.quadTriangleIndexBuffer,
                    g.tileExtentSegments
                  );
                }
              }
              pointCoordinate(a) {
                const u = this.painter.transform;
                if (a.x < 0 || a.x > u.width || a.y < 0 || a.y > u.height)
                  return null;
                const g = [a.x, a.y, 1, 1];
                d.transformMat4$1(g, g, u.pixelMatrixInverse),
                  d.scale$1(g, g, 1 / g[3]),
                  (g[0] /= u.worldSize),
                  (g[1] /= u.worldSize);
                const v = u._camera.position,
                  b = d.mercatorZfromAltitude(1, u.center.lat),
                  D = [v[0], v[1], v[2] / b, 0],
                  I = d.subtract([], g.slice(0, 3), D);
                d.normalize(I, I);
                const M = this.raycast(D, I, this._exaggeration);
                return null !== M && M
                  ? (d.scaleAndAdd(D, D, I, M), (D[3] = D[2]), (D[2] *= b), D)
                  : null;
              }
              drawDepth() {
                const a = this.painter,
                  u = a.context,
                  g = this.proxySourceCache,
                  v = Math.ceil(a.width),
                  b = Math.ceil(a.height);
                if (
                  (!this._depthFBO ||
                    (this._depthFBO.width === v &&
                      this._depthFBO.height === b) ||
                    (this._depthFBO.destroy(),
                    (this._depthFBO = void 0),
                    (this._depthTexture = void 0)),
                  !this._depthFBO)
                ) {
                  const D = u.gl,
                    I = u.createFramebuffer(v, b, !0);
                  u.activeTexture.set(D.TEXTURE0);
                  const M = new d.Texture(
                    u,
                    { width: v, height: b, data: null },
                    D.RGBA
                  );
                  M.bind(D.NEAREST, D.CLAMP_TO_EDGE),
                    I.colorAttachment.set(M.texture);
                  const R = u.createRenderbuffer(u.gl.DEPTH_COMPONENT16, v, b);
                  I.depthAttachment.set(R),
                    (this._depthFBO = I),
                    (this._depthTexture = M);
                }
                u.bindFramebuffer.set(this._depthFBO.framebuffer),
                  u.viewport.set([0, 0, v, b]),
                  (function (D, I, M, R) {
                    if ("globe" === D.transform.projection.name) return;
                    const k = D.context,
                      z = k.gl;
                    k.clear({ depth: 1 });
                    const H = D.useProgram("terrainDepth"),
                      q = new d.DepthMode(
                        z.LESS,
                        d.DepthMode.ReadWrite,
                        D.depthRangeFor3D
                      );
                    for (const X of R) {
                      const Z = M.getTile(X),
                        Y = ps(X.projMatrix, 0);
                      I.setupElevationDraw(Z, H),
                        H.draw(
                          k,
                          z.TRIANGLES,
                          q,
                          d.StencilMode.disabled,
                          d.ColorMode.unblended,
                          d.CullFaceMode.backCCW,
                          Y,
                          "terrain_depth",
                          I.gridBuffer,
                          I.gridIndexBuffer,
                          I.gridNoSkirtSegments
                        );
                    }
                  })(a, this, g, this.proxyCoords);
              }
              _setupProxiedCoordsForOrtho(a, u, g) {
                if (a.getSource() instanceof Bt)
                  return this._setupProxiedCoordsForImageSource(a, u, g);
                this._findCoveringTileCache[a.id] =
                  this._findCoveringTileCache[a.id] || {};
                const v = (this.proxiedCoords[a.id] = []),
                  b = this.proxyCoords;
                for (let I = 0; I < b.length; I++) {
                  const M = b[I],
                    R = this._findTileCoveringTileID(M, a);
                  if (R) {
                    const k = this._createProxiedId(
                      M,
                      R,
                      g[M.key] && g[M.key][a.id]
                    );
                    v.push(k), (this.proxyToSource[M.key][a.id] = [k]);
                  }
                }
                let D = !1;
                for (let I = 0; I < u.length; I++) {
                  const M = a.getTile(u[I]);
                  if (!M || !M.hasData()) continue;
                  const R = this._findTileCoveringTileID(
                    M.tileID,
                    this.proxySourceCache
                  );
                  if (R && R.tileID.canonical.z !== M.tileID.canonical.z) {
                    const k = this.proxyToSource[R.tileID.key][a.id],
                      z = this._createProxiedId(
                        R.tileID,
                        M,
                        g[R.tileID.key] && g[R.tileID.key][a.id]
                      );
                    k
                      ? k.splice(k.length - 1, 0, z)
                      : (this.proxyToSource[R.tileID.key][a.id] = [z]),
                      v.push(z),
                      (D = !0);
                  }
                }
                this._sourceTilesOverlap[a.id] = D;
              }
              _setupProxiedCoordsForImageSource(a, u, g) {
                if (!a.getSource().loaded()) return;
                const v = (this.proxiedCoords[a.id] = []),
                  b = this.proxyCoords,
                  D = a.getSource(),
                  I = new d.Point(D.tileID.x, D.tileID.y)._div(1 << D.tileID.z),
                  M = D.coordinates
                    .map(d.MercatorCoordinate.fromLngLat)
                    .reduce(
                      (k, z) => (
                        (k.min.x = Math.min(k.min.x, z.x - I.x)),
                        (k.min.y = Math.min(k.min.y, z.y - I.y)),
                        (k.max.x = Math.max(k.max.x, z.x - I.x)),
                        (k.max.y = Math.max(k.max.y, z.y - I.y)),
                        k
                      ),
                      {
                        min: new d.Point(Number.MAX_VALUE, Number.MAX_VALUE),
                        max: new d.Point(-Number.MAX_VALUE, -Number.MAX_VALUE),
                      }
                    ),
                  R = (k, z) => {
                    const H = k.wrap + k.canonical.x / (1 << k.canonical.z),
                      q = k.canonical.y / (1 << k.canonical.z),
                      X = d.EXTENT / (1 << k.canonical.z),
                      Z = z.wrap + z.canonical.x / (1 << z.canonical.z),
                      Y = z.canonical.y / (1 << z.canonical.z);
                    return (
                      H + X < Z + M.min.x ||
                      H > Z + M.max.x ||
                      q + X < Y + M.min.y ||
                      q > Y + M.max.y
                    );
                  };
                for (let k = 0; k < b.length; k++) {
                  const z = b[k];
                  for (let H = 0; H < u.length; H++) {
                    const q = a.getTile(u[H]);
                    if (!q || !q.hasData() || R(z, q.tileID)) continue;
                    const X = this._createProxiedId(
                        z,
                        q,
                        g[z.key] && g[z.key][a.id]
                      ),
                      Z = this.proxyToSource[z.key][a.id];
                    Z ? Z.push(X) : (this.proxyToSource[z.key][a.id] = [X]),
                      v.push(X);
                  }
                }
              }
              _createProxiedId(a, u, g) {
                let v = this.orthoMatrix;
                if (g) {
                  const b = g.find((D) => D.key === u.tileID.key);
                  if (b) return b;
                }
                if (u.tileID.key !== a.key) {
                  const b = a.canonical.z - u.tileID.canonical.z;
                  let D, I, M;
                  v = d.create();
                  const R = (u.tileID.wrap - a.wrap) << a.overscaledZ;
                  b > 0
                    ? ((D = d.EXTENT >> b),
                      (I =
                        D * ((u.tileID.canonical.x << b) - a.canonical.x + R)),
                      (M = D * ((u.tileID.canonical.y << b) - a.canonical.y)))
                    : ((D = d.EXTENT << -b),
                      (I =
                        d.EXTENT *
                        (u.tileID.canonical.x - ((a.canonical.x + R) << -b))),
                      (M =
                        d.EXTENT *
                        (u.tileID.canonical.y - (a.canonical.y << -b)))),
                    d.ortho(v, 0, D, 0, D, 0, 1),
                    d.translate(v, v, [I, M, 0]);
                }
                return new or(u.tileID, a.key, v);
              }
              _findTileCoveringTileID(a, u) {
                let g = u.getTile(a);
                if (g && g.hasData()) return g;
                const v = this._findCoveringTileCache[u.id],
                  b = v[a.key];
                if (
                  ((g = b ? u.getTileByID(b) : null),
                  (g && g.hasData()) || null === b)
                )
                  return g;
                let D = g ? g.tileID : a,
                  I = D.overscaledZ;
                const M = u.getSource().minzoom,
                  R = [];
                if (!b) {
                  const z = u.getSource().maxzoom;
                  if (a.canonical.z >= z) {
                    const H = a.canonical.z - z;
                    u.getSource().reparseOverscaled
                      ? ((I = Math.max(
                          a.canonical.z + 2,
                          u.transform.tileZoom
                        )),
                        (D = new d.OverscaledTileID(
                          I,
                          a.wrap,
                          z,
                          a.canonical.x >> H,
                          a.canonical.y >> H
                        )))
                      : 0 !== H &&
                        ((I = z),
                        (D = new d.OverscaledTileID(
                          I,
                          a.wrap,
                          z,
                          a.canonical.x >> H,
                          a.canonical.y >> H
                        )));
                  }
                  D.key !== a.key && (R.push(D.key), (g = u.getTile(D)));
                }
                const k = (z) => {
                  R.forEach((H) => {
                    v[H] = z;
                  }),
                    (R.length = 0);
                };
                for (I -= 1; I >= M && (!g || !g.hasData()); I--) {
                  g && k(g.tileID.key);
                  const z = D.calculateScaledKey(I);
                  if (((g = u.getTileByID(z)), g && g.hasData())) break;
                  const H = v[z];
                  if (null === H) break;
                  void 0 === H ? R.push(z) : (g = u.getTileByID(H));
                }
                return k(g ? g.tileID.key : null), g && g.hasData() ? g : null;
              }
              findDEMTileFor(a) {
                return this.enabled
                  ? this._findTileCoveringTileID(a, this.sourceCache)
                  : null;
              }
              prepareDrawTile() {
                this.renderedToTile = !0;
              }
              _clearRenderCacheForTile(a, u) {
                let g = this._tilesDirty[a];
                g || (g = this._tilesDirty[a] = {}), (g[u.key] = !0);
              }
              getWirefameBuffer() {
                if (!this.wireframeSegments) {
                  const a = (function (u) {
                    let g = 0;
                    const v = new d.StructArrayLayout2ui4(),
                      b = 131;
                    for (let D = 1; D < 129; D++) {
                      for (let I = 1; I < 129; I++)
                        (g = D * b + I),
                          v.emplaceBack(g, g + 1),
                          v.emplaceBack(g, g + b),
                          v.emplaceBack(g + 1, g + b),
                          128 === D && v.emplaceBack(g + b, g + b + 1);
                      v.emplaceBack(g + 1, g + 1 + b);
                    }
                    return v;
                  })();
                  (this.wireframeIndexBuffer =
                    this.painter.context.createIndexBuffer(a)),
                    (this.wireframeSegments = d.SegmentVector.simpleSegment(
                      0,
                      0,
                      this.gridBuffer.length,
                      a.length
                    ));
                }
                return [this.wireframeIndexBuffer, this.wireframeSegments];
              }
            }
            class rn {
              static cacheKey(a, u, g, v) {
                let b = `${u}${v ? v.cacheKey : ""}`;
                for (const D of g) a.usedDefines.includes(D) && (b += `/${D}`);
                return b;
              }
              constructor(a, u, g, v, b, D) {
                const I = a.gl;
                this.program = I.createProgram();
                const M = (function (B) {
                    const W = [];
                    for (let ee = 0; ee < B.length; ee++) {
                      if (null === B[ee]) continue;
                      const te = B[ee].split(" ");
                      W.push(te.pop());
                    }
                    return W;
                  })(g.staticAttributes),
                  R = v ? v.getBinderAttributes() : [],
                  k = M.concat(R);
                let z = v ? v.defines() : [];
                z = z.concat(D.map((B) => `#define ${B}`));
                const H = a.isWebGL2 ? "#version 300 es\n" : "",
                  q =
                    H +
                    z
                      .concat(
                        a.extStandardDerivatives && 0 === H.length
                          ? "#extension GL_OES_standard_derivatives : enable\n".concat(
                              $o
                            )
                          : $o,
                        $o,
                        Rh,
                        kh.fragmentSource,
                        Al.fragmentSource,
                        g.fragmentSource
                      )
                      .join("\n"),
                  X =
                    H +
                    z
                      .concat(
                        "\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif",
                        Rh,
                        kh.vertexSource,
                        Al.vertexSource,
                        Ml.vertexSource,
                        g.vertexSource
                      )
                      .join("\n"),
                  Z = I.createShader(I.FRAGMENT_SHADER);
                if (I.isContextLost()) return void (this.failedToCreate = !0);
                I.shaderSource(Z, q),
                  I.compileShader(Z),
                  I.attachShader(this.program, Z);
                const Y = I.createShader(I.VERTEX_SHADER);
                if (I.isContextLost()) this.failedToCreate = !0;
                else {
                  I.shaderSource(Y, X),
                    I.compileShader(Y),
                    I.attachShader(this.program, Y),
                    (this.attributes = {}),
                    (this.numAttributes = k.length);
                  for (let B = 0; B < this.numAttributes; B++)
                    k[B] &&
                      (I.bindAttribLocation(this.program, B, k[B]),
                      (this.attributes[k[B]] = B));
                  I.linkProgram(this.program),
                    I.deleteShader(Y),
                    I.deleteShader(Z),
                    (this.fixedUniforms = b(a)),
                    (this.binderUniforms = v ? v.getUniforms(a) : []),
                    D.includes("TERRAIN") &&
                      (this.terrainUniforms = {
                        u_dem: new d.Uniform1i((B = a)),
                        u_dem_prev: new d.Uniform1i(B),
                        u_dem_unpack: new d.Uniform4f(B),
                        u_dem_tl: new d.Uniform2f(B),
                        u_dem_scale: new d.Uniform1f(B),
                        u_dem_tl_prev: new d.Uniform2f(B),
                        u_dem_scale_prev: new d.Uniform1f(B),
                        u_dem_size: new d.Uniform1f(B),
                        u_dem_lerp: new d.Uniform1f(B),
                        u_exaggeration: new d.Uniform1f(B),
                        u_depth: new d.Uniform1i(B),
                        u_depth_size_inv: new d.Uniform2f(B),
                        u_meter_to_dem: new d.Uniform1f(B),
                        u_label_plane_matrix_inv: new d.UniformMatrix4f(B),
                      }),
                    D.includes("GLOBE") &&
                      (this.globeUniforms = ((B) => ({
                        u_tile_tl_up: new d.Uniform3f(B),
                        u_tile_tr_up: new d.Uniform3f(B),
                        u_tile_br_up: new d.Uniform3f(B),
                        u_tile_bl_up: new d.Uniform3f(B),
                        u_tile_up_scale: new d.Uniform1f(B),
                      }))(a)),
                    D.includes("FOG") &&
                      (this.fogUniforms = ((B) => ({
                        u_fog_matrix: new d.UniformMatrix4f(B),
                        u_fog_range: new d.Uniform2f(B),
                        u_fog_color: new d.Uniform4f(B),
                        u_fog_horizon_blend: new d.Uniform1f(B),
                        u_fog_temporal_offset: new d.Uniform1f(B),
                        u_frustum_tl: new d.Uniform3f(B),
                        u_frustum_tr: new d.Uniform3f(B),
                        u_frustum_br: new d.Uniform3f(B),
                        u_frustum_bl: new d.Uniform3f(B),
                        u_globe_pos: new d.Uniform3f(B),
                        u_globe_radius: new d.Uniform1f(B),
                        u_globe_transition: new d.Uniform1f(B),
                        u_is_globe: new d.Uniform1i(B),
                        u_viewport: new d.Uniform2f(B),
                      }))(a));
                }
                var B;
              }
              setTerrainUniformValues(a, u) {
                if (!this.terrainUniforms) return;
                const g = this.terrainUniforms;
                if (!this.failedToCreate) {
                  a.program.set(this.program);
                  for (const v in u) g[v] && g[v].set(this.program, v, u[v]);
                }
              }
              setGlobeUniformValues(a, u) {
                if (!this.globeUniforms) return;
                const g = this.globeUniforms;
                if (!this.failedToCreate) {
                  a.program.set(this.program);
                  for (const v in u) g[v] && g[v].set(this.program, v, u[v]);
                }
              }
              setFogUniformValues(a, u) {
                if (!this.fogUniforms) return;
                const g = this.fogUniforms;
                if (!this.failedToCreate) {
                  a.program.set(this.program);
                  for (const v in u) g[v].set(this.program, v, u[v]);
                }
              }
              draw(a, u, g, v, b, D, I, M, R, k, z, H, q, X, Z) {
                const Y = a.gl;
                if (this.failedToCreate) return;
                a.program.set(this.program),
                  a.setDepthMode(g),
                  a.setStencilMode(v),
                  a.setColorMode(b),
                  a.setCullFace(D);
                for (const W of Object.keys(this.fixedUniforms))
                  this.fixedUniforms[W].set(this.program, W, I[W]);
                X &&
                  X.setUniforms(this.program, a, this.binderUniforms, H, {
                    zoom: q,
                  });
                const B = { [Y.LINES]: 2, [Y.TRIANGLES]: 3, [Y.LINE_STRIP]: 1 }[
                  u
                ];
                for (const W of z.get()) {
                  const ee = W.vaos || (W.vaos = {});
                  (ee[M] || (ee[M] = new vo())).bind(
                    a,
                    this,
                    R,
                    X ? X.getPaintVertexBuffers() : [],
                    k,
                    W.vertexOffset,
                    Z || []
                  ),
                    Y.drawElements(
                      u,
                      W.primitiveLength * B,
                      Y.UNSIGNED_SHORT,
                      W.primitiveOffset * B * 2
                    );
                }
              }
            }
            function Mi(f, a) {
              const u = Math.pow(2, a.tileID.overscaledZ),
                g = (a.tileSize * Math.pow(2, f.transform.tileZoom)) / u,
                v = g * (a.tileID.canonical.x + a.tileID.wrap * u),
                b = g * a.tileID.canonical.y;
              return {
                u_image: 0,
                u_texsize: a.imageAtlasTexture.size,
                u_tile_units_to_pixels: 1 / Ci(a, 1, f.transform.tileZoom),
                u_pixel_coord_upper: [v >> 16, b >> 16],
                u_pixel_coord_lower: [65535 & v, 65535 & b],
              };
            }
            const yr = d.create(),
              In = (f, a, u, g, v, b, D, I, M, R, k) => {
                const z = a.style.light,
                  H = z.properties.get("position"),
                  q = [H.x, H.y, H.z],
                  X = d.create$1();
                "viewport" === z.properties.get("anchor") &&
                  (d.fromRotation(X, -a.transform.angle),
                  d.transformMat3(q, q, X));
                const Z = z.properties.get("color"),
                  Y = a.transform,
                  B = {
                    u_matrix: f,
                    u_lightpos: q,
                    u_lightintensity: z.properties.get("intensity"),
                    u_lightcolor: [Z.r, Z.g, Z.b],
                    u_vertical_gradient: +u,
                    u_opacity: g,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: yr,
                    u_merc_center: [0, 0],
                    u_up_dir: [0, 0, 0],
                    u_height_lift: 0,
                    u_ao: v,
                    u_edge_radius: b,
                  };
                return (
                  "globe" === Y.projection.name &&
                    ((B.u_tile_id = [
                      D.canonical.x,
                      D.canonical.y,
                      1 << D.canonical.z,
                    ]),
                    (B.u_zoom_transition = M),
                    (B.u_inv_rot_matrix = k),
                    (B.u_merc_center = R),
                    (B.u_up_dir = Y.projection.upVector(
                      new d.CanonicalTileID(0, 0, 0),
                      R[0] * d.EXTENT,
                      R[1] * d.EXTENT
                    )),
                    (B.u_height_lift = I)),
                  B
                );
              },
              sr = (f, a, u, g, v, b, D, I, M, R, k, z) => {
                const H = In(f, a, u, g, v, b, D, M, R, k, z),
                  q = {
                    u_height_factor:
                      -Math.pow(2, D.overscaledZ) / I.tileSize / 8,
                  };
                return d.extend(H, Mi(a, I), q);
              },
              pi = (f) => ({ u_matrix: f }),
              Fa = (f, a, u) => d.extend(pi(f), Mi(a, u)),
              Gr = (f, a) => ({ u_matrix: f, u_world: a }),
              ro = (f, a, u, g) => d.extend(Fa(f, a, u), { u_world: g }),
              ht = d.create(),
              qt = (f, a, u, g, v, b) => {
                const D = f.transform,
                  I = "globe" === D.projection.name;
                let M;
                if ("map" === b.paint.get("circle-pitch-alignment"))
                  if (I) {
                    const k =
                      d.globePixelsToTileUnits(D.zoom, a.canonical) *
                      D._pixelsPerMercatorPixel;
                    M = Float32Array.from([k, 0, 0, k]);
                  } else M = D.calculatePixelsToTileUnitsMatrix(u);
                else
                  M = new Float32Array([
                    D.pixelsToGLUnits[0],
                    0,
                    0,
                    D.pixelsToGLUnits[1],
                  ]);
                const R = {
                  u_camera_to_center_distance: D.cameraToCenterDistance,
                  u_matrix: f.translatePosMatrix(
                    a.projMatrix,
                    u,
                    b.paint.get("circle-translate"),
                    b.paint.get("circle-translate-anchor")
                  ),
                  u_device_pixel_ratio: d.exported.devicePixelRatio,
                  u_extrude_scale: M,
                  u_inv_rot_matrix: ht,
                  u_merc_center: [0, 0],
                  u_tile_id: [0, 0, 0],
                  u_zoom_transition: 0,
                  u_up_dir: [0, 0, 0],
                };
                if (I) {
                  (R.u_inv_rot_matrix = g),
                    (R.u_merc_center = v),
                    (R.u_tile_id = [
                      a.canonical.x,
                      a.canonical.y,
                      1 << a.canonical.z,
                    ]),
                    (R.u_zoom_transition = d.globeToMercatorTransition(D.zoom));
                  const k = v[0] * d.EXTENT,
                    z = v[1] * d.EXTENT;
                  R.u_up_dir = D.projection.upVector(
                    new d.CanonicalTileID(0, 0, 0),
                    k,
                    z
                  );
                }
                return R;
              },
              $n = (f) => {
                const a = [];
                return (
                  "map" === f.paint.get("circle-pitch-alignment") &&
                    a.push("PITCH_WITH_MAP"),
                  "map" === f.paint.get("circle-pitch-scale") &&
                    a.push("SCALE_WITH_MAP"),
                  a
                );
              },
              vr = (f, a, u, g) => {
                const v = d.EXTENT / u.tileSize;
                return {
                  u_matrix: f,
                  u_camera_to_center_distance: a.getCameraToCenterDistance(g),
                  u_extrude_scale: [
                    a.pixelsToGLUnits[0] / v,
                    a.pixelsToGLUnits[1] / v,
                  ],
                };
              },
              Go = (f, a, u = 1) => ({
                u_matrix: f,
                u_color: a,
                u_overlay: 0,
                u_overlay_scale: u,
              }),
              Ai = d.create(),
              Hs = (f, a, u, g, v, b, D) => {
                const I = f.transform,
                  M = "globe" === I.projection.name,
                  R = M
                    ? d.globePixelsToTileUnits(I.zoom, a.canonical) *
                      I._pixelsPerMercatorPixel
                    : Ci(u, 1, b),
                  k = {
                    u_matrix: a.projMatrix,
                    u_extrude_scale: R,
                    u_intensity: D,
                    u_inv_rot_matrix: Ai,
                    u_merc_center: [0, 0],
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_up_dir: [0, 0, 0],
                  };
                if (M) {
                  (k.u_inv_rot_matrix = g),
                    (k.u_merc_center = v),
                    (k.u_tile_id = [
                      a.canonical.x,
                      a.canonical.y,
                      1 << a.canonical.z,
                    ]),
                    (k.u_zoom_transition = d.globeToMercatorTransition(I.zoom));
                  const z = v[0] * d.EXTENT,
                    H = v[1] * d.EXTENT;
                  k.u_up_dir = I.projection.upVector(
                    new d.CanonicalTileID(0, 0, 0),
                    z,
                    H
                  );
                }
                return k;
              },
              ei = (f, a, u, g, v, b, D) => {
                const I = f.transform,
                  M = I.calculatePixelsToTileUnitsMatrix(a);
                return {
                  u_matrix: Kt(f, a, u, g),
                  u_pixels_to_tile_units: M,
                  u_device_pixel_ratio: b,
                  u_units_to_pixels: [
                    1 / I.pixelsToGLUnits[0],
                    1 / I.pixelsToGLUnits[1],
                  ],
                  u_dash_image: 0,
                  u_gradient_image: 1,
                  u_image_height: v,
                  u_texsize: Gs(u) ? a.lineAtlasTexture.size : [0, 0],
                  u_tile_units_to_pixels: qo(a, f.transform),
                  u_alpha_discard_threshold: 0,
                  u_trim_offset: D,
                };
              },
              fs = (f, a, u, g, v) => {
                const b = f.transform;
                return {
                  u_matrix: Kt(f, a, u, g),
                  u_texsize: a.imageAtlasTexture.size,
                  u_pixels_to_tile_units: b.calculatePixelsToTileUnitsMatrix(a),
                  u_device_pixel_ratio: v,
                  u_image: 0,
                  u_tile_units_to_pixels: qo(a, b),
                  u_units_to_pixels: [
                    1 / b.pixelsToGLUnits[0],
                    1 / b.pixelsToGLUnits[1],
                  ],
                  u_alpha_discard_threshold: 0,
                };
              };
            function qo(f, a) {
              return 1 / Ci(f, 1, a.tileZoom);
            }
            function Kt(f, a, u, g) {
              return f.translatePosMatrix(
                g || a.tileID.projMatrix,
                a,
                u.paint.get("line-translate"),
                u.paint.get("line-translate-anchor")
              );
            }
            function Gs(f) {
              const a = f.paint.get("line-dasharray").value;
              return a.value || "constant" !== a.kind;
            }
            const qs = (f, a, u, g, v, b) => {
              return {
                u_matrix: f,
                u_tl_parent: a,
                u_scale_parent: u,
                u_fade_t: g.mix,
                u_opacity: g.opacity * v.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: v.paint.get("raster-brightness-min"),
                u_brightness_high: v.paint.get("raster-brightness-max"),
                u_saturation_factor:
                  ((I = v.paint.get("raster-saturation")),
                  I > 0 ? 1 - 1 / (1.001 - I) : -I),
                u_contrast_factor:
                  ((D = v.paint.get("raster-contrast")),
                  D > 0 ? 1 / (1 - D) : 1 + D),
                u_spin_weights: oo(v.paint.get("raster-hue-rotate")),
                u_perspective_transform: b,
              };
              var D, I;
            };
            function oo(f) {
              f *= Math.PI / 180;
              const a = Math.sin(f),
                u = Math.cos(f);
              return [
                (2 * u + 1) / 3,
                (-Math.sqrt(3) * a - u + 1) / 3,
                (Math.sqrt(3) * a - u + 1) / 3,
              ];
            }
            const Wo = d.create(),
              Ni = (f, a, u, g, v, b, D, I, M, R, k, z, H, q, X, Z) => {
                const Y = v.transform,
                  B = {
                    u_is_size_zoom_constant: +(
                      "constant" === f || "source" === f
                    ),
                    u_is_size_feature_constant: +(
                      "constant" === f || "camera" === f
                    ),
                    u_size_t: a ? a.uSizeT : 0,
                    u_size: a ? a.uSize : 0,
                    u_camera_to_center_distance: Y.cameraToCenterDistance,
                    u_rotate_symbol: +u,
                    u_aspect_ratio: Y.width / Y.height,
                    u_fade_change: v.options.fadeDuration
                      ? v.symbolFadeChange
                      : 1,
                    u_matrix: b,
                    u_label_plane_matrix: D,
                    u_coord_matrix: I,
                    u_is_text: +M,
                    u_pitch_with_map: +g,
                    u_texsize: R,
                    u_texture: 0,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: Wo,
                    u_merc_center: [0, 0],
                    u_camera_forward: [0, 0, 0],
                    u_ecef_origin: [0, 0, 0],
                    u_tile_matrix: Wo,
                    u_up_vector: [0, -1, 0],
                  };
                return (
                  "globe" === Z.name &&
                    ((B.u_tile_id = [
                      k.canonical.x,
                      k.canonical.y,
                      1 << k.canonical.z,
                    ]),
                    (B.u_zoom_transition = z),
                    (B.u_inv_rot_matrix = q),
                    (B.u_merc_center = H),
                    (B.u_camera_forward = Y._camera.forward()),
                    (B.u_ecef_origin = d.globeECEFOrigin(
                      Y.globeMatrix,
                      k.toUnwrapped()
                    )),
                    (B.u_tile_matrix = Float32Array.from(Y.globeMatrix)),
                    (B.u_up_vector = X)),
                  B
                );
              },
              Ws = (f, a, u, g, v, b, D, I, M, R, k, z, H, q, X, Z, Y) =>
                d.extend(Ni(f, a, u, g, v, b, D, I, M, R, z, H, q, X, Z, Y), {
                  u_gamma_scale: g
                    ? v.transform.cameraToCenterDistance *
                      Math.cos(v.terrain ? 0 : v.transform._pitch)
                    : 1,
                  u_device_pixel_ratio: d.exported.devicePixelRatio,
                  u_is_halo: +k,
                }),
              Na = (f, a, u, g, v, b, D, I, M, R, k, z, H, q, X, Z) =>
                d.extend(
                  Ws(f, a, u, g, v, b, D, I, !0, M, !0, k, z, H, q, X, Z),
                  { u_texsize_icon: R, u_texture_icon: 1 }
                ),
              qr = (f, a, u) => ({ u_matrix: f, u_opacity: a, u_color: u }),
              Ll = (f, a, u, g, v) =>
                d.extend(
                  (function (b, D, I) {
                    const M = D.imageManager.getPattern(b.toString()),
                      { width: R, height: k } = D.imageManager.getPixelSize(),
                      z = Math.pow(2, I.tileID.overscaledZ),
                      H = (I.tileSize * Math.pow(2, D.transform.tileZoom)) / z,
                      q = H * (I.tileID.canonical.x + I.tileID.wrap * z),
                      X = H * I.tileID.canonical.y;
                    return {
                      u_image: 0,
                      u_pattern_tl: M.tl,
                      u_pattern_br: M.br,
                      u_texsize: [R, k],
                      u_pattern_size: M.displaySize,
                      u_tile_units_to_pixels:
                        1 / Ci(I, 1, D.transform.tileZoom),
                      u_pixel_coord_upper: [q >> 16, X >> 16],
                      u_pixel_coord_lower: [65535 & q, 65535 & X],
                    };
                  })(g, u, v),
                  { u_matrix: f, u_opacity: a }
                ),
              xu = {
                fillExtrusion: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_lightpos: new d.Uniform3f(f),
                  u_lightintensity: new d.Uniform1f(f),
                  u_lightcolor: new d.Uniform3f(f),
                  u_vertical_gradient: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_edge_radius: new d.Uniform1f(f),
                  u_ao: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_up_dir: new d.Uniform3f(f),
                  u_height_lift: new d.Uniform1f(f),
                }),
                fillExtrusionPattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_lightpos: new d.Uniform3f(f),
                  u_lightintensity: new d.Uniform1f(f),
                  u_lightcolor: new d.Uniform3f(f),
                  u_vertical_gradient: new d.Uniform1f(f),
                  u_height_factor: new d.Uniform1f(f),
                  u_edge_radius: new d.Uniform1f(f),
                  u_ao: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_up_dir: new d.Uniform3f(f),
                  u_height_lift: new d.Uniform1f(f),
                  u_image: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                }),
                fill: (f) => ({ u_matrix: new d.UniformMatrix4f(f) }),
                fillPattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_image: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                }),
                fillOutline: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_world: new d.Uniform2f(f),
                }),
                fillOutlinePattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_world: new d.Uniform2f(f),
                  u_image: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                }),
                circle: (f) => ({
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_extrude_scale: new d.UniformMatrix2f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_up_dir: new d.Uniform3f(f),
                }),
                collisionBox: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_extrude_scale: new d.Uniform2f(f),
                }),
                collisionCircle: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_inv_matrix: new d.UniformMatrix4f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_viewport_size: new d.Uniform2f(f),
                }),
                debug: (f) => ({
                  u_color: new d.UniformColor(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_overlay: new d.Uniform1i(f),
                  u_overlay_scale: new d.Uniform1f(f),
                }),
                clippingMask: (f) => ({ u_matrix: new d.UniformMatrix4f(f) }),
                heatmap: (f) => ({
                  u_extrude_scale: new d.Uniform1f(f),
                  u_intensity: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_up_dir: new d.Uniform3f(f),
                }),
                heatmapTexture: (f) => ({
                  u_image: new d.Uniform1i(f),
                  u_color_ramp: new d.Uniform1i(f),
                  u_opacity: new d.Uniform1f(f),
                }),
                hillshade: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_image: new d.Uniform1i(f),
                  u_latrange: new d.Uniform2f(f),
                  u_light: new d.Uniform2f(f),
                  u_shadow: new d.UniformColor(f),
                  u_highlight: new d.UniformColor(f),
                  u_accent: new d.UniformColor(f),
                }),
                hillshadePrepare: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_image: new d.Uniform1i(f),
                  u_dimension: new d.Uniform2f(f),
                  u_zoom: new d.Uniform1f(f),
                  u_unpack: new d.Uniform4f(f),
                }),
                line: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_pixels_to_tile_units: new d.UniformMatrix2f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_units_to_pixels: new d.Uniform2f(f),
                  u_dash_image: new d.Uniform1i(f),
                  u_gradient_image: new d.Uniform1i(f),
                  u_image_height: new d.Uniform1f(f),
                  u_texsize: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                  u_alpha_discard_threshold: new d.Uniform1f(f),
                  u_trim_offset: new d.Uniform2f(f),
                }),
                linePattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pixels_to_tile_units: new d.UniformMatrix2f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_image: new d.Uniform1i(f),
                  u_units_to_pixels: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                  u_alpha_discard_threshold: new d.Uniform1f(f),
                }),
                raster: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_tl_parent: new d.Uniform2f(f),
                  u_scale_parent: new d.Uniform1f(f),
                  u_fade_t: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_image0: new d.Uniform1i(f),
                  u_image1: new d.Uniform1i(f),
                  u_brightness_low: new d.Uniform1f(f),
                  u_brightness_high: new d.Uniform1f(f),
                  u_saturation_factor: new d.Uniform1f(f),
                  u_contrast_factor: new d.Uniform1f(f),
                  u_spin_weights: new d.Uniform3f(f),
                  u_perspective_transform: new d.Uniform2f(f),
                }),
                symbolIcon: (f) => ({
                  u_is_size_zoom_constant: new d.Uniform1i(f),
                  u_is_size_feature_constant: new d.Uniform1i(f),
                  u_size_t: new d.Uniform1f(f),
                  u_size: new d.Uniform1f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_rotate_symbol: new d.Uniform1i(f),
                  u_aspect_ratio: new d.Uniform1f(f),
                  u_fade_change: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_label_plane_matrix: new d.UniformMatrix4f(f),
                  u_coord_matrix: new d.UniformMatrix4f(f),
                  u_is_text: new d.Uniform1i(f),
                  u_pitch_with_map: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_camera_forward: new d.Uniform3f(f),
                  u_tile_matrix: new d.UniformMatrix4f(f),
                  u_up_vector: new d.Uniform3f(f),
                  u_ecef_origin: new d.Uniform3f(f),
                  u_texture: new d.Uniform1i(f),
                }),
                symbolSDF: (f) => ({
                  u_is_size_zoom_constant: new d.Uniform1i(f),
                  u_is_size_feature_constant: new d.Uniform1i(f),
                  u_size_t: new d.Uniform1f(f),
                  u_size: new d.Uniform1f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_rotate_symbol: new d.Uniform1i(f),
                  u_aspect_ratio: new d.Uniform1f(f),
                  u_fade_change: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_label_plane_matrix: new d.UniformMatrix4f(f),
                  u_coord_matrix: new d.UniformMatrix4f(f),
                  u_is_text: new d.Uniform1i(f),
                  u_pitch_with_map: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_texture: new d.Uniform1i(f),
                  u_gamma_scale: new d.Uniform1f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_tile_id: new d.Uniform3f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_inv_rot_matrix: new d.UniformMatrix4f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_camera_forward: new d.Uniform3f(f),
                  u_tile_matrix: new d.UniformMatrix4f(f),
                  u_up_vector: new d.Uniform3f(f),
                  u_ecef_origin: new d.Uniform3f(f),
                  u_is_halo: new d.Uniform1i(f),
                }),
                symbolTextAndIcon: (f) => ({
                  u_is_size_zoom_constant: new d.Uniform1i(f),
                  u_is_size_feature_constant: new d.Uniform1i(f),
                  u_size_t: new d.Uniform1f(f),
                  u_size: new d.Uniform1f(f),
                  u_camera_to_center_distance: new d.Uniform1f(f),
                  u_rotate_symbol: new d.Uniform1i(f),
                  u_aspect_ratio: new d.Uniform1f(f),
                  u_fade_change: new d.Uniform1f(f),
                  u_matrix: new d.UniformMatrix4f(f),
                  u_label_plane_matrix: new d.UniformMatrix4f(f),
                  u_coord_matrix: new d.UniformMatrix4f(f),
                  u_is_text: new d.Uniform1i(f),
                  u_pitch_with_map: new d.Uniform1i(f),
                  u_texsize: new d.Uniform2f(f),
                  u_texsize_icon: new d.Uniform2f(f),
                  u_texture: new d.Uniform1i(f),
                  u_texture_icon: new d.Uniform1i(f),
                  u_gamma_scale: new d.Uniform1f(f),
                  u_device_pixel_ratio: new d.Uniform1f(f),
                  u_is_halo: new d.Uniform1i(f),
                }),
                background: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_color: new d.UniformColor(f),
                }),
                backgroundPattern: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_image: new d.Uniform1i(f),
                  u_pattern_tl: new d.Uniform2f(f),
                  u_pattern_br: new d.Uniform2f(f),
                  u_texsize: new d.Uniform2f(f),
                  u_pattern_size: new d.Uniform2f(f),
                  u_pixel_coord_upper: new d.Uniform2f(f),
                  u_pixel_coord_lower: new d.Uniform2f(f),
                  u_tile_units_to_pixels: new d.Uniform1f(f),
                }),
                terrainRaster: vn,
                terrainDepth: vn,
                skybox: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_sun_direction: new d.Uniform3f(f),
                  u_cubemap: new d.Uniform1i(f),
                  u_opacity: new d.Uniform1f(f),
                  u_temporal_offset: new d.Uniform1f(f),
                }),
                skyboxGradient: (f) => ({
                  u_matrix: new d.UniformMatrix4f(f),
                  u_color_ramp: new d.Uniform1i(f),
                  u_center_direction: new d.Uniform3f(f),
                  u_radius: new d.Uniform1f(f),
                  u_opacity: new d.Uniform1f(f),
                  u_temporal_offset: new d.Uniform1f(f),
                }),
                skyboxCapture: (f) => ({
                  u_matrix_3f: new d.UniformMatrix3f(f),
                  u_sun_direction: new d.Uniform3f(f),
                  u_sun_intensity: new d.Uniform1f(f),
                  u_color_tint_r: new d.Uniform4f(f),
                  u_color_tint_m: new d.Uniform4f(f),
                  u_luminance: new d.Uniform1f(f),
                }),
                globeRaster: (f) => ({
                  u_proj_matrix: new d.UniformMatrix4f(f),
                  u_globe_matrix: new d.UniformMatrix4f(f),
                  u_normalize_matrix: new d.UniformMatrix4f(f),
                  u_merc_matrix: new d.UniformMatrix4f(f),
                  u_zoom_transition: new d.Uniform1f(f),
                  u_merc_center: new d.Uniform2f(f),
                  u_image0: new d.Uniform1i(f),
                  u_grid_matrix: new d.UniformMatrix3f(f),
                  u_skirt_height: new d.Uniform1f(f),
                  u_frustum_tl: new d.Uniform3f(f),
                  u_frustum_tr: new d.Uniform3f(f),
                  u_frustum_br: new d.Uniform3f(f),
                  u_frustum_bl: new d.Uniform3f(f),
                  u_globe_pos: new d.Uniform3f(f),
                  u_globe_radius: new d.Uniform1f(f),
                  u_viewport: new d.Uniform2f(f),
                }),
                globeAtmosphere: (f) => ({
                  u_frustum_tl: new d.Uniform3f(f),
                  u_frustum_tr: new d.Uniform3f(f),
                  u_frustum_br: new d.Uniform3f(f),
                  u_frustum_bl: new d.Uniform3f(f),
                  u_horizon: new d.Uniform1f(f),
                  u_transition: new d.Uniform1f(f),
                  u_fadeout_range: new d.Uniform1f(f),
                  u_color: new d.Uniform4f(f),
                  u_high_color: new d.Uniform4f(f),
                  u_space_color: new d.Uniform4f(f),
                  u_star_intensity: new d.Uniform1f(f),
                  u_star_density: new d.Uniform1f(f),
                  u_star_size: new d.Uniform1f(f),
                  u_temporal_offset: new d.Uniform1f(f),
                  u_horizon_angle: new d.Uniform1f(f),
                  u_rotation_matrix: new d.UniformMatrix4f(f),
                }),
              };
            let On;
            function vc(f, a, u, g, v, b, D) {
              const I = f.context,
                M = I.gl,
                R = f.transform,
                k = f.useProgram("collisionBox"),
                z = [];
              let H = 0,
                q = 0;
              for (let te = 0; te < g.length; te++) {
                const he = g[te],
                  de = a.getTile(he),
                  ue = de.getBucket(u);
                if (!ue) continue;
                const _e = gr(he, ue, R);
                let ge = _e;
                (0 === v[0] && 0 === v[1]) ||
                  (ge = f.translatePosMatrix(_e, de, v, b));
                const Te = D ? ue.textCollisionBox : ue.iconCollisionBox,
                  Ge = ue.collisionCircleArray;
                if (Ge.length > 0) {
                  const be = d.create(),
                    Le = ge;
                  d.mul(be, ue.placementInvProjMatrix, R.glCoordMatrix),
                    d.mul(be, be, ue.placementViewportMatrix),
                    z.push({
                      circleArray: Ge,
                      circleOffset: q,
                      transform: Le,
                      invTransform: be,
                      projection: ue.getProjection(),
                    }),
                    (H += Ge.length / 4),
                    (q = H);
                }
                Te &&
                  (f.terrain && f.terrain.setupElevationDraw(de, k),
                  k.draw(
                    I,
                    M.LINES,
                    d.DepthMode.disabled,
                    d.StencilMode.disabled,
                    f.colorModeForRenderPass(),
                    d.CullFaceMode.disabled,
                    vr(ge, R, de, ue.getProjection()),
                    u.id,
                    Te.layoutVertexBuffer,
                    Te.indexBuffer,
                    Te.segments,
                    null,
                    R.zoom,
                    null,
                    [Te.collisionVertexBuffer, Te.collisionVertexBufferExt]
                  ));
              }
              if (!D || !z.length) return;
              const X = f.useProgram("collisionCircle"),
                Z = new d.StructArrayLayout2f1f2i16();
              Z.resize(4 * H), Z._trim();
              let Y = 0;
              for (const te of z)
                for (let he = 0; he < te.circleArray.length / 4; he++) {
                  const de = 4 * he,
                    ue = te.circleArray[de + 0],
                    _e = te.circleArray[de + 1],
                    ge = te.circleArray[de + 2],
                    Te = te.circleArray[de + 3];
                  Z.emplace(Y++, ue, _e, ge, Te, 0),
                    Z.emplace(Y++, ue, _e, ge, Te, 1),
                    Z.emplace(Y++, ue, _e, ge, Te, 2),
                    Z.emplace(Y++, ue, _e, ge, Te, 3);
                }
              (!On || On.length < 2 * H) &&
                (On = (function (te) {
                  const he = 2 * te,
                    de = new d.StructArrayLayout3ui6();
                  de.resize(he), de._trim();
                  for (let ue = 0; ue < he; ue++) {
                    const _e = 6 * ue;
                    (de.uint16[_e + 0] = 4 * ue + 0),
                      (de.uint16[_e + 1] = 4 * ue + 1),
                      (de.uint16[_e + 2] = 4 * ue + 2),
                      (de.uint16[_e + 3] = 4 * ue + 2),
                      (de.uint16[_e + 4] = 4 * ue + 3),
                      (de.uint16[_e + 5] = 4 * ue + 0);
                  }
                  return de;
                })(H));
              const B = I.createIndexBuffer(On, !0),
                W = I.createVertexBuffer(
                  Z,
                  d.collisionCircleLayout.members,
                  !0
                );
              for (const te of z) {
                const he = {
                  u_matrix: te.transform,
                  u_inv_matrix: te.invTransform,
                  u_camera_to_center_distance: (ee =
                    R).getCameraToCenterDistance(te.projection),
                  u_viewport_size: [ee.width, ee.height],
                };
                X.draw(
                  I,
                  M.TRIANGLES,
                  d.DepthMode.disabled,
                  d.StencilMode.disabled,
                  f.colorModeForRenderPass(),
                  d.CullFaceMode.disabled,
                  he,
                  u.id,
                  W,
                  B,
                  d.SegmentVector.simpleSegment(
                    0,
                    2 * te.circleOffset,
                    te.circleArray.length,
                    te.circleArray.length / 2
                  ),
                  null,
                  R.zoom
                );
              }
              var ee;
              W.destroy(), B.destroy();
            }
            const fp = d.create();
            function kl(
              { width: f, height: a, anchor: u, textOffset: g, textScale: v },
              b
            ) {
              const { horizontalAlign: D, verticalAlign: I } =
                  d.getAnchorAlignment(u),
                M = -(D - 0.5) * f,
                R = -(I - 0.5) * a,
                k = d.evaluateVariableOffset(u, g);
              return new d.Point((M / v + k[0]) * b, (R / v + k[1]) * b);
            }
            function Nh(f, a, u, g, v, b, D, I, M, R, k) {
              const z = f.text.placedSymbolArray,
                H = f.text.dynamicLayoutVertexArray,
                q = f.icon.dynamicLayoutVertexArray,
                X = {},
                Z = f.getProjection(),
                Y = pt(I, Z, b),
                B = b.elevation,
                W = Z.upVectorScale(
                  I.canonical,
                  b.center.lat,
                  b.worldSize
                ).metersToTile;
              H.clear();
              for (let ee = 0; ee < z.length; ee++) {
                const te = z.get(ee),
                  { tileAnchorX: he, tileAnchorY: de, numGlyphs: ue } = te,
                  _e =
                    te.hidden ||
                    !te.crossTileID ||
                    (f.allowVerticalPlacement && !te.placedOrientation)
                      ? null
                      : g[te.crossTileID];
                if (_e) {
                  let ge = 0,
                    Te = 0,
                    Ge = 0;
                  if (B) {
                    const Xe = B ? B.getAtTileOffset(I, he, de) : 0,
                      [dt, Dt, ct] = Z.upVector(I.canonical, he, de);
                    (ge = Xe * dt * W), (Te = Xe * Dt * W), (Ge = Xe * ct * W);
                  }
                  let [be, Le, Ie, je] = Fi(
                    te.projectedAnchorX + ge,
                    te.projectedAnchorY + Te,
                    te.projectedAnchorZ + Ge,
                    u ? Y : D
                  );
                  const we = op(b.getCameraToCenterDistance(Z), je);
                  let ke =
                    (v.evaluateSizeForFeature(f.textSizeData, R, te) * we) /
                    d.ONE_EM;
                  u && (ke *= f.tilePixelRatio / M);
                  const He = kl(_e, ke);
                  u
                    ? (({
                        x: be,
                        y: Le,
                        z: Ie,
                      } = Z.projectTilePoint(
                        he + He.x,
                        de + He.y,
                        I.canonical
                      )),
                      ([be, Le, Ie] = Fi(be + ge, Le + Te, Ie + Ge, D)))
                    : (a && He._rotate(-b.angle),
                      (be += He.x),
                      (Le += He.y),
                      (Ie = 0));
                  const Ne =
                    f.allowVerticalPlacement &&
                    te.placedOrientation === d.WritingMode.vertical
                      ? Math.PI / 2
                      : 0;
                  for (let Xe = 0; Xe < ue; Xe++)
                    d.addDynamicAttributes(H, be, Le, Ie, Ne);
                  k &&
                    te.associatedIconIndex >= 0 &&
                    (X[te.associatedIconIndex] = {
                      x: be,
                      y: Le,
                      z: Ie,
                      angle: Ne,
                    });
                } else Mr(ue, H);
              }
              if (k) {
                q.clear();
                const ee = f.icon.placedSymbolArray;
                for (let te = 0; te < ee.length; te++) {
                  const he = ee.get(te),
                    { numGlyphs: de } = he,
                    ue = X[te];
                  if (he.hidden || !ue) Mr(de, q);
                  else {
                    const { x: _e, y: ge, z: Te, angle: Ge } = ue;
                    for (let be = 0; be < de; be++)
                      d.addDynamicAttributes(q, _e, ge, Te, Ge);
                  }
                }
                f.icon.dynamicLayoutVertexBuffer.updateData(q);
              }
              f.text.dynamicLayoutVertexBuffer.updateData(H);
            }
            function za(f, a, u) {
              return u.iconsInText && a
                ? "symbolTextAndIcon"
                : f
                ? "symbolSDF"
                : "symbolIcon";
            }
            function xc(f, a, u, g, v, b, D, I, M, R, k, z) {
              const H = f.context,
                q = H.gl,
                X = f.transform,
                Z = "map" === I,
                Y = "map" === M,
                B = Z && "point" !== u.layout.get("symbol-placement"),
                W = Z && !Y && !B,
                ee = void 0 !== u.layout.get("symbol-sort-key").constantOr(1);
              let te = !1;
              const he = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                de = [
                  d.mercatorXfromLng(X.center.lng),
                  d.mercatorYfromLat(X.center.lat),
                ],
                ue = u.layout.get("text-variable-anchor"),
                _e = "globe" === X.projection.name,
                ge = [],
                Te = [0, -1, 0];
              let Ge = Te;
              (!_e && !X.mercatorFromTransition) ||
                Z ||
                (Ge = (function (be) {
                  const Le = be._camera.getWorldToCamera(be.worldSize, 1),
                    Ie = d.multiply([], Le, be.globeMatrix);
                  d.invert(Ie, Ie);
                  const je = [0, 0, 0],
                    we = [0, 1, 0, 0];
                  return (
                    d.transformMat4$1(we, we, Ie),
                    (je[0] = we[0]),
                    (je[1] = we[1]),
                    (je[2] = we[2]),
                    d.normalize(je, je),
                    je
                  );
                })(X));
              for (const be of g) {
                const Le = a.getTile(be),
                  Ie = Le.getBucket(u);
                if (!Ie || ("mercator" === Ie.projection.name && _e)) continue;
                const je = v ? Ie.text : Ie.icon;
                if (!je || Ie.fullyClipped || !je.segments.get().length)
                  continue;
                const we = je.programConfigurations.get(u.id),
                  ke = v || Ie.sdfIcons,
                  He = v ? Ie.textSizeData : Ie.iconSizeData,
                  Ne = Y || 0 !== X.pitch,
                  Xe = d.evaluateSizeForZoom(He, X.zoom);
                let dt,
                  Dt,
                  ct,
                  wt,
                  Wt = [0, 0],
                  jt = null;
                if (v)
                  (Dt = Le.glyphAtlasTexture),
                    (ct = q.LINEAR),
                    (dt = Le.glyphAtlasTexture.size),
                    Ie.iconsInText &&
                      ((Wt = Le.imageAtlasTexture.size),
                      (jt = Le.imageAtlasTexture),
                      (wt =
                        Ne ||
                        f.options.rotating ||
                        f.options.zooming ||
                        "composite" === He.kind ||
                        "camera" === He.kind
                          ? q.LINEAR
                          : q.NEAREST));
                else {
                  const Or =
                    1 !== u.layout.get("icon-size").constantOr(0) ||
                    Ie.iconsNeedLinear;
                  (Dt = Le.imageAtlasTexture),
                    (ct =
                      ke || f.options.rotating || f.options.zooming || Or || Ne
                        ? q.LINEAR
                        : q.NEAREST),
                    (dt = Le.imageAtlasTexture.size);
                }
                const ft = "globe" === Ie.projection.name,
                  Yt = ft ? Ge : Te,
                  kn = ft ? d.globeToMercatorTransition(X.zoom) : 0,
                  fn = pt(be, Ie.getProjection(), X),
                  Tn = X.calculatePixelsToTileUnitsMatrix(Le),
                  ji = Ae(
                    fn,
                    Le.tileID.canonical,
                    Y,
                    Z,
                    X,
                    Ie.getProjection(),
                    Tn
                  ),
                  mi = f.terrain && Y && B ? d.invert(d.create(), ji) : fp,
                  br = hi(
                    fn,
                    Le.tileID.canonical,
                    Y,
                    Z,
                    X,
                    Ie.getProjection(),
                    Tn
                  ),
                  Ko = ue && Ie.hasTextData(),
                  Un =
                    "none" !== u.layout.get("icon-text-fit") &&
                    Ko &&
                    Ie.hasIconData();
                if (B) {
                  const Or = X.elevation,
                    na = Or
                      ? Or.getAtTileOffsetFunc(
                          be,
                          X.center.lat,
                          X.worldSize,
                          Ie.getProjection()
                        )
                      : null,
                    Wa = Vo(
                      fn,
                      Le.tileID.canonical,
                      Y,
                      Z,
                      X,
                      Ie.getProjection(),
                      Tn
                    );
                  Mh(Ie, fn, f, v, Wa, br, Y, R, na, be);
                }
                const Cn = B || (v && ue) || Un,
                  ln = f.translatePosMatrix(fn, Le, b, D),
                  ni = Cn ? fp : ji,
                  wr = f.translatePosMatrix(br, Le, b, D, !0),
                  Rn = Ie.getProjection().createInversionMatrix(
                    X,
                    be.canonical
                  ),
                  Ui = [];
                f.terrainRenderModeElevated() &&
                  Y &&
                  Ui.push("PITCH_WITH_MAP_TERRAIN"),
                  ft && Ui.push("PROJECTION_GLOBE_VIEW"),
                  Cn && Ui.push("PROJECTED_POS_ON_VIEWPORT");
                const Fu =
                  ke &&
                  0 !==
                    u.paint
                      .get(v ? "text-halo-width" : "icon-halo-width")
                      .constantOr(1);
                let ta;
                ta = ke
                  ? Ie.iconsInText
                    ? Na(
                        He.kind,
                        Xe,
                        W,
                        Y,
                        f,
                        ln,
                        ni,
                        wr,
                        dt,
                        Wt,
                        be,
                        kn,
                        de,
                        Rn,
                        Yt,
                        Ie.getProjection()
                      )
                    : Ws(
                        He.kind,
                        Xe,
                        W,
                        Y,
                        f,
                        ln,
                        ni,
                        wr,
                        v,
                        dt,
                        !0,
                        be,
                        kn,
                        de,
                        Rn,
                        Yt,
                        Ie.getProjection()
                      )
                  : Ni(
                      He.kind,
                      Xe,
                      W,
                      Y,
                      f,
                      ln,
                      ni,
                      wr,
                      v,
                      dt,
                      be,
                      kn,
                      de,
                      Rn,
                      Yt,
                      Ie.getProjection()
                    );
                const Bl = {
                  program: f.useProgram(za(ke, v, Ie), we, Ui),
                  buffers: je,
                  uniformValues: ta,
                  atlasTexture: Dt,
                  atlasTextureIcon: jt,
                  atlasInterpolation: ct,
                  atlasInterpolationIcon: wt,
                  isSDF: ke,
                  hasHalo: Fu,
                  tile: Le,
                  labelPlaneMatrixInv: mi,
                };
                if (ee && Ie.canOverlap) {
                  te = !0;
                  const Or = je.segments.get();
                  for (const na of Or)
                    ge.push({
                      segments: new d.SegmentVector([na]),
                      sortKey: na.sortKey,
                      state: Bl,
                    });
                } else
                  ge.push({ segments: je.segments, sortKey: 0, state: Bl });
              }
              te && ge.sort((be, Le) => be.sortKey - Le.sortKey);
              for (const be of ge) {
                const Le = be.state;
                if (
                  (f.terrain &&
                    f.terrain.setupElevationDraw(Le.tile, Le.program, {
                      useDepthForOcclusion: !_e,
                      labelPlaneMatrixInv: Le.labelPlaneMatrixInv,
                    }),
                  H.activeTexture.set(q.TEXTURE0),
                  Le.atlasTexture.bind(Le.atlasInterpolation, q.CLAMP_TO_EDGE),
                  Le.atlasTextureIcon &&
                    (H.activeTexture.set(q.TEXTURE1),
                    Le.atlasTextureIcon &&
                      Le.atlasTextureIcon.bind(
                        Le.atlasInterpolationIcon,
                        q.CLAMP_TO_EDGE
                      )),
                  Le.isSDF)
                ) {
                  const Ie = Le.uniformValues;
                  Le.hasHalo &&
                    ((Ie.u_is_halo = 1),
                    bo(
                      Le.buffers,
                      be.segments,
                      u,
                      f,
                      Le.program,
                      he,
                      k,
                      z,
                      Ie
                    )),
                    (Ie.u_is_halo = 0);
                }
                bo(
                  Le.buffers,
                  be.segments,
                  u,
                  f,
                  Le.program,
                  he,
                  k,
                  z,
                  Le.uniformValues
                );
              }
            }
            function bo(f, a, u, g, v, b, D, I, M) {
              const R = g.context,
                k = [
                  f.dynamicLayoutVertexBuffer,
                  f.opacityVertexBuffer,
                  f.globeExtVertexBuffer,
                ];
              v.draw(
                R,
                R.gl.TRIANGLES,
                b,
                D,
                I,
                d.CullFaceMode.disabled,
                M,
                u.id,
                f.layoutVertexBuffer,
                f.indexBuffer,
                a,
                u.paint,
                g.transform.zoom,
                f.programConfigurations.get(u.id),
                k
              );
            }
            function Ki(f, a, u, g, v, b, D) {
              const I = f.context.gl,
                M = u.paint.get("fill-pattern"),
                R = M && M.constantOr(1);
              let k, z, H, q, X;
              D
                ? ((z =
                    R && !u.getPaintProperty("fill-outline-color")
                      ? "fillOutlinePattern"
                      : "fillOutline"),
                  (k = I.LINES))
                : ((z = R ? "fillPattern" : "fill"), (k = I.TRIANGLES));
              for (const Z of g) {
                const Y = a.getTile(Z);
                if (R && !Y.patternsLoaded()) continue;
                const B = Y.getBucket(u);
                if (!B) continue;
                f.prepareDrawTile();
                const W = B.programConfigurations.get(u.id),
                  ee = f.useProgram(z, W);
                R &&
                  (f.context.activeTexture.set(I.TEXTURE0),
                  Y.imageAtlasTexture.bind(I.LINEAR, I.CLAMP_TO_EDGE),
                  W.updatePaintBuffers());
                const te = M.constantOr(null);
                if (te && Y.imageAtlas) {
                  const de = Y.imageAtlas.patternPositions[te.toString()];
                  de && W.setConstantPatternPositions(de);
                }
                const he = f.translatePosMatrix(
                  Z.projMatrix,
                  Y,
                  u.paint.get("fill-translate"),
                  u.paint.get("fill-translate-anchor")
                );
                if (D) {
                  (q = B.indexBuffer2), (X = B.segments2);
                  const de =
                    f.terrain && f.terrain.renderingToTexture
                      ? f.terrain.drapeBufferSize
                      : [I.drawingBufferWidth, I.drawingBufferHeight];
                  H =
                    "fillOutlinePattern" === z && R
                      ? ro(he, f, Y, de)
                      : Gr(he, de);
                } else
                  (q = B.indexBuffer),
                    (X = B.segments),
                    (H = R ? Fa(he, f, Y) : pi(he));
                f.prepareDrawProgram(f.context, ee, Z.toUnwrapped()),
                  ee.draw(
                    f.context,
                    k,
                    v,
                    f.stencilModeForClipping(Z),
                    b,
                    d.CullFaceMode.disabled,
                    H,
                    u.id,
                    B.layoutVertexBuffer,
                    q,
                    X,
                    u.paint,
                    f.transform.zoom,
                    W
                  );
              }
            }
            function bu(f, a, u, g, v, b, D) {
              const I = f.context,
                M = I.gl,
                R = f.transform,
                k = u.paint.get("fill-extrusion-pattern"),
                z = k.constantOr(1),
                H = u.paint.get("fill-extrusion-opacity"),
                q = [
                  u.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                  u.paint.get("fill-extrusion-ambient-occlusion-radius"),
                ],
                X = u.layout.get("fill-extrusion-edge-radius"),
                Z = X > 0 && !u.paint.get("fill-extrusion-rounded-roof"),
                Y = Z ? 0 : X,
                B =
                  "globe" === R.projection.name
                    ? d.fillExtrusionHeightLift()
                    : 0,
                W = "globe" === R.projection.name,
                ee = W ? d.globeToMercatorTransition(R.zoom) : 0,
                te = [
                  d.mercatorXfromLng(R.center.lng),
                  d.mercatorYfromLat(R.center.lat),
                ],
                he = [];
              W && he.push("PROJECTION_GLOBE_VIEW"),
                q[0] > 0 && he.push("FAUX_AO"),
                Z && he.push("ZERO_ROOF_RADIUS");
              for (const de of g) {
                const ue = a.getTile(de),
                  _e = ue.getBucket(u);
                if (!_e || _e.projection.name !== R.projection.name) continue;
                const ge = _e.programConfigurations.get(u.id),
                  Te = f.useProgram(
                    z ? "fillExtrusionPattern" : "fillExtrusion",
                    ge,
                    he
                  );
                if (f.terrain) {
                  const ke = f.terrain;
                  if (f.style.terrainSetForDrapingOnly())
                    ke.setupElevationDraw(ue, Te, { useMeterToDem: !0 });
                  else {
                    if (!_e.enableTerrain) continue;
                    if (
                      (ke.setupElevationDraw(ue, Te, { useMeterToDem: !0 }),
                      xr(I, a, de, _e, u, ke),
                      !_e.centroidVertexBuffer)
                    ) {
                      const He = Te.attributes.a_centroid_pos;
                      void 0 !== He && M.vertexAttrib2f(He, 0, 0);
                    }
                  }
                }
                z &&
                  (f.context.activeTexture.set(M.TEXTURE0),
                  ue.imageAtlasTexture.bind(M.LINEAR, M.CLAMP_TO_EDGE),
                  ge.updatePaintBuffers());
                const Ge = k.constantOr(null);
                if (Ge && ue.imageAtlas) {
                  const ke = ue.imageAtlas.patternPositions[Ge.toString()];
                  ke && ge.setConstantPatternPositions(ke);
                }
                const be = f.translatePosMatrix(
                    de.projMatrix,
                    ue,
                    u.paint.get("fill-extrusion-translate"),
                    u.paint.get("fill-extrusion-translate-anchor")
                  ),
                  Le = R.projection.createInversionMatrix(R, de.canonical),
                  Ie = u.paint.get("fill-extrusion-vertical-gradient"),
                  je = z
                    ? sr(be, f, Ie, H, q, Y, de, ue, B, ee, te, Le)
                    : In(be, f, Ie, H, q, Y, de, B, ee, te, Le);
                f.prepareDrawProgram(I, Te, de.toUnwrapped());
                const we = [];
                f.terrain && we.push(_e.centroidVertexBuffer),
                  W && we.push(_e.layoutVertexExtBuffer),
                  Te.draw(
                    I,
                    I.gl.TRIANGLES,
                    v,
                    b,
                    D,
                    d.CullFaceMode.backCCW,
                    je,
                    u.id,
                    _e.layoutVertexBuffer,
                    _e.indexBuffer,
                    _e.segments,
                    u.paint,
                    f.transform.zoom,
                    ge,
                    we
                  );
              }
            }
            function xr(f, a, u, g, v, b) {
              const D = [
                  (B) => {
                    let W = B.canonical.x - 1,
                      ee = B.wrap;
                    return (
                      W < 0 && ((W = (1 << B.canonical.z) - 1), ee--),
                      new d.OverscaledTileID(
                        B.overscaledZ,
                        ee,
                        B.canonical.z,
                        W,
                        B.canonical.y
                      )
                    );
                  },
                  (B) => {
                    let W = B.canonical.x + 1,
                      ee = B.wrap;
                    return (
                      W === 1 << B.canonical.z && ((W = 0), ee++),
                      new d.OverscaledTileID(
                        B.overscaledZ,
                        ee,
                        B.canonical.z,
                        W,
                        B.canonical.y
                      )
                    );
                  },
                  (B) =>
                    new d.OverscaledTileID(
                      B.overscaledZ,
                      B.wrap,
                      B.canonical.z,
                      B.canonical.x,
                      (0 === B.canonical.y
                        ? 1 << B.canonical.z
                        : B.canonical.y) - 1
                    ),
                  (B) =>
                    new d.OverscaledTileID(
                      B.overscaledZ,
                      B.wrap,
                      B.canonical.z,
                      B.canonical.x,
                      B.canonical.y === (1 << B.canonical.z) - 1
                        ? 0
                        : B.canonical.y + 1
                    ),
                ],
                I = (B) => {
                  const W = a.getSource().minzoom,
                    ee = (he) => {
                      const de = a.getTileByID(he);
                      if (de && de.hasData()) return de.getBucket(v);
                    },
                    te = [0, -1, 1];
                  for (const he of te) {
                    if (B.overscaledZ + he < W) continue;
                    const de = ee(B.calculateScaledKey(B.overscaledZ + he));
                    if (de) return de;
                  }
                },
                M = [0, 0, 0],
                R = (B, W) => (
                  (M[0] = Math.min(B.min.y, W.min.y)),
                  (M[1] = Math.max(B.max.y, W.max.y)),
                  (M[2] =
                    d.EXTENT - W.min.x > B.max.x
                      ? W.min.x - d.EXTENT
                      : B.max.x),
                  M
                ),
                k = (B, W) => (
                  (M[0] = Math.min(B.min.x, W.min.x)),
                  (M[1] = Math.max(B.max.x, W.max.x)),
                  (M[2] =
                    d.EXTENT - W.min.y > B.max.y
                      ? W.min.y - d.EXTENT
                      : B.max.y),
                  M
                ),
                z = [
                  (B, W) => R(B, W),
                  (B, W) => R(W, B),
                  (B, W) => k(B, W),
                  (B, W) => k(W, B),
                ],
                H = new d.Point(0, 0);
              let q, X, Z;
              const Y = (B, W, ee, te, he) => {
                const de = [
                    [te ? ee : B, te ? B : ee, 0],
                    [te ? ee : W, te ? W : ee, 0],
                  ],
                  ue = he < 0 ? d.EXTENT + he : he,
                  _e = [te ? ue : (B + W) / 2, te ? (B + W) / 2 : ue, 0];
                return (
                  (0 === ee && he < 0) || (0 !== ee && he > 0)
                    ? b.getForTilePoints(Z, [_e], !0, X)
                    : de.push(_e),
                  b.getForTilePoints(u, de, !0, q),
                  Math.max(de[0][2], de[1][2], _e[2]) / b.exaggeration()
                );
              };
              for (let B = 0; B < 4; B++) {
                const W = (B < 2 ? 1 : 5) - B,
                  ee = g.borders[B];
                if (0 === ee.length) continue;
                const te = (Z = D[B](u)),
                  he = I(te);
                if (
                  !(
                    he &&
                    he instanceof d.FillExtrusionBucket &&
                    he.enableTerrain
                  ) ||
                  (g.borderDoneWithNeighborZ[B] === he.canonical.z &&
                    he.borderDoneWithNeighborZ[W] === g.canonical.z) ||
                  ((X = b.findDEMTileFor(te)), !X || !X.dem)
                )
                  continue;
                if (!q) {
                  const ge = b.findDEMTileFor(u);
                  if (!ge || !ge.dem) return;
                  q = ge;
                }
                const de = he.borders[W];
                let ue = 0;
                const _e = he.borderDoneWithNeighborZ[W] !== g.canonical.z;
                if (g.canonical.z === he.canonical.z) {
                  for (let ge = 0; ge < ee.length; ge++) {
                    const Te = g.featuresOnBorder[ee[ge]],
                      Ge = Te.borders[B];
                    let be;
                    for (
                      ;
                      ue < de.length &&
                      ((be = he.featuresOnBorder[de[ue]]),
                      !(be.borders[W][1] > Ge[0] + 3));

                    )
                      _e && he.encodeCentroid(void 0, be, !1), ue++;
                    if (be && ue < de.length) {
                      const Le = ue;
                      let Ie = 0;
                      for (
                        ;
                        !(be.borders[W][0] > Ge[1] - 3) &&
                        (Ie++, ++ue !== de.length);

                      )
                        be = he.featuresOnBorder[de[ue]];
                      if (
                        ((be = he.featuresOnBorder[de[Le]]),
                        Te.intersectsCount() > 1 ||
                          be.intersectsCount() > 1 ||
                          1 !== Ie)
                      ) {
                        1 !== Ie && (ue = Le),
                          g.encodeCentroid(void 0, Te, !1),
                          _e && he.encodeCentroid(void 0, be, !1);
                        continue;
                      }
                      const je = z[B](Te, be),
                        we = B % 2 ? d.EXTENT - 1 : 0;
                      (H.x = Y(
                        je[0],
                        Math.min(d.EXTENT - 1, je[1]),
                        we,
                        B < 2,
                        je[2]
                      )),
                        (H.y = 0),
                        g.encodeCentroid(H, Te, !1),
                        _e && he.encodeCentroid(H, be, !1);
                    } else g.encodeCentroid(void 0, Te, !1);
                  }
                  (g.borderDoneWithNeighborZ[B] = he.canonical.z),
                    (g.needsCentroidUpdate = !0),
                    _e &&
                      ((he.borderDoneWithNeighborZ[W] = g.canonical.z),
                      (he.needsCentroidUpdate = !0));
                } else {
                  for (const ge of ee)
                    g.encodeCentroid(void 0, g.featuresOnBorder[ge], !1);
                  if (_e) {
                    for (const ge of de)
                      he.encodeCentroid(void 0, he.featuresOnBorder[ge], !1);
                    (he.borderDoneWithNeighborZ[W] = g.canonical.z),
                      (he.needsCentroidUpdate = !0);
                  }
                  (g.borderDoneWithNeighborZ[B] = he.canonical.z),
                    (g.needsCentroidUpdate = !0);
                }
              }
              (g.needsCentroidUpdate ||
                (!g.centroidVertexBuffer &&
                  0 !== g.centroidVertexArray.length)) &&
                g.uploadCentroid(f);
            }
            const ar = new d.Color(1, 0, 0, 1),
              zh = new d.Color(0, 1, 0, 1),
              wu = new d.Color(0, 0, 1, 1),
              Eu = new d.Color(1, 0, 1, 1),
              wo = new d.Color(0, 1, 1, 1);
            function Rf(f, a, u) {
              const g = f.context,
                v = f.transform,
                b = g.gl,
                D = "globe" === v.projection.name,
                I = D ? ["PROJECTION_GLOBE_VIEW"] : null;
              let M = u.projMatrix;
              if (D && d.globeToMercatorTransition(v.zoom) > 0) {
                const Te = d.transitionTileAABBinECEF(u.canonical, v),
                  Ge = d.globeDenormalizeECEF(Te);
                (M = d.multiply(new Float32Array(16), v.globeMatrix, Ge)),
                  d.multiply(M, v.projMatrix, M);
              }
              const R = f.useProgram("debug", null, I),
                k = a.getTileByID(u.key);
              f.terrain && f.terrain.setupElevationDraw(k, R);
              const z = d.DepthMode.disabled,
                H = d.StencilMode.disabled,
                q = f.colorModeForRenderPass(),
                X = "$debug";
              g.activeTexture.set(b.TEXTURE0),
                f.emptyTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE),
                D
                  ? k._makeGlobeTileDebugBuffers(f.context, v)
                  : k._makeDebugTileBoundsBuffers(f.context, v.projection);
              const Z = k._tileDebugBuffer || f.debugBuffer,
                Y = k._tileDebugIndexBuffer || f.debugIndexBuffer,
                B = k._tileDebugSegments || f.debugSegments;
              R.draw(
                g,
                b.LINE_STRIP,
                z,
                H,
                q,
                d.CullFaceMode.disabled,
                Go(M, d.Color.red),
                X,
                Z,
                Y,
                B,
                null,
                null,
                null,
                [k._globeTileDebugBorderBuffer]
              );
              const W = k.latestRawTileData,
                ee = Math.floor(((W && W.byteLength) || 0) / 1024),
                te = a.getTile(u).tileSize,
                he = (512 / Math.min(te, 512)) * (u.overscaledZ / v.zoom) * 0.5;
              let de = u.canonical.toString();
              u.overscaledZ !== u.canonical.z && (de += ` => ${u.overscaledZ}`),
                (de += ` ${ee}kb`),
                (function (Te, Ge) {
                  Te.initDebugOverlayCanvas();
                  const be = Te.debugOverlayCanvas,
                    Le = Te.context.gl,
                    Ie = Te.debugOverlayCanvas.getContext("2d");
                  Ie.clearRect(0, 0, be.width, be.height),
                    (Ie.shadowColor = "white"),
                    (Ie.shadowBlur = 2),
                    (Ie.lineWidth = 1.5),
                    (Ie.strokeStyle = "white"),
                    (Ie.textBaseline = "top"),
                    (Ie.font = "bold 36px Open Sans, sans-serif"),
                    Ie.fillText(Ge, 5, 5),
                    Ie.strokeText(Ge, 5, 5),
                    Te.debugOverlayTexture.update(be),
                    Te.debugOverlayTexture.bind(Le.LINEAR, Le.CLAMP_TO_EDGE);
                })(f, de);
              const ue = k._tileDebugTextBuffer || f.debugBuffer,
                _e = k._tileDebugTextIndexBuffer || f.quadTriangleIndexBuffer,
                ge = k._tileDebugTextSegments || f.debugSegments;
              R.draw(
                g,
                b.TRIANGLES,
                z,
                H,
                d.ColorMode.alphaBlended,
                d.CullFaceMode.disabled,
                Go(M, d.Color.transparent, he),
                X,
                ue,
                _e,
                ge,
                null,
                null,
                null,
                [k._globeTileDebugTextBuffer]
              );
            }
            function Of(f, a, u, g) {
              Rl(f, 0, a + u / 2, f.transform.width, u, g);
            }
            function Tu(f, a, u, g) {
              Rl(f, a - u / 2, 0, u, f.transform.height, g);
            }
            function Rl(f, a, u, g, v, b) {
              const D = f.context,
                I = D.gl;
              I.enable(I.SCISSOR_TEST),
                I.scissor(
                  a * d.exported.devicePixelRatio,
                  u * d.exported.devicePixelRatio,
                  g * d.exported.devicePixelRatio,
                  v * d.exported.devicePixelRatio
                ),
                D.clear({ color: b }),
                I.disable(I.SCISSOR_TEST);
            }
            const Ff = d.createLayout([
                { name: "a_pos_3f", components: 3, type: "Float32" },
              ]),
              { members: Nf } = Ff;
            function Zs(f, a, u, g) {
              f.emplaceBack(a, u, g);
            }
            class Bh {
              constructor(a) {
                (this.vertexArray = new d.StructArrayLayout3f12()),
                  (this.indices = new d.StructArrayLayout3ui6()),
                  Zs(this.vertexArray, -1, -1, 1),
                  Zs(this.vertexArray, 1, -1, 1),
                  Zs(this.vertexArray, -1, 1, 1),
                  Zs(this.vertexArray, 1, 1, 1),
                  Zs(this.vertexArray, -1, -1, -1),
                  Zs(this.vertexArray, 1, -1, -1),
                  Zs(this.vertexArray, -1, 1, -1),
                  Zs(this.vertexArray, 1, 1, -1),
                  this.indices.emplaceBack(5, 1, 3),
                  this.indices.emplaceBack(3, 7, 5),
                  this.indices.emplaceBack(6, 2, 0),
                  this.indices.emplaceBack(0, 4, 6),
                  this.indices.emplaceBack(2, 6, 7),
                  this.indices.emplaceBack(7, 3, 2),
                  this.indices.emplaceBack(5, 4, 0),
                  this.indices.emplaceBack(0, 1, 5),
                  this.indices.emplaceBack(0, 2, 3),
                  this.indices.emplaceBack(3, 1, 0),
                  this.indices.emplaceBack(7, 6, 4),
                  this.indices.emplaceBack(4, 5, 7),
                  (this.vertexBuffer = a.createVertexBuffer(
                    this.vertexArray,
                    Nf
                  )),
                  (this.indexBuffer = a.createIndexBuffer(this.indices)),
                  (this.segment = d.SegmentVector.simpleSegment(0, 0, 36, 12));
              }
            }
            function Eo(f, a, u, g, v, b) {
              const D = f.gl,
                I = a.paint.get("sky-atmosphere-color"),
                M = a.paint.get("sky-atmosphere-halo-color"),
                R = a.paint.get("sky-atmosphere-sun-intensity"),
                k = {
                  u_matrix_3f: d.fromMat4(d.create$1(), g),
                  u_sun_direction: v,
                  u_sun_intensity: R,
                  u_color_tint_r: [(X = I).r, X.g, X.b, X.a],
                  u_color_tint_m: [(Z = M).r, Z.g, Z.b, Z.a],
                  u_luminance: 5e-5,
                };
              var X, Z;
              D.framebufferTexture2D(
                D.FRAMEBUFFER,
                D.COLOR_ATTACHMENT0,
                D.TEXTURE_CUBE_MAP_POSITIVE_X + b,
                a.skyboxTexture,
                0
              ),
                u.draw(
                  f,
                  D.TRIANGLES,
                  d.DepthMode.disabled,
                  d.StencilMode.disabled,
                  d.ColorMode.unblended,
                  d.CullFaceMode.frontCW,
                  k,
                  "skyboxCapture",
                  a.skyboxGeometry.vertexBuffer,
                  a.skyboxGeometry.indexBuffer,
                  a.skyboxGeometry.segment
                );
            }
            const Du = d.createLayout([
              { type: "Float32", name: "a_pos", components: 3 },
              { type: "Float32", name: "a_uv", components: 2 },
            ]);
            class zf {
              constructor(a) {
                const u = new d.StructArrayLayout5f20();
                u.emplaceBack(-1, 1, 1, 0, 0),
                  u.emplaceBack(1, 1, 1, 1, 0),
                  u.emplaceBack(1, -1, 1, 1, 1),
                  u.emplaceBack(-1, -1, 1, 0, 1);
                const g = new d.StructArrayLayout3ui6();
                g.emplaceBack(0, 1, 2),
                  g.emplaceBack(2, 3, 0),
                  (this.vertexBuffer = a.createVertexBuffer(u, Du.members)),
                  (this.indexBuffer = a.createIndexBuffer(g)),
                  (this.segments = d.SegmentVector.simpleSegment(0, 0, 4, 2));
              }
              destroy() {
                this.vertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy();
              }
            }
            const Ol = {
              symbol: function (f, a, u, g, v) {
                if ("translucent" !== f.renderPass) return;
                const b = d.StencilMode.disabled,
                  D = f.colorModeForRenderPass();
                u.layout.get("text-variable-anchor") &&
                  (function (I, M, R, k, z, H, q) {
                    const X = M.transform,
                      Z = "map" === z,
                      Y = "map" === H;
                    for (const B of I) {
                      const W = k.getTile(B),
                        ee = W.getBucket(R);
                      if (!ee || !ee.text || !ee.text.segments.get().length)
                        continue;
                      const te = d.evaluateSizeForZoom(ee.textSizeData, X.zoom),
                        he = pt(B, ee.getProjection(), X),
                        de = X.calculatePixelsToTileUnitsMatrix(W),
                        ue = Ae(
                          he,
                          W.tileID.canonical,
                          Y,
                          Z,
                          X,
                          ee.getProjection(),
                          de
                        ),
                        _e =
                          "none" !== R.layout.get("icon-text-fit") &&
                          ee.hasIconData();
                      if (te) {
                        const ge = Math.pow(2, X.zoom - W.tileID.overscaledZ);
                        Nh(ee, Z, Y, q, d.symbolSize, X, ue, B, ge, te, _e);
                      }
                    }
                  })(
                    g,
                    f,
                    u,
                    a,
                    u.layout.get("text-rotation-alignment"),
                    u.layout.get("text-pitch-alignment"),
                    v
                  ),
                  0 !== u.paint.get("icon-opacity").constantOr(1) &&
                    xc(
                      f,
                      a,
                      u,
                      g,
                      !1,
                      u.paint.get("icon-translate"),
                      u.paint.get("icon-translate-anchor"),
                      u.layout.get("icon-rotation-alignment"),
                      u.layout.get("icon-pitch-alignment"),
                      u.layout.get("icon-keep-upright"),
                      b,
                      D
                    ),
                  0 !== u.paint.get("text-opacity").constantOr(1) &&
                    xc(
                      f,
                      a,
                      u,
                      g,
                      !0,
                      u.paint.get("text-translate"),
                      u.paint.get("text-translate-anchor"),
                      u.layout.get("text-rotation-alignment"),
                      u.layout.get("text-pitch-alignment"),
                      u.layout.get("text-keep-upright"),
                      b,
                      D
                    ),
                  a.map.showCollisionBoxes &&
                    (vc(
                      f,
                      a,
                      u,
                      g,
                      u.paint.get("text-translate"),
                      u.paint.get("text-translate-anchor"),
                      !0
                    ),
                    vc(
                      f,
                      a,
                      u,
                      g,
                      u.paint.get("icon-translate"),
                      u.paint.get("icon-translate-anchor"),
                      !1
                    ));
              },
              circle: function (f, a, u, g) {
                if ("translucent" !== f.renderPass) return;
                const v = u.paint.get("circle-opacity"),
                  b = u.paint.get("circle-stroke-width"),
                  D = u.paint.get("circle-stroke-opacity"),
                  I = void 0 !== u.layout.get("circle-sort-key").constantOr(1);
                if (
                  0 === v.constantOr(1) &&
                  (0 === b.constantOr(1) || 0 === D.constantOr(1))
                )
                  return;
                const M = f.context,
                  R = M.gl,
                  k = f.transform,
                  z = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                  H = d.StencilMode.disabled,
                  q = f.colorModeForRenderPass(),
                  X = "globe" === k.projection.name,
                  Z = [
                    d.mercatorXfromLng(k.center.lng),
                    d.mercatorYfromLat(k.center.lat),
                  ],
                  Y = [];
                for (let W = 0; W < g.length; W++) {
                  const ee = g[W],
                    te = a.getTile(ee),
                    he = te.getBucket(u);
                  if (!he || he.projection.name !== k.projection.name) continue;
                  const de = he.programConfigurations.get(u.id),
                    ue = $n(u);
                  X && ue.push("PROJECTION_GLOBE_VIEW");
                  const _e = f.useProgram("circle", de, ue),
                    ge = he.layoutVertexBuffer,
                    Te = he.globeExtVertexBuffer,
                    Ge = he.indexBuffer,
                    be = k.projection.createInversionMatrix(k, ee.canonical),
                    Le = {
                      programConfiguration: de,
                      program: _e,
                      layoutVertexBuffer: ge,
                      globeExtVertexBuffer: Te,
                      indexBuffer: Ge,
                      uniformValues: qt(f, ee, te, be, Z, u),
                      tile: te,
                    };
                  if (I) {
                    const Ie = he.segments.get();
                    for (const je of Ie)
                      Y.push({
                        segments: new d.SegmentVector([je]),
                        sortKey: je.sortKey,
                        state: Le,
                      });
                  } else
                    Y.push({ segments: he.segments, sortKey: 0, state: Le });
                }
                I && Y.sort((W, ee) => W.sortKey - ee.sortKey);
                const B = { useDepthForOcclusion: !X };
                for (const W of Y) {
                  const {
                      programConfiguration: ee,
                      program: te,
                      layoutVertexBuffer: he,
                      globeExtVertexBuffer: de,
                      indexBuffer: ue,
                      uniformValues: _e,
                      tile: ge,
                    } = W.state,
                    Te = W.segments;
                  f.terrain && f.terrain.setupElevationDraw(ge, te, B),
                    f.prepareDrawProgram(M, te, ge.tileID.toUnwrapped()),
                    te.draw(
                      M,
                      R.TRIANGLES,
                      z,
                      H,
                      q,
                      d.CullFaceMode.disabled,
                      _e,
                      u.id,
                      he,
                      ue,
                      Te,
                      u.paint,
                      k.zoom,
                      ee,
                      [de]
                    );
                }
              },
              heatmap: function (f, a, u, g) {
                if (0 !== u.paint.get("heatmap-opacity"))
                  if ("offscreen" === f.renderPass) {
                    const v = f.context,
                      b = v.gl,
                      D = d.StencilMode.disabled,
                      I = new d.ColorMode([b.ONE, b.ONE], d.Color.transparent, [
                        !0,
                        !0,
                        !0,
                        !0,
                      ]);
                    (function (q, X, Z, Y) {
                      const B = q.gl,
                        W = X.width * Y,
                        ee = X.height * Y;
                      q.activeTexture.set(B.TEXTURE1),
                        q.viewport.set([0, 0, W, ee]);
                      let te = Z.heatmapFbo;
                      if (!te || (te && (te.width !== W || te.height !== ee))) {
                        te && te.destroy();
                        const he = B.createTexture();
                        B.bindTexture(B.TEXTURE_2D, he),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_WRAP_S,
                            B.CLAMP_TO_EDGE
                          ),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_WRAP_T,
                            B.CLAMP_TO_EDGE
                          ),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_MIN_FILTER,
                            B.LINEAR
                          ),
                          B.texParameteri(
                            B.TEXTURE_2D,
                            B.TEXTURE_MAG_FILTER,
                            B.LINEAR
                          ),
                          (te = Z.heatmapFbo = q.createFramebuffer(W, ee, !1)),
                          (function (de, ue, _e, ge, Te, Ge) {
                            const be = de.gl;
                            be.texImage2D(
                              be.TEXTURE_2D,
                              0,
                              de.isWebGL2 && de.extRenderToTextureHalfFloat
                                ? be.RGBA16F
                                : be.RGBA,
                              Te,
                              Ge,
                              0,
                              be.RGBA,
                              de.extRenderToTextureHalfFloat
                                ? de.isWebGL2
                                  ? be.HALF_FLOAT
                                  : de.extTextureHalfFloat.HALF_FLOAT_OES
                                : be.UNSIGNED_BYTE,
                              null
                            ),
                              ge.colorAttachment.set(_e);
                          })(q, 0, he, te, W, ee);
                      } else
                        B.bindTexture(B.TEXTURE_2D, te.colorAttachment.get()),
                          q.bindFramebuffer.set(te.framebuffer);
                    })(
                      v,
                      f,
                      u,
                      "globe" === f.transform.projection.name ? 0.5 : 0.25
                    ),
                      v.clear({ color: d.Color.transparent });
                    const M = f.transform,
                      R = "globe" === M.projection.name,
                      k = R ? ["PROJECTION_GLOBE_VIEW"] : null,
                      z = R ? d.CullFaceMode.frontCCW : d.CullFaceMode.disabled,
                      H = [
                        d.mercatorXfromLng(M.center.lng),
                        d.mercatorYfromLat(M.center.lat),
                      ];
                    for (let q = 0; q < g.length; q++) {
                      const X = g[q];
                      if (a.hasRenderableParent(X)) continue;
                      const Z = a.getTile(X),
                        Y = Z.getBucket(u);
                      if (!Y || Y.projection.name !== M.projection.name)
                        continue;
                      const B = Y.programConfigurations.get(u.id),
                        W = f.useProgram("heatmap", B, k),
                        { zoom: ee } = f.transform;
                      f.terrain && f.terrain.setupElevationDraw(Z, W),
                        f.prepareDrawProgram(v, W, X.toUnwrapped());
                      const te = M.projection.createInversionMatrix(
                        M,
                        X.canonical
                      );
                      W.draw(
                        v,
                        b.TRIANGLES,
                        d.DepthMode.disabled,
                        D,
                        I,
                        z,
                        Hs(
                          f,
                          X,
                          Z,
                          te,
                          H,
                          ee,
                          u.paint.get("heatmap-intensity")
                        ),
                        u.id,
                        Y.layoutVertexBuffer,
                        Y.indexBuffer,
                        Y.segments,
                        u.paint,
                        f.transform.zoom,
                        B,
                        R ? [Y.globeExtVertexBuffer] : null
                      );
                    }
                    v.viewport.set([0, 0, f.width, f.height]);
                  } else
                    "translucent" === f.renderPass &&
                      (f.context.setColorMode(f.colorModeForRenderPass()),
                      (function (v, b) {
                        const D = v.context,
                          I = D.gl,
                          M = b.heatmapFbo;
                        if (!M) return;
                        D.activeTexture.set(I.TEXTURE0),
                          I.bindTexture(I.TEXTURE_2D, M.colorAttachment.get()),
                          D.activeTexture.set(I.TEXTURE1);
                        let R = b.colorRampTexture;
                        R ||
                          (R = b.colorRampTexture =
                            new d.Texture(D, b.colorRamp, I.RGBA)),
                          R.bind(I.LINEAR, I.CLAMP_TO_EDGE),
                          v
                            .useProgram("heatmapTexture")
                            .draw(
                              D,
                              I.TRIANGLES,
                              d.DepthMode.disabled,
                              d.StencilMode.disabled,
                              v.colorModeForRenderPass(),
                              d.CullFaceMode.disabled,
                              {
                                u_image: 0,
                                u_color_ramp: 1,
                                u_opacity: b.paint.get("heatmap-opacity"),
                              },
                              b.id,
                              v.viewportBuffer,
                              v.quadTriangleIndexBuffer,
                              v.viewportSegments,
                              b.paint,
                              v.transform.zoom
                            );
                      })(f, u));
              },
              line: function (f, a, u, g) {
                if ("translucent" !== f.renderPass) return;
                const v = u.paint.get("line-opacity"),
                  b = u.paint.get("line-width");
                if (0 === v.constantOr(1) || 0 === b.constantOr(1)) return;
                const D = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                  I = f.colorModeForRenderPass(),
                  M =
                    f.terrain && f.terrain.renderingToTexture
                      ? 1
                      : d.exported.devicePixelRatio,
                  R = u.paint.get("line-dasharray"),
                  k = R.constantOr(1),
                  z = u.layout.get("line-cap"),
                  H = u.paint.get("line-pattern"),
                  q = H.constantOr(1),
                  X = u.paint.get("line-gradient"),
                  Z = q ? "linePattern" : "line",
                  Y = f.context,
                  B = Y.gl,
                  W = ((te) => {
                    const he = [];
                    Gs(te) && he.push("RENDER_LINE_DASH"),
                      te.paint.get("line-gradient") &&
                        he.push("RENDER_LINE_GRADIENT");
                    const de = te.paint.get("line-trim-offset");
                    (0 === de[0] && 0 === de[1]) ||
                      he.push("RENDER_LINE_TRIM_OFFSET");
                    const ue = te.paint.get("line-pattern").constantOr(1),
                      _e = 1 !== te.paint.get("line-opacity").constantOr(1);
                    return (
                      !ue && _e && he.push("RENDER_LINE_ALPHA_DISCARD"), he
                    );
                  })(u);
                let ee = W.includes("RENDER_LINE_ALPHA_DISCARD");
                f.terrain &&
                  f.terrain.clipOrMaskOverlapStencilType() &&
                  (ee = !1);
                for (const te of g) {
                  const he = a.getTile(te);
                  if (q && !he.patternsLoaded()) continue;
                  const de = he.getBucket(u);
                  if (!de) continue;
                  f.prepareDrawTile();
                  const ue = de.programConfigurations.get(u.id),
                    _e = f.useProgram(Z, ue, W),
                    ge = H.constantOr(null);
                  if (ge && he.imageAtlas) {
                    const ke = he.imageAtlas.patternPositions[ge.toString()];
                    ke && ue.setConstantPatternPositions(ke);
                  }
                  const Te = R.constantOr(null),
                    Ge = z.constantOr(null);
                  if (!q && Te && Ge && he.lineAtlas) {
                    const ke = he.lineAtlas.getDash(Te, Ge);
                    ke && ue.setConstantPatternPositions(ke);
                  }
                  let [be, Le] = u.paint.get("line-trim-offset");
                  ("round" === Ge || "square" === Ge) &&
                    be !== Le &&
                    (0 === be && (be -= 1), 1 === Le && (Le += 1));
                  const Ie = f.terrain ? te.projMatrix : null,
                    je = q
                      ? fs(f, he, u, Ie, M)
                      : ei(f, he, u, Ie, de.lineClipsArray.length, M, [be, Le]);
                  if (X) {
                    const ke = de.gradients[u.id];
                    let He = ke.texture;
                    if (u.gradientVersion !== ke.version) {
                      let Ne = 256;
                      if (u.stepInterpolant) {
                        const Xe = a.getSource().maxzoom,
                          dt =
                            te.canonical.z === Xe
                              ? Math.ceil(
                                  1 << (f.transform.maxZoom - te.canonical.z)
                                )
                              : 1;
                        Ne = d.clamp(
                          d.nextPowerOfTwo(
                            (de.maxLineLength / d.EXTENT) * 1024 * dt
                          ),
                          256,
                          Y.maxTextureSize
                        );
                      }
                      (ke.gradient = d.renderColorRamp({
                        expression: u.gradientExpression(),
                        evaluationKey: "lineProgress",
                        resolution: Ne,
                        image: ke.gradient || void 0,
                        clips: de.lineClipsArray,
                      })),
                        ke.texture
                          ? ke.texture.update(ke.gradient)
                          : (ke.texture = new d.Texture(
                              Y,
                              ke.gradient,
                              B.RGBA
                            )),
                        (ke.version = u.gradientVersion),
                        (He = ke.texture);
                    }
                    Y.activeTexture.set(B.TEXTURE1),
                      He.bind(
                        u.stepInterpolant ? B.NEAREST : B.LINEAR,
                        B.CLAMP_TO_EDGE
                      );
                  }
                  k &&
                    (Y.activeTexture.set(B.TEXTURE0),
                    he.lineAtlasTexture.bind(B.LINEAR, B.REPEAT),
                    ue.updatePaintBuffers()),
                    q &&
                      (Y.activeTexture.set(B.TEXTURE0),
                      he.imageAtlasTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE),
                      ue.updatePaintBuffers()),
                    f.prepareDrawProgram(Y, _e, te.toUnwrapped());
                  const we = (ke) => {
                    _e.draw(
                      Y,
                      B.TRIANGLES,
                      D,
                      ke,
                      I,
                      d.CullFaceMode.disabled,
                      je,
                      u.id,
                      de.layoutVertexBuffer,
                      de.indexBuffer,
                      de.segments,
                      u.paint,
                      f.transform.zoom,
                      ue,
                      [de.layoutVertexBuffer2]
                    );
                  };
                  if (ee) {
                    const ke = f.stencilModeForClipping(te).ref;
                    0 === ke && f.terrain && Y.clear({ stencil: 0 });
                    const He = { func: B.EQUAL, mask: 255 };
                    (je.u_alpha_discard_threshold = 0.8),
                      we(
                        new d.StencilMode(He, ke, 255, B.KEEP, B.KEEP, B.INVERT)
                      ),
                      (je.u_alpha_discard_threshold = 0),
                      we(
                        new d.StencilMode(He, ke, 255, B.KEEP, B.KEEP, B.KEEP)
                      );
                  } else we(f.stencilModeForClipping(te));
                }
                ee &&
                  (f.resetStencilClippingMasks(),
                  f.terrain && Y.clear({ stencil: 0 }));
              },
              fill: function (f, a, u, g) {
                const v = u.paint.get("fill-color"),
                  b = u.paint.get("fill-opacity");
                if (0 === b.constantOr(1)) return;
                const D = f.colorModeForRenderPass(),
                  I = u.paint.get("fill-pattern"),
                  M =
                    f.opaquePassEnabledForLayer() &&
                    !I.constantOr(1) &&
                    1 === v.constantOr(d.Color.transparent).a &&
                    1 === b.constantOr(0)
                      ? "opaque"
                      : "translucent";
                if (f.renderPass === M) {
                  const R = f.depthModeForSublayer(
                    1,
                    "opaque" === f.renderPass
                      ? d.DepthMode.ReadWrite
                      : d.DepthMode.ReadOnly
                  );
                  Ki(f, a, u, g, R, D, !1);
                }
                if (
                  "translucent" === f.renderPass &&
                  u.paint.get("fill-antialias")
                ) {
                  const R = f.depthModeForSublayer(
                    u.getPaintProperty("fill-outline-color") ? 2 : 0,
                    d.DepthMode.ReadOnly
                  );
                  Ki(f, a, u, g, R, D, !0);
                }
              },
              "fill-extrusion": function (f, a, u, g) {
                const v = u.paint.get("fill-extrusion-opacity");
                if (0 !== v && "translucent" === f.renderPass) {
                  const b = new d.DepthMode(
                    f.context.gl.LEQUAL,
                    d.DepthMode.ReadWrite,
                    f.depthRangeFor3D
                  );
                  if (
                    1 !== v ||
                    u.paint.get("fill-extrusion-pattern").constantOr(1)
                  )
                    bu(
                      f,
                      a,
                      u,
                      g,
                      b,
                      d.StencilMode.disabled,
                      d.ColorMode.disabled
                    ),
                      bu(
                        f,
                        a,
                        u,
                        g,
                        b,
                        f.stencilModeFor3D(),
                        f.colorModeForRenderPass()
                      ),
                      f.resetStencilClippingMasks();
                  else {
                    const D = f.colorModeForRenderPass();
                    bu(f, a, u, g, b, d.StencilMode.disabled, D);
                  }
                }
              },
              hillshade: function (f, a, u, g) {
                if (
                  "offscreen" !== f.renderPass &&
                  "translucent" !== f.renderPass
                )
                  return;
                const v = f.context,
                  b = f.depthModeForSublayer(0, d.DepthMode.ReadOnly),
                  D = f.colorModeForRenderPass(),
                  I = f.terrain && f.terrain.renderingToTexture,
                  [M, R] =
                    "translucent" !== f.renderPass || I
                      ? [{}, g]
                      : f.stencilConfigForOverlap(g);
                for (const k of R) {
                  const z = a.getTile(k);
                  if (z.needsHillshadePrepare && "offscreen" === f.renderPass)
                    Oa(f, z, u, b, d.StencilMode.disabled, D);
                  else if ("translucent" === f.renderPass) {
                    const H =
                      I && f.terrain
                        ? f.terrain.stencilModeForRTTOverlap(k)
                        : M[k.overscaledZ];
                    kf(f, k, z, u, b, H, D);
                  }
                }
                v.viewport.set([0, 0, f.width, f.height]),
                  f.resetStencilClippingMasks();
              },
              raster: function (f, a, u, g, v, b) {
                if (
                  "translucent" !== f.renderPass ||
                  0 === u.paint.get("raster-opacity") ||
                  !g.length
                )
                  return;
                const D = f.context,
                  I = D.gl,
                  M = a.getSource(),
                  R = f.useProgram("raster"),
                  k = f.colorModeForRenderPass(),
                  z = f.terrain && f.terrain.renderingToTexture,
                  [H, q] =
                    M instanceof Bt || z
                      ? [{}, g]
                      : f.stencilConfigForOverlap(g),
                  X = q[q.length - 1].overscaledZ,
                  Z = !f.options.moving;
                for (const Y of q) {
                  const B = z
                      ? d.DepthMode.disabled
                      : f.depthModeForSublayer(
                          Y.overscaledZ - X,
                          1 === u.paint.get("raster-opacity")
                            ? d.DepthMode.ReadWrite
                            : d.DepthMode.ReadOnly,
                          I.LESS
                        ),
                    W = Y.toUnwrapped(),
                    ee = a.getTile(Y);
                  if (z && (!ee || !ee.hasData())) continue;
                  const te = z
                      ? Y.projMatrix
                      : f.transform.calculateProjMatrix(W, Z),
                    he =
                      f.terrain && z
                        ? f.terrain.stencilModeForRTTOverlap(Y)
                        : H[Y.overscaledZ],
                    de = b ? 0 : u.paint.get("raster-fade-duration");
                  ee.registerFadeDuration(de);
                  const ue = a.findLoadedParent(Y, 0),
                    _e = Oh(ee, ue, a, f.transform, de);
                  let ge, Te;
                  f.terrain && f.terrain.prepareDrawTile();
                  const Ge =
                    "nearest" === u.paint.get("raster-resampling")
                      ? I.NEAREST
                      : I.LINEAR;
                  D.activeTexture.set(I.TEXTURE0),
                    ee.texture.bind(Ge, I.CLAMP_TO_EDGE),
                    D.activeTexture.set(I.TEXTURE1),
                    ue
                      ? (ue.texture.bind(Ge, I.CLAMP_TO_EDGE),
                        (ge = Math.pow(
                          2,
                          ue.tileID.overscaledZ - ee.tileID.overscaledZ
                        )),
                        (Te = [
                          (ee.tileID.canonical.x * ge) % 1,
                          (ee.tileID.canonical.y * ge) % 1,
                        ]))
                      : ee.texture.bind(Ge, I.CLAMP_TO_EDGE),
                    ee.texture.useMipmap &&
                      D.extTextureFilterAnisotropic &&
                      f.transform.pitch > 20 &&
                      I.texParameterf(
                        I.TEXTURE_2D,
                        D.extTextureFilterAnisotropic
                          .TEXTURE_MAX_ANISOTROPY_EXT,
                        D.extTextureFilterAnisotropicMax
                      );
                  const be = qs(
                    te,
                    Te || [0, 0],
                    ge || 1,
                    _e,
                    u,
                    M instanceof Bt ? M.perspectiveTransform : [0, 0]
                  );
                  if ((f.prepareDrawProgram(D, R, W), M instanceof Bt))
                    M.boundsBuffer &&
                      M.boundsSegments &&
                      R.draw(
                        D,
                        I.TRIANGLES,
                        B,
                        d.StencilMode.disabled,
                        k,
                        d.CullFaceMode.disabled,
                        be,
                        u.id,
                        M.boundsBuffer,
                        f.quadTriangleIndexBuffer,
                        M.boundsSegments
                      );
                  else {
                    const {
                      tileBoundsBuffer: Le,
                      tileBoundsIndexBuffer: Ie,
                      tileBoundsSegments: je,
                    } = f.getTileBoundsBuffers(ee);
                    R.draw(
                      D,
                      I.TRIANGLES,
                      B,
                      he,
                      k,
                      d.CullFaceMode.disabled,
                      be,
                      u.id,
                      Le,
                      Ie,
                      je
                    );
                  }
                }
                f.resetStencilClippingMasks();
              },
              background: function (f, a, u, g) {
                const v = u.paint.get("background-color"),
                  b = u.paint.get("background-opacity");
                if (0 === b) return;
                const D = f.context,
                  I = D.gl,
                  M = f.transform,
                  R = M.tileSize,
                  k = u.paint.get("background-pattern");
                if (f.isPatternMissing(k)) return;
                const z =
                  !k && 1 === v.a && 1 === b && f.opaquePassEnabledForLayer()
                    ? "opaque"
                    : "translucent";
                if (f.renderPass !== z) return;
                const H = d.StencilMode.disabled,
                  q = f.depthModeForSublayer(
                    0,
                    "opaque" === z
                      ? d.DepthMode.ReadWrite
                      : d.DepthMode.ReadOnly
                  ),
                  X = f.colorModeForRenderPass(),
                  Z = f.useProgram(k ? "backgroundPattern" : "background");
                let Y,
                  B = g;
                B ||
                  ((Y = f.getBackgroundTiles()),
                  (B = Object.values(Y).map((W) => W.tileID))),
                  k &&
                    (D.activeTexture.set(I.TEXTURE0),
                    f.imageManager.bind(f.context));
                for (const W of B) {
                  const ee = W.toUnwrapped(),
                    te = g ? W.projMatrix : f.transform.calculateProjMatrix(ee);
                  f.prepareDrawTile();
                  const he = a
                      ? a.getTile(W)
                      : Y
                      ? Y[W.key]
                      : new d.Tile(W, R, M.zoom, f),
                    de = k
                      ? Ll(te, b, f, k, { tileID: W, tileSize: R })
                      : qr(te, b, v);
                  f.prepareDrawProgram(D, Z, ee);
                  const {
                    tileBoundsBuffer: ue,
                    tileBoundsIndexBuffer: _e,
                    tileBoundsSegments: ge,
                  } = f.getTileBoundsBuffers(he);
                  Z.draw(
                    D,
                    I.TRIANGLES,
                    q,
                    H,
                    X,
                    d.CullFaceMode.disabled,
                    de,
                    u.id,
                    ue,
                    _e,
                    ge
                  );
                }
              },
              sky: function (f, a, u) {
                const g = f.transform,
                  v =
                    "mercator" === g.projection.name ||
                    "globe" === g.projection.name
                      ? 1
                      : d.smoothstep(7, 8, g.zoom),
                  b = u.paint.get("sky-opacity") * v;
                if (0 === b) return;
                const D = f.context,
                  I = u.paint.get("sky-type"),
                  M = new d.DepthMode(
                    D.gl.LEQUAL,
                    d.DepthMode.ReadOnly,
                    [0, 1]
                  ),
                  R = (f.frameCounter / 1e3) % 1;
                "atmosphere" === I
                  ? "offscreen" === f.renderPass
                    ? u.needsSkyboxCapture(f) &&
                      ((function (k, z, H, q) {
                        const X = k.context,
                          Z = X.gl;
                        let Y = z.skyboxFbo;
                        if (!Y) {
                          (Y = z.skyboxFbo = X.createFramebuffer(32, 32, !1)),
                            (z.skyboxGeometry = new Bh(X)),
                            (z.skyboxTexture = X.gl.createTexture()),
                            Z.bindTexture(Z.TEXTURE_CUBE_MAP, z.skyboxTexture),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_WRAP_S,
                              Z.CLAMP_TO_EDGE
                            ),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_WRAP_T,
                              Z.CLAMP_TO_EDGE
                            ),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_MIN_FILTER,
                              Z.LINEAR
                            ),
                            Z.texParameteri(
                              Z.TEXTURE_CUBE_MAP,
                              Z.TEXTURE_MAG_FILTER,
                              Z.LINEAR
                            );
                          for (let te = 0; te < 6; ++te)
                            Z.texImage2D(
                              Z.TEXTURE_CUBE_MAP_POSITIVE_X + te,
                              0,
                              Z.RGBA,
                              32,
                              32,
                              0,
                              Z.RGBA,
                              Z.UNSIGNED_BYTE,
                              null
                            );
                        }
                        X.bindFramebuffer.set(Y.framebuffer),
                          X.viewport.set([0, 0, 32, 32]);
                        const B = z.getCenter(k, !0),
                          W = k.useProgram("skyboxCapture"),
                          ee = new Float64Array(16);
                        d.identity(ee),
                          d.rotateY(ee, ee, 0.5 * -Math.PI),
                          Eo(X, z, W, ee, B, 0),
                          d.identity(ee),
                          d.rotateY(ee, ee, 0.5 * Math.PI),
                          Eo(X, z, W, ee, B, 1),
                          d.identity(ee),
                          d.rotateX(ee, ee, 0.5 * -Math.PI),
                          Eo(X, z, W, ee, B, 2),
                          d.identity(ee),
                          d.rotateX(ee, ee, 0.5 * Math.PI),
                          Eo(X, z, W, ee, B, 3),
                          d.identity(ee),
                          Eo(X, z, W, ee, B, 4),
                          d.identity(ee),
                          d.rotateY(ee, ee, Math.PI),
                          Eo(X, z, W, ee, B, 5),
                          X.viewport.set([0, 0, k.width, k.height]);
                      })(f, u),
                      u.markSkyboxValid(f))
                    : "sky" === f.renderPass &&
                      (function (k, z, H, q, X) {
                        const Z = k.context,
                          Y = Z.gl,
                          B = k.transform,
                          W = k.useProgram("skybox");
                        Z.activeTexture.set(Y.TEXTURE0),
                          Y.bindTexture(Y.TEXTURE_CUBE_MAP, z.skyboxTexture);
                        const ee = {
                          u_matrix: B.skyboxMatrix,
                          u_sun_direction: z.getCenter(k, !1),
                          u_cubemap: 0,
                          u_opacity: q,
                          u_temporal_offset: X,
                        };
                        k.prepareDrawProgram(Z, W),
                          W.draw(
                            Z,
                            Y.TRIANGLES,
                            H,
                            d.StencilMode.disabled,
                            k.colorModeForRenderPass(),
                            d.CullFaceMode.backCW,
                            ee,
                            "skybox",
                            z.skyboxGeometry.vertexBuffer,
                            z.skyboxGeometry.indexBuffer,
                            z.skyboxGeometry.segment
                          );
                      })(f, u, M, b, R)
                  : "gradient" === I &&
                    "sky" === f.renderPass &&
                    (function (k, z, H, q, X) {
                      const Z = k.context,
                        Y = Z.gl,
                        B = k.transform,
                        W = k.useProgram("skyboxGradient");
                      z.skyboxGeometry || (z.skyboxGeometry = new Bh(Z)),
                        Z.activeTexture.set(Y.TEXTURE0);
                      let ee = z.colorRampTexture;
                      ee ||
                        (ee = z.colorRampTexture =
                          new d.Texture(Z, z.colorRamp, Y.RGBA)),
                        ee.bind(Y.LINEAR, Y.CLAMP_TO_EDGE);
                      const te =
                        ((he = B.skyboxMatrix),
                        (de = z.getCenter(k, !1)),
                        (ue = z.paint.get("sky-gradient-radius")),
                        (_e = q),
                        (ge = X),
                        {
                          u_matrix: he,
                          u_color_ramp: 0,
                          u_center_direction: de,
                          u_radius: d.degToRad(ue),
                          u_opacity: _e,
                          u_temporal_offset: ge,
                        });
                      var he, de, ue, _e, ge;
                      k.prepareDrawProgram(Z, W),
                        W.draw(
                          Z,
                          Y.TRIANGLES,
                          H,
                          d.StencilMode.disabled,
                          k.colorModeForRenderPass(),
                          d.CullFaceMode.backCW,
                          te,
                          "skyboxGradient",
                          z.skyboxGeometry.vertexBuffer,
                          z.skyboxGeometry.indexBuffer,
                          z.skyboxGeometry.segment
                        );
                    })(f, u, M, b, R);
              },
              debug: function (f, a, u) {
                for (let g = 0; g < u.length; g++) Rf(f, a, u[g]);
              },
              custom: function (f, a, u, g) {
                const v = f.context,
                  b = u.implementation;
                if (
                  !f.transform.projection.unsupportedLayers ||
                  !f.transform.projection.unsupportedLayers.includes(
                    "custom"
                  ) ||
                  (f.terrain &&
                    (f.terrain.renderingToTexture ||
                      "offscreen" === f.renderPass) &&
                    u.isLayerDraped())
                ) {
                  if ("offscreen" === f.renderPass) {
                    const D = b.prerender;
                    if (D) {
                      if (
                        (f.setCustomLayerDefaults(),
                        v.setColorMode(f.colorModeForRenderPass()),
                        "globe" === f.transform.projection.name)
                      ) {
                        const I = f.transform.pointMerc;
                        D.call(
                          b,
                          v.gl,
                          f.transform.customLayerMatrix(),
                          f.transform.getProjection(),
                          f.transform.globeToMercatorMatrix(),
                          d.globeToMercatorTransition(f.transform.zoom),
                          [I.x, I.y],
                          f.transform.pixelsPerMeterRatio
                        );
                      } else D.call(b, v.gl, f.transform.customLayerMatrix());
                      v.setDirty(), f.setBaseState();
                    }
                  } else if ("translucent" === f.renderPass) {
                    if (f.terrain && f.terrain.renderingToTexture) {
                      const I = b.renderToTile;
                      if (I) {
                        const M = g[0].canonical,
                          R = new d.MercatorCoordinate(
                            M.x + g[0].wrap * (1 << M.z),
                            M.y,
                            M.z
                          );
                        v.setDepthMode(d.DepthMode.disabled),
                          v.setStencilMode(d.StencilMode.disabled),
                          v.setColorMode(f.colorModeForRenderPass()),
                          f.setCustomLayerDefaults(),
                          I.call(b, v.gl, R),
                          v.setDirty(),
                          f.setBaseState();
                      }
                      return;
                    }
                    f.setCustomLayerDefaults(),
                      v.setColorMode(f.colorModeForRenderPass()),
                      v.setStencilMode(d.StencilMode.disabled);
                    const D =
                      "3d" === b.renderingMode
                        ? new d.DepthMode(
                            f.context.gl.LEQUAL,
                            d.DepthMode.ReadWrite,
                            f.depthRangeFor3D
                          )
                        : f.depthModeForSublayer(0, d.DepthMode.ReadOnly);
                    if (
                      (v.setDepthMode(D),
                      "globe" === f.transform.projection.name)
                    ) {
                      const I = f.transform.pointMerc;
                      b.render(
                        v.gl,
                        f.transform.customLayerMatrix(),
                        f.transform.getProjection(),
                        f.transform.globeToMercatorMatrix(),
                        d.globeToMercatorTransition(f.transform.zoom),
                        [I.x, I.y],
                        f.transform.pixelsPerMeterRatio
                      );
                    } else b.render(v.gl, f.transform.customLayerMatrix());
                    v.setDirty(), f.setBaseState(), v.bindFramebuffer.set(null);
                  }
                } else
                  d.warnOnce(
                    "Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers."
                  );
              },
            };
            class bc {
              constructor(a, u, g = !1) {
                (this.context = new Ye(a, g)),
                  (this.transform = u),
                  (this._tileTextures = {}),
                  (this.frameCopies = []),
                  (this.loadTimeStamps = []),
                  this.setup(),
                  (this.numSublayers =
                    d.SourceCache.maxUnderzooming +
                    d.SourceCache.maxOverzooming +
                    1),
                  (this.depthEpsilon = 1 / Math.pow(2, 16)),
                  (this.deferredRenderGpuTimeQueries = []),
                  (this.gpuTimers = {}),
                  (this.frameCounter = 0),
                  (this._backgroundTiles = {});
              }
              updateTerrain(a, u) {
                const g =
                  !!a &&
                  !!a.terrain &&
                  this.transform.projection.supportsTerrain;
                if (!(g || (this._terrain && this._terrain.enabled))) return;
                this._terrain || (this._terrain = new Fh(this, a));
                const v = this._terrain;
                (this.transform.elevation = g ? v : null),
                  v.update(a, this.transform, u);
              }
              _updateFog(a) {
                const u = a.fog;
                if (
                  !u ||
                  "globe" === this.transform.projection.name ||
                  u.getOpacity(this.transform.pitch) < 1 ||
                  u.properties.get("horizon-blend") < 0.03
                )
                  return void (this.transform.fogCullDistSq = null);
                const [g, v] = u.getFovAdjustedRange(this.transform._fov);
                if (g > v) return void (this.transform.fogCullDistSq = null);
                const b = g + 0.78 * (v - g);
                this.transform.fogCullDistSq = b * b;
              }
              get terrain() {
                return this.transform._terrainEnabled() &&
                  this._terrain &&
                  this._terrain.enabled
                  ? this._terrain
                  : null;
              }
              resize(a, u) {
                if (
                  ((this.width = a * d.exported.devicePixelRatio),
                  (this.height = u * d.exported.devicePixelRatio),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.style)
                )
                  for (const g of this.style.order)
                    this.style._layers[g].resize();
              }
              setup() {
                const a = this.context,
                  u = new d.StructArrayLayout2i4();
                u.emplaceBack(0, 0),
                  u.emplaceBack(d.EXTENT, 0),
                  u.emplaceBack(0, d.EXTENT),
                  u.emplaceBack(d.EXTENT, d.EXTENT),
                  (this.tileExtentBuffer = a.createVertexBuffer(
                    u,
                    d.posAttributes.members
                  )),
                  (this.tileExtentSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const g = new d.StructArrayLayout2i4();
                g.emplaceBack(0, 0),
                  g.emplaceBack(d.EXTENT, 0),
                  g.emplaceBack(0, d.EXTENT),
                  g.emplaceBack(d.EXTENT, d.EXTENT),
                  (this.debugBuffer = a.createVertexBuffer(
                    g,
                    d.posAttributes.members
                  )),
                  (this.debugSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    5
                  ));
                const v = new d.StructArrayLayout2i4();
                v.emplaceBack(-1, -1),
                  v.emplaceBack(1, -1),
                  v.emplaceBack(-1, 1),
                  v.emplaceBack(1, 1),
                  (this.viewportBuffer = a.createVertexBuffer(
                    v,
                    d.posAttributes.members
                  )),
                  (this.viewportSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const b = new d.StructArrayLayout4i8();
                b.emplaceBack(0, 0, 0, 0),
                  b.emplaceBack(d.EXTENT, 0, d.EXTENT, 0),
                  b.emplaceBack(0, d.EXTENT, 0, d.EXTENT),
                  b.emplaceBack(d.EXTENT, d.EXTENT, d.EXTENT, d.EXTENT),
                  (this.mercatorBoundsBuffer = a.createVertexBuffer(
                    b,
                    d.boundsAttributes.members
                  )),
                  (this.mercatorBoundsSegments = d.SegmentVector.simpleSegment(
                    0,
                    0,
                    4,
                    2
                  ));
                const D = new d.StructArrayLayout3ui6();
                D.emplaceBack(0, 1, 2),
                  D.emplaceBack(2, 1, 3),
                  (this.quadTriangleIndexBuffer = a.createIndexBuffer(D));
                const I = new d.StructArrayLayout1ui2();
                for (const R of [0, 1, 3, 2, 0]) I.emplaceBack(R);
                (this.debugIndexBuffer = a.createIndexBuffer(I)),
                  (this.emptyTexture = new d.Texture(
                    a,
                    new d.RGBAImage(
                      { width: 1, height: 1 },
                      Uint8Array.of(0, 0, 0, 0)
                    ),
                    a.gl.RGBA
                  )),
                  (this.identityMat = d.create());
                const M = this.context.gl;
                (this.stencilClearMode = new d.StencilMode(
                  { func: M.ALWAYS, mask: 0 },
                  0,
                  255,
                  M.ZERO,
                  M.ZERO,
                  M.ZERO
                )),
                  this.loadTimeStamps.push(d.window.performance.now()),
                  (this.atmosphereBuffer = new zf(this.context));
              }
              getMercatorTileBoundsBuffers() {
                return {
                  tileBoundsBuffer: this.mercatorBoundsBuffer,
                  tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                  tileBoundsSegments: this.mercatorBoundsSegments,
                };
              }
              getTileBoundsBuffers(a) {
                return (
                  a._makeTileBoundsBuffers(
                    this.context,
                    this.transform.projection
                  ),
                  a._tileBoundsBuffer
                    ? {
                        tileBoundsBuffer: a._tileBoundsBuffer,
                        tileBoundsIndexBuffer: a._tileBoundsIndexBuffer,
                        tileBoundsSegments: a._tileBoundsSegments,
                      }
                    : this.getMercatorTileBoundsBuffers()
                );
              }
              clearStencil() {
                const a = this.context,
                  u = a.gl;
                (this.nextStencilID = 1),
                  (this.currentStencilSource = void 0),
                  (this._tileClippingMaskIDs = {}),
                  this.useProgram("clippingMask").draw(
                    a,
                    u.TRIANGLES,
                    d.DepthMode.disabled,
                    this.stencilClearMode,
                    d.ColorMode.disabled,
                    d.CullFaceMode.disabled,
                    xo(this.identityMat),
                    "$clipping",
                    this.viewportBuffer,
                    this.quadTriangleIndexBuffer,
                    this.viewportSegments
                  );
              }
              resetStencilClippingMasks() {
                this.terrain ||
                  ((this.currentStencilSource = void 0),
                  (this._tileClippingMaskIDs = {}));
              }
              _renderTileClippingMasks(a, u, g) {
                if (
                  !u ||
                  this.currentStencilSource === u.id ||
                  !a.isTileClipped() ||
                  !g ||
                  0 === g.length
                )
                  return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                  let I = !1;
                  for (const M of g)
                    if (void 0 === this._tileClippingMaskIDs[M.key]) {
                      I = !0;
                      break;
                    }
                  if (!I) return;
                }
                this.currentStencilSource = u.id;
                const v = this.context,
                  b = v.gl;
                this.nextStencilID + g.length > 256 && this.clearStencil(),
                  v.setColorMode(d.ColorMode.disabled),
                  v.setDepthMode(d.DepthMode.disabled);
                const D = this.useProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const I of g) {
                  const M = u.getTile(I),
                    R = (this._tileClippingMaskIDs[I.key] = this
                      .nextStencilID++),
                    {
                      tileBoundsBuffer: k,
                      tileBoundsIndexBuffer: z,
                      tileBoundsSegments: H,
                    } = this.getTileBoundsBuffers(M);
                  D.draw(
                    v,
                    b.TRIANGLES,
                    d.DepthMode.disabled,
                    new d.StencilMode(
                      { func: b.ALWAYS, mask: 0 },
                      R,
                      255,
                      b.KEEP,
                      b.KEEP,
                      b.REPLACE
                    ),
                    d.ColorMode.disabled,
                    d.CullFaceMode.disabled,
                    xo(I.projMatrix),
                    "$clipping",
                    k,
                    z,
                    H
                  );
                }
              }
              stencilModeFor3D() {
                (this.currentStencilSource = void 0),
                  this.nextStencilID + 1 > 256 && this.clearStencil();
                const a = this.nextStencilID++,
                  u = this.context.gl;
                return new d.StencilMode(
                  { func: u.NOTEQUAL, mask: 255 },
                  a,
                  255,
                  u.KEEP,
                  u.KEEP,
                  u.REPLACE
                );
              }
              stencilModeForClipping(a) {
                if (this.terrain)
                  return this.terrain.stencilModeForRTTOverlap(a);
                const u = this.context.gl;
                return new d.StencilMode(
                  { func: u.EQUAL, mask: 255 },
                  this._tileClippingMaskIDs[a.key],
                  0,
                  u.KEEP,
                  u.KEEP,
                  u.REPLACE
                );
              }
              stencilConfigForOverlap(a) {
                const u = this.context.gl,
                  g = a.sort((D, I) => I.overscaledZ - D.overscaledZ),
                  v = g[g.length - 1].overscaledZ,
                  b = g[0].overscaledZ - v + 1;
                if (b > 1) {
                  (this.currentStencilSource = void 0),
                    this.nextStencilID + b > 256 && this.clearStencil();
                  const D = {};
                  for (let I = 0; I < b; I++)
                    D[I + v] = new d.StencilMode(
                      { func: u.GEQUAL, mask: 255 },
                      I + this.nextStencilID,
                      255,
                      u.KEEP,
                      u.KEEP,
                      u.REPLACE
                    );
                  return (this.nextStencilID += b), [D, g];
                }
                return [{ [v]: d.StencilMode.disabled }, g];
              }
              colorModeForRenderPass() {
                const a = this.context.gl;
                return this._showOverdrawInspector
                  ? new d.ColorMode(
                      [a.CONSTANT_COLOR, a.ONE],
                      new d.Color(0.125, 0.125, 0.125, 0),
                      [!0, !0, !0, !0]
                    )
                  : "opaque" === this.renderPass
                  ? d.ColorMode.unblended
                  : d.ColorMode.alphaBlended;
              }
              depthModeForSublayer(a, u, g) {
                if (!this.opaquePassEnabledForLayer())
                  return d.DepthMode.disabled;
                const v =
                  1 -
                  ((1 + this.currentLayer) * this.numSublayers + a) *
                    this.depthEpsilon;
                return new d.DepthMode(g || this.context.gl.LEQUAL, u, [v, v]);
              }
              opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
              }
              render(a, u) {
                (this.style = a),
                  (this.options = u),
                  (this.imageManager = a.imageManager),
                  (this.glyphManager = a.glyphManager),
                  (this.symbolFadeChange = a.placement.symbolFadeChange(
                    d.exported.now()
                  )),
                  this.imageManager.beginFrame();
                const g = this.style.order,
                  v = this.style._sourceCaches;
                for (const R in v) {
                  const k = v[R];
                  k.used && k.prepare(this.context);
                }
                const b = {},
                  D = {},
                  I = {};
                for (const R in v) {
                  const k = v[R];
                  (b[R] = k.getVisibleCoordinates()),
                    (D[R] = b[R].slice().reverse()),
                    (I[R] = k.getVisibleCoordinates(!0).reverse());
                }
                this.opaquePassCutoff = 1 / 0;
                for (let R = 0; R < g.length; R++)
                  if (this.style._layers[g[R]].is3D()) {
                    this.opaquePassCutoff = R;
                    break;
                  }
                if (
                  (this.terrain &&
                    (this.terrain.updateTileBinding(I),
                    (this.opaquePassCutoff = 0)),
                  "globe" !== this.transform.projection.name ||
                    this.globeSharedBuffers ||
                    (this.globeSharedBuffers = new d.GlobeSharedBuffers(
                      this.context
                    )),
                  !d.isMapAuthenticated(this.context.gl))
                )
                  return;
                this.renderPass = "offscreen";
                for (const R of g) {
                  const k = this.style._layers[R],
                    z = a._getLayerSourceCache(k);
                  if (!k.hasOffscreenPass() || k.isHidden(this.transform.zoom))
                    continue;
                  const H = z ? D[z.id] : void 0;
                  ("custom" === k.type || k.isSky() || (H && H.length)) &&
                    this.renderLayer(this, z, k, H);
                }
                this.depthRangeFor3D = [
                  0,
                  1 -
                    (a.order.length + 2) *
                      this.numSublayers *
                      this.depthEpsilon,
                ];
                const M = this.terrain;
                if (
                  (M &&
                    (this.style.hasSymbolLayers() ||
                      this.style.hasCircleLayers()) &&
                    M.drawDepth(),
                  this.context.bindFramebuffer.set(null),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.context.clear({
                    color: u.showOverdrawInspector
                      ? d.Color.black
                      : d.Color.transparent,
                    depth: 1,
                  }),
                  this.clearStencil(),
                  (this._showOverdrawInspector = u.showOverdrawInspector),
                  (this.renderPass = "opaque"),
                  !this.terrain)
                )
                  for (
                    this.currentLayer = g.length - 1;
                    this.currentLayer >= 0;
                    this.currentLayer--
                  ) {
                    const R = this.style._layers[g[this.currentLayer]],
                      k = a._getLayerSourceCache(R);
                    if (R.isSky()) continue;
                    const z = k ? D[k.id] : void 0;
                    this._renderTileClippingMasks(R, k, z),
                      this.renderLayer(this, k, R, z);
                  }
                if (
                  (this.style.fog &&
                    this.transform.projection.supportsFog &&
                    (function (R, k) {
                      const z = R.context,
                        H = z.gl,
                        q = R.transform,
                        X = new d.DepthMode(
                          H.LEQUAL,
                          d.DepthMode.ReadOnly,
                          [0, 1]
                        ),
                        Z = R.useProgram(
                          "globeAtmosphere",
                          null,
                          "globe" === q.projection.name
                            ? ["PROJECTION_GLOBE_VIEW", "FOG"]
                            : ["FOG"]
                        ),
                        Y = d.globeToMercatorTransition(q.zoom),
                        B = k.properties.get("color").toArray01(),
                        W = k.properties.get("high-color").toArray01(),
                        ee = k.properties
                          .get("space-color")
                          .toArray01PremultipliedAlpha(),
                        te = d.identity$1([]);
                      d.rotateY$1(te, te, -d.degToRad(q._center.lng)),
                        d.rotateX$1(te, te, d.degToRad(q._center.lat)),
                        d.rotateZ$1(te, te, q.angle),
                        d.rotateX$1(te, te, -q._pitch);
                      const he = d.fromQuat(new Float32Array(16), te),
                        de = d.mapValue(
                          k.properties.get("star-intensity"),
                          0,
                          1,
                          0,
                          0.25
                        ),
                        _e = d.mapValue(
                          k.properties.get("horizon-blend"),
                          0,
                          1,
                          5e-4,
                          0.25
                        ),
                        ge =
                          d.globeUseCustomAntiAliasing(R, z, q) && 5e-4 === _e
                            ? q.worldSize / (2 * Math.PI * 1.025) - 1
                            : q.globeRadius,
                        Te = (R.frameCounter / 1e3) % 1,
                        Ge = d.length(q.globeCenterInViewSpace),
                        be = Math.sqrt(Math.pow(Ge, 2) - Math.pow(ge, 2)),
                        Le = Math.acos(be / Ge),
                        Ie = {
                          u_frustum_tl: q.frustumCorners.TL,
                          u_frustum_tr: q.frustumCorners.TR,
                          u_frustum_br: q.frustumCorners.BR,
                          u_frustum_bl: q.frustumCorners.BL,
                          u_horizon: q.frustumCorners.horizon,
                          u_transition: Y,
                          u_fadeout_range: _e,
                          u_color: B,
                          u_high_color: W,
                          u_space_color: ee,
                          u_star_intensity: de,
                          u_star_size: 5 * d.exported.devicePixelRatio,
                          u_star_density: 0,
                          u_temporal_offset: Te,
                          u_horizon_angle: Le,
                          u_rotation_matrix: he,
                        };
                      R.prepareDrawProgram(z, Z);
                      const je = R.atmosphereBuffer;
                      je &&
                        Z.draw(
                          z,
                          H.TRIANGLES,
                          X,
                          d.StencilMode.disabled,
                          d.ColorMode.alphaBlended,
                          d.CullFaceMode.backCW,
                          Ie,
                          "skybox",
                          je.vertexBuffer,
                          je.indexBuffer,
                          je.segments
                        );
                    })(this, this.style.fog),
                  (this.renderPass = "sky"),
                  (d.globeToMercatorTransition(this.transform.zoom) > 0 ||
                    "globe" !== this.transform.projection.name) &&
                    this.transform.isHorizonVisible())
                )
                  for (
                    this.currentLayer = 0;
                    this.currentLayer < g.length;
                    this.currentLayer++
                  ) {
                    const R = this.style._layers[g[this.currentLayer]],
                      k = a._getLayerSourceCache(R);
                    R.isSky() &&
                      this.renderLayer(this, k, R, k ? D[k.id] : void 0);
                  }
                for (
                  this.renderPass = "translucent", this.currentLayer = 0;
                  this.currentLayer < g.length;

                ) {
                  const R = this.style._layers[g[this.currentLayer]],
                    k = a._getLayerSourceCache(R);
                  if (R.isSky()) {
                    ++this.currentLayer;
                    continue;
                  }
                  if (this.terrain && this.style.isLayerDraped(R)) {
                    if (R.isHidden(this.transform.zoom)) {
                      ++this.currentLayer;
                      continue;
                    }
                    this.currentLayer = this.terrain.renderBatch(
                      this.currentLayer
                    );
                    continue;
                  }
                  const z = k ? ("symbol" === R.type ? I : D)[k.id] : void 0;
                  this._renderTileClippingMasks(R, k, k ? b[k.id] : void 0),
                    this.renderLayer(this, k, R, z),
                    ++this.currentLayer;
                }
                if (
                  (this.terrain && this.terrain.postRender(),
                  this.options.showTileBoundaries ||
                    this.options.showQueryGeometry ||
                    this.options.showTileAABBs)
                ) {
                  let R = null;
                  d.values(this.style._layers).forEach((k) => {
                    const z = a._getLayerSourceCache(k);
                    z &&
                      !k.isHidden(this.transform.zoom) &&
                      (!R || R.getSource().maxzoom < z.getSource().maxzoom) &&
                      (R = z);
                  }),
                    R &&
                      this.options.showTileBoundaries &&
                      Ol.debug(this, R, R.getVisibleCoordinates());
                }
                this.options.showPadding &&
                  (function (R) {
                    const k = R.transform.padding;
                    Of(R, R.transform.height - (k.top || 0), 3, ar),
                      Of(R, k.bottom || 0, 3, zh),
                      Tu(R, k.left || 0, 3, wu),
                      Tu(R, R.transform.width - (k.right || 0), 3, Eu);
                    const z = R.transform.centerPoint;
                    var H, q, X, Z;
                    Rl(
                      (H = R),
                      (q = z.x) - 1,
                      (X = R.transform.height - z.y) - 10,
                      2,
                      20,
                      (Z = wo)
                    ),
                      Rl(H, q - 10, X - 1, 20, 2, Z);
                  })(this),
                  this.context.setDefault(),
                  (this.frameCounter =
                    (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER),
                  this.tileLoaded &&
                    this.options.speedIndexTiming &&
                    (this.loadTimeStamps.push(d.window.performance.now()),
                    this.saveCanvasCopy());
              }
              renderLayer(a, u, g, v) {
                g.isHidden(this.transform.zoom) ||
                  (("background" === g.type ||
                    "sky" === g.type ||
                    "custom" === g.type ||
                    (v && v.length)) &&
                    ((this.id = g.id),
                    this.gpuTimingStart(g),
                    (!a.transform.projection.unsupportedLayers ||
                      !a.transform.projection.unsupportedLayers.includes(
                        g.type
                      ) ||
                      (a.terrain && "custom" === g.type)) &&
                      Ol[g.type](
                        a,
                        u,
                        g,
                        v,
                        this.style.placement.variableOffsets,
                        this.options.isInitialLoad
                      ),
                    this.gpuTimingEnd()));
              }
              gpuTimingStart(a) {
                if (!this.options.gpuTiming) return;
                const u = this.context.extTimerQuery;
                let g = this.gpuTimers[a.id];
                g ||
                  (g = this.gpuTimers[a.id] =
                    { calls: 0, cpuTime: 0, query: u.createQueryEXT() }),
                  g.calls++,
                  u.beginQueryEXT(u.TIME_ELAPSED_EXT, g.query);
              }
              gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                  const a = this.context.extTimerQuery,
                    u = a.createQueryEXT();
                  this.deferredRenderGpuTimeQueries.push(u),
                    a.beginQueryEXT(a.TIME_ELAPSED_EXT, u);
                }
              }
              gpuTimingDeferredRenderEnd() {
                if (!this.options.gpuTimingDeferredRender) return;
                const a = this.context.extTimerQuery;
                a.endQueryEXT(a.TIME_ELAPSED_EXT);
              }
              gpuTimingEnd() {
                if (!this.options.gpuTiming) return;
                const a = this.context.extTimerQuery;
                a.endQueryEXT(a.TIME_ELAPSED_EXT);
              }
              collectGpuTimers() {
                const a = this.gpuTimers;
                return (this.gpuTimers = {}), a;
              }
              collectDeferredRenderGpuQueries() {
                const a = this.deferredRenderGpuTimeQueries;
                return (this.deferredRenderGpuTimeQueries = []), a;
              }
              queryGpuTimers(a) {
                const u = {};
                for (const g in a) {
                  const v = a[g],
                    b = this.context.extTimerQuery,
                    D = b.getQueryObjectEXT(v.query, b.QUERY_RESULT_EXT) / 1e6;
                  b.deleteQueryEXT(v.query), (u[g] = D);
                }
                return u;
              }
              queryGpuTimeDeferredRender(a) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const u = this.context.extTimerQuery;
                let g = 0;
                for (const v of a)
                  (g += u.getQueryObjectEXT(v, u.QUERY_RESULT_EXT) / 1e6),
                    u.deleteQueryEXT(v);
                return g;
              }
              translatePosMatrix(a, u, g, v, b) {
                if (!g[0] && !g[1]) return a;
                const D = b
                  ? "map" === v
                    ? this.transform.angle
                    : 0
                  : "viewport" === v
                  ? -this.transform.angle
                  : 0;
                if (D) {
                  const R = Math.sin(D),
                    k = Math.cos(D);
                  g = [g[0] * k - g[1] * R, g[0] * R + g[1] * k];
                }
                const I = [
                    b ? g[0] : Ci(u, g[0], this.transform.zoom),
                    b ? g[1] : Ci(u, g[1], this.transform.zoom),
                    0,
                  ],
                  M = new Float32Array(16);
                return d.translate(M, a, I), M;
              }
              saveTileTexture(a) {
                const u = this._tileTextures[a.size[0]];
                u ? u.push(a) : (this._tileTextures[a.size[0]] = [a]);
              }
              getTileTexture(a) {
                const u = this._tileTextures[a];
                return u && u.length > 0 ? u.pop() : null;
              }
              isPatternMissing(a) {
                return (
                  null === a ||
                  (void 0 !== a && !this.imageManager.getPattern(a.toString()))
                );
              }
              terrainRenderModeElevated() {
                return (
                  this.style &&
                  !!this.style.getTerrain() &&
                  !!this.terrain &&
                  !this.terrain.renderingToTexture
                );
              }
              currentGlobalDefines() {
                const a = this.terrain && this.terrain.renderingToTexture,
                  u = this.terrain && 0 === this.terrain.exaggeration(),
                  g = this.style && this.style.fog,
                  v = [];
                return (
                  this.terrainRenderModeElevated() && v.push("TERRAIN"),
                  "globe" === this.transform.projection.name && v.push("GLOBE"),
                  u && v.push("ZERO_EXAGGERATION"),
                  g &&
                    !a &&
                    0 !== g.getOpacity(this.transform.pitch) &&
                    v.push("FOG"),
                  a && v.push("RENDER_TO_TEXTURE"),
                  this._showOverdrawInspector && v.push("OVERDRAW_INSPECTOR"),
                  v
                );
              }
              useProgram(a, u, g) {
                this.cache = this.cache || {};
                const v = g || [],
                  b = this.currentGlobalDefines().concat(v),
                  D = rn.cacheKey(Hr[a], a, b, u);
                return (
                  this.cache[D] ||
                    (this.cache[D] = new rn(
                      this.context,
                      a,
                      Hr[a],
                      u,
                      xu[a],
                      b
                    )),
                  this.cache[D]
                );
              }
              setCustomLayerDefaults() {
                this.context.unbindVAO(),
                  this.context.cullFace.setDefault(),
                  this.context.frontFace.setDefault(),
                  this.context.cullFaceSide.setDefault(),
                  this.context.activeTexture.setDefault(),
                  this.context.pixelStoreUnpack.setDefault(),
                  this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                  this.context.pixelStoreUnpackFlipY.setDefault();
              }
              setBaseState() {
                const a = this.context.gl;
                this.context.cullFace.set(!1),
                  this.context.viewport.set([0, 0, this.width, this.height]),
                  this.context.blendEquation.set(a.FUNC_ADD);
              }
              initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas &&
                  ((this.debugOverlayCanvas =
                    d.window.document.createElement("canvas")),
                  (this.debugOverlayCanvas.width = 512),
                  (this.debugOverlayCanvas.height = 512),
                  (this.debugOverlayTexture = new d.Texture(
                    this.context,
                    this.debugOverlayCanvas,
                    this.context.gl.RGBA
                  )));
              }
              destroy() {
                this._terrain && this._terrain.destroy(),
                  this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                  this.emptyTexture.destroy(),
                  this.debugOverlayTexture &&
                    this.debugOverlayTexture.destroy(),
                  this.atmosphereBuffer && this.atmosphereBuffer.destroy();
              }
              prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
              }
              prepareDrawProgram(a, u, g) {
                if (this.terrain && this.terrain.renderingToTexture) return;
                const v = this.style.fog;
                if (v) {
                  const b = v.getOpacity(this.transform.pitch),
                    D = ((I, M, R, k, z, H, q, X, Z, Y, B) => {
                      const W = I.transform,
                        ee = M.properties.get("color").toArray01();
                      ee[3] = k;
                      const te = (I.frameCounter / 1e3) % 1;
                      return {
                        u_fog_matrix: R
                          ? W.calculateFogTileMatrix(R)
                          : I.identityMat,
                        u_fog_range: M.getFovAdjustedRange(W._fov),
                        u_fog_color: ee,
                        u_fog_horizon_blend: M.properties.get("horizon-blend"),
                        u_fog_temporal_offset: te,
                        u_frustum_tl: z,
                        u_frustum_tr: H,
                        u_frustum_br: q,
                        u_frustum_bl: X,
                        u_globe_pos: Z,
                        u_globe_radius: Y,
                        u_viewport: B,
                        u_globe_transition: d.globeToMercatorTransition(W.zoom),
                        u_is_globe: +("globe" === W.projection.name),
                      };
                    })(
                      this,
                      v,
                      g,
                      b,
                      this.transform.frustumCorners.TL,
                      this.transform.frustumCorners.TR,
                      this.transform.frustumCorners.BR,
                      this.transform.frustumCorners.BL,
                      this.transform.globeCenterInViewSpace,
                      this.transform.globeRadius,
                      [
                        this.transform.width * d.exported.devicePixelRatio,
                        this.transform.height * d.exported.devicePixelRatio,
                      ]
                    );
                  u.setFogUniformValues(a, D);
                }
              }
              setTileLoadedFlag(a) {
                this.tileLoaded = a;
              }
              saveCanvasCopy() {
                const a = this.canvasCopy();
                a && (this.frameCopies.push(a), (this.tileLoaded = !1));
              }
              canvasCopy() {
                const a = this.context.gl,
                  u = a.createTexture();
                return (
                  a.bindTexture(a.TEXTURE_2D, u),
                  a.copyTexImage2D(
                    a.TEXTURE_2D,
                    0,
                    a.RGBA,
                    0,
                    0,
                    a.drawingBufferWidth,
                    a.drawingBufferHeight,
                    0
                  ),
                  u
                );
              }
              getCanvasCopiesAndTimestamps() {
                return {
                  canvasCopies: this.frameCopies,
                  timeStamps: this.loadTimeStamps,
                };
              }
              averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const a = this.style && this.style.fog;
                return !!a && 0 !== a.getOpacity(this.transform.pitch);
              }
              getBackgroundTiles() {
                const a = this._backgroundTiles,
                  u = (this._backgroundTiles = {}),
                  g = this.transform.coveringTiles({ tileSize: 512 });
                for (const v of g)
                  u[v.key] =
                    a[v.key] ||
                    new d.Tile(v, 512, this.transform.tileZoom, this);
                return u;
              }
              clearBackgroundTiles() {
                this._backgroundTiles = {};
              }
            }
            class Vh {
              constructor(a = 0, u = 0, g = 0, v = 0) {
                if (
                  isNaN(a) ||
                  a < 0 ||
                  isNaN(u) ||
                  u < 0 ||
                  isNaN(g) ||
                  g < 0 ||
                  isNaN(v) ||
                  v < 0
                )
                  throw new Error(
                    "Invalid value for edge-insets, top, bottom, left and right must all be numbers"
                  );
                (this.top = a),
                  (this.bottom = u),
                  (this.left = g),
                  (this.right = v);
              }
              interpolate(a, u, g) {
                return (
                  null != u.top &&
                    null != a.top &&
                    (this.top = d.number(a.top, u.top, g)),
                  null != u.bottom &&
                    null != a.bottom &&
                    (this.bottom = d.number(a.bottom, u.bottom, g)),
                  null != u.left &&
                    null != a.left &&
                    (this.left = d.number(a.left, u.left, g)),
                  null != u.right &&
                    null != a.right &&
                    (this.right = d.number(a.right, u.right, g)),
                  this
                );
              }
              getCenter(a, u) {
                const g = d.clamp((this.left + a - this.right) / 2, 0, a),
                  v = d.clamp((this.top + u - this.bottom) / 2, 0, u);
                return new d.Point(g, v);
              }
              equals(a) {
                return (
                  this.top === a.top &&
                  this.bottom === a.bottom &&
                  this.left === a.left &&
                  this.right === a.right
                );
              }
              clone() {
                return new Vh(this.top, this.bottom, this.left, this.right);
              }
              toJSON() {
                return {
                  top: this.top,
                  bottom: this.bottom,
                  left: this.left,
                  right: this.right,
                };
              }
            }
            function jh(f, a) {
              const u = d.getColumn(f, 3);
              d.fromQuat(f, a), d.setColumn(f, 3, u);
            }
            function hn(f, a) {
              const u = d.identity$1([]);
              return d.rotateZ$1(u, u, -a), d.rotateX$1(u, u, -f), u;
            }
            function Su(f, a) {
              const u = [f[0], f[1], 0],
                g = [a[0], a[1], 0];
              if (d.length(u) >= 1e-15) {
                const D = d.normalize([], u);
                d.scale$2(g, D, d.dot(g, D)), (a[0] = g[0]), (a[1] = g[1]);
              }
              const v = d.cross([], a, f);
              if (d.len(v) < 1e-15) return null;
              const b = Math.atan2(-v[1], v[0]);
              return hn(
                Math.atan2(Math.sqrt(f[0] * f[0] + f[1] * f[1]), -f[2]),
                b
              );
            }
            class Bf {
              constructor(a, u) {
                (this.position = a), (this.orientation = u);
              }
              get position() {
                return this._position;
              }
              set position(a) {
                if (a) {
                  const u =
                    a instanceof d.MercatorCoordinate
                      ? a
                      : new d.MercatorCoordinate(a[0], a[1], a[2]);
                  this._renderWorldCopies && (u.x = d.wrap(u.x, 0, 1)),
                    (this._position = u);
                } else this._position = null;
              }
              lookAtPoint(a, u) {
                if (((this.orientation = null), !this.position)) return;
                const g = this.position,
                  v = this._elevation
                    ? this._elevation.getAtPointOrZero(
                        d.MercatorCoordinate.fromLngLat(a)
                      )
                    : 0,
                  b = d.MercatorCoordinate.fromLngLat(a, v),
                  D = [b.x - g.x, b.y - g.y, b.z - g.z];
                u || (u = [0, 0, 1]),
                  (u[2] = Math.abs(u[2])),
                  (this.orientation = Su(D, u));
              }
              setPitchBearing(a, u) {
                this.orientation = hn(d.degToRad(a), d.degToRad(-u));
              }
            }
            class wc {
              constructor(a, u) {
                (this._transform = d.identity([])),
                  (this.orientation = u),
                  (this.position = a);
              }
              get mercatorPosition() {
                const a = this.position;
                return new d.MercatorCoordinate(a[0], a[1], a[2]);
              }
              get position() {
                const a = d.getColumn(this._transform, 3);
                return [a[0], a[1], a[2]];
              }
              set position(a) {
                var u;
                a &&
                  d.setColumn(this._transform, 3, [(u = a)[0], u[1], u[2], 1]);
              }
              get orientation() {
                return this._orientation;
              }
              set orientation(a) {
                (this._orientation = a || d.identity$1([])),
                  a && jh(this._transform, this._orientation);
              }
              getPitchBearing() {
                const a = this.forward(),
                  u = this.right();
                return {
                  bearing: Math.atan2(-u[1], u[0]),
                  pitch: Math.atan2(
                    Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                    -a[2]
                  ),
                };
              }
              setPitchBearing(a, u) {
                (this._orientation = hn(a, u)),
                  jh(this._transform, this._orientation);
              }
              forward() {
                const a = d.getColumn(this._transform, 2);
                return [-a[0], -a[1], -a[2]];
              }
              up() {
                const a = d.getColumn(this._transform, 1);
                return [-a[0], -a[1], -a[2]];
              }
              right() {
                const a = d.getColumn(this._transform, 0);
                return [a[0], a[1], a[2]];
              }
              getCameraToWorld(a, u) {
                const g = new Float64Array(16);
                return d.invert(g, this.getWorldToCamera(a, u)), g;
              }
              getWorldToCameraPosition(a, u, g) {
                const v = this.position;
                d.scale$2(v, v, -a);
                const b = new Float64Array(16);
                return (
                  d.fromScaling(b, [g, g, g]),
                  d.translate(b, b, v),
                  (b[10] *= u),
                  b
                );
              }
              getWorldToCamera(a, u) {
                const g = new Float64Array(16),
                  v = new Float64Array(4),
                  b = this.position;
                return (
                  d.conjugate(v, this._orientation),
                  d.scale$2(b, b, -a),
                  d.fromQuat(g, v),
                  d.translate(g, g, b),
                  (g[1] *= -1),
                  (g[5] *= -1),
                  (g[9] *= -1),
                  (g[13] *= -1),
                  (g[8] *= u),
                  (g[9] *= u),
                  (g[10] *= u),
                  (g[11] *= u),
                  g
                );
              }
              getCameraToClipPerspective(a, u, g, v) {
                const b = new Float64Array(16);
                return d.perspective(b, a, u, g, v), b;
              }
              getDistanceToElevation(a, u = !1) {
                const g =
                    0 === a
                      ? 0
                      : d.mercatorZfromAltitude(
                          a,
                          u
                            ? d.latFromMercatorY(this.position[1])
                            : this.position[1]
                        ),
                  v = this.forward();
                return (g - this.position[2]) / v[2];
              }
              clone() {
                return new wc([...this.position], [...this.orientation]);
              }
            }
            function Xs(f, a) {
              const u = Uh(f.projection, f.zoom, f.width, f.height),
                g = (function (b, D, I, M, R) {
                  const k = new d.LngLat(I.lng - 180 * Ks, I.lat),
                    z = new d.LngLat(I.lng + 180 * Ks, I.lat),
                    H = b.project(k.lng, k.lat),
                    q = b.project(z.lng, z.lat),
                    X = -Math.atan2(q.y - H.y, q.x - H.x),
                    Z = d.MercatorCoordinate.fromLngLat(I);
                  Z.y = d.clamp(Z.y, -1 + Ks, 1 - Ks);
                  const Y = Z.toLngLat(),
                    B = b.project(Y.lng, Y.lat),
                    W = d.MercatorCoordinate.fromLngLat(Y);
                  W.x += Ks;
                  const ee = W.toLngLat(),
                    te = b.project(ee.lng, ee.lat),
                    he = Iu(te.x - B.x, te.y - B.y, X),
                    de = d.MercatorCoordinate.fromLngLat(Y);
                  de.y += Ks;
                  const ue = de.toLngLat(),
                    _e = b.project(ue.lng, ue.lat),
                    ge = Iu(_e.x - B.x, _e.y - B.y, X),
                    Te = Math.abs(he.x) / Math.abs(ge.y),
                    Ge = d.identity([]);
                  d.rotateZ(Ge, Ge, -X * (1 - (R ? 0 : M)));
                  const be = d.identity([]);
                  return (
                    d.scale(be, be, [1, 1 - (1 - Te) * M, 1]),
                    (be[4] = (-ge.x / ge.y) * M),
                    d.rotateZ(be, be, X),
                    d.multiply(be, Ge, be),
                    be
                  );
                })(f.projection, 0, f.center, u, a),
                v = Vf(f);
              return d.scale(g, g, [v, v, 1]), g;
            }
            function Vf(f) {
              const a = f.projection,
                u = Uh(f.projection, f.zoom, f.width, f.height),
                g = Ys(a, f.center),
                v = Ys(a, d.LngLat.convert(a.center));
              return Math.pow(2, g * u + (1 - u) * v);
            }
            function Uh(f, a, u, g, v = 1 / 0) {
              const b = f.range;
              if (!b) return 0;
              const D = Math.min(v, Math.max(u, g)),
                I = Math.log(D / 1024) / Math.LN2;
              return d.smoothstep(b[0] + I, b[1] + I, a);
            }
            const Ks = 1 / 4e4;
            function Ys(f, a) {
              const u = d.clamp(
                  a.lat,
                  -d.MAX_MERCATOR_LATITUDE,
                  d.MAX_MERCATOR_LATITUDE
                ),
                g = new d.LngLat(a.lng - 180 * Ks, u),
                v = new d.LngLat(a.lng + 180 * Ks, u),
                b = f.project(g.lng, u),
                D = f.project(v.lng, u),
                I = d.MercatorCoordinate.fromLngLat(g),
                M = d.MercatorCoordinate.fromLngLat(v),
                R = D.x - b.x,
                k = D.y - b.y,
                z = M.x - I.x,
                H = M.y - I.y,
                q = Math.sqrt((z * z + H * H) / (R * R + k * k));
              return Math.log(q) / Math.LN2;
            }
            function Iu(f, a, u) {
              const g = Math.cos(u),
                v = Math.sin(u);
              return { x: f * g - a * v, y: f * v + a * g };
            }
            class Zo {
              constructor(a, u, g, v, b, D, I) {
                (this.tileSize = 512),
                  (this._renderWorldCopies = void 0 === b || b),
                  (this._minZoom = a || 0),
                  (this._maxZoom = u || 22),
                  (this._minPitch = g ?? 0),
                  (this._maxPitch = v ?? 60),
                  this.setProjection(D),
                  this.setMaxBounds(I),
                  (this.width = 0),
                  (this.height = 0),
                  (this._center = new d.LngLat(0, 0)),
                  (this.zoom = 0),
                  (this.angle = 0),
                  (this._fov = 0.6435011087932844),
                  (this._pitch = 0),
                  (this._nearZ = 0),
                  (this._farZ = 0),
                  (this._unmodified = !0),
                  (this._edgeInsets = new Vh()),
                  (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {}),
                  (this._fogTileMatrixCache = {}),
                  (this._distanceTileDataCache = {}),
                  (this._camera = new wc()),
                  (this._centerAltitude = 0),
                  (this._averageElevation = 0),
                  (this.cameraElevationReference = "ground"),
                  (this._pixelsPerMercatorPixel = 1),
                  (this.globeRadius = 0),
                  (this.globeCenterInViewSpace = [0, 0, 0]),
                  (this._horizonShift = 0.1);
              }
              clone() {
                const a = new Zo(
                  this._minZoom,
                  this._maxZoom,
                  this._minPitch,
                  this.maxPitch,
                  this._renderWorldCopies,
                  this.getProjection()
                );
                return (
                  (a._elevation = this._elevation),
                  (a._centerAltitude = this._centerAltitude),
                  (a._centerAltitudeValidForExaggeration =
                    this._centerAltitudeValidForExaggeration),
                  (a.tileSize = this.tileSize),
                  (a.mercatorFromTransition = this.mercatorFromTransition),
                  (a.width = this.width),
                  (a.height = this.height),
                  (a.cameraElevationReference = this.cameraElevationReference),
                  (a._center = this._center),
                  a._setZoom(this.zoom),
                  (a._seaLevelZoom = this._seaLevelZoom),
                  (a.angle = this.angle),
                  (a._fov = this._fov),
                  (a._pitch = this._pitch),
                  (a._nearZ = this._nearZ),
                  (a._farZ = this._farZ),
                  (a._averageElevation = this._averageElevation),
                  (a._unmodified = this._unmodified),
                  (a._edgeInsets = this._edgeInsets.clone()),
                  (a._camera = this._camera.clone()),
                  a._calcMatrices(),
                  (a.freezeTileCoverage = this.freezeTileCoverage),
                  (a.frustumCorners = this.frustumCorners),
                  a
                );
              }
              get elevation() {
                return this._elevation;
              }
              set elevation(a) {
                this._elevation !== a &&
                  ((this._elevation = a),
                  this._updateCameraOnTerrain(),
                  this._calcMatrices());
              }
              updateElevation(a, u = !1) {
                const g =
                  this._elevation &&
                  this._elevation.exaggeration() !==
                    this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || g) &&
                  this._updateCameraOnTerrain(),
                  (a || g) && this._constrainCamera(u),
                  this._calcMatrices();
              }
              getProjection() {
                return d.pick(this.projection, ["name", "center", "parallels"]);
              }
              setProjection(a) {
                this.projectionOptions = a || { name: "mercator" };
                const u = this.projection ? this.getProjection() : void 0;
                this.projection = d.getProjection(this.projectionOptions);
                const g = !Be(u, this.getProjection());
                return (
                  g && this._calcMatrices(),
                  (this.mercatorFromTransition = !1),
                  g
                );
              }
              setMercatorFromTransition() {
                const a = this.projection.name;
                (this.mercatorFromTransition = !0),
                  (this.projectionOptions = { name: "mercator" }),
                  (this.projection = d.getProjection({ name: "mercator" }));
                const u = a !== this.projection.name;
                return u && this._calcMatrices(), u;
              }
              get minZoom() {
                return this._minZoom;
              }
              set minZoom(a) {
                this._minZoom !== a &&
                  ((this._minZoom = a), (this.zoom = Math.max(this.zoom, a)));
              }
              get maxZoom() {
                return this._maxZoom;
              }
              set maxZoom(a) {
                this._maxZoom !== a &&
                  ((this._maxZoom = a), (this.zoom = Math.min(this.zoom, a)));
              }
              get minPitch() {
                return this._minPitch;
              }
              set minPitch(a) {
                this._minPitch !== a &&
                  ((this._minPitch = a),
                  (this.pitch = Math.max(this.pitch, a)));
              }
              get maxPitch() {
                return this._maxPitch;
              }
              set maxPitch(a) {
                this._maxPitch !== a &&
                  ((this._maxPitch = a),
                  (this.pitch = Math.min(this.pitch, a)));
              }
              get renderWorldCopies() {
                return (
                  this._renderWorldCopies &&
                  !0 === this.projection.supportsWorldCopies
                );
              }
              set renderWorldCopies(a) {
                void 0 === a ? (a = !0) : null === a && (a = !1),
                  (this._renderWorldCopies = a);
              }
              get worldSize() {
                return this.tileSize * this.scale;
              }
              get cameraWorldSizeForFog() {
                const a = Math.max(
                  this._camera.getDistanceToElevation(this._averageElevation),
                  Number.EPSILON
                );
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(a));
              }
              get cameraWorldSize() {
                const a = Math.max(
                  this._camera.getDistanceToElevation(
                    this._averageElevation,
                    !0
                  ),
                  Number.EPSILON
                );
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(a));
              }
              get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(
                  this.center.lat,
                  this.worldSize
                );
              }
              get cameraPixelsPerMeter() {
                return d.mercatorZfromAltitude(
                  this.center.lat,
                  this.cameraWorldSizeForFog
                );
              }
              get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
              }
              get size() {
                return new d.Point(this.width, this.height);
              }
              get bearing() {
                return d.wrap(this.rotation, -180, 180);
              }
              set bearing(a) {
                this.rotation = a;
              }
              get rotation() {
                return (-this.angle / Math.PI) * 180;
              }
              set rotation(a) {
                const u = (-a * Math.PI) / 180;
                var g, v, b, D, I, M, R, k, z, H;
                this.angle !== u &&
                  ((this._unmodified = !1),
                  (this.angle = u),
                  this._calcMatrices(),
                  (this.rotationMatrix =
                    ((g = new d.ARRAY_TYPE(4)),
                    d.ARRAY_TYPE != Float32Array && ((g[1] = 0), (g[2] = 0)),
                    (g[0] = 1),
                    (g[3] = 1),
                    g)),
                  (v = this.rotationMatrix),
                  (D = this.angle),
                  (I = (b = this.rotationMatrix)[0]),
                  (M = b[1]),
                  (R = b[2]),
                  (k = b[3]),
                  (z = Math.sin(D)),
                  (H = Math.cos(D)),
                  (v[0] = I * H + R * z),
                  (v[1] = M * H + k * z),
                  (v[2] = I * -z + R * H),
                  (v[3] = M * -z + k * H));
              }
              get pitch() {
                return (this._pitch / Math.PI) * 180;
              }
              set pitch(a) {
                const u =
                  (d.clamp(a, this.minPitch, this.maxPitch) / 180) * Math.PI;
                this._pitch !== u &&
                  ((this._unmodified = !1),
                  (this._pitch = u),
                  this._calcMatrices());
              }
              get aspect() {
                return this.width / this.height;
              }
              get fov() {
                return (this._fov / Math.PI) * 180;
              }
              get fovX() {
                return this._fov;
              }
              get fovY() {
                const a = 1 / Math.tan(0.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / a);
              }
              set fov(a) {
                (a = Math.max(0.01, Math.min(60, a))),
                  this._fov !== a &&
                    ((this._unmodified = !1),
                    (this._fov = d.degToRad(a)),
                    this._calcMatrices());
              }
              get averageElevation() {
                return this._averageElevation;
              }
              set averageElevation(a) {
                (this._averageElevation = a),
                  this._calcFogMatrices(),
                  (this._distanceTileDataCache = {});
              }
              get zoom() {
                return this._zoom;
              }
              set zoom(a) {
                const u = Math.min(Math.max(a, this.minZoom), this.maxZoom);
                this._zoom !== u &&
                  ((this._unmodified = !1),
                  this._setZoom(u),
                  this._updateSeaLevelZoom(),
                  this._constrain(),
                  this._calcMatrices());
              }
              _setZoom(a) {
                (this._zoom = a),
                  (this.scale = this.zoomScale(a)),
                  (this.tileZoom = Math.floor(a)),
                  (this.zoomFraction = a - this.tileZoom);
              }
              _updateCameraOnTerrain() {
                if (
                  !this._elevation ||
                  !this._elevation.isDataAvailableAtPoint(
                    this.locationCoordinate(this.center)
                  )
                )
                  return (
                    (this._centerAltitude = 0),
                    (this._seaLevelZoom = null),
                    void (this._centerAltitudeValidForExaggeration = void 0)
                  );
                const a = this._elevation;
                (this._centerAltitude = a.getAtPointOrZero(
                  this.locationCoordinate(this.center)
                )),
                  (this._centerAltitudeValidForExaggeration = a.exaggeration()),
                  this._updateSeaLevelZoom();
              }
              _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration &&
                  (this._seaLevelZoom = this._zoomFromMercatorZ(
                    (this.pixelsPerMeter * this._centerAltitude +
                      this.cameraToCenterDistance) /
                      this.worldSize
                  ));
              }
              sampleAverageElevation() {
                if (!this._elevation) return 0;
                const a = this._elevation,
                  u = [
                    [0.5, 0.2],
                    [0.3, 0.5],
                    [0.5, 0.5],
                    [0.7, 0.5],
                    [0.5, 0.8],
                  ],
                  g = this.horizonLineFromTop();
                let v = 0,
                  b = 0;
                for (let D = 0; D < u.length; D++) {
                  const I = new d.Point(
                      u[D][0] * this.width,
                      g + u[D][1] * (this.height - g)
                    ),
                    M = a.pointCoordinate(I);
                  if (!M) continue;
                  const R =
                    1 /
                    Math.hypot(
                      M[0] - this._camera.position[0],
                      M[1] - this._camera.position[1]
                    );
                  (v += M[3] * R), (b += R);
                }
                return 0 === b ? NaN : v / b;
              }
              get center() {
                return this._center;
              }
              set center(a) {
                (a.lat === this._center.lat && a.lng === this._center.lng) ||
                  ((this._unmodified = !1),
                  (this._center = a),
                  this._terrainEnabled() &&
                    ("ground" === this.cameraElevationReference
                      ? this._updateCameraOnTerrain()
                      : this._updateZoomFromElevation()),
                  this._constrain(),
                  this._calcMatrices());
              }
              _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const a = this._seaLevelZoom,
                  u = this._elevation.getAtPointOrZero(
                    this.locationCoordinate(this.center)
                  ),
                  g = (this.pixelsPerMeter / this.worldSize) * u,
                  v = this._mercatorZfromZoom(a),
                  b = this._mercatorZfromZoom(this._maxZoom),
                  D = Math.max(v - g, b);
                this._setZoom(this._zoomFromMercatorZ(D));
              }
              get padding() {
                return this._edgeInsets.toJSON();
              }
              set padding(a) {
                this._edgeInsets.equals(a) ||
                  ((this._unmodified = !1),
                  this._edgeInsets.interpolate(this._edgeInsets, a, 1),
                  this._calcMatrices());
              }
              computeZoomRelativeTo(a) {
                const u = this.rayIntersectionCoordinate(
                  this.pointRayIntersection(this.centerPoint, a.toAltitude())
                );
                let g;
                g =
                  a.z < this._camera.position[2]
                    ? [u.x, u.y, u.z]
                    : [a.x, a.y, a.z];
                const v = d.length(d.sub([], this._camera.position, g));
                return d.clamp(
                  this._zoomFromMercatorZ(v),
                  this._minZoom,
                  this._maxZoom
                );
              }
              setFreeCameraOptions(a) {
                if (!this.height || (!a.position && !a.orientation)) return;
                this._updateCameraState();
                let u = !1;
                if (
                  (a.orientation &&
                    !d.exactEquals(a.orientation, this._camera.orientation) &&
                    (u = this._setCameraOrientation(a.orientation)),
                  a.position)
                ) {
                  const g = [a.position.x, a.position.y, a.position.z];
                  d.exactEquals$1(g, this._camera.position) ||
                    (this._setCameraPosition(g), (u = !0));
                }
                u && (this._updateStateFromCamera(), this.recenterOnTerrain());
              }
              getFreeCameraOptions() {
                this._updateCameraState();
                const a = this._camera.position,
                  u = new Bf();
                return (
                  (u.position = new d.MercatorCoordinate(a[0], a[1], a[2])),
                  (u.orientation = this._camera.orientation),
                  (u._elevation = this.elevation),
                  (u._renderWorldCopies = this.renderWorldCopies),
                  u
                );
              }
              _setCameraOrientation(a) {
                if (!d.length$1(a)) return !1;
                d.normalize$1(a, a);
                const u = d.transformQuat([], [0, 0, -1], a),
                  g = d.transformQuat([], [0, -1, 0], a);
                if (g[2] < 0) return !1;
                const v = Su(u, g);
                return !!v && ((this._camera.orientation = v), !0);
              }
              _setCameraPosition(a) {
                const u = this.zoomScale(this.minZoom) * this.tileSize,
                  g = this.zoomScale(this.maxZoom) * this.tileSize,
                  v = this.cameraToCenterDistance;
                (a[2] = d.clamp(a[2], v / g, v / u)),
                  (this._camera.position = a);
              }
              get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
              }
              get fovAboveCenter() {
                return this._fov * (0.5 + this.centerOffset.y / this.height);
              }
              isPaddingEqual(a) {
                return this._edgeInsets.equals(a);
              }
              interpolatePadding(a, u, g) {
                (this._unmodified = !1),
                  this._edgeInsets.interpolate(a, u, g),
                  this._constrain(),
                  this._calcMatrices();
              }
              coveringZoomLevel(a) {
                const u = (a.roundZoom ? Math.round : Math.floor)(
                  this.zoom + this.scaleZoom(this.tileSize / a.tileSize)
                );
                return Math.max(0, u);
              }
              getVisibleUnwrappedCoordinates(a) {
                const u = [new d.UnwrappedTileID(0, a)];
                if (this.renderWorldCopies) {
                  const g = this.pointCoordinate(new d.Point(0, 0)),
                    v = this.pointCoordinate(new d.Point(this.width, 0)),
                    b = this.pointCoordinate(
                      new d.Point(this.width, this.height)
                    ),
                    D = this.pointCoordinate(new d.Point(0, this.height)),
                    I = Math.floor(Math.min(g.x, v.x, b.x, D.x)),
                    M = Math.floor(Math.max(g.x, v.x, b.x, D.x)),
                    R = 1;
                  for (let k = I - R; k <= M + R; k++)
                    0 !== k && u.push(new d.UnwrappedTileID(k, a));
                }
                return u;
              }
              coveringTiles(a) {
                let u = this.coveringZoomLevel(a);
                const g = u,
                  v = this.elevation && !a.isTerrainDEM,
                  b = "mercator" === this.projection.name;
                if (void 0 !== a.minzoom && u < a.minzoom) return [];
                void 0 !== a.maxzoom && u > a.maxzoom && (u = a.maxzoom);
                const D = this.locationCoordinate(this.center),
                  I = this.center.lat,
                  M = 1 << u,
                  R = [M * D.x, M * D.y, 0],
                  k = "globe" === this.projection.name,
                  z = !k,
                  H = d.Frustum.fromInvProjectionMatrix(
                    this.invProjMatrix,
                    this.worldSize,
                    u,
                    z
                  ),
                  q = k
                    ? this._camera.mercatorPosition
                    : this.pointCoordinate(this.getCameraPoint()),
                  X = M * d.mercatorZfromAltitude(1, this.center.lat),
                  Z =
                    this._camera.position[2] /
                    d.mercatorZfromAltitude(1, this.center.lat),
                  Y = [M * q.x, M * q.y, Z * (z ? 1 : X)],
                  B =
                    (this.cameraToCenterDistance / a.tileSize) *
                    (a.roundZoom ? 1 : 0.502),
                  W =
                    this.pitch <= 60 &&
                    this._edgeInsets.top <= this._edgeInsets.bottom &&
                    !this._elevation &&
                    !this.projection.isReprojectedInTileSpace
                      ? u
                      : 0,
                  ee =
                    a.isTerrainDEM && this._elevation
                      ? 1e4 * this._elevation.exaggeration()
                      : this._centerAltitude,
                  te = a.isTerrainDEM
                    ? -ee
                    : this._elevation
                    ? this._elevation.getMinElevationBelowMSL()
                    : 0,
                  he = this.projection.isReprojectedInTileSpace ? Vf(this) : 1,
                  de = (we) => {
                    const He = new d.MercatorCoordinate(
                        we.x + 25e-6,
                        we.y,
                        we.z
                      ),
                      Ne = new d.MercatorCoordinate(we.x, we.y + 25e-6, we.z),
                      Xe = we.toLngLat(),
                      dt = He.toLngLat(),
                      Dt = Ne.toLngLat(),
                      ct = this.locationCoordinate(Xe),
                      wt = this.locationCoordinate(dt),
                      Wt = this.locationCoordinate(Dt),
                      jt = Math.hypot(wt.x - ct.x, wt.y - ct.y),
                      ft = Math.hypot(Wt.x - ct.x, Wt.y - ct.y);
                    return (Math.sqrt(jt * ft) * he) / 25e-6;
                  },
                  ue = (we) => {
                    const ke = ee,
                      He = te;
                    return {
                      aabb: d.tileAABB(
                        this,
                        M,
                        0,
                        0,
                        0,
                        we,
                        He,
                        ke,
                        this.projection
                      ),
                      zoom: 0,
                      x: 0,
                      y: 0,
                      minZ: He,
                      maxZ: ke,
                      wrap: we,
                      fullyVisible: !1,
                    };
                  },
                  _e = [];
                let ge = [];
                const Te = u,
                  Ge = a.reparseOverscaled ? g : u,
                  be = (we) => we * we,
                  Le = be((Z - this._centerAltitude) * X),
                  Ie = (we) => {
                    if (!this._elevation || !we.tileID || !b) return;
                    const ke = this._elevation.getMinMaxForTile(we.tileID),
                      He = we.aabb;
                    ke
                      ? ((He.min[2] = ke.min),
                        (He.max[2] = ke.max),
                        (He.center[2] = (He.min[2] + He.max[2]) / 2))
                      : ((we.shouldSplit = je(we)),
                        we.shouldSplit ||
                          (He.min[2] =
                            He.max[2] =
                            He.center[2] =
                              this._centerAltitude));
                  },
                  je = (we) => {
                    if (we.zoom < W) return !0;
                    if (we.zoom === Te) return !1;
                    if (null != we.shouldSplit) return we.shouldSplit;
                    const ke = we.aabb.distanceX(Y),
                      He = we.aabb.distanceY(Y);
                    let Ne = Le,
                      Xe = 1;
                    if (k) {
                      Ne = be(we.aabb.distanceZ(Y));
                      const ct = Math.pow(2, we.zoom),
                        wt = d.latFromMercatorY((we.y + 1) / ct),
                        Wt = d.latFromMercatorY(we.y / ct),
                        jt = Math.min(Math.max(I, wt), Wt),
                        ft =
                          d.circumferenceAtLatitude(jt) /
                          d.circumferenceAtLatitude(I);
                      if (
                        ((Xe =
                          jt === I
                            ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3)
                            : Math.min(1, ft / this._mercatorScaleRatio)),
                        this.zoom <= d.GLOBE_ZOOM_THRESHOLD_MIN &&
                          we.zoom === Te - 1 &&
                          ft >= 0.9)
                      )
                        return !0;
                    } else if (
                      (v && (Ne = be(we.aabb.distanceZ(Y) * X)),
                      this.projection.isReprojectedInTileSpace && g <= 5)
                    ) {
                      const ct = Math.pow(2, we.zoom),
                        wt = de(
                          new d.MercatorCoordinate(
                            (we.x + 0.5) / ct,
                            (we.y + 0.5) / ct
                          )
                        );
                      Xe = wt > 0.85 ? 1 : wt;
                    }
                    const dt = ke * ke + He * He + Ne;
                    return (
                      dt <
                      be(
                        (1 << (Te - we.zoom)) *
                          B *
                          Xe *
                          ((ct, wt) => {
                            if (wt * be(0.707) < ct) return 1;
                            const Wt = Math.sqrt(wt / ct);
                            return (
                              Wt /
                              (1.4144271570014144 +
                                (Math.pow(1.1, Wt - 1.4144271570014144 + 1) -
                                  1) /
                                  (1.1 - 1) -
                                1)
                            );
                          })(Math.max(Ne, Le), dt)
                      )
                    );
                  };
                if (this.renderWorldCopies)
                  for (let we = 1; we <= 3; we++)
                    _e.push(ue(-we)), _e.push(ue(we));
                for (_e.push(ue(0)); _e.length > 0; ) {
                  const we = _e.pop(),
                    ke = we.x,
                    He = we.y;
                  let Ne = we.fullyVisible;
                  if (!Ne) {
                    const Xe = we.aabb.intersects(H);
                    if (0 === Xe) continue;
                    Ne = 2 === Xe;
                  }
                  if (we.zoom !== Te && je(we))
                    for (let Xe = 0; Xe < 4; Xe++) {
                      const dt = (ke << 1) + (Xe % 2),
                        Dt = (He << 1) + (Xe >> 1),
                        ct = {
                          aabb: b
                            ? we.aabb.quadrant(Xe)
                            : d.tileAABB(
                                this,
                                M,
                                we.zoom + 1,
                                dt,
                                Dt,
                                we.wrap,
                                we.minZ,
                                we.maxZ,
                                this.projection
                              ),
                          zoom: we.zoom + 1,
                          x: dt,
                          y: Dt,
                          wrap: we.wrap,
                          fullyVisible: Ne,
                          tileID: void 0,
                          shouldSplit: void 0,
                          minZ: we.minZ,
                          maxZ: we.maxZ,
                        };
                      v &&
                        !k &&
                        ((ct.tileID = new d.OverscaledTileID(
                          we.zoom + 1 === Te ? Ge : we.zoom + 1,
                          we.wrap,
                          we.zoom + 1,
                          dt,
                          Dt
                        )),
                        Ie(ct)),
                        _e.push(ct);
                    }
                  else {
                    const Xe = we.zoom === Te ? Ge : we.zoom;
                    if (a.minzoom && a.minzoom > Xe) continue;
                    const dt =
                        R[0] -
                        (0.5 + ke + (we.wrap << we.zoom)) *
                          (1 << (u - we.zoom)),
                      Dt = R[1] - 0.5 - He,
                      ct = we.tileID
                        ? we.tileID
                        : new d.OverscaledTileID(Xe, we.wrap, we.zoom, ke, He);
                    ge.push({ tileID: ct, distanceSq: dt * dt + Dt * Dt });
                  }
                }
                if (this.fogCullDistSq) {
                  const we = this.fogCullDistSq,
                    ke = this.horizonLineFromTop();
                  ge = ge.filter((He) => {
                    const Ne = [0, 0, 0, 1],
                      Xe = [d.EXTENT, d.EXTENT, 0, 1],
                      dt = this.calculateFogTileMatrix(He.tileID.toUnwrapped());
                    d.transformMat4$1(Ne, Ne, dt),
                      d.transformMat4$1(Xe, Xe, dt);
                    const Dt = d.getAABBPointSquareDist(Ne, Xe);
                    if (0 === Dt) return !0;
                    let ct = !1;
                    const wt = this._elevation;
                    if (wt && Dt > we && 0 !== ke) {
                      const Wt = this.calculateProjMatrix(
                        He.tileID.toUnwrapped()
                      );
                      let jt;
                      a.isTerrainDEM || (jt = wt.getMinMaxForTile(He.tileID)),
                        jt || (jt = { min: te, max: ee });
                      const ft = d.furthestTileCorner(this.rotation),
                        Yt = [ft[0] * d.EXTENT, ft[1] * d.EXTENT, jt.max];
                      d.transformMat4(Yt, Yt, Wt),
                        (ct = (1 - Yt[1]) * this.height * 0.5 < ke);
                    }
                    return Dt < we || ct;
                  });
                }
                return ge
                  .sort((we, ke) => we.distanceSq - ke.distanceSq)
                  .map((we) => we.tileID);
              }
              resize(a, u) {
                (this.width = a),
                  (this.height = u),
                  (this.pixelsToGLUnits = [2 / a, -2 / u]),
                  this._constrain(),
                  this._calcMatrices();
              }
              get unmodified() {
                return this._unmodified;
              }
              zoomScale(a) {
                return Math.pow(2, a);
              }
              scaleZoom(a) {
                return Math.log(a) / Math.LN2;
              }
              project(a) {
                const u = d.clamp(
                    a.lat,
                    -d.MAX_MERCATOR_LATITUDE,
                    d.MAX_MERCATOR_LATITUDE
                  ),
                  g = this.projection.project(a.lng, u);
                return new d.Point(g.x * this.worldSize, g.y * this.worldSize);
              }
              unproject(a) {
                return this.projection.unproject(
                  a.x / this.worldSize,
                  a.y / this.worldSize
                );
              }
              get point() {
                return this.project(this.center);
              }
              get pointMerc() {
                return this.point._div(this.worldSize);
              }
              get pixelsPerMeterRatio() {
                return (
                  this.pixelsPerMeter /
                  d.mercatorZfromAltitude(1, this.center.lat) /
                  this.worldSize
                );
              }
              setLocationAtPoint(a, u) {
                let g, v;
                const b = this.centerPoint;
                if ("globe" === this.projection.name) {
                  const I = this.worldSize;
                  (g = (u.x - b.x) / I), (v = (u.y - b.y) / I);
                } else {
                  const I = this.pointCoordinate(u),
                    M = this.pointCoordinate(b);
                  (g = I.x - M.x), (v = I.y - M.y);
                }
                const D = this.locationCoordinate(a);
                this.setLocation(new d.MercatorCoordinate(D.x - g, D.y - v));
              }
              setLocation(a) {
                (this.center = this.coordinateLocation(a)),
                  this.projection.wrap && (this.center = this.center.wrap());
              }
              locationPoint(a) {
                return this.projection.locationPoint(this, a);
              }
              locationPoint3D(a) {
                return this.projection.locationPoint(this, a, !0);
              }
              pointLocation(a) {
                return this.coordinateLocation(this.pointCoordinate(a));
              }
              pointLocation3D(a) {
                return this.coordinateLocation(this.pointCoordinate3D(a));
              }
              locationCoordinate(a, u) {
                const g = u ? d.mercatorZfromAltitude(u, a.lat) : void 0,
                  v = this.projection.project(a.lng, a.lat);
                return new d.MercatorCoordinate(v.x, v.y, g);
              }
              coordinateLocation(a) {
                return this.projection.unproject(a.x, a.y);
              }
              pointRayIntersection(a, u) {
                const g = u ?? this._centerAltitude,
                  v = [a.x, a.y, 0, 1],
                  b = [a.x, a.y, 1, 1];
                d.transformMat4$1(v, v, this.pixelMatrixInverse),
                  d.transformMat4$1(b, b, this.pixelMatrixInverse);
                const D = b[3];
                d.scale$1(v, v, 1 / v[3]), d.scale$1(b, b, 1 / D);
                const I = v[2],
                  M = b[2];
                return { p0: v, p1: b, t: I === M ? 0 : (g - I) / (M - I) };
              }
              screenPointToMercatorRay(a) {
                const u = [a.x, a.y, 0, 1],
                  g = [a.x, a.y, 1, 1];
                return (
                  d.transformMat4$1(u, u, this.pixelMatrixInverse),
                  d.transformMat4$1(g, g, this.pixelMatrixInverse),
                  d.scale$1(u, u, 1 / u[3]),
                  d.scale$1(g, g, 1 / g[3]),
                  (u[2] =
                    d.mercatorZfromAltitude(u[2], this._center.lat) *
                    this.worldSize),
                  (g[2] =
                    d.mercatorZfromAltitude(g[2], this._center.lat) *
                    this.worldSize),
                  d.scale$1(u, u, 1 / this.worldSize),
                  d.scale$1(g, g, 1 / this.worldSize),
                  new d.Ray(
                    [u[0], u[1], u[2]],
                    d.normalize([], d.sub([], g, u))
                  )
                );
              }
              rayIntersectionCoordinate(a) {
                const { p0: u, p1: g, t: v } = a,
                  b = d.mercatorZfromAltitude(u[2], this._center.lat),
                  D = d.mercatorZfromAltitude(g[2], this._center.lat);
                return new d.MercatorCoordinate(
                  d.number(u[0], g[0], v) / this.worldSize,
                  d.number(u[1], g[1], v) / this.worldSize,
                  d.number(b, D, v)
                );
              }
              pointCoordinate(a, u = this._centerAltitude) {
                return this.projection.pointCoordinate(this, a.x, a.y, u);
              }
              pointCoordinate3D(a) {
                if (!this.elevation) return this.pointCoordinate(a);
                let u = this.projection.pointCoordinate3D(this, a.x, a.y);
                if (u) return new d.MercatorCoordinate(u[0], u[1], u[2]);
                let g = 0,
                  v = this.horizonLineFromTop();
                if (a.y > v) return this.pointCoordinate(a);
                const b = 0.02 * v,
                  D = a.clone();
                for (let I = 0; I < 10 && v - g > b; I++) {
                  D.y = d.number(g, v, 0.66);
                  const M = this.projection.pointCoordinate3D(this, D.x, D.y);
                  M ? ((v = D.y), (u = M)) : (g = D.y);
                }
                return u
                  ? new d.MercatorCoordinate(u[0], u[1], u[2])
                  : this.pointCoordinate(a);
              }
              isPointAboveHorizon(a) {
                return this.projection.isPointAboveHorizon(this, a);
              }
              isPointOnSurface(a) {
                if (a.y < 0 || a.y > this.height || a.x < 0 || a.x > this.width)
                  return !1;
                if (this.elevation || this.zoom >= d.GLOBE_ZOOM_THRESHOLD_MAX)
                  return !this.isPointAboveHorizon(a);
                const u = this.pointCoordinate(a);
                return u.y >= 0 && u.y <= 1;
              }
              _coordinatePoint(a, u) {
                const g =
                    u && this.elevation
                      ? this.elevation.getAtPointOrZero(a, this._centerAltitude)
                      : this._centerAltitude,
                  v = [
                    a.x * this.worldSize,
                    a.y * this.worldSize,
                    g + a.toAltitude(),
                    1,
                  ];
                return (
                  d.transformMat4$1(v, v, this.pixelMatrix),
                  v[3] > 0
                    ? new d.Point(v[0] / v[3], v[1] / v[3])
                    : new d.Point(Number.MAX_VALUE, Number.MAX_VALUE)
                );
              }
              _getBoundsNonRectangular() {
                const { top: a, left: u } = this._edgeInsets,
                  g = this.height - this._edgeInsets.bottom,
                  v = this.width - this._edgeInsets.right,
                  b = this.pointLocation3D(new d.Point(u, a)),
                  D = this.pointLocation3D(new d.Point(v, a)),
                  I = this.pointLocation3D(new d.Point(v, g)),
                  M = this.pointLocation3D(new d.Point(u, g));
                let R = Math.min(b.lng, D.lng, I.lng, M.lng),
                  k = Math.max(b.lng, D.lng, I.lng, M.lng),
                  z = Math.min(b.lat, D.lat, I.lat, M.lat),
                  H = Math.max(b.lat, D.lat, I.lat, M.lat);
                const q = (Math.pow(2, -this.zoom) / 16) * 270,
                  X = "globe" === this.projection.name ? 1 : 4,
                  Z = (Y, B, W, ee, te) => {
                    const he = (Y + W) / 2,
                      de = (B + ee) / 2,
                      ue = new d.Point(he, de),
                      { lng: _e, lat: ge } = this.pointLocation3D(ue),
                      Te = Math.max(0, R - _e, z - ge, _e - k, ge - H);
                    (R = Math.min(R, _e)),
                      (k = Math.max(k, _e)),
                      (z = Math.min(z, ge)),
                      (H = Math.max(H, ge)),
                      (te < X || Te > q) &&
                        (Z(Y, B, he, de, te + 1), Z(he, de, W, ee, te + 1));
                  };
                if (
                  (Z(u, a, v, a, 1),
                  Z(v, a, v, g, 1),
                  Z(v, g, u, g, 1),
                  Z(u, g, u, a, 1),
                  "globe" === this.projection.name)
                ) {
                  const [Y, B] = d.polesInViewport(this);
                  Y
                    ? ((H = 90), (k = 180), (R = -180))
                    : B && ((z = -90), (k = 180), (R = -180));
                }
                return new d.LngLatBounds(
                  new d.LngLat(R, z),
                  new d.LngLat(k, H)
                );
              }
              _getBoundsRectangular(a, u) {
                const { top: g, left: v } = this._edgeInsets,
                  b = this.height - this._edgeInsets.bottom,
                  D = this.width - this._edgeInsets.right,
                  I = new d.Point(v, g),
                  M = new d.Point(D, g),
                  R = new d.Point(D, b),
                  k = new d.Point(v, b);
                let z = this.pointCoordinate(I, a),
                  H = this.pointCoordinate(M, a);
                const q = this.pointCoordinate(R, u),
                  X = this.pointCoordinate(k, u),
                  Z = (Y, B) => (B.y - Y.y) / (B.x - Y.x);
                return (
                  z.y > 1 && H.y >= 0
                    ? (z = new d.MercatorCoordinate(
                        (1 - X.y) / Z(X, z) + X.x,
                        1
                      ))
                    : z.y < 0 &&
                      H.y <= 1 &&
                      (z = new d.MercatorCoordinate(-X.y / Z(X, z) + X.x, 0)),
                  H.y > 1 && z.y >= 0
                    ? (H = new d.MercatorCoordinate(
                        (1 - q.y) / Z(q, H) + q.x,
                        1
                      ))
                    : H.y < 0 &&
                      z.y <= 1 &&
                      (H = new d.MercatorCoordinate(-q.y / Z(q, H) + q.x, 0)),
                  new d.LngLatBounds()
                    .extend(this.coordinateLocation(z))
                    .extend(this.coordinateLocation(H))
                    .extend(this.coordinateLocation(X))
                    .extend(this.coordinateLocation(q))
                );
              }
              _getBoundsRectangularTerrain() {
                const a = this.elevation;
                if (!a.visibleDemTiles.length || a.isUsingMockSource())
                  return this._getBoundsRectangular(0, 0);
                const u = a.visibleDemTiles.reduce(
                  (g, v) => {
                    if (v.dem) {
                      const b = v.dem.tree;
                      (g.min = Math.min(g.min, b.minimums[0])),
                        (g.max = Math.max(g.max, b.maximums[0]));
                    }
                    return g;
                  },
                  { min: Number.MAX_VALUE, max: 0 }
                );
                return this._getBoundsRectangular(
                  u.min * a.exaggeration(),
                  u.max * a.exaggeration()
                );
              }
              getBounds() {
                return "mercator" === this.projection.name ||
                  "equirectangular" === this.projection.name
                  ? this._terrainEnabled()
                    ? this._getBoundsRectangularTerrain()
                    : this._getBoundsRectangular(0, 0)
                  : this._getBoundsNonRectangular();
              }
              horizonLineFromTop(a = !0) {
                const u =
                    this.height /
                      2 /
                      Math.tan(this._fov / 2) /
                      Math.tan(Math.max(this._pitch, 0.1)) +
                    this.centerOffset.y,
                  g = this.height / 2 - u * (1 - this._horizonShift);
                return a ? Math.max(0, g) : g;
              }
              getMaxBounds() {
                return this.maxBounds;
              }
              setMaxBounds(a) {
                (this.maxBounds = a),
                  (this.minLat = -d.MAX_MERCATOR_LATITUDE),
                  (this.maxLat = d.MAX_MERCATOR_LATITUDE),
                  (this.minLng = -180),
                  (this.maxLng = 180),
                  a &&
                    ((this.minLat = a.getSouth()),
                    (this.maxLat = a.getNorth()),
                    (this.minLng = a.getWest()),
                    (this.maxLng = a.getEast()),
                    this.maxLng < this.minLng && (this.maxLng += 360)),
                  (this.worldMinX =
                    d.mercatorXfromLng(this.minLng) * this.tileSize),
                  (this.worldMaxX =
                    d.mercatorXfromLng(this.maxLng) * this.tileSize),
                  (this.worldMinY =
                    d.mercatorYfromLat(this.maxLat) * this.tileSize),
                  (this.worldMaxY =
                    d.mercatorYfromLat(this.minLat) * this.tileSize),
                  this._constrain();
              }
              calculatePosMatrix(a, u) {
                return this.projection.createTileMatrix(this, u, a);
              }
              calculateDistanceTileData(a) {
                const u = a.key,
                  g = this._distanceTileDataCache;
                if (g[u]) return g[u];
                const v = a.canonical,
                  b = 1 / this.height,
                  D = this.cameraWorldSize,
                  I = D / this.zoomScale(v.z),
                  M = (v.x + Math.pow(2, v.z) * a.wrap) * I,
                  R = v.y * I,
                  k = this.point;
                (k.x *= D / this.worldSize), (k.y *= D / this.worldSize);
                const z = this.angle,
                  H = Math.sin(-z),
                  q = -Math.cos(-z);
                return (
                  (g[u] = {
                    bearing: [H, q],
                    center: [(k.x - M) * b, (k.y - R) * b],
                    scale: (I / d.EXTENT) * b,
                  }),
                  g[u]
                );
              }
              calculateFogTileMatrix(a) {
                const u = a.key,
                  g = this._fogTileMatrixCache;
                if (g[u]) return g[u];
                const v = this.projection.createTileMatrix(
                  this,
                  this.cameraWorldSizeForFog,
                  a
                );
                return (
                  d.multiply(v, this.worldToFogMatrix, v),
                  (g[u] = new Float32Array(v)),
                  g[u]
                );
              }
              calculateProjMatrix(a, u = !1) {
                const g = a.key,
                  v = u ? this._alignedProjMatrixCache : this._projMatrixCache;
                if (v[g]) return v[g];
                const b = this.calculatePosMatrix(a, this.worldSize);
                return (
                  d.multiply(
                    b,
                    this.projection.isReprojectedInTileSpace
                      ? this.mercatorMatrix
                      : u
                      ? this.alignedProjMatrix
                      : this.projMatrix,
                    b
                  ),
                  (v[g] = new Float32Array(b)),
                  v[g]
                );
              }
              calculatePixelsToTileUnitsMatrix(a) {
                const u = a.tileID.key,
                  g = this._pixelsToTileUnitsCache;
                if (g[u]) return g[u];
                const v = (function (b, D) {
                  const { scale: I } = b.tileTransform,
                    M =
                      (I * d.EXTENT) /
                      (b.tileSize *
                        Math.pow(
                          2,
                          D.zoom - b.tileID.overscaledZ + b.tileID.canonical.z
                        ));
                  return (
                    (R = new Float32Array(4)),
                    (H = (k = D.inverseAdjustmentMatrix)[1]),
                    (q = k[2]),
                    (X = k[3]),
                    (Y = (z = [M, M])[1]),
                    (R[0] = k[0] * (Z = z[0])),
                    (R[1] = H * Z),
                    (R[2] = q * Y),
                    (R[3] = X * Y),
                    R
                  );
                  var R, k, z, H, q, X, Z, Y;
                })(a, this);
                return (g[u] = v), g[u];
              }
              customLayerMatrix() {
                return this.mercatorMatrix.slice();
              }
              globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                  const a = 1 / this.worldSize,
                    u = d.fromScaling([], [a, a, a]);
                  return d.multiply(u, u, this.globeMatrix), u;
                }
              }
              recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name)
                  return;
                const a = this._elevation;
                this._updateCameraState();
                const u =
                    d.mercatorZfromAltitude(1, this._center.lat) *
                    this.worldSize,
                  g = this._computeCameraPosition(u),
                  v = this._camera.forward(),
                  b = d.mercatorZfromAltitude(1, this._center.lat);
                (g[2] /= b), (v[2] /= b), d.normalize(v, v);
                const D = a.raycast(g, v, a.exaggeration());
                if (D) {
                  const I = d.scaleAndAdd([], g, v, D),
                    M = new d.MercatorCoordinate(
                      I[0],
                      I[1],
                      d.mercatorZfromAltitude(I[2], d.latFromMercatorY(I[1]))
                    ),
                    R =
                      (M.z +
                        d.length([M.x - g[0], M.y - g[1], M.z - g[2] * b])) *
                      this._pixelsPerMercatorPixel;
                  (this._seaLevelZoom = this._zoomFromMercatorZ(R)),
                    (this._centerAltitude = M.toAltitude()),
                    (this._center = this.coordinateLocation(M)),
                    this._updateZoomFromElevation(),
                    this._constrain(),
                    this._calcMatrices();
                }
              }
              _constrainCamera(a = !1) {
                if (!this._elevation) return;
                const u = this._elevation,
                  g =
                    d.mercatorZfromAltitude(1, this._center.lat) *
                    this.worldSize,
                  v = this._computeCameraPosition(g),
                  b = u.getAtPointOrZero(new d.MercatorCoordinate(...v)),
                  D = (this.pixelsPerMeter / this.worldSize) * b,
                  I = this._minimumHeightOverTerrain(),
                  M = v[2] - D;
                if (M <= I)
                  if (M < 0 || a) {
                    const R = this.locationCoordinate(
                        this._center,
                        this._centerAltitude
                      ),
                      k = [v[0], v[1], R.z - v[2]],
                      z = d.length(k);
                    k[2] -= (I - M) / this._pixelsPerMercatorPixel;
                    const H = d.length(k);
                    if (0 === H) return;
                    d.scale$2(k, k, (z / H) * this._pixelsPerMercatorPixel),
                      (this._camera.position = [
                        v[0],
                        v[1],
                        R.z * this._pixelsPerMercatorPixel - k[2],
                      ]),
                      this._updateStateFromCamera();
                  } else this._isCameraConstrained = !0;
              }
              _constrain() {
                if (
                  !this.center ||
                  !this.width ||
                  !this.height ||
                  this._constraining
                )
                  return;
                this._constraining = !0;
                const a =
                  "globe" === this.projection.name ||
                  this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || a) {
                  const H = this.center;
                  return (
                    (H.lat = d.clamp(H.lat, this.minLat, this.maxLat)),
                    (this.maxBounds || (!this.renderWorldCopies && !a)) &&
                      (H.lng = d.clamp(H.lng, this.minLng, this.maxLng)),
                    (this.center = H),
                    void (this._constraining = !1)
                  );
                }
                const u = this._unmodified,
                  { x: g, y: v } = this.point;
                let b = 0,
                  D = g,
                  I = v;
                const M = this.width / 2,
                  R = this.height / 2,
                  k = this.worldMinY * this.scale,
                  z = this.worldMaxY * this.scale;
                if (
                  (v - R < k && (I = k + R),
                  v + R > z && (I = z - R),
                  z - k < this.height &&
                    ((b = Math.max(b, this.height / (z - k))),
                    (I = (z + k) / 2)),
                  this.maxBounds ||
                    !this._renderWorldCopies ||
                    !this.projection.wrap)
                ) {
                  const H = this.worldMinX * this.scale,
                    q = this.worldMaxX * this.scale,
                    X = this.worldSize / 2 - (H + q) / 2;
                  (D = ((g + X + this.worldSize) % this.worldSize) - X),
                    D - M < H && (D = H + M),
                    D + M > q && (D = q - M),
                    q - H < this.width &&
                      ((b = Math.max(b, this.width / (q - H))),
                      (D = (q + H) / 2));
                }
                (D === g && I === v) ||
                  (this.center = this.unproject(new d.Point(D, I))),
                  b && (this.zoom += this.scaleZoom(b)),
                  this._constrainCamera(),
                  (this._unmodified = u),
                  (this._constraining = !1);
              }
              _minZoomForBounds() {
                let a = Math.max(
                  0,
                  this.scaleZoom(
                    this.height / (this.worldMaxY - this.worldMinY)
                  )
                );
                return (
                  this.maxBounds &&
                    (a = Math.max(
                      a,
                      this.scaleZoom(
                        this.width / (this.worldMaxX - this.worldMinX)
                      )
                    )),
                  a
                );
              }
              _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
              }
              _calcMatrices() {
                if (!this.height) return;
                const a = this.centerOffset,
                  u = this.pixelsPerMeter;
                "globe" === this.projection.name &&
                  (this._mercatorScaleRatio =
                    d.mercatorZfromAltitude(1, this.center.lat) /
                    d.mercatorZfromAltitude(1, d.GLOBE_SCALE_MATCH_LATITUDE));
                const g = Uh(
                  this.projection,
                  this.zoom,
                  this.width,
                  this.height,
                  1024
                );
                (this._pixelsPerMercatorPixel =
                  this.projection.pixelSpaceConversion(
                    this.center.lat,
                    this.worldSize,
                    g
                  )),
                  (this.cameraToCenterDistance =
                    (0.5 / Math.tan(0.5 * this._fov)) *
                    this.height *
                    this._pixelsPerMercatorPixel),
                  this._updateCameraState(),
                  (this._farZ = this.projection.farthestPixelDistance(this)),
                  (this._nearZ = this.height / 50);
                const v = "meters" === this.projection.zAxisUnit ? u : 1,
                  b = this._camera.getWorldToCamera(this.worldSize, v),
                  D = this._camera.getCameraToClipPerspective(
                    this._fov,
                    this.width / this.height,
                    this._nearZ,
                    this._farZ
                  );
                (D[8] = (2 * -a.x) / this.width),
                  (D[9] = (2 * a.y) / this.height);
                let I = d.mul([], D, b);
                if (this.projection.isReprojectedInTileSpace) {
                  const de = this.locationCoordinate(this.center),
                    ue = d.identity([]);
                  d.translate(ue, ue, [
                    de.x * this.worldSize,
                    de.y * this.worldSize,
                    0,
                  ]),
                    d.multiply(ue, ue, Xs(this)),
                    d.translate(ue, ue, [
                      -de.x * this.worldSize,
                      -de.y * this.worldSize,
                      0,
                    ]),
                    d.multiply(I, I, ue),
                    (this.inverseAdjustmentMatrix = (function (_e) {
                      const ge = Xs(_e, !0);
                      return et([], [ge[0], ge[1], ge[4], ge[5]]);
                    })(this));
                } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                (this.mercatorMatrix = d.scale([], I, [
                  this.worldSize,
                  this.worldSize,
                  this.worldSize / v,
                  1,
                ])),
                  (this.projMatrix = I),
                  (this.invProjMatrix = d.invert(
                    new Float64Array(16),
                    this.projMatrix
                  ));
                const M = d.invert([], D);
                this.frustumCorners = d.FrustumCorners.fromInvProjectionMatrix(
                  M,
                  this.horizonLineFromTop(),
                  this.height
                );
                const R = new Float32Array(16);
                d.identity(R),
                  d.scale(R, R, [1, -1, 1]),
                  d.rotateX(R, R, this._pitch),
                  d.rotateZ(R, R, this.angle);
                const k = d.perspective(
                    new Float32Array(16),
                    this._fov,
                    this.width / this.height,
                    this._nearZ,
                    this._farZ
                  ),
                  z =
                    (Math.PI / 2 - this._pitch) *
                    (this.height / this._fov) *
                    this._horizonShift;
                (k[8] = (2 * -a.x) / this.width),
                  (k[9] = (2 * (a.y + z)) / this.height),
                  (this.skyboxMatrix = d.multiply(R, k, R));
                const H = this.point,
                  q = H.x,
                  X = H.y,
                  Z = (this.width % 2) / 2,
                  Y = (this.height % 2) / 2,
                  B = Math.cos(this.angle),
                  W = Math.sin(this.angle),
                  ee = q - Math.round(q) + B * Z + W * Y,
                  te = X - Math.round(X) + B * Y + W * Z,
                  he = new Float64Array(I);
                if (
                  (d.translate(he, he, [
                    ee > 0.5 ? ee - 1 : ee,
                    te > 0.5 ? te - 1 : te,
                    0,
                  ]),
                  (this.alignedProjMatrix = he),
                  (I = d.create()),
                  d.scale(I, I, [this.width / 2, -this.height / 2, 1]),
                  d.translate(I, I, [1, -1, 0]),
                  (this.labelPlaneMatrix = I),
                  (I = d.create()),
                  d.scale(I, I, [1, -1, 1]),
                  d.translate(I, I, [-1, -1, 0]),
                  d.scale(I, I, [2 / this.width, 2 / this.height, 1]),
                  (this.glCoordMatrix = I),
                  (this.pixelMatrix = d.multiply(
                    new Float64Array(16),
                    this.labelPlaneMatrix,
                    this.projMatrix
                  )),
                  this._calcFogMatrices(),
                  (this._distanceTileDataCache = {}),
                  (I = d.invert(new Float64Array(16), this.pixelMatrix)),
                  !I)
                )
                  throw new Error("failed to invert matrix");
                if (
                  ((this.pixelMatrixInverse = I),
                  "globe" === this.projection.name ||
                    this.mercatorFromTransition)
                ) {
                  this.globeMatrix = d.calculateGlobeMatrix(this);
                  const de = [
                    this.globeMatrix[12],
                    this.globeMatrix[13],
                    this.globeMatrix[14],
                  ];
                  (this.globeCenterInViewSpace = d.transformMat4(de, de, b)),
                    (this.globeRadius = this.worldSize / 2 / Math.PI - 1);
                } else this.globeMatrix = I;
                (this._projMatrixCache = {}),
                  (this._alignedProjMatrixCache = {}),
                  (this._pixelsToTileUnitsCache = {});
              }
              _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const a = this.cameraWorldSizeForFog,
                  u = this.cameraPixelsPerMeter,
                  g = this._camera.position,
                  v = 1 / this.height / this._pixelsPerMercatorPixel,
                  b = [a, a, u];
                d.scale$2(b, b, v), d.scale$2(g, g, -1), d.multiply$2(g, g, b);
                const D = d.create();
                d.translate(D, D, g),
                  d.scale(D, D, b),
                  (this.mercatorFogMatrix = D),
                  (this.worldToFogMatrix =
                    this._camera.getWorldToCameraPosition(a, u, v));
              }
              _computeCameraPosition(a) {
                const u = (a = a || this.pixelsPerMeter) / this.pixelsPerMeter,
                  g = this._camera.forward(),
                  v = this.point,
                  b =
                    this._mercatorZfromZoom(
                      this._seaLevelZoom ? this._seaLevelZoom : this._zoom
                    ) *
                      u -
                    (a / this.worldSize) * this._centerAltitude;
                return [
                  v.x / this.worldSize - g[0] * b,
                  v.y / this.worldSize - g[1] * b,
                  (a / this.worldSize) * this._centerAltitude - g[2] * b,
                ];
              }
              _updateCameraState() {
                this.height &&
                  (this._camera.setPitchBearing(this._pitch, this.angle),
                  (this._camera.position = this._computeCameraPosition()));
              }
              _translateCameraConstrained(a) {
                const u =
                    this._maxCameraBoundsDistance() * Math.cos(this._pitch),
                  g = this._camera.position[2],
                  v = a[2];
                let b = 1;
                this.projection.wrap && (this.center = this.center.wrap()),
                  v > 0 && (b = Math.min((u - g) / v, 1)),
                  (this._camera.position = d.scaleAndAdd(
                    [],
                    this._camera.position,
                    a,
                    b
                  )),
                  this._updateStateFromCamera();
              }
              _updateStateFromCamera() {
                const a = this._camera.position,
                  u = this._camera.forward(),
                  { pitch: g, bearing: v } = this._camera.getPitchBearing(),
                  b =
                    d.mercatorZfromAltitude(
                      this._centerAltitude,
                      this.center.lat
                    ) * this._pixelsPerMercatorPixel,
                  D =
                    this._mercatorZfromZoom(this._maxZoom) *
                    Math.cos(d.degToRad(this._maxPitch)),
                  I = Math.max((a[2] - b) / Math.cos(g), D),
                  M = this._zoomFromMercatorZ(I);
                d.scaleAndAdd(a, a, u, I),
                  (this._pitch = d.clamp(
                    g,
                    d.degToRad(this.minPitch),
                    d.degToRad(this.maxPitch)
                  )),
                  (this.angle = d.wrap(v, -Math.PI, Math.PI)),
                  this._setZoom(d.clamp(M, this._minZoom, this._maxZoom)),
                  this._updateSeaLevelZoom(),
                  (this._center = this.coordinateLocation(
                    new d.MercatorCoordinate(a[0], a[1], a[2])
                  )),
                  (this._unmodified = !1),
                  this._constrain(),
                  this._calcMatrices();
              }
              _worldSizeFromZoom(a) {
                return Math.pow(2, a) * this.tileSize;
              }
              _mercatorZfromZoom(a) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(a);
              }
              _minimumHeightOverTerrain() {
                const a = Math.min(
                  (null != this._seaLevelZoom
                    ? this._seaLevelZoom
                    : this._zoom) + 4,
                  this._maxZoom
                );
                return this._mercatorZfromZoom(a);
              }
              _zoomFromMercatorZ(a) {
                return this.scaleZoom(
                  this.cameraToCenterDistance / (a * this.tileSize)
                );
              }
              zoomFromMercatorZAdjusted(a) {
                let u = 0,
                  g = d.GLOBE_ZOOM_THRESHOLD_MAX,
                  v = 0,
                  b = 1 / 0;
                for (; g - u > 1e-6 && g > u; ) {
                  const D = u + 0.5 * (g - u),
                    I = this.tileSize * Math.pow(2, D),
                    M = this.getCameraToCenterDistance(this.projection, D, I),
                    R = this.scaleZoom(M / (a * this.tileSize)),
                    k = Math.abs(D - R);
                  k < b && ((b = k), (v = D)), D < R ? (u = D) : (g = D);
                }
                return v;
              }
              _terrainEnabled() {
                return !(
                  !this._elevation ||
                  (!this.projection.supportsTerrain &&
                    (d.warnOnce(
                      "Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."
                    ),
                    1))
                );
              }
              anyCornerOffEdge(a, u) {
                const g = Math.min(a.x, u.x),
                  v = Math.max(a.x, u.x),
                  b = Math.min(a.y, u.y),
                  D = Math.max(a.y, u.y);
                if (b < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const I = [
                    new d.Point(g, b),
                    new d.Point(v, D),
                    new d.Point(g, D),
                    new d.Point(v, b),
                  ],
                  M = this.renderWorldCopies ? -3 : 0,
                  R = this.renderWorldCopies ? 4 : 1;
                for (const k of I) {
                  const z = this.pointRayIntersection(k);
                  if (z.t < 0) return !0;
                  const H = this.rayIntersectionCoordinate(z);
                  if (H.x < M || H.y < 0 || H.x > R || H.y > 1) return !0;
                }
                return !1;
              }
              isHorizonVisible() {
                return (
                  this.pitch + d.radToDeg(this.fovAboveCenter) > 88 ||
                  this.anyCornerOffEdge(
                    new d.Point(0, 0),
                    new d.Point(this.width, this.height)
                  )
                );
              }
              zoomDeltaToMovement(a, u) {
                const g = d.length(d.sub([], this._camera.position, a)),
                  v = this._zoomFromMercatorZ(g) + u;
                return g - this._mercatorZfromZoom(v);
              }
              getCameraPoint() {
                if ("globe" === this.projection.name) {
                  const a = (function ([u, g, v], b) {
                    const D = [u, g, v, 1];
                    d.transformMat4$1(D, D, b);
                    const I = (D[3] = Math.max(D[3], 1e-6));
                    return (D[0] /= I), (D[1] /= I), (D[2] /= I), D;
                  })(
                    [
                      this.globeMatrix[12],
                      this.globeMatrix[13],
                      this.globeMatrix[14],
                    ],
                    this.pixelMatrix
                  );
                  return new d.Point(a[0], a[1]);
                }
                {
                  const a =
                    Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                  return this.centerPoint.add(new d.Point(0, a));
                }
              }
              getCameraToCenterDistance(a, u = this.zoom, g = this.worldSize) {
                const v = Uh(a, u, this.width, this.height, 1024),
                  b = a.pixelSpaceConversion(this.center.lat, g, v);
                return (0.5 / Math.tan(0.5 * this._fov)) * this.height * b;
              }
              getWorldToCameraMatrix() {
                const a = this._camera.getWorldToCamera(
                  this.worldSize,
                  "meters" === this.projection.zAxisUnit
                    ? this.pixelsPerMeter
                    : 1
                );
                return (
                  "globe" === this.projection.name &&
                    d.multiply(a, a, this.globeMatrix),
                  a
                );
              }
            }
            function Ba(f, a) {
              let u = !1,
                g = null;
              const v = () => {
                (g = null), u && (f(), (g = setTimeout(v, a)), (u = !1));
              };
              return () => ((u = !0), g || v(), g);
            }
            class $h {
              constructor(a) {
                (this._hashName = a && encodeURIComponent(a)),
                  d.bindAll(
                    ["_getCurrentHash", "_onHashChange", "_updateHash"],
                    this
                  ),
                  (this._updateHash = Ba(
                    this._updateHashUnthrottled.bind(this),
                    300
                  ));
              }
              addTo(a) {
                return (
                  (this._map = a),
                  d.window.addEventListener(
                    "hashchange",
                    this._onHashChange,
                    !1
                  ),
                  a.on("moveend", this._updateHash),
                  this
                );
              }
              remove() {
                return this._map
                  ? (this._map.off("moveend", this._updateHash),
                    d.window.removeEventListener(
                      "hashchange",
                      this._onHashChange,
                      !1
                    ),
                    clearTimeout(this._updateHash()),
                    (this._map = void 0),
                    this)
                  : this;
              }
              getHashString() {
                const a = this._map;
                if (!a) return "";
                const u = Ec(a);
                if (this._hashName) {
                  const g = this._hashName;
                  let v = !1;
                  const b = d.window.location.hash
                    .slice(1)
                    .split("&")
                    .map((D) => {
                      const I = D.split("=")[0];
                      return I === g ? ((v = !0), `${I}=${u}`) : D;
                    })
                    .filter((D) => D);
                  return v || b.push(`${g}=${u}`), `#${b.join("&")}`;
                }
                return `#${u}`;
              }
              _getCurrentHash() {
                const a = d.window.location.hash.replace("#", "");
                if (this._hashName) {
                  let u;
                  return (
                    a
                      .split("&")
                      .map((g) => g.split("="))
                      .forEach((g) => {
                        g[0] === this._hashName && (u = g);
                      }),
                    ((u && u[1]) || "").split("/")
                  );
                }
                return a.split("/");
              }
              _onHashChange() {
                const a = this._map;
                if (!a) return !1;
                const u = this._getCurrentHash();
                if (u.length >= 3 && !u.some((g) => isNaN(g))) {
                  const g =
                    a.dragRotate.isEnabled() && a.touchZoomRotate.isEnabled()
                      ? +(u[3] || 0)
                      : a.getBearing();
                  return (
                    a.jumpTo({
                      center: [+u[2], +u[1]],
                      zoom: +u[0],
                      bearing: g,
                      pitch: +(u[4] || 0),
                    }),
                    !0
                  );
                }
                return !1;
              }
              _updateHashUnthrottled() {
                const a = d.window.location.href.replace(
                  /(#.+)?$/,
                  this.getHashString()
                );
                d.window.history.replaceState(d.window.history.state, null, a);
              }
            }
            function Ec(f, a) {
              const u = f.getCenter(),
                g = Math.round(100 * f.getZoom()) / 100,
                v = Math.ceil(
                  (g * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10
                ),
                b = Math.pow(10, v),
                D = Math.round(u.lng * b) / b,
                I = Math.round(u.lat * b) / b,
                M = f.getBearing(),
                R = f.getPitch();
              let k = a ? `/${D}/${I}/${g}` : `${g}/${I}/${D}`;
              return (
                (M || R) && (k += "/" + Math.round(10 * M) / 10),
                R && (k += `/${Math.round(R)}`),
                k
              );
            }
            const Fl = { linearity: 0.3, easing: d.bezier(0, 0, 0.3, 1) },
              Tc = d.extend({ deceleration: 2500, maxSpeed: 1400 }, Fl),
              Cu = d.extend({ deceleration: 20, maxSpeed: 1400 }, Fl),
              at = d.extend({ deceleration: 1e3, maxSpeed: 360 }, Fl),
              To = d.extend({ deceleration: 1e3, maxSpeed: 90 }, Fl);
            class Wr {
              constructor(a) {
                (this._map = a), this.clear();
              }
              clear() {
                this._inertiaBuffer = [];
              }
              record(a) {
                this._drainInertiaBuffer(),
                  this._inertiaBuffer.push({
                    time: d.exported.now(),
                    settings: a,
                  });
              }
              _drainInertiaBuffer() {
                const a = this._inertiaBuffer,
                  u = d.exported.now();
                for (; a.length > 0 && u - a[0].time > 160; ) a.shift();
              }
              _onMoveEnd(a) {
                if (
                  this._map._prefersReducedMotion() ||
                  (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                )
                  return;
                const u = {
                  zoom: 0,
                  bearing: 0,
                  pitch: 0,
                  pan: new d.Point(0, 0),
                  pinchAround: void 0,
                  around: void 0,
                };
                for (const { settings: b } of this._inertiaBuffer)
                  (u.zoom += b.zoomDelta || 0),
                    (u.bearing += b.bearingDelta || 0),
                    (u.pitch += b.pitchDelta || 0),
                    b.panDelta && u.pan._add(b.panDelta),
                    b.around && (u.around = b.around),
                    b.pinchAround && (u.pinchAround = b.pinchAround);
                const g =
                    this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                    this._inertiaBuffer[0].time,
                  v = {};
                if (u.pan.mag()) {
                  const b = Dc(u.pan.mag(), g, d.extend({}, Tc, a || {}));
                  (v.offset = u.pan.mult(b.amount / u.pan.mag())),
                    (v.center = this._map.transform.center),
                    Va(v, b);
                }
                if (u.zoom) {
                  const b = Dc(u.zoom, g, Cu);
                  (v.zoom = this._map.transform.zoom + b.amount), Va(v, b);
                }
                if (u.bearing) {
                  const b = Dc(u.bearing, g, at);
                  (v.bearing =
                    this._map.transform.bearing + d.clamp(b.amount, -179, 179)),
                    Va(v, b);
                }
                if (u.pitch) {
                  const b = Dc(u.pitch, g, To);
                  (v.pitch = this._map.transform.pitch + b.amount), Va(v, b);
                }
                if (v.zoom || v.bearing) {
                  const b = void 0 === u.pinchAround ? u.around : u.pinchAround;
                  v.around = b ? this._map.unproject(b) : this._map.getCenter();
                }
                return this.clear(), (v.noMoveStart = !0), v;
              }
            }
            function Va(f, a) {
              (!f.duration || f.duration < a.duration) &&
                ((f.duration = a.duration), (f.easing = a.easing));
            }
            function Dc(f, a, u) {
              const { maxSpeed: g, linearity: v, deceleration: b } = u,
                D = d.clamp((f * v) / (a / 1e3), -g, g),
                I = Math.abs(D) / (b * v);
              return {
                easing: u.easing,
                duration: 1e3 * I,
                amount: D * (I / 2),
              };
            }
            class Ei extends d.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(a, u, g, v = {}) {
                const b = Ir(u.getCanvasContainer(), g),
                  D = u.unproject(b);
                super(
                  a,
                  d.extend({ point: b, lngLat: D, originalEvent: g }, v)
                ),
                  (this._defaultPrevented = !1),
                  (this.target = u);
              }
            }
            class Sc extends d.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(a, u, g) {
                const v = "touchend" === a ? g.changedTouches : g.touches,
                  b = Sa(u.getCanvasContainer(), v),
                  D = b.map((M) => u.unproject(M)),
                  I = b.reduce(
                    (M, R, k, z) => M.add(R.div(z.length)),
                    new d.Point(0, 0)
                  );
                super(a, {
                  points: b,
                  point: I,
                  lngLats: D,
                  lngLat: u.unproject(I),
                  originalEvent: g,
                }),
                  (this._defaultPrevented = !1);
              }
            }
            class Hh extends d.Event {
              preventDefault() {
                this._defaultPrevented = !0;
              }
              get defaultPrevented() {
                return this._defaultPrevented;
              }
              constructor(a, u, g) {
                super(a, { originalEvent: g }), (this._defaultPrevented = !1);
              }
            }
            class ti {
              constructor(a, u) {
                (this._map = a), (this._clickTolerance = u.clickTolerance);
              }
              reset() {
                this._mousedownPos = void 0;
              }
              wheel(a) {
                return this._firePreventable(new Hh(a.type, this._map, a));
              }
              mousedown(a, u) {
                return (
                  (this._mousedownPos = u),
                  this._firePreventable(new Ei(a.type, this._map, a))
                );
              }
              mouseup(a) {
                this._map.fire(new Ei(a.type, this._map, a));
              }
              preclick(a) {
                const u = d.extend({}, a);
                (u.type = "preclick"),
                  this._map.fire(new Ei(u.type, this._map, u));
              }
              click(a, u) {
                (this._mousedownPos &&
                  this._mousedownPos.dist(u) >= this._clickTolerance) ||
                  (this.preclick(a),
                  this._map.fire(new Ei(a.type, this._map, a)));
              }
              dblclick(a) {
                return this._firePreventable(new Ei(a.type, this._map, a));
              }
              mouseover(a) {
                this._map.fire(new Ei(a.type, this._map, a));
              }
              mouseout(a) {
                this._map.fire(new Ei(a.type, this._map, a));
              }
              touchstart(a) {
                return this._firePreventable(new Sc(a.type, this._map, a));
              }
              touchmove(a) {
                this._map.fire(new Sc(a.type, this._map, a));
              }
              touchend(a) {
                this._map.fire(new Sc(a.type, this._map, a));
              }
              touchcancel(a) {
                this._map.fire(new Sc(a.type, this._map, a));
              }
              _firePreventable(a) {
                if ((this._map.fire(a), a.defaultPrevented)) return {};
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class Mu {
              constructor(a) {
                this._map = a;
              }
              reset() {
                (this._delayContextMenu = !1),
                  (this._contextMenuEvent = void 0);
              }
              mousemove(a) {
                this._map.fire(new Ei(a.type, this._map, a));
              }
              mousedown() {
                this._delayContextMenu = !0;
              }
              mouseup() {
                (this._delayContextMenu = !1),
                  this._contextMenuEvent &&
                    (this._map.fire(
                      new Ei("contextmenu", this._map, this._contextMenuEvent)
                    ),
                    delete this._contextMenuEvent);
              }
              contextmenu(a) {
                this._delayContextMenu
                  ? (this._contextMenuEvent = a)
                  : this._map.fire(new Ei(a.type, this._map, a)),
                  this._map.listens("contextmenu") && a.preventDefault();
              }
              isEnabled() {
                return !0;
              }
              isActive() {
                return !1;
              }
              enable() {}
              disable() {}
            }
            class jf {
              constructor(a, u) {
                (this._map = a),
                  (this._el = a.getCanvasContainer()),
                  (this._container = a.getContainer()),
                  (this._clickTolerance = u.clickTolerance || 1);
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active;
              }
              enable() {
                this.isEnabled() || (this._enabled = !0);
              }
              disable() {
                this.isEnabled() && (this._enabled = !1);
              }
              mousedown(a, u) {
                this.isEnabled() &&
                  a.shiftKey &&
                  0 === a.button &&
                  (oc(),
                  (this._startPos = this._lastPos = u),
                  (this._active = !0));
              }
              mousemoveWindow(a, u) {
                if (!this._active) return;
                const g = u,
                  v = this._startPos,
                  b = this._lastPos;
                if (
                  !v ||
                  !b ||
                  b.equals(g) ||
                  (!this._box && g.dist(v) < this._clickTolerance)
                )
                  return;
                (this._lastPos = g),
                  this._box ||
                    ((this._box = Ot(
                      "div",
                      "mapboxgl-boxzoom",
                      this._container
                    )),
                    this._container.classList.add("mapboxgl-crosshair"),
                    this._fireEvent("boxzoomstart", a));
                const D = Math.min(v.x, g.x),
                  I = Math.max(v.x, g.x),
                  M = Math.min(v.y, g.y),
                  R = Math.max(v.y, g.y);
                this._map._requestDomTask(() => {
                  this._box &&
                    ((this._box.style.transform = `translate(${D}px,${M}px)`),
                    (this._box.style.width = I - D + "px"),
                    (this._box.style.height = R - M + "px"));
                });
              }
              mouseupWindow(a, u) {
                if (!this._active) return;
                const g = this._startPos,
                  v = u;
                if (g && 0 === a.button) {
                  if ((this.reset(), eo(), g.x !== v.x || g.y !== v.y))
                    return (
                      this._map.fire(
                        new d.Event("boxzoomend", { originalEvent: a })
                      ),
                      {
                        cameraAnimation: (b) =>
                          b.fitScreenCoordinates(g, v, this._map.getBearing(), {
                            linear: !1,
                          }),
                      }
                    );
                  this._fireEvent("boxzoomcancel", a);
                }
              }
              keydown(a) {
                this._active &&
                  27 === a.keyCode &&
                  (this.reset(), this._fireEvent("boxzoomcancel", a));
              }
              blur() {
                this.reset();
              }
              reset() {
                (this._active = !1),
                  this._container.classList.remove("mapboxgl-crosshair"),
                  this._box && (this._box.remove(), (this._box = null)),
                  vl(),
                  delete this._startPos,
                  delete this._lastPos;
              }
              _fireEvent(a, u) {
                return this._map.fire(new d.Event(a, { originalEvent: u }));
              }
            }
            function ja(f, a) {
              const u = {};
              for (let g = 0; g < f.length; g++) u[f[g].identifier] = a[g];
              return u;
            }
            class zi {
              constructor(a) {
                this.reset(), (this.numTouches = a.numTouches);
              }
              reset() {
                (this.centroid = void 0),
                  (this.startTime = 0),
                  (this.touches = {}),
                  (this.aborted = !1);
              }
              touchstart(a, u, g) {
                (this.centroid || g.length > this.numTouches) &&
                  (this.aborted = !0),
                  this.aborted ||
                    (0 === this.startTime && (this.startTime = a.timeStamp),
                    g.length === this.numTouches &&
                      ((this.centroid = (function (v) {
                        const b = new d.Point(0, 0);
                        for (const D of v) b._add(D);
                        return b.div(v.length);
                      })(u)),
                      (this.touches = ja(g, u))));
              }
              touchmove(a, u, g) {
                if (this.aborted || !this.centroid) return;
                const v = ja(g, u);
                for (const b in this.touches) {
                  const D = v[b];
                  (!D || D.dist(this.touches[b]) > 30) && (this.aborted = !0);
                }
              }
              touchend(a, u, g) {
                if (
                  ((!this.centroid || a.timeStamp - this.startTime > 500) &&
                    (this.aborted = !0),
                  0 === g.length)
                ) {
                  const v = !this.aborted && this.centroid;
                  if ((this.reset(), v)) return v;
                }
              }
            }
            class Gh {
              constructor(a) {
                (this.singleTap = new zi(a)),
                  (this.numTaps = a.numTaps),
                  this.reset();
              }
              reset() {
                (this.lastTime = 1 / 0),
                  (this.lastTap = void 0),
                  (this.count = 0),
                  this.singleTap.reset();
              }
              touchstart(a, u, g) {
                this.singleTap.touchstart(a, u, g);
              }
              touchmove(a, u, g) {
                this.singleTap.touchmove(a, u, g);
              }
              touchend(a, u, g) {
                const v = this.singleTap.touchend(a, u, g);
                if (v) {
                  const b = a.timeStamp - this.lastTime < 500,
                    D = !this.lastTap || this.lastTap.dist(v) < 30;
                  if (
                    ((b && D) || this.reset(),
                    this.count++,
                    (this.lastTime = a.timeStamp),
                    (this.lastTap = v),
                    this.count === this.numTaps)
                  )
                    return this.reset(), v;
                }
              }
            }
            class qh {
              constructor() {
                (this._zoomIn = new Gh({ numTouches: 1, numTaps: 2 })),
                  (this._zoomOut = new Gh({ numTouches: 2, numTaps: 1 })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  this._zoomIn.reset(),
                  this._zoomOut.reset();
              }
              touchstart(a, u, g) {
                this._zoomIn.touchstart(a, u, g),
                  this._zoomOut.touchstart(a, u, g);
              }
              touchmove(a, u, g) {
                this._zoomIn.touchmove(a, u, g),
                  this._zoomOut.touchmove(a, u, g);
              }
              touchend(a, u, g) {
                const v = this._zoomIn.touchend(a, u, g),
                  b = this._zoomOut.touchend(a, u, g);
                return v
                  ? ((this._active = !0),
                    a.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (D) =>
                        D.easeTo(
                          {
                            duration: 300,
                            zoom: D.getZoom() + 1,
                            around: D.unproject(v),
                          },
                          { originalEvent: a }
                        ),
                    })
                  : b
                  ? ((this._active = !0),
                    a.preventDefault(),
                    setTimeout(() => this.reset(), 0),
                    {
                      cameraAnimation: (D) =>
                        D.easeTo(
                          {
                            duration: 300,
                            zoom: D.getZoom() - 1,
                            around: D.unproject(b),
                          },
                          { originalEvent: a }
                        ),
                    })
                  : void 0;
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            const Ua = { 0: 1, 2: 2 };
            class Bi {
              constructor(a) {
                this.reset(), (this._clickTolerance = a.clickTolerance || 1);
              }
              blur() {
                this.reset();
              }
              reset() {
                (this._active = !1),
                  (this._moved = !1),
                  (this._lastPoint = void 0),
                  (this._eventButton = void 0);
              }
              _correctButton(a, u) {
                return !1;
              }
              _move(a, u) {
                return {};
              }
              mousedown(a, u) {
                if (this._lastPoint) return;
                const g = is(a);
                this._correctButton(a, g) &&
                  ((this._lastPoint = u), (this._eventButton = g));
              }
              mousemoveWindow(a, u) {
                const g = this._lastPoint;
                if (g)
                  if (
                    (a.preventDefault(),
                    null != this._eventButton &&
                      (function (v, b) {
                        const D = Ua[b];
                        return void 0 === v.buttons || (v.buttons & D) !== D;
                      })(a, this._eventButton))
                  )
                    this.reset();
                  else if (this._moved || !(u.dist(g) < this._clickTolerance))
                    return (
                      (this._moved = !0),
                      (this._lastPoint = u),
                      this._move(g, u)
                    );
              }
              mouseupWindow(a) {
                this._lastPoint &&
                  is(a) === this._eventButton &&
                  (this._moved && eo(), this.reset());
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class Wh extends Bi {
              mousedown(a, u) {
                super.mousedown(a, u), this._lastPoint && (this._active = !0);
              }
              _correctButton(a, u) {
                return 0 === u && !a.ctrlKey;
              }
              _move(a, u) {
                return { around: u, panDelta: u.sub(a) };
              }
            }
            class Nl extends Bi {
              _correctButton(a, u) {
                return (0 === u && a.ctrlKey) || 2 === u;
              }
              _move(a, u) {
                const g = 0.8 * (u.x - a.x);
                if (g) return (this._active = !0), { bearingDelta: g };
              }
              contextmenu(a) {
                a.preventDefault();
              }
            }
            class Zh extends Bi {
              _correctButton(a, u) {
                return (0 === u && a.ctrlKey) || 2 === u;
              }
              _move(a, u) {
                const g = -0.5 * (u.y - a.y);
                if (g) return (this._active = !0), { pitchDelta: g };
              }
              contextmenu(a) {
                a.preventDefault();
              }
            }
            class Do {
              constructor(a, u) {
                (this._map = a),
                  (this._el = a.getCanvasContainer()),
                  (this._minTouches = 1),
                  (this._clickTolerance = u.clickTolerance || 1),
                  this.reset(),
                  d.bindAll(
                    ["_addTouchPanBlocker", "_showTouchPanBlockerAlert"],
                    this
                  );
              }
              reset() {
                (this._active = !1),
                  (this._touches = {}),
                  (this._sum = new d.Point(0, 0));
              }
              touchstart(a, u, g) {
                return this._calculateTransform(a, u, g);
              }
              touchmove(a, u, g) {
                if (this._active && !(g.length < this._minTouches)) {
                  if (this._map._cooperativeGestures && !this._map.isMoving()) {
                    if (1 === g.length && !d.isFullscreen())
                      return void this._showTouchPanBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility &&
                      ((this._alertContainer.style.visibility = "hidden"),
                      clearTimeout(this._alertTimer));
                  }
                  return (
                    a.cancelable && a.preventDefault(),
                    this._calculateTransform(a, u, g)
                  );
                }
              }
              touchend(a, u, g) {
                this._calculateTransform(a, u, g),
                  this._active && g.length < this._minTouches && this.reset();
              }
              touchcancel() {
                this.reset();
              }
              _calculateTransform(a, u, g) {
                g.length > 0 && (this._active = !0);
                const v = ja(g, u),
                  b = new d.Point(0, 0),
                  D = new d.Point(0, 0);
                let I = 0;
                for (const R in v) {
                  const k = v[R],
                    z = this._touches[R];
                  z && (b._add(k), D._add(k.sub(z)), I++, (v[R] = k));
                }
                if (((this._touches = v), I < this._minTouches || !D.mag()))
                  return;
                const M = D.div(I);
                return (
                  this._sum._add(M),
                  this._sum.mag() < this._clickTolerance
                    ? void 0
                    : { around: b.div(I), panDelta: M }
                );
              }
              enable() {
                (this._enabled = !0),
                  this._map._cooperativeGestures &&
                    (this._addTouchPanBlocker(),
                    this._el.classList.add(
                      "mapboxgl-touch-pan-blocker-override",
                      "mapboxgl-scrollable-page"
                    ));
              }
              disable() {
                (this._enabled = !1),
                  this._map._cooperativeGestures &&
                    (clearTimeout(this._alertTimer),
                    this._alertContainer.remove(),
                    this._el.classList.remove(
                      "mapboxgl-touch-pan-blocker-override",
                      "mapboxgl-scrollable-page"
                    )),
                  this.reset();
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return !!this._active;
              }
              _addTouchPanBlocker() {
                this._map &&
                  !this._alertContainer &&
                  ((this._alertContainer = Ot(
                    "div",
                    "mapboxgl-touch-pan-blocker",
                    this._map._container
                  )),
                  (this._alertContainer.textContent = this._map._getUIString(
                    "TouchPanBlocker.Message"
                  )),
                  (this._alertContainer.style.fontSize = `${Math.max(
                    10,
                    Math.min(24, Math.floor(0.05 * this._el.clientWidth))
                  )}px`));
              }
              _showTouchPanBlockerAlert() {
                (this._alertContainer.style.visibility = "visible"),
                  this._alertContainer.classList.add(
                    "mapboxgl-touch-pan-blocker-show"
                  ),
                  this._alertContainer.setAttribute("role", "alert"),
                  clearTimeout(this._alertTimer),
                  (this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove(
                      "mapboxgl-touch-pan-blocker-show"
                    ),
                      this._alertContainer.setAttribute("role", "null");
                  }, 500));
              }
            }
            class zl {
              constructor() {
                this.reset();
              }
              reset() {
                (this._active = !1), (this._firstTwoTouches = void 0);
              }
              _start(a) {}
              _move(a, u, g) {
                return {};
              }
              touchstart(a, u, g) {
                this._firstTwoTouches ||
                  g.length < 2 ||
                  ((this._firstTwoTouches = [g[0].identifier, g[1].identifier]),
                  this._start([u[0], u[1]]));
              }
              touchmove(a, u, g) {
                const v = this._firstTwoTouches;
                if (!v) return;
                a.preventDefault();
                const [b, D] = v,
                  I = $a(g, u, b),
                  M = $a(g, u, D);
                if (!I || !M) return;
                const R = this._aroundCenter ? null : I.add(M).div(2);
                return this._move([I, M], R, a);
              }
              touchend(a, u, g) {
                if (!this._firstTwoTouches) return;
                const [v, b] = this._firstTwoTouches,
                  D = $a(g, u, v),
                  I = $a(g, u, b);
                (D && I) || (this._active && eo(), this.reset());
              }
              touchcancel() {
                this.reset();
              }
              enable(a) {
                (this._enabled = !0),
                  (this._aroundCenter = !!a && "center" === a.around);
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            function $a(f, a, u) {
              for (let g = 0; g < f.length; g++)
                if (f[g].identifier === u) return a[g];
            }
            function Ft(f, a) {
              return Math.log(f / a) / Math.LN2;
            }
            class Xh extends zl {
              reset() {
                super.reset(), (this._distance = 0), (this._startDistance = 0);
              }
              _start(a) {
                this._startDistance = this._distance = a[0].dist(a[1]);
              }
              _move(a, u) {
                const g = this._distance;
                if (
                  ((this._distance = a[0].dist(a[1])),
                  this._active ||
                    !(Math.abs(Ft(this._distance, this._startDistance)) < 0.1))
                )
                  return (
                    (this._active = !0),
                    { zoomDelta: Ft(this._distance, g), pinchAround: u }
                  );
              }
            }
            function mp(f, a) {
              return (180 * f.angleWith(a)) / Math.PI;
            }
            class gp extends zl {
              reset() {
                super.reset(),
                  (this._minDiameter = 0),
                  (this._startVector = void 0),
                  (this._vector = void 0);
              }
              _start(a) {
                (this._startVector = this._vector = a[0].sub(a[1])),
                  (this._minDiameter = a[0].dist(a[1]));
              }
              _move(a, u) {
                const g = this._vector;
                if (
                  ((this._vector = a[0].sub(a[1])),
                  g && (this._active || !this._isBelowThreshold(this._vector)))
                )
                  return (
                    (this._active = !0),
                    { bearingDelta: mp(this._vector, g), pinchAround: u }
                  );
              }
              _isBelowThreshold(a) {
                this._minDiameter = Math.min(this._minDiameter, a.mag());
                const u = (25 / (Math.PI * this._minDiameter)) * 360,
                  g = this._startVector;
                if (!g) return !1;
                const v = mp(a, g);
                return Math.abs(v) < u;
              }
            }
            function Qs(f) {
              return Math.abs(f.y) > Math.abs(f.x);
            }
            class _p extends zl {
              constructor(a) {
                super(), (this._map = a);
              }
              reset() {
                super.reset(),
                  (this._valid = void 0),
                  (this._firstMove = void 0),
                  (this._lastPoints = void 0);
              }
              _start(a) {
                (this._lastPoints = a),
                  Qs(a[0].sub(a[1])) && (this._valid = !1);
              }
              _move(a, u, g) {
                const v = this._lastPoints;
                if (!v) return;
                const b = a[0].sub(v[0]),
                  D = a[1].sub(v[1]);
                return (this._map._cooperativeGestures &&
                  !d.isFullscreen() &&
                  g.touches.length < 3) ||
                  ((this._valid = this.gestureBeginsVertically(
                    b,
                    D,
                    g.timeStamp
                  )),
                  !this._valid)
                  ? void 0
                  : ((this._lastPoints = a),
                    (this._active = !0),
                    { pitchDelta: ((b.y + D.y) / 2) * -0.5 });
              }
              gestureBeginsVertically(a, u, g) {
                if (void 0 !== this._valid) return this._valid;
                const v = a.mag() >= 2,
                  b = u.mag() >= 2;
                if (!v && !b) return;
                if (!v || !b)
                  return (
                    null == this._firstMove && (this._firstMove = g),
                    g - this._firstMove < 100 && void 0
                  );
                const D = a.y > 0 == u.y > 0;
                return Qs(a) && Qs(u) && D;
              }
            }
            const Kh = { panStep: 100, bearingStep: 15, pitchStep: 10 };
            class Uf {
              constructor() {
                const a = Kh;
                (this._panStep = a.panStep),
                  (this._bearingStep = a.bearingStep),
                  (this._pitchStep = a.pitchStep),
                  (this._rotationDisabled = !1);
              }
              blur() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              keydown(a) {
                if (a.altKey || a.ctrlKey || a.metaKey) return;
                let u = 0,
                  g = 0,
                  v = 0,
                  b = 0,
                  D = 0;
                switch (a.keyCode) {
                  case 61:
                  case 107:
                  case 171:
                  case 187:
                    u = 1;
                    break;
                  case 189:
                  case 109:
                  case 173:
                    u = -1;
                    break;
                  case 37:
                    a.shiftKey ? (g = -1) : (a.preventDefault(), (b = -1));
                    break;
                  case 39:
                    a.shiftKey ? (g = 1) : (a.preventDefault(), (b = 1));
                    break;
                  case 38:
                    a.shiftKey ? (v = 1) : (a.preventDefault(), (D = -1));
                    break;
                  case 40:
                    a.shiftKey ? (v = -1) : (a.preventDefault(), (D = 1));
                    break;
                  default:
                    return;
                }
                return (
                  this._rotationDisabled && ((g = 0), (v = 0)),
                  {
                    cameraAnimation: (I) => {
                      const M = I.getZoom();
                      I.easeTo(
                        {
                          duration: 300,
                          easeId: "keyboardHandler",
                          easing: yp,
                          zoom: u
                            ? Math.round(M) + u * (a.shiftKey ? 2 : 1)
                            : M,
                          bearing: I.getBearing() + g * this._bearingStep,
                          pitch: I.getPitch() + v * this._pitchStep,
                          offset: [-b * this._panStep, -D * this._panStep],
                          center: I.getCenter(),
                        },
                        { originalEvent: a }
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
              disableRotation() {
                this._rotationDisabled = !0;
              }
              enableRotation() {
                this._rotationDisabled = !1;
              }
            }
            function yp(f) {
              return f * (2 - f);
            }
            const Ze = 4.000244140625;
            class dn {
              constructor(a, u) {
                (this._map = a),
                  (this._el = a.getCanvasContainer()),
                  (this._handler = u),
                  (this._delta = 0),
                  (this._defaultZoomRate = 0.01),
                  (this._wheelZoomRate = 0.0022222222222222222),
                  d.bindAll(
                    [
                      "_onTimeout",
                      "_addScrollZoomBlocker",
                      "_showBlockerAlert",
                    ],
                    this
                  );
              }
              setZoomRate(a) {
                this._defaultZoomRate = a;
              }
              setWheelZoomRate(a) {
                this._wheelZoomRate = a;
              }
              isEnabled() {
                return !!this._enabled;
              }
              isActive() {
                return this._active || void 0 !== this._finishTimeout;
              }
              isZooming() {
                return !!this._zooming;
              }
              enable(a) {
                this.isEnabled() ||
                  ((this._enabled = !0),
                  (this._aroundCenter = !!a && "center" === a.around),
                  this._map._cooperativeGestures &&
                    this._addScrollZoomBlocker());
              }
              disable() {
                this.isEnabled() &&
                  ((this._enabled = !1),
                  this._map._cooperativeGestures &&
                    (clearTimeout(this._alertTimer),
                    this._alertContainer.remove()));
              }
              wheel(a) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                  if (
                    !(
                      a.ctrlKey ||
                      a.metaKey ||
                      this.isZooming() ||
                      d.isFullscreen()
                    )
                  )
                    return void this._showBlockerAlert();
                  "hidden" !== this._alertContainer.style.visibility &&
                    ((this._alertContainer.style.visibility = "hidden"),
                    clearTimeout(this._alertTimer));
                }
                let u =
                  a.deltaMode === d.window.WheelEvent.DOM_DELTA_LINE
                    ? 40 * a.deltaY
                    : a.deltaY;
                const g = d.exported.now(),
                  v = g - (this._lastWheelEventTime || 0);
                (this._lastWheelEventTime = g),
                  0 !== u && u % Ze == 0
                    ? (this._type = "wheel")
                    : 0 !== u && Math.abs(u) < 4
                    ? (this._type = "trackpad")
                    : v > 400
                    ? ((this._type = null),
                      (this._lastValue = u),
                      (this._timeout = setTimeout(this._onTimeout, 40, a)))
                    : this._type ||
                      ((this._type =
                        Math.abs(v * u) < 200 ? "trackpad" : "wheel"),
                      this._timeout &&
                        (clearTimeout(this._timeout),
                        (this._timeout = null),
                        (u += this._lastValue))),
                  a.shiftKey && u && (u /= 4),
                  this._type &&
                    ((this._lastWheelEvent = a),
                    (this._delta -= u),
                    this._active || this._start(a)),
                  a.preventDefault();
              }
              _onTimeout(a) {
                (this._type = "wheel"),
                  (this._delta -= this._lastValue),
                  this._active || this._start(a);
              }
              _start(a) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null),
                  (this._active = !0),
                  this.isZooming() || (this._zooming = !0),
                  this._finishTimeout &&
                    (clearTimeout(this._finishTimeout),
                    delete this._finishTimeout);
                const u = Ir(this._el, a);
                (this._aroundPoint = this._aroundCenter
                  ? this._map.transform.centerPoint
                  : u),
                  (this._aroundCoord = this._map.transform.pointCoordinate3D(
                    this._aroundPoint
                  )),
                  (this._targetZoom = void 0),
                  this._frameId ||
                    ((this._frameId = !0), this._handler._triggerRenderFrame());
              }
              renderFrame() {
                if (
                  !this._frameId ||
                  ((this._frameId = null), !this.isActive())
                )
                  return;
                const a = this._map.transform;
                "wheel" === this._type &&
                  a.projection.wrap &&
                  (a._center.lng >= 180 || a._center.lng <= -180) &&
                  ((this._prevEase = null),
                  (this._easing = null),
                  (this._lastWheelEvent = null),
                  (this._lastWheelEventTime = 0));
                const u = () =>
                  a._terrainEnabled() && this._aroundCoord
                    ? a.computeZoomRelativeTo(this._aroundCoord)
                    : a.zoom;
                if (0 !== this._delta) {
                  const M =
                    "wheel" === this._type && Math.abs(this._delta) > Ze
                      ? this._wheelZoomRate
                      : this._defaultZoomRate;
                  let R = 2 / (1 + Math.exp(-Math.abs(this._delta * M)));
                  this._delta < 0 && 0 !== R && (R = 1 / R);
                  const k = u(),
                    z = Math.pow(2, k),
                    H =
                      "number" == typeof this._targetZoom
                        ? a.zoomScale(this._targetZoom)
                        : z;
                  (this._targetZoom = Math.min(
                    a.maxZoom,
                    Math.max(a.minZoom, a.scaleZoom(H * R))
                  )),
                    "wheel" === this._type &&
                      ((this._startZoom = k),
                      (this._easing = this._smoothOutEasing(200))),
                    (this._delta = 0);
                }
                const g =
                    "number" == typeof this._targetZoom
                      ? this._targetZoom
                      : u(),
                  v = this._startZoom,
                  b = this._easing;
                let D,
                  I = !1;
                if ("wheel" === this._type && v && b) {
                  const M = Math.min(
                      (d.exported.now() - this._lastWheelEventTime) / 200,
                      1
                    ),
                    R = b(M);
                  (D = d.number(v, g, R)),
                    M < 1 ? this._frameId || (this._frameId = !0) : (I = !0);
                } else (D = g), (I = !0);
                return (
                  (this._active = !0),
                  I &&
                    ((this._active = !1),
                    (this._finishTimeout = setTimeout(() => {
                      (this._zooming = !1),
                        this._handler._triggerRenderFrame(),
                        delete this._targetZoom,
                        delete this._finishTimeout;
                    }, 200))),
                  {
                    noInertia: !0,
                    needsRenderFrame: !I,
                    zoomDelta: D - u(),
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent,
                  }
                );
              }
              _smoothOutEasing(a) {
                let u = d.ease;
                if (this._prevEase) {
                  const g = this._prevEase,
                    v = (d.exported.now() - g.start) / g.duration,
                    b = g.easing(v + 0.01) - g.easing(v),
                    D = (0.27 / Math.sqrt(b * b + 1e-4)) * 0.01,
                    I = Math.sqrt(0.0729 - D * D);
                  u = d.bezier(D, I, 0.25, 1);
                }
                return (
                  (this._prevEase = {
                    start: d.exported.now(),
                    duration: a,
                    easing: u,
                  }),
                  u
                );
              }
              blur() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              _addScrollZoomBlocker() {
                this._map &&
                  !this._alertContainer &&
                  ((this._alertContainer = Ot(
                    "div",
                    "mapboxgl-scroll-zoom-blocker",
                    this._map._container
                  )),
                  (this._alertContainer.textContent = /(Mac|iPad)/i.test(
                    d.window.navigator.userAgent
                  )
                    ? this._map._getUIString("ScrollZoomBlocker.CmdMessage")
                    : this._map._getUIString("ScrollZoomBlocker.CtrlMessage")),
                  (this._alertContainer.style.fontSize = `${Math.max(
                    10,
                    Math.min(24, Math.floor(0.05 * this._el.clientWidth))
                  )}px`));
              }
              _showBlockerAlert() {
                (this._alertContainer.style.visibility = "visible"),
                  this._alertContainer.classList.add(
                    "mapboxgl-scroll-zoom-blocker-show"
                  ),
                  this._alertContainer.setAttribute("role", "alert"),
                  clearTimeout(this._alertTimer),
                  (this._alertTimer = setTimeout(() => {
                    this._alertContainer.classList.remove(
                      "mapboxgl-scroll-zoom-blocker-show"
                    ),
                      this._alertContainer.setAttribute("role", "null");
                  }, 200));
              }
            }
            class Ha {
              constructor(a, u) {
                (this._clickZoom = a), (this._tapZoom = u);
              }
              enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
              }
              disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
              }
              isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
              }
              isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
              }
            }
            class fi {
              constructor() {
                this.reset();
              }
              reset() {
                this._active = !1;
              }
              blur() {
                this.reset();
              }
              dblclick(a, u) {
                return (
                  a.preventDefault(),
                  {
                    cameraAnimation: (g) => {
                      g.easeTo(
                        {
                          duration: 300,
                          zoom: g.getZoom() + (a.shiftKey ? -1 : 1),
                          around: g.unproject(u),
                        },
                        { originalEvent: a }
                      );
                    },
                  }
                );
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class Pi {
              constructor() {
                (this._tap = new Gh({ numTouches: 1, numTaps: 1 })),
                  this.reset();
              }
              reset() {
                (this._active = !1),
                  (this._swipePoint = void 0),
                  (this._swipeTouch = 0),
                  (this._tapTime = 0),
                  this._tap.reset();
              }
              touchstart(a, u, g) {
                this._swipePoint ||
                  (this._tapTime &&
                    a.timeStamp - this._tapTime > 500 &&
                    this.reset(),
                  this._tapTime
                    ? g.length > 0 &&
                      ((this._swipePoint = u[0]),
                      (this._swipeTouch = g[0].identifier))
                    : this._tap.touchstart(a, u, g));
              }
              touchmove(a, u, g) {
                if (this._tapTime) {
                  if (this._swipePoint) {
                    if (g[0].identifier !== this._swipeTouch) return;
                    const v = u[0],
                      b = v.y - this._swipePoint.y;
                    return (
                      (this._swipePoint = v),
                      a.preventDefault(),
                      (this._active = !0),
                      { zoomDelta: b / 128 }
                    );
                  }
                } else this._tap.touchmove(a, u, g);
              }
              touchend(a, u, g) {
                this._tapTime
                  ? this._swipePoint && 0 === g.length && this.reset()
                  : this._tap.touchend(a, u, g) &&
                    (this._tapTime = a.timeStamp);
              }
              touchcancel() {
                this.reset();
              }
              enable() {
                this._enabled = !0;
              }
              disable() {
                (this._enabled = !1), this.reset();
              }
              isEnabled() {
                return this._enabled;
              }
              isActive() {
                return this._active;
              }
            }
            class Yh {
              constructor(a, u, g) {
                (this._el = a), (this._mousePan = u), (this._touchPan = g);
              }
              enable(a) {
                (this._inertiaOptions = a || {}),
                  this._mousePan.enable(),
                  this._touchPan.enable(),
                  this._el.classList.add("mapboxgl-touch-drag-pan");
              }
              disable() {
                this._mousePan.disable(),
                  this._touchPan.disable(),
                  this._el.classList.remove("mapboxgl-touch-drag-pan");
              }
              isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
              }
              isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
              }
            }
            class Ic {
              constructor(a, u, g) {
                (this._pitchWithRotate = a.pitchWithRotate),
                  (this._mouseRotate = u),
                  (this._mousePitch = g);
              }
              enable() {
                this._mouseRotate.enable(),
                  this._pitchWithRotate && this._mousePitch.enable();
              }
              disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
              }
              isEnabled() {
                return (
                  this._mouseRotate.isEnabled() &&
                  (!this._pitchWithRotate || this._mousePitch.isEnabled())
                );
              }
              isActive() {
                return (
                  this._mouseRotate.isActive() || this._mousePitch.isActive()
                );
              }
            }
            class Xo {
              constructor(a, u, g, v) {
                (this._el = a),
                  (this._touchZoom = u),
                  (this._touchRotate = g),
                  (this._tapDragZoom = v),
                  (this._rotationDisabled = !1),
                  (this._enabled = !0);
              }
              enable(a) {
                this._touchZoom.enable(a),
                  this._rotationDisabled || this._touchRotate.enable(a),
                  this._tapDragZoom.enable(),
                  this._el.classList.add("mapboxgl-touch-zoom-rotate");
              }
              disable() {
                this._touchZoom.disable(),
                  this._touchRotate.disable(),
                  this._tapDragZoom.disable(),
                  this._el.classList.remove("mapboxgl-touch-zoom-rotate");
              }
              isEnabled() {
                return (
                  this._touchZoom.isEnabled() &&
                  (this._rotationDisabled || this._touchRotate.isEnabled()) &&
                  this._tapDragZoom.isEnabled()
                );
              }
              isActive() {
                return (
                  this._touchZoom.isActive() ||
                  this._touchRotate.isActive() ||
                  this._tapDragZoom.isActive()
                );
              }
              disableRotation() {
                (this._rotationDisabled = !0), this._touchRotate.disable();
              }
              enableRotation() {
                (this._rotationDisabled = !1),
                  this._touchZoom.isEnabled() && this._touchRotate.enable();
              }
            }
            const kr = (f) => f.zoom || f.drag || f.pitch || f.rotate;
            class Au extends d.Event {}
            class Ng {
              constructor() {
                (this.constants = [1, 1, 0.01]), (this.radius = 0);
              }
              setup(a, u) {
                const g = d.sub([], u, a);
                this.radius = d.length(
                  g[2] < 0 ? d.div([], g, this.constants) : [g[0], g[1], 0]
                );
              }
              projectRay(a) {
                d.div(a, a, this.constants),
                  d.normalize(a, a),
                  d.mul$1(a, a, this.constants);
                const u = d.scale$2([], a, this.radius);
                if (u[2] > 0) {
                  const g = d.scale$2([], [0, 0, 1], d.dot(u, [0, 0, 1])),
                    v = d.scale$2(
                      [],
                      d.normalize([], [u[0], u[1], 0]),
                      this.radius
                    ),
                    b = d.add(
                      [],
                      u,
                      d.scale$2([], d.sub([], d.add([], v, g), u), 2)
                    );
                  (u[0] = b[0]), (u[1] = b[1]);
                }
                return u;
              }
            }
            function So(f) {
              return (
                (f.panDelta && f.panDelta.mag()) ||
                f.zoomDelta ||
                f.bearingDelta ||
                f.pitchDelta
              );
            }
            class ms {
              constructor(a, u) {
                (this._map = a),
                  (this._el = this._map.getCanvasContainer()),
                  (this._handlers = []),
                  (this._handlersById = {}),
                  (this._changes = []),
                  (this._inertia = new Wr(a)),
                  (this._bearingSnap = u.bearingSnap),
                  (this._previousActiveHandlers = {}),
                  (this._trackingEllipsoid = new Ng()),
                  (this._dragOrigin = null),
                  (this._eventsInProgress = {}),
                  this._addDefaultHandlers(u),
                  d.bindAll(["handleEvent", "handleWindowEvent"], this);
                const g = this._el;
                this._listeners = [
                  [g, "touchstart", { passive: !0 }],
                  [g, "touchmove", { passive: !1 }],
                  [g, "touchend", void 0],
                  [g, "touchcancel", void 0],
                  [g, "mousedown", void 0],
                  [g, "mousemove", void 0],
                  [g, "mouseup", void 0],
                  [d.window.document, "mousemove", { capture: !0 }],
                  [d.window.document, "mouseup", void 0],
                  [g, "mouseover", void 0],
                  [g, "mouseout", void 0],
                  [g, "dblclick", void 0],
                  [g, "click", void 0],
                  [g, "keydown", { capture: !1 }],
                  [g, "keyup", void 0],
                  [g, "wheel", { passive: !1 }],
                  [g, "contextmenu", void 0],
                  [d.window, "blur", void 0],
                ];
                for (const [v, b, D] of this._listeners)
                  v.addEventListener(
                    b,
                    v === d.window.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    D
                  );
              }
              destroy() {
                for (const [a, u, g] of this._listeners)
                  a.removeEventListener(
                    u,
                    a === d.window.document
                      ? this.handleWindowEvent
                      : this.handleEvent,
                    g
                  );
              }
              _addDefaultHandlers(a) {
                const u = this._map,
                  g = u.getCanvasContainer();
                this._add("mapEvent", new ti(u, a));
                const v = (u.boxZoom = new jf(u, a));
                this._add("boxZoom", v);
                const b = new qh(),
                  D = new fi();
                (u.doubleClickZoom = new Ha(D, b)),
                  this._add("tapZoom", b),
                  this._add("clickZoom", D);
                const I = new Pi();
                this._add("tapDragZoom", I);
                const M = (u.touchPitch = new _p(u));
                this._add("touchPitch", M);
                const R = new Nl(a),
                  k = new Zh(a);
                (u.dragRotate = new Ic(a, R, k)),
                  this._add("mouseRotate", R, ["mousePitch"]),
                  this._add("mousePitch", k, ["mouseRotate"]);
                const z = new Wh(a),
                  H = new Do(u, a);
                (u.dragPan = new Yh(g, z, H)),
                  this._add("mousePan", z),
                  this._add("touchPan", H, ["touchZoom", "touchRotate"]);
                const q = new gp(),
                  X = new Xh();
                (u.touchZoomRotate = new Xo(g, X, q, I)),
                  this._add("touchRotate", q, ["touchPan", "touchZoom"]),
                  this._add("touchZoom", X, ["touchPan", "touchRotate"]),
                  this._add("blockableMapEvent", new Mu(u));
                const Z = (u.scrollZoom = new dn(u, this));
                this._add("scrollZoom", Z, ["mousePan"]);
                const Y = (u.keyboard = new Uf());
                this._add("keyboard", Y);
                for (const B of [
                  "boxZoom",
                  "doubleClickZoom",
                  "tapDragZoom",
                  "touchPitch",
                  "dragRotate",
                  "dragPan",
                  "touchZoomRotate",
                  "scrollZoom",
                  "keyboard",
                ])
                  a.interactive && a[B] && u[B].enable(a[B]);
              }
              _add(a, u, g) {
                this._handlers.push({ handlerName: a, handler: u, allowed: g }),
                  (this._handlersById[a] = u);
              }
              stop(a) {
                if (!this._updatingCamera) {
                  for (const { handler: u } of this._handlers) u.reset();
                  this._inertia.clear(),
                    this._fireEvents({}, {}, a),
                    (this._changes = []);
                }
              }
              isActive() {
                for (const { handler: a } of this._handlers)
                  if (a.isActive()) return !0;
                return !1;
              }
              isZooming() {
                return (
                  !!this._eventsInProgress.zoom ||
                  this._map.scrollZoom.isZooming()
                );
              }
              isRotating() {
                return !!this._eventsInProgress.rotate;
              }
              isMoving() {
                return !!kr(this._eventsInProgress) || this.isZooming();
              }
              _isDragging() {
                return !!this._eventsInProgress.drag;
              }
              _blockedByActive(a, u, g) {
                for (const v in a)
                  if (v !== g && (!u || u.indexOf(v) < 0)) return !0;
                return !1;
              }
              handleWindowEvent(a) {
                this.handleEvent(a, `${a.type}Window`);
              }
              _getMapTouches(a) {
                const u = [];
                for (const g of a) this._el.contains(g.target) && u.push(g);
                return u;
              }
              handleEvent(a, u) {
                this._updatingCamera = !0;
                const g = "renderFrame" === a.type,
                  v = g ? void 0 : a,
                  b = { needsRenderFrame: !1 },
                  D = {},
                  I = {},
                  M = a.touches ? this._getMapTouches(a.touches) : void 0,
                  R = M ? Sa(this._el, M) : g ? void 0 : Ir(this._el, a);
                for (const { handlerName: H, handler: q, allowed: X } of this
                  ._handlers) {
                  if (!q.isEnabled()) continue;
                  let Z;
                  this._blockedByActive(I, X, H)
                    ? q.reset()
                    : q[u || a.type] &&
                      ((Z = q[u || a.type](a, R, M)),
                      this.mergeHandlerResult(b, D, Z, H, v),
                      Z && Z.needsRenderFrame && this._triggerRenderFrame()),
                    (Z || q.isActive()) && (I[H] = q);
                }
                const k = {};
                for (const H in this._previousActiveHandlers)
                  I[H] || (k[H] = v);
                (this._previousActiveHandlers = I),
                  (Object.keys(k).length || So(b)) &&
                    (this._changes.push([b, D, k]), this._triggerRenderFrame()),
                  (Object.keys(I).length || So(b)) && this._map._stop(!0),
                  (this._updatingCamera = !1);
                const { cameraAnimation: z } = b;
                z &&
                  (this._inertia.clear(),
                  this._fireEvents({}, {}, !0),
                  (this._changes = []),
                  z(this._map));
              }
              mergeHandlerResult(a, u, g, v, b) {
                if (!g) return;
                d.extend(a, g);
                const D = {
                  handlerName: v,
                  originalEvent: g.originalEvent || b,
                };
                void 0 !== g.zoomDelta && (u.zoom = D),
                  void 0 !== g.panDelta && (u.drag = D),
                  void 0 !== g.pitchDelta && (u.pitch = D),
                  void 0 !== g.bearingDelta && (u.rotate = D);
              }
              _applyChanges() {
                const a = {},
                  u = {},
                  g = {};
                for (const [v, b, D] of this._changes)
                  v.panDelta &&
                    (a.panDelta = (a.panDelta || new d.Point(0, 0))._add(
                      v.panDelta
                    )),
                    v.zoomDelta &&
                      (a.zoomDelta = (a.zoomDelta || 0) + v.zoomDelta),
                    v.bearingDelta &&
                      (a.bearingDelta = (a.bearingDelta || 0) + v.bearingDelta),
                    v.pitchDelta &&
                      (a.pitchDelta = (a.pitchDelta || 0) + v.pitchDelta),
                    void 0 !== v.around && (a.around = v.around),
                    void 0 !== v.aroundCoord && (a.aroundCoord = v.aroundCoord),
                    void 0 !== v.pinchAround && (a.pinchAround = v.pinchAround),
                    v.noInertia && (a.noInertia = v.noInertia),
                    d.extend(u, b),
                    d.extend(g, D);
                this._updateMapTransform(a, u, g), (this._changes = []);
              }
              _updateMapTransform(a, u, g) {
                const v = this._map,
                  b = v.transform,
                  D = (W) => [W.x, W.y, W.z];
                if (
                  ((W) => {
                    const ee = this._eventsInProgress.drag;
                    return ee && !this._handlersById[ee.handlerName].isActive();
                  })() &&
                  !So(a)
                ) {
                  const W = b.zoom;
                  (b.cameraElevationReference = "sea"),
                    b.recenterOnTerrain(),
                    (b.cameraElevationReference = "ground"),
                    W !== b.zoom && this._map._update(!0);
                }
                if ((b._isCameraConstrained && v._stop(!0), !So(a)))
                  return void this._fireEvents(u, g, !0);
                let {
                  panDelta: I,
                  zoomDelta: M,
                  bearingDelta: R,
                  pitchDelta: k,
                  around: z,
                  aroundCoord: H,
                  pinchAround: q,
                } = a;
                b._isCameraConstrained &&
                  (M > 0 && (M = 0), (b._isCameraConstrained = !1)),
                  void 0 !== q && (z = q),
                  (M || ((W) => u[W] && !this._eventsInProgress[W])("drag")) &&
                    z &&
                    ((this._dragOrigin = D(b.pointCoordinate3D(z))),
                    this._trackingEllipsoid.setup(
                      b._camera.position,
                      this._dragOrigin
                    )),
                  (b.cameraElevationReference = "sea"),
                  v._stop(!0),
                  (z = z || v.transform.centerPoint),
                  R && (b.bearing += R),
                  k && (b.pitch += k),
                  b._updateCameraState();
                const X = [0, 0, 0];
                if (I)
                  if ("mercator" === b.projection.name) {
                    const W = this._trackingEllipsoid.projectRay(
                        b.screenPointToMercatorRay(z).dir
                      ),
                      ee = this._trackingEllipsoid.projectRay(
                        b.screenPointToMercatorRay(z.sub(I)).dir
                      );
                    (X[0] = ee[0] - W[0]), (X[1] = ee[1] - W[1]);
                  } else {
                    const W = b.pointCoordinate(z);
                    if ("globe" === b.projection.name) {
                      I = I.rotate(-b.angle);
                      const ee = b._pixelsPerMercatorPixel / b.worldSize;
                      (X[0] =
                        -I.x * d.mercatorScale(d.latFromMercatorY(W.y)) * ee),
                        (X[1] = -I.y * d.mercatorScale(b.center.lat) * ee);
                    } else {
                      const ee = b.pointCoordinate(z.sub(I));
                      W && ee && ((X[0] = ee.x - W.x), (X[1] = ee.y - W.y));
                    }
                  }
                const Z = b.zoom,
                  Y = [0, 0, 0];
                if (M) {
                  const W = D(H || b.pointCoordinate3D(z)),
                    ee = {
                      dir: d.normalize([], d.sub([], W, b._camera.position)),
                    };
                  if (ee.dir[2] < 0) {
                    const te = b.zoomDeltaToMovement(W, M);
                    d.scale$2(Y, ee.dir, te);
                  }
                }
                const B = d.add(X, X, Y);
                b._translateCameraConstrained(B),
                  M && Math.abs(b.zoom - Z) > 1e-4 && b.recenterOnTerrain(),
                  (b.cameraElevationReference = "ground"),
                  this._map._update(),
                  a.noInertia || this._inertia.record(a),
                  this._fireEvents(u, g, !0);
              }
              _fireEvents(a, u, g) {
                const v = kr(this._eventsInProgress),
                  b = kr(a),
                  D = {};
                for (const k in a) {
                  const { originalEvent: z } = a[k];
                  this._eventsInProgress[k] || (D[`${k}start`] = z),
                    (this._eventsInProgress[k] = a[k]);
                }
                !v && b && this._fireEvent("movestart", b.originalEvent);
                for (const k in D) this._fireEvent(k, D[k]);
                b && this._fireEvent("move", b.originalEvent);
                for (const k in a) {
                  const { originalEvent: z } = a[k];
                  this._fireEvent(k, z);
                }
                const I = {};
                let M;
                for (const k in this._eventsInProgress) {
                  const { handlerName: z, originalEvent: H } =
                    this._eventsInProgress[k];
                  this._handlersById[z].isActive() ||
                    (delete this._eventsInProgress[k],
                    (M = u[z] || H),
                    (I[`${k}end`] = M));
                }
                for (const k in I) this._fireEvent(k, I[k]);
                const R = kr(this._eventsInProgress);
                if (g && (v || b) && !R) {
                  this._updatingCamera = !0;
                  const k = this._inertia._onMoveEnd(
                      this._map.dragPan._inertiaOptions
                    ),
                    z = (H) =>
                      0 !== H &&
                      -this._bearingSnap < H &&
                      H < this._bearingSnap;
                  k
                    ? (z(k.bearing || this._map.getBearing()) &&
                        (k.bearing = 0),
                      this._map.easeTo(k, { originalEvent: M }))
                    : (this._map.fire(
                        new d.Event("moveend", { originalEvent: M })
                      ),
                      z(this._map.getBearing()) && this._map.resetNorth()),
                    (this._updatingCamera = !1);
                }
              }
              _fireEvent(a, u) {
                this._map.fire(new d.Event(a, u ? { originalEvent: u } : {}));
              }
              _requestFrame() {
                return (
                  this._map.triggerRepaint(),
                  this._map._renderTaskQueue.add((a) => {
                    (this._frameId = void 0),
                      this.handleEvent(new Au("renderFrame", { timeStamp: a })),
                      this._applyChanges();
                  })
                );
              }
              _triggerRenderFrame() {
                void 0 === this._frameId &&
                  (this._frameId = this._requestFrame());
              }
            }
            const Js =
              "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
            class Vi extends d.Evented {
              constructor(a, u) {
                super(),
                  (this._moving = !1),
                  (this._zooming = !1),
                  (this.transform = a),
                  (this._bearingSnap = u.bearingSnap),
                  (this._respectPrefersReducedMotion =
                    !1 !== u.respectPrefersReducedMotion),
                  d.bindAll(["_renderFrameCallback"], this);
              }
              getCenter() {
                return new d.LngLat(
                  this.transform.center.lng,
                  this.transform.center.lat
                );
              }
              setCenter(a, u) {
                return this.jumpTo({ center: a }, u);
              }
              panBy(a, u, g) {
                return (
                  (a = d.Point.convert(a).mult(-1)),
                  this.panTo(
                    this.transform.center,
                    d.extend({ offset: a }, u),
                    g
                  )
                );
              }
              panTo(a, u, g) {
                return this.easeTo(d.extend({ center: a }, u), g);
              }
              getZoom() {
                return this.transform.zoom;
              }
              setZoom(a, u) {
                return this.jumpTo({ zoom: a }, u), this;
              }
              zoomTo(a, u, g) {
                return this.easeTo(d.extend({ zoom: a }, u), g);
              }
              zoomIn(a, u) {
                return this.zoomTo(this.getZoom() + 1, a, u), this;
              }
              zoomOut(a, u) {
                return this.zoomTo(this.getZoom() - 1, a, u), this;
              }
              getBearing() {
                return this.transform.bearing;
              }
              setBearing(a, u) {
                return this.jumpTo({ bearing: a }, u), this;
              }
              getPadding() {
                return this.transform.padding;
              }
              setPadding(a, u) {
                return this.jumpTo({ padding: a }, u), this;
              }
              rotateTo(a, u, g) {
                return this.easeTo(d.extend({ bearing: a }, u), g);
              }
              resetNorth(a, u) {
                return (
                  this.rotateTo(0, d.extend({ duration: 1e3 }, a), u), this
                );
              }
              resetNorthPitch(a, u) {
                return (
                  this.easeTo(
                    d.extend({ bearing: 0, pitch: 0, duration: 1e3 }, a),
                    u
                  ),
                  this
                );
              }
              snapToNorth(a, u) {
                return Math.abs(this.getBearing()) < this._bearingSnap
                  ? this.resetNorth(a, u)
                  : this;
              }
              getPitch() {
                return this.transform.pitch;
              }
              setPitch(a, u) {
                return this.jumpTo({ pitch: a }, u), this;
              }
              cameraForBounds(a, u) {
                a = d.LngLatBounds.convert(a);
                const g = (u && u.bearing) || 0,
                  v = (u && u.pitch) || 0,
                  b = a.getNorthWest(),
                  D = a.getSouthEast();
                return this._cameraForBounds(this.transform, b, D, g, v, u);
              }
              _extendCameraOptions(a) {
                const u = { top: 0, bottom: 0, right: 0, left: 0 };
                if (
                  "number" ==
                  typeof (a = d.extend(
                    {
                      padding: u,
                      offset: [0, 0],
                      maxZoom: this.transform.maxZoom,
                    },
                    a
                  )).padding
                ) {
                  const g = a.padding;
                  a.padding = { top: g, bottom: g, right: g, left: g };
                }
                return (a.padding = d.extend(u, a.padding)), a;
              }
              _minimumAABBFrustumDistance(a, u) {
                const g = u.max[0] - u.min[0],
                  v = u.max[1] - u.min[1];
                return g / v > a.aspect
                  ? g / (2 * Math.tan(0.5 * a.fovX) * a.aspect)
                  : v / (2 * Math.tan(0.5 * a.fovY) * a.aspect);
              }
              _cameraForBoundsOnGlobe(a, u, g, v, b, D) {
                const I = a.clone(),
                  M = this._extendCameraOptions(D);
                (I.bearing = v), (I.pitch = b);
                const R = d.LngLat.convert(u),
                  k = d.LngLat.convert(g),
                  z = 0.5 * (R.lat + k.lat),
                  H = 0.5 * (R.lng + k.lng),
                  q = d.latLngToECEF(z, H),
                  X = d.normalize([], q),
                  Z = d.normalize([], d.cross([], X, [0, 1, 0])),
                  Y = d.cross([], Z, X),
                  B = [
                    Z[0],
                    Z[1],
                    Z[2],
                    0,
                    Y[0],
                    Y[1],
                    Y[2],
                    0,
                    X[0],
                    X[1],
                    X[2],
                    0,
                    0,
                    0,
                    0,
                    1,
                  ],
                  W = [
                    q,
                    d.latLngToECEF(R.lat, R.lng),
                    d.latLngToECEF(k.lat, R.lng),
                    d.latLngToECEF(k.lat, k.lng),
                    d.latLngToECEF(R.lat, k.lng),
                    d.latLngToECEF(z, R.lng),
                    d.latLngToECEF(z, k.lng),
                    d.latLngToECEF(R.lat, H),
                    d.latLngToECEF(k.lat, H),
                  ];
                let ee = d.Aabb.fromPoints(
                  W.map((Ne) => [d.dot(Z, Ne), d.dot(Y, Ne), d.dot(X, Ne)])
                );
                const te = d.transformMat4([], ee.center, B);
                0 === d.squaredLength(te) && d.set(te, 0, 0, 1),
                  d.normalize(te, te),
                  d.scale$2(te, te, d.GLOBE_RADIUS),
                  (I.center = d.ecefToLatLng(te));
                const he = I.getWorldToCameraMatrix(),
                  de = d.invert(new Float64Array(16), he);
                (ee = d.Aabb.applyTransform(ee, d.multiply([], he, B))),
                  d.transformMat4(te, te, he);
                const ue = 0.5 * (ee.max[2] - ee.min[2]),
                  _e = this._minimumAABBFrustumDistance(I, ee),
                  ge = d.scale$2([], [0, 0, 1], ue),
                  Te = d.add(ge, te, ge),
                  Ge = _e + (0 === I.pitch ? 0 : d.distance(te, Te)),
                  be = I.globeCenterInViewSpace,
                  Le = d.sub([], te, [be[0], be[1], be[2]]);
                d.normalize(Le, Le), d.scale$2(Le, Le, Ge);
                const Ie = d.add([], te, Le);
                d.transformMat4(Ie, Ie, de);
                const je = d.earthRadius / d.GLOBE_RADIUS,
                  we = d.length(Ie),
                  ke = d.mercatorZfromAltitude(
                    Math.max(we * je - d.earthRadius, Number.EPSILON),
                    0
                  ),
                  He = Math.min(I.zoomFromMercatorZAdjusted(ke), M.maxZoom);
                return He >
                  0.5 *
                    (d.GLOBE_ZOOM_THRESHOLD_MIN + d.GLOBE_ZOOM_THRESHOLD_MAX)
                  ? (I.setProjection({ name: "mercator" }),
                    (I.zoom = He),
                    this._cameraForBounds(I, u, g, v, b, D))
                  : { center: I.center, zoom: He, bearing: v, pitch: b };
              }
              queryTerrainElevation(a, u) {
                const g = this.transform.elevation;
                return g
                  ? ((u = d.extend({}, { exaggerated: !0 }, u)),
                    g.getAtPoint(
                      d.MercatorCoordinate.fromLngLat(a),
                      null,
                      u.exaggerated
                    ))
                  : null;
              }
              _cameraForBounds(a, u, g, v, b, D) {
                if ("globe" === a.projection.name)
                  return this._cameraForBoundsOnGlobe(a, u, g, v, b, D);
                const I = a.clone(),
                  M = this._extendCameraOptions(D),
                  R = I.padding;
                (I.bearing = v), (I.pitch = b);
                const k = d.LngLat.convert(u),
                  z = d.LngLat.convert(g),
                  H = new d.LngLat(k.lng, z.lat),
                  q = new d.LngLat(z.lng, k.lat),
                  X = I.project(k),
                  Z = I.project(z),
                  Y = this.queryTerrainElevation(k),
                  B = this.queryTerrainElevation(z),
                  W = this.queryTerrainElevation(H),
                  ee = this.queryTerrainElevation(q),
                  te = [
                    [X.x, X.y, Math.min(Y || 0, B || 0, W || 0, ee || 0)],
                    [Z.x, Z.y, Math.max(Y || 0, B || 0, W || 0, ee || 0)],
                  ];
                let he = d.Aabb.fromPoints(te);
                const de = I.getWorldToCameraMatrix(),
                  ue = d.invert(new Float64Array(16), de);
                he = d.Aabb.applyTransform(he, de);
                const _e = d.sub([], he.max, he.min),
                  ge = R.left || 0,
                  Te = R.right || 0,
                  Ge = R.bottom || 0,
                  be = R.top || 0,
                  { left: Le, right: Ie, top: je, bottom: we } = M.padding,
                  ke = 0.5 * (ge + Te),
                  He = 0.5 * (be + Ge),
                  Ne = Math.min(
                    I.scaleZoom(
                      I.scale *
                        Math.min(
                          (I.width - (ge + Te + Le + Ie)) / _e[0],
                          (I.height - (Ge + be + we + je)) / _e[1]
                        )
                    ),
                    M.maxZoom
                  ),
                  Xe = I.scale / I.zoomScale(Ne);
                he = new d.Aabb(
                  [
                    he.min[0] - (Le + ke) * Xe,
                    he.min[1] - (we + He) * Xe,
                    he.min[2],
                  ],
                  [
                    he.max[0] + (Ie + ke) * Xe,
                    he.max[1] + (je + He) * Xe,
                    he.max[2],
                  ]
                );
                const dt = 0.5 * _e[2],
                  Dt = this._minimumAABBFrustumDistance(I, he),
                  ct = [0, 0, 1, 0];
                d.transformMat4$1(ct, ct, de), d.normalize$2(ct, ct);
                const wt = d.scale$2([], ct, Dt + dt),
                  Wt = d.add([], he.center, wt),
                  jt = (
                    "number" == typeof M.offset.x &&
                    "number" == typeof M.offset.y
                      ? new d.Point(M.offset.x, M.offset.y)
                      : d.Point.convert(M.offset)
                  ).rotate(-d.degToRad(v));
                (he.center[0] -= jt.x * Xe),
                  (he.center[1] += jt.y * Xe),
                  d.transformMat4(he.center, he.center, ue),
                  d.transformMat4(Wt, Wt, ue);
                const ft = [
                  he.center[0],
                  he.center[1],
                  Wt[2] * I.pixelsPerMeter,
                ];
                d.scale$2(ft, ft, 1 / I.worldSize);
                const Yt = d.lngFromMercatorX(ft[0]),
                  kn = d.latFromMercatorY(ft[1]),
                  fn = Math.min(I._zoomFromMercatorZ(ft[2]), M.maxZoom),
                  Tn = new d.LngLat(Yt, kn);
                return I.mercatorFromTransition &&
                  fn <
                    0.5 *
                      (d.GLOBE_ZOOM_THRESHOLD_MIN + d.GLOBE_ZOOM_THRESHOLD_MAX)
                  ? (I.setProjection({ name: "globe" }),
                    (I.zoom = fn),
                    this._cameraForBounds(I, u, g, v, b, D))
                  : { center: Tn, zoom: fn, bearing: v, pitch: b };
              }
              fitBounds(a, u, g) {
                const v = this.cameraForBounds(a, u);
                return this._fitInternal(v, u, g);
              }
              fitScreenCoordinates(a, u, g, v, b) {
                const D = d.Point.convert(a),
                  I = d.Point.convert(u),
                  M = new d.Point(Math.min(D.x, I.x), Math.min(D.y, I.y)),
                  R = new d.Point(Math.max(D.x, I.x), Math.max(D.y, I.y));
                if (
                  "mercator" === this.transform.projection.name &&
                  this.transform.anyCornerOffEdge(D, I)
                )
                  return this;
                const k = this.transform.pointLocation3D(M),
                  z = this.transform.pointLocation3D(R),
                  H = this.transform.pointLocation3D(new d.Point(M.x, R.y)),
                  q = this.transform.pointLocation3D(new d.Point(R.x, M.y)),
                  X = [
                    Math.min(k.lng, z.lng, H.lng, q.lng),
                    Math.min(k.lat, z.lat, H.lat, q.lat),
                  ],
                  Z = [
                    Math.max(k.lng, z.lng, H.lng, q.lng),
                    Math.max(k.lat, z.lat, H.lat, q.lat),
                  ],
                  Y = v && v.pitch ? v.pitch : this.getPitch(),
                  B = this._cameraForBounds(this.transform, X, Z, g, Y, v);
                return this._fitInternal(B, v, b);
              }
              _fitInternal(a, u, g) {
                return a
                  ? (delete (u = d.extend(a, u)).padding,
                    u.linear ? this.easeTo(u, g) : this.flyTo(u, g))
                  : this;
              }
              jumpTo(a, u) {
                this.stop();
                const g = a.preloadOnly
                  ? this.transform.clone()
                  : this.transform;
                let v = !1,
                  b = !1,
                  D = !1;
                return (
                  "zoom" in a &&
                    g.zoom !== +a.zoom &&
                    ((v = !0), (g.zoom = +a.zoom)),
                  void 0 !== a.center &&
                    (g.center = d.LngLat.convert(a.center)),
                  "bearing" in a &&
                    g.bearing !== +a.bearing &&
                    ((b = !0), (g.bearing = +a.bearing)),
                  "pitch" in a &&
                    g.pitch !== +a.pitch &&
                    ((D = !0), (g.pitch = +a.pitch)),
                  null == a.padding ||
                    g.isPaddingEqual(a.padding) ||
                    (g.padding = a.padding),
                  a.preloadOnly
                    ? (this._preloadTiles(g), this)
                    : (this.fire(new d.Event("movestart", u)).fire(
                        new d.Event("move", u)
                      ),
                      v &&
                        this.fire(new d.Event("zoomstart", u))
                          .fire(new d.Event("zoom", u))
                          .fire(new d.Event("zoomend", u)),
                      b &&
                        this.fire(new d.Event("rotatestart", u))
                          .fire(new d.Event("rotate", u))
                          .fire(new d.Event("rotateend", u)),
                      D &&
                        this.fire(new d.Event("pitchstart", u))
                          .fire(new d.Event("pitch", u))
                          .fire(new d.Event("pitchend", u)),
                      this.fire(new d.Event("moveend", u)))
                );
              }
              getFreeCameraOptions() {
                return (
                  this.transform.projection.supportsFreeCamera ||
                    d.warnOnce(Js),
                  this.transform.getFreeCameraOptions()
                );
              }
              setFreeCameraOptions(a, u) {
                const g = this.transform;
                if (!g.projection.supportsFreeCamera)
                  return d.warnOnce(Js), this;
                this.stop();
                const v = g.zoom,
                  b = g.pitch,
                  D = g.bearing;
                g.setFreeCameraOptions(a);
                const I = v !== g.zoom,
                  M = b !== g.pitch,
                  R = D !== g.bearing;
                return (
                  this.fire(new d.Event("movestart", u)).fire(
                    new d.Event("move", u)
                  ),
                  I &&
                    this.fire(new d.Event("zoomstart", u))
                      .fire(new d.Event("zoom", u))
                      .fire(new d.Event("zoomend", u)),
                  R &&
                    this.fire(new d.Event("rotatestart", u))
                      .fire(new d.Event("rotate", u))
                      .fire(new d.Event("rotateend", u)),
                  M &&
                    this.fire(new d.Event("pitchstart", u))
                      .fire(new d.Event("pitch", u))
                      .fire(new d.Event("pitchend", u)),
                  this.fire(new d.Event("moveend", u)),
                  this
                );
              }
              easeTo(a, u) {
                this._stop(!1, a.easeId),
                  (!1 ===
                    (a = d.extend(
                      { offset: [0, 0], duration: 500, easing: d.ease },
                      a
                    )).animate ||
                    this._prefersReducedMotion(a)) &&
                    (a.duration = 0);
                const g = this.transform,
                  v = this.getZoom(),
                  b = this.getBearing(),
                  D = this.getPitch(),
                  I = this.getPadding(),
                  M = "zoom" in a ? +a.zoom : v,
                  R = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b,
                  k = "pitch" in a ? +a.pitch : D,
                  z = "padding" in a ? a.padding : g.padding,
                  H = d.Point.convert(a.offset);
                let q, X, Z;
                if ("globe" === g.projection.name) {
                  const ge = d.MercatorCoordinate.fromLngLat(g.center),
                    Te = H.rotate(-g.angle);
                  (ge.x += Te.x / g.worldSize), (ge.y += Te.y / g.worldSize);
                  const Ge = ge.toLngLat(),
                    be = d.LngLat.convert(a.center || Ge);
                  this._normalizeCenter(be),
                    (q = g.centerPoint.add(Te)),
                    (X = new d.Point(ge.x, ge.y).mult(g.worldSize)),
                    (Z = new d.Point(
                      d.mercatorXfromLng(be.lng),
                      d.mercatorYfromLat(be.lat)
                    )
                      .mult(g.worldSize)
                      .sub(X));
                } else {
                  q = g.centerPoint.add(H);
                  const ge = g.pointLocation(q),
                    Te = d.LngLat.convert(a.center || ge);
                  this._normalizeCenter(Te),
                    (X = g.project(ge)),
                    (Z = g.project(Te).sub(X));
                }
                const Y = g.zoomScale(M - v);
                let B, W;
                a.around &&
                  ((B = d.LngLat.convert(a.around)), (W = g.locationPoint(B)));
                const ee = this._zooming || M !== v,
                  te = this._rotating || b !== R,
                  he = this._pitching || k !== D,
                  de = !g.isPaddingEqual(z),
                  ue = (ge) => (Te) => {
                    if (
                      (ee && (ge.zoom = d.number(v, M, Te)),
                      te && (ge.bearing = d.number(b, R, Te)),
                      he && (ge.pitch = d.number(D, k, Te)),
                      de &&
                        (ge.interpolatePadding(I, z, Te),
                        (q = ge.centerPoint.add(H))),
                      B)
                    )
                      ge.setLocationAtPoint(B, W);
                    else {
                      const Ge = ge.zoomScale(ge.zoom - v),
                        be = M > v ? Math.min(2, Y) : Math.max(0.5, Y),
                        Le = Math.pow(be, 1 - Te),
                        Ie = ge.unproject(X.add(Z.mult(Te * Le)).mult(Ge));
                      ge.setLocationAtPoint(
                        ge.renderWorldCopies ? Ie.wrap() : Ie,
                        q
                      );
                    }
                    return a.preloadOnly || this._fireMoveEvents(u), ge;
                  };
                if (a.preloadOnly) {
                  const ge = this._emulate(ue, a.duration, g);
                  return this._preloadTiles(ge), this;
                }
                const _e = {
                  moving: this._moving,
                  zooming: this._zooming,
                  rotating: this._rotating,
                  pitching: this._pitching,
                };
                return (
                  (this._zooming = ee),
                  (this._rotating = te),
                  (this._pitching = he),
                  (this._padding = de),
                  (this._easeId = a.easeId),
                  this._prepareEase(u, a.noMoveStart, _e),
                  this._ease(
                    ue(g),
                    (ge) => {
                      g.recenterOnTerrain(), this._afterEase(u, ge);
                    },
                    a
                  ),
                  this
                );
              }
              _prepareEase(a, u, g = {}) {
                (this._moving = !0),
                  (this.transform.cameraElevationReference = "sea"),
                  u || g.moving || this.fire(new d.Event("movestart", a)),
                  this._zooming &&
                    !g.zooming &&
                    this.fire(new d.Event("zoomstart", a)),
                  this._rotating &&
                    !g.rotating &&
                    this.fire(new d.Event("rotatestart", a)),
                  this._pitching &&
                    !g.pitching &&
                    this.fire(new d.Event("pitchstart", a));
              }
              _fireMoveEvents(a) {
                this.fire(new d.Event("move", a)),
                  this._zooming && this.fire(new d.Event("zoom", a)),
                  this._rotating && this.fire(new d.Event("rotate", a)),
                  this._pitching && this.fire(new d.Event("pitch", a));
              }
              _afterEase(a, u) {
                if (this._easeId && u && this._easeId === u) return;
                (this._easeId = void 0),
                  (this.transform.cameraElevationReference = "ground");
                const g = this._zooming,
                  v = this._rotating,
                  b = this._pitching;
                (this._moving = !1),
                  (this._zooming = !1),
                  (this._rotating = !1),
                  (this._pitching = !1),
                  (this._padding = !1),
                  g && this.fire(new d.Event("zoomend", a)),
                  v && this.fire(new d.Event("rotateend", a)),
                  b && this.fire(new d.Event("pitchend", a)),
                  this.fire(new d.Event("moveend", a));
              }
              flyTo(a, u) {
                if (this._prefersReducedMotion(a)) {
                  const Ne = d.pick(a, [
                    "center",
                    "zoom",
                    "bearing",
                    "pitch",
                    "around",
                  ]);
                  return this.jumpTo(Ne, u);
                }
                this.stop(),
                  (a = d.extend(
                    { offset: [0, 0], speed: 1.2, curve: 1.42, easing: d.ease },
                    a
                  ));
                const g = this.transform,
                  v = this.getZoom(),
                  b = this.getBearing(),
                  D = this.getPitch(),
                  I = this.getPadding(),
                  M = "zoom" in a ? d.clamp(+a.zoom, g.minZoom, g.maxZoom) : v,
                  R = "bearing" in a ? this._normalizeBearing(a.bearing, b) : b,
                  k = "pitch" in a ? +a.pitch : D,
                  z = "padding" in a ? a.padding : g.padding,
                  H = g.zoomScale(M - v),
                  q = d.Point.convert(a.offset);
                let X = g.centerPoint.add(q);
                const Z = g.pointLocation(X),
                  Y = d.LngLat.convert(a.center || Z);
                this._normalizeCenter(Y);
                const B = g.project(Z),
                  W = g.project(Y).sub(B);
                let ee = a.curve;
                const te = Math.max(g.width, g.height),
                  he = te / H,
                  de = W.mag();
                if ("minZoom" in a) {
                  const Ne = d.clamp(
                      Math.min(a.minZoom, v, M),
                      g.minZoom,
                      g.maxZoom
                    ),
                    Xe = te / g.zoomScale(Ne - v);
                  ee = Math.sqrt((Xe / de) * 2);
                }
                const ue = ee * ee;
                function _e(Ne) {
                  const Xe =
                    (he * he - te * te + (Ne ? -1 : 1) * ue * ue * de * de) /
                    (2 * (Ne ? he : te) * ue * de);
                  return Math.log(Math.sqrt(Xe * Xe + 1) - Xe);
                }
                function ge(Ne) {
                  return (Math.exp(Ne) - Math.exp(-Ne)) / 2;
                }
                function Te(Ne) {
                  return (Math.exp(Ne) + Math.exp(-Ne)) / 2;
                }
                const Ge = _e(0);
                let be = function (Ne) {
                    return Te(Ge) / Te(Ge + ee * Ne);
                  },
                  Le = function (Ne) {
                    return (
                      (te *
                        ((Te(Ge) * (ge((Xe = Ge + ee * Ne)) / Te(Xe)) -
                          ge(Ge)) /
                          ue)) /
                      de
                    );
                    var Xe;
                  },
                  Ie = (_e(1) - Ge) / ee;
                if (Math.abs(de) < 1e-6 || !isFinite(Ie)) {
                  if (Math.abs(te - he) < 1e-6) return this.easeTo(a, u);
                  const Ne = he < te ? -1 : 1;
                  (Ie = Math.abs(Math.log(he / te)) / ee),
                    (Le = function () {
                      return 0;
                    }),
                    (be = function (Xe) {
                      return Math.exp(Ne * ee * Xe);
                    });
                }
                (a.duration =
                  "duration" in a
                    ? +a.duration
                    : (1e3 * Ie) /
                      ("screenSpeed" in a ? +a.screenSpeed / ee : +a.speed)),
                  a.maxDuration &&
                    a.duration > a.maxDuration &&
                    (a.duration = 0);
                const je = b !== R,
                  we = k !== D,
                  ke = !g.isPaddingEqual(z),
                  He = (Ne) => (Xe) => {
                    const dt = Xe * Ie,
                      Dt = 1 / be(dt);
                    (Ne.zoom = 1 === Xe ? M : v + Ne.scaleZoom(Dt)),
                      je && (Ne.bearing = d.number(b, R, Xe)),
                      we && (Ne.pitch = d.number(D, k, Xe)),
                      ke &&
                        (Ne.interpolatePadding(I, z, Xe),
                        (X = Ne.centerPoint.add(q)));
                    const ct =
                      1 === Xe
                        ? Y
                        : Ne.unproject(B.add(W.mult(Le(dt))).mult(Dt));
                    return (
                      Ne.setLocationAtPoint(
                        Ne.renderWorldCopies ? ct.wrap() : ct,
                        X
                      ),
                      Ne._updateCameraOnTerrain(),
                      a.preloadOnly || this._fireMoveEvents(u),
                      Ne
                    );
                  };
                if (a.preloadOnly) {
                  const Ne = this._emulate(He, a.duration, g);
                  return this._preloadTiles(Ne), this;
                }
                return (
                  (this._zooming = !0),
                  (this._rotating = je),
                  (this._pitching = we),
                  (this._padding = ke),
                  this._prepareEase(u, !1),
                  this._ease(He(g), () => this._afterEase(u), a),
                  this
                );
              }
              isEasing() {
                return !!this._easeFrameId;
              }
              stop() {
                return this._stop();
              }
              _stop(a, u) {
                if (
                  (this._easeFrameId &&
                    (this._cancelRenderFrame(this._easeFrameId),
                    (this._easeFrameId = void 0),
                    (this._onEaseFrame = void 0)),
                  this._onEaseEnd)
                ) {
                  const g = this._onEaseEnd;
                  (this._onEaseEnd = void 0), g.call(this, u);
                }
                if (!a) {
                  const g = this.handlers;
                  g && g.stop(!1);
                }
                return this;
              }
              _ease(a, u, g) {
                !1 === g.animate || 0 === g.duration
                  ? (a(1), u())
                  : ((this._easeStart = d.exported.now()),
                    (this._easeOptions = g),
                    (this._onEaseFrame = a),
                    (this._onEaseEnd = u),
                    (this._easeFrameId = this._requestRenderFrame(
                      this._renderFrameCallback
                    )));
              }
              _renderFrameCallback() {
                const a = Math.min(
                    (d.exported.now() - this._easeStart) /
                      this._easeOptions.duration,
                    1
                  ),
                  u = this._onEaseFrame;
                u && u(this._easeOptions.easing(a)),
                  a < 1
                    ? (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback
                      ))
                    : this.stop();
              }
              _normalizeBearing(a, u) {
                a = d.wrap(a, -180, 180);
                const g = Math.abs(a - u);
                return (
                  Math.abs(a - 360 - u) < g && (a -= 360),
                  Math.abs(a + 360 - u) < g && (a += 360),
                  a
                );
              }
              _normalizeCenter(a) {
                const u = this.transform;
                if (!u.renderWorldCopies || u.maxBounds) return;
                const g = a.lng - u.center.lng;
                a.lng += g > 180 ? -360 : g < -180 ? 360 : 0;
              }
              _prefersReducedMotion(a) {
                return (
                  this._respectPrefersReducedMotion &&
                  d.exported.prefersReducedMotion &&
                  !(a && a.essential)
                );
              }
              _emulate(a, u, g) {
                const v = Math.ceil((15 * u) / 1e3),
                  b = [],
                  D = a(g.clone());
                for (let I = 0; I <= v; I++) {
                  const M = D(I / v);
                  b.push(M.clone());
                }
                return b;
              }
            }
            class st {
              constructor(a = {}) {
                (this.options = a),
                  d.bindAll(
                    [
                      "_toggleAttribution",
                      "_updateEditLink",
                      "_updateData",
                      "_updateCompact",
                    ],
                    this
                  );
              }
              getDefaultPosition() {
                return "bottom-right";
              }
              onAdd(a) {
                const u = this.options && this.options.compact;
                return (
                  (this._map = a),
                  (this._container = Ot(
                    "div",
                    "mapboxgl-ctrl mapboxgl-ctrl-attrib"
                  )),
                  (this._compactButton = Ot(
                    "button",
                    "mapboxgl-ctrl-attrib-button",
                    this._container
                  )),
                  Ot(
                    "span",
                    "mapboxgl-ctrl-icon",
                    this._compactButton
                  ).setAttribute("aria-hidden", "true"),
                  (this._compactButton.type = "button"),
                  this._compactButton.addEventListener(
                    "click",
                    this._toggleAttribution
                  ),
                  this._setElementTitle(
                    this._compactButton,
                    "ToggleAttribution"
                  ),
                  (this._innerContainer = Ot(
                    "div",
                    "mapboxgl-ctrl-attrib-inner",
                    this._container
                  )),
                  this._innerContainer.setAttribute("role", "list"),
                  u && this._container.classList.add("mapboxgl-compact"),
                  this._updateAttributions(),
                  this._updateEditLink(),
                  this._map.on("styledata", this._updateData),
                  this._map.on("sourcedata", this._updateData),
                  this._map.on("moveend", this._updateEditLink),
                  void 0 === u &&
                    (this._map.on("resize", this._updateCompact),
                    this._updateCompact()),
                  this._container
                );
              }
              onRemove() {
                this._container.remove(),
                  this._map.off("styledata", this._updateData),
                  this._map.off("sourcedata", this._updateData),
                  this._map.off("moveend", this._updateEditLink),
                  this._map.off("resize", this._updateCompact),
                  (this._map = void 0),
                  (this._attribHTML = void 0);
              }
              _setElementTitle(a, u) {
                const g = this._map._getUIString(`AttributionControl.${u}`);
                a.setAttribute("aria-label", g),
                  a.removeAttribute("title"),
                  a.firstElementChild &&
                    a.firstElementChild.setAttribute("title", g);
              }
              _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show")
                  ? (this._container.classList.remove("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "false"))
                  : (this._container.classList.add("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "true"));
              }
              _updateEditLink() {
                let a = this._editLink;
                a ||
                  (a = this._editLink =
                    this._container.querySelector(".mapbox-improve-map"));
                const u = [
                  { key: "owner", value: this.styleOwner },
                  { key: "id", value: this.styleId },
                  {
                    key: "access_token",
                    value:
                      this._map._requestManager._customAccessToken ||
                      d.config.ACCESS_TOKEN,
                  },
                ];
                if (a) {
                  const g = u.reduce(
                    (v, b, D) => (
                      b.value &&
                        (v += `${b.key}=${b.value}${
                          D < u.length - 1 ? "&" : ""
                        }`),
                      v
                    ),
                    "?"
                  );
                  (a.href = `${d.config.FEEDBACK_URL}/${g}#${Ec(
                    this._map,
                    !0
                  )}`),
                    (a.rel = "noopener nofollow"),
                    this._setElementTitle(a, "MapFeedback");
                }
              }
              _updateData(a) {
                !a ||
                  ("metadata" !== a.sourceDataType &&
                    "visibility" !== a.sourceDataType &&
                    "style" !== a.dataType) ||
                  (this._updateAttributions(), this._updateEditLink());
              }
              _updateAttributions() {
                if (!this._map.style) return;
                let a = [];
                if (this._map.style.stylesheet) {
                  const v = this._map.style.stylesheet;
                  (this.styleOwner = v.owner), (this.styleId = v.id);
                }
                const u = this._map.style._sourceCaches;
                for (const v in u) {
                  const b = u[v];
                  if (b.used) {
                    const D = b.getSource();
                    D.attribution &&
                      a.indexOf(D.attribution) < 0 &&
                      a.push(D.attribution);
                  }
                }
                a.sort((v, b) => v.length - b.length),
                  (a = a.filter((v, b) => {
                    for (let D = b + 1; D < a.length; D++)
                      if (a[D].indexOf(v) >= 0) return !1;
                    return !0;
                  })),
                  this.options.customAttribution &&
                    (Array.isArray(this.options.customAttribution)
                      ? (a = [...this.options.customAttribution, ...a])
                      : a.unshift(this.options.customAttribution));
                const g = a.join(" | ");
                g !== this._attribHTML &&
                  ((this._attribHTML = g),
                  a.length
                    ? ((this._innerContainer.innerHTML = g),
                      this._container.classList.remove("mapboxgl-attrib-empty"))
                    : this._container.classList.add("mapboxgl-attrib-empty"),
                  (this._editLink = null));
              }
              _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640
                  ? this._container.classList.add("mapboxgl-compact")
                  : this._container.classList.remove(
                      "mapboxgl-compact",
                      "mapboxgl-compact-show"
                    );
              }
            }
            class Pu {
              constructor() {
                d.bindAll(["_updateLogo", "_updateCompact"], this);
              }
              onAdd(a) {
                (this._map = a), (this._container = Ot("div", "mapboxgl-ctrl"));
                const u = Ot("a", "mapboxgl-ctrl-logo");
                return (
                  (u.target = "_blank"),
                  (u.rel = "noopener nofollow"),
                  (u.href = "https://www.mapbox.com/"),
                  u.setAttribute(
                    "aria-label",
                    this._map._getUIString("LogoControl.Title")
                  ),
                  u.setAttribute("rel", "noopener nofollow"),
                  this._container.appendChild(u),
                  (this._container.style.display = "none"),
                  this._map.on("sourcedata", this._updateLogo),
                  this._updateLogo(),
                  this._map.on("resize", this._updateCompact),
                  this._updateCompact(),
                  this._container
                );
              }
              onRemove() {
                this._container.remove(),
                  this._map.off("sourcedata", this._updateLogo),
                  this._map.off("resize", this._updateCompact);
              }
              getDefaultPosition() {
                return "bottom-left";
              }
              _updateLogo(a) {
                (a && "metadata" !== a.sourceDataType) ||
                  (this._container.style.display = this._logoRequired()
                    ? "block"
                    : "none");
              }
              _logoRequired() {
                if (!this._map.style) return !0;
                const a = this._map.style._sourceCaches;
                if (0 === Object.entries(a).length) return !0;
                for (const u in a) {
                  const g = a[u].getSource();
                  if (g.hasOwnProperty("mapbox_logo") && !g.mapbox_logo)
                    return !1;
                }
                return !0;
              }
              _updateCompact() {
                const a = this._container.children;
                if (a.length) {
                  const u = a[0];
                  this._map.getCanvasContainer().offsetWidth < 250
                    ? u.classList.add("mapboxgl-compact")
                    : u.classList.remove("mapboxgl-compact");
                }
              }
            }
            class ea {
              constructor() {
                (this._queue = []),
                  (this._id = 0),
                  (this._cleared = !1),
                  (this._currentlyRunning = !1);
              }
              add(a) {
                const u = ++this._id;
                return (
                  this._queue.push({ callback: a, id: u, cancelled: !1 }), u
                );
              }
              remove(a) {
                const u = this._currentlyRunning,
                  g = u ? this._queue.concat(u) : this._queue;
                for (const v of g)
                  if (v.id === a) return void (v.cancelled = !0);
              }
              run(a = 0) {
                const u = (this._currentlyRunning = this._queue);
                this._queue = [];
                for (const g of u)
                  if (!g.cancelled && (g.callback(a), this._cleared)) break;
                (this._cleared = !1), (this._currentlyRunning = !1);
              }
              clear() {
                this._currentlyRunning && (this._cleared = !0),
                  (this._queue = []);
              }
            }
            function Rr(f, a, u) {
              if (((f = new d.LngLat(f.lng, f.lat)), a)) {
                const g = new d.LngLat(f.lng - 360, f.lat),
                  v = new d.LngLat(f.lng + 360, f.lat),
                  b = 360 * Math.ceil(Math.abs(f.lng - u.center.lng) / 360),
                  D = u.locationPoint(f).distSqr(a),
                  I = a.x < 0 || a.y < 0 || a.x > u.width || a.y > u.height;
                u.locationPoint(g).distSqr(a) < D &&
                (I || Math.abs(g.lng - u.center.lng) < b)
                  ? (f = g)
                  : u.locationPoint(v).distSqr(a) < D &&
                    (I || Math.abs(v.lng - u.center.lng) < b) &&
                    (f = v);
              }
              for (; Math.abs(f.lng - u.center.lng) > 180; ) {
                const g = u.locationPoint(f);
                if (g.x >= 0 && g.y >= 0 && g.x <= u.width && g.y <= u.height)
                  break;
                f.lng > u.center.lng ? (f.lng -= 360) : (f.lng += 360);
              }
              return f;
            }
            const Ga = {
              center: "translate(-50%,-50%)",
              top: "translate(-50%,0)",
              "top-left": "translate(0,0)",
              "top-right": "translate(-100%,0)",
              bottom: "translate(-50%,-100%)",
              "bottom-left": "translate(0,-100%)",
              "bottom-right": "translate(-100%,-100%)",
              left: "translate(0,-50%)",
              right: "translate(-100%,-50%)",
            };
            class ot extends d.Evented {
              constructor(a, u) {
                if (
                  (super(),
                  (a instanceof d.window.HTMLElement || u) &&
                    (a = d.extend({ element: a }, u)),
                  d.bindAll(
                    [
                      "_update",
                      "_onMove",
                      "_onUp",
                      "_addDragHandler",
                      "_onMapClick",
                      "_onKeyPress",
                      "_clearFadeTimer",
                    ],
                    this
                  ),
                  (this._anchor = (a && a.anchor) || "center"),
                  (this._color = (a && a.color) || "#3FB1CE"),
                  (this._scale = (a && a.scale) || 1),
                  (this._draggable = (a && a.draggable) || !1),
                  (this._clickTolerance = (a && a.clickTolerance) || 0),
                  (this._isDragging = !1),
                  (this._state = "inactive"),
                  (this._rotation = (a && a.rotation) || 0),
                  (this._rotationAlignment =
                    (a && a.rotationAlignment) || "auto"),
                  (this._pitchAlignment =
                    (a && a.pitchAlignment && a.pitchAlignment) || "auto"),
                  (this._updateMoving = () => this._update(!0)),
                  (this._occludedOpacity = (a && a.occludedOpacity) || 0.2),
                  a && a.element)
                )
                  (this._element = a.element),
                    (this._offset = d.Point.convert((a && a.offset) || [0, 0]));
                else {
                  (this._defaultMarker = !0), (this._element = Ot("div"));
                  const v = 41,
                    b = 27,
                    D = Ii(
                      "svg",
                      {
                        display: "block",
                        height: v * this._scale + "px",
                        width: b * this._scale + "px",
                        viewBox: `0 0 ${b} ${v}`,
                      },
                      this._element
                    ),
                    I = Ii(
                      "radialGradient",
                      { id: "shadowGradient" },
                      Ii("defs", {}, D)
                    );
                  Ii("stop", { offset: "10%", "stop-opacity": 0.4 }, I),
                    Ii("stop", { offset: "100%", "stop-opacity": 0.05 }, I),
                    Ii(
                      "ellipse",
                      {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)",
                      },
                      D
                    ),
                    Ii(
                      "path",
                      {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z",
                      },
                      D
                    ),
                    Ii(
                      "path",
                      {
                        opacity: 0.25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z",
                      },
                      D
                    ),
                    Ii(
                      "circle",
                      { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 },
                      D
                    ),
                    (this._offset = d.Point.convert(
                      (a && a.offset) || [0, -14]
                    ));
                }
                this._element.hasAttribute("aria-label") ||
                  this._element.setAttribute("aria-label", "Map marker"),
                  this._element.classList.add("mapboxgl-marker"),
                  this._element.addEventListener("dragstart", (v) => {
                    v.preventDefault();
                  }),
                  this._element.addEventListener("mousedown", (v) => {
                    v.preventDefault();
                  });
                const g = this._element.classList;
                for (const v in Ga) g.remove(`mapboxgl-marker-anchor-${v}`);
                g.add(`mapboxgl-marker-anchor-${this._anchor}`),
                  (this._popup = null);
              }
              addTo(a) {
                return (
                  a === this._map ||
                    (this.remove(),
                    (this._map = a),
                    a.getCanvasContainer().appendChild(this._element),
                    a.on("move", this._updateMoving),
                    a.on("moveend", this._update),
                    a.on("remove", this._clearFadeTimer),
                    a._addMarker(this),
                    this.setDraggable(this._draggable),
                    this._update(),
                    a.on("click", this._onMapClick)),
                  this
                );
              }
              remove() {
                const a = this._map;
                return (
                  a &&
                    (a.off("click", this._onMapClick),
                    a.off("move", this._updateMoving),
                    a.off("moveend", this._update),
                    a.off("mousedown", this._addDragHandler),
                    a.off("touchstart", this._addDragHandler),
                    a.off("mouseup", this._onUp),
                    a.off("touchend", this._onUp),
                    a.off("mousemove", this._onMove),
                    a.off("touchmove", this._onMove),
                    a.off("remove", this._clearFadeTimer),
                    a._removeMarker(this),
                    (this._map = void 0)),
                  this._clearFadeTimer(),
                  this._element.remove(),
                  this._popup && this._popup.remove(),
                  this
                );
              }
              getLngLat() {
                return this._lngLat;
              }
              setLngLat(a) {
                return (
                  (this._lngLat = d.LngLat.convert(a)),
                  (this._pos = null),
                  this._popup && this._popup.setLngLat(this._lngLat),
                  this._update(!0),
                  this
                );
              }
              getElement() {
                return this._element;
              }
              setPopup(a) {
                if (
                  (this._popup &&
                    (this._popup.remove(),
                    (this._popup = null),
                    this._element.removeAttribute("role"),
                    this._element.removeEventListener(
                      "keypress",
                      this._onKeyPress
                    ),
                    this._originalTabIndex ||
                      this._element.removeAttribute("tabindex")),
                  a)
                ) {
                  if (!("offset" in a.options)) {
                    const v = Math.sqrt(Math.pow(13.5, 2) / 2);
                    a.options.offset = this._defaultMarker
                      ? {
                          top: [0, 0],
                          "top-left": [0, 0],
                          "top-right": [0, 0],
                          bottom: [0, -38.1],
                          "bottom-left": [v, -1 * (24.6 + v)],
                          "bottom-right": [-v, -1 * (24.6 + v)],
                          left: [13.5, -24.6],
                          right: [-13.5, -24.6],
                        }
                      : this._offset;
                  }
                  (this._popup = a),
                    (a._marker = this),
                    this._lngLat && this._popup.setLngLat(this._lngLat),
                    this._element.setAttribute("role", "button"),
                    (this._originalTabIndex =
                      this._element.getAttribute("tabindex")),
                    this._originalTabIndex ||
                      this._element.setAttribute("tabindex", "0"),
                    this._element.addEventListener(
                      "keypress",
                      this._onKeyPress
                    ),
                    this._element.setAttribute("aria-expanded", "false");
                }
                return this;
              }
              _onKeyPress(a) {
                const u = a.code,
                  g = a.charCode || a.keyCode;
                ("Space" !== u && "Enter" !== u && 32 !== g && 13 !== g) ||
                  this.togglePopup();
              }
              _onMapClick(a) {
                const u = a.originalEvent.target,
                  g = this._element;
                this._popup && (u === g || g.contains(u)) && this.togglePopup();
              }
              getPopup() {
                return this._popup;
              }
              togglePopup() {
                const a = this._popup;
                return a
                  ? (a.isOpen()
                      ? (a.remove(),
                        this._element.setAttribute("aria-expanded", "false"))
                      : this._map &&
                        (a.addTo(this._map),
                        this._element.setAttribute("aria-expanded", "true")),
                    this)
                  : this;
              }
              _behindTerrain() {
                const a = this._map,
                  u = this._pos;
                if (!a || !u) return !1;
                const g = a.unproject(u),
                  v = a.getFreeCameraOptions();
                if (!v.position) return !1;
                const b = v.position.toLngLat();
                return b.distanceTo(g) < 0.9 * b.distanceTo(this._lngLat);
              }
              _evaluateOpacity() {
                const a = this._map;
                if (!a) return;
                const u = this._pos;
                if (
                  !u ||
                  u.x < 0 ||
                  u.x > a.transform.width ||
                  u.y < 0 ||
                  u.y > a.transform.height
                )
                  return void this._clearFadeTimer();
                const g = a.unproject(u);
                let v;
                a._showingGlobe() &&
                d.isLngLatBehindGlobe(a.transform, this._lngLat)
                  ? (v = 0)
                  : ((v = 1 - a._queryFogOpacity(g)),
                    a.transform._terrainEnabled() &&
                      a.getTerrain() &&
                      this._behindTerrain() &&
                      (v *= this._occludedOpacity)),
                  (this._element.style.opacity = `${v}`),
                  (this._element.style.pointerEvents = v > 0 ? "auto" : "none"),
                  this._popup && this._popup._setOpacity(v),
                  (this._fadeTimer = null);
              }
              _clearFadeTimer() {
                this._fadeTimer &&
                  (clearTimeout(this._fadeTimer), (this._fadeTimer = null));
              }
              _updateDOM() {
                const a = this._pos;
                if (!a || !this._map) return;
                const u = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${
                  a.x
                }px,${a.y}px)\n            ${
                  Ga[this._anchor]
                }\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${
                  u.x
                }px,${u.y}px)\n        `;
              }
              _calculateXYTransform() {
                const a = this._pos,
                  u = this._map,
                  g = this.getPitchAlignment();
                if (!u || !a || "map" !== g) return "";
                if (!u._showingGlobe()) {
                  const M = u.getPitch();
                  return M ? `rotateX(${M}deg)` : "";
                }
                const v = d.radToDeg(
                    d.globeTiltAtLngLat(u.transform, this._lngLat)
                  ),
                  b = a.sub(d.globeCenterToScreenPoint(u.transform)),
                  D = Math.abs(b.x) + Math.abs(b.y);
                if (0 === D) return "";
                const I = v / D;
                return `rotateX(${-b.y * I}deg) rotateY(${b.x * I}deg)`;
              }
              _calculateZTransform() {
                const a = this._pos,
                  u = this._map;
                if (!u || !a) return "";
                let g = 0;
                const v = this.getRotationAlignment();
                if ("map" === v)
                  if (u._showingGlobe()) {
                    const b = u.project(
                        new d.LngLat(this._lngLat.lng, this._lngLat.lat + 0.001)
                      ),
                      D = u
                        .project(
                          new d.LngLat(
                            this._lngLat.lng,
                            this._lngLat.lat - 0.001
                          )
                        )
                        .sub(b);
                    g = d.radToDeg(Math.atan2(D.y, D.x)) - 90;
                  } else g = -u.getBearing();
                else if ("horizon" === v) {
                  const b = d.smoothstep(4, 6, u.getZoom()),
                    D = d.globeCenterToScreenPoint(u.transform);
                  D.y += b * u.transform.height;
                  const I = a.sub(D),
                    M = d.radToDeg(Math.atan2(I.y, I.x));
                  g = (M > 90 ? M - 270 : M + 90) * (1 - b);
                }
                return (g += this._rotation), g ? `rotateZ(${g}deg)` : "";
              }
              _update(a) {
                d.window.cancelAnimationFrame(this._updateFrameId);
                const u = this._map;
                u &&
                  (u.transform.renderWorldCopies &&
                    (this._lngLat = Rr(this._lngLat, this._pos, u.transform)),
                  (this._pos = u.project(this._lngLat)),
                  !0 === a
                    ? (this._updateFrameId = d.window.requestAnimationFrame(
                        () => {
                          this._element &&
                            this._pos &&
                            this._anchor &&
                            ((this._pos = this._pos.round()),
                            this._updateDOM());
                        }
                      ))
                    : (this._pos = this._pos.round()),
                  u._requestDomTask(() => {
                    this._map &&
                      (this._element &&
                        this._pos &&
                        this._anchor &&
                        this._updateDOM(),
                      (u._showingGlobe() || u.getTerrain() || u.getFog()) &&
                        !this._fadeTimer &&
                        (this._fadeTimer = setTimeout(
                          this._evaluateOpacity.bind(this),
                          60
                        )));
                  }));
              }
              getOffset() {
                return this._offset;
              }
              setOffset(a) {
                return (
                  (this._offset = d.Point.convert(a)), this._update(), this
                );
              }
              _onMove(a) {
                const u = this._map;
                if (!u) return;
                const g = this._pointerdownPos,
                  v = this._positionDelta;
                if (g && v) {
                  if (!this._isDragging) {
                    const b = this._clickTolerance || u._clickTolerance;
                    if (a.point.dist(g) < b) return;
                    this._isDragging = !0;
                  }
                  (this._pos = a.point.sub(v)),
                    (this._lngLat = u.unproject(this._pos)),
                    this.setLngLat(this._lngLat),
                    (this._element.style.pointerEvents = "none"),
                    "pending" === this._state &&
                      ((this._state = "active"),
                      this.fire(new d.Event("dragstart"))),
                    this.fire(new d.Event("drag"));
                }
              }
              _onUp() {
                (this._element.style.pointerEvents = "auto"),
                  (this._positionDelta = null),
                  (this._pointerdownPos = null),
                  (this._isDragging = !1);
                const a = this._map;
                a &&
                  (a.off("mousemove", this._onMove),
                  a.off("touchmove", this._onMove)),
                  "active" === this._state && this.fire(new d.Event("dragend")),
                  (this._state = "inactive");
              }
              _addDragHandler(a) {
                const u = this._map,
                  g = this._pos;
                u &&
                  g &&
                  this._element.contains(a.originalEvent.target) &&
                  (a.preventDefault(),
                  (this._positionDelta = a.point.sub(g)),
                  (this._pointerdownPos = a.point),
                  (this._state = "pending"),
                  u.on("mousemove", this._onMove),
                  u.on("touchmove", this._onMove),
                  u.once("mouseup", this._onUp),
                  u.once("touchend", this._onUp));
              }
              setDraggable(a) {
                this._draggable = !!a;
                const u = this._map;
                return (
                  u &&
                    (a
                      ? (u.on("mousedown", this._addDragHandler),
                        u.on("touchstart", this._addDragHandler))
                      : (u.off("mousedown", this._addDragHandler),
                        u.off("touchstart", this._addDragHandler))),
                  this
                );
              }
              isDraggable() {
                return this._draggable;
              }
              setRotation(a) {
                return (this._rotation = a || 0), this._update(), this;
              }
              getRotation() {
                return this._rotation;
              }
              setRotationAlignment(a) {
                return (
                  (this._rotationAlignment = a || "auto"), this._update(), this
                );
              }
              getRotationAlignment() {
                return "auto" === this._rotationAlignment ||
                  ("horizon" === this._rotationAlignment &&
                    this._map &&
                    !this._map._showingGlobe())
                  ? "viewport"
                  : this._rotationAlignment;
              }
              setPitchAlignment(a) {
                return (
                  (this._pitchAlignment = a || "auto"), this._update(), this
                );
              }
              getPitchAlignment() {
                return "auto" === this._pitchAlignment
                  ? this.getRotationAlignment()
                  : this._pitchAlignment;
              }
              setOccludedOpacity(a) {
                return (this._occludedOpacity = a || 0.2), this._update(), this;
              }
              getOccludedOpacity() {
                return this._occludedOpacity;
              }
            }
            const Qh = {
                closeButton: !0,
                closeOnClick: !0,
                focusAfterOpen: !0,
                className: "",
                maxWidth: "240px",
              },
              $f = [
                "a[href]",
                "[tabindex]:not([tabindex='-1'])",
                "[contenteditable]:not([contenteditable='false'])",
                "button:not([disabled])",
                "input:not([disabled])",
                "select:not([disabled])",
                "textarea:not([disabled])",
              ].join(", ");
            function Lu(f = new d.Point(0, 0), a = "bottom") {
              if ("number" == typeof f) {
                const u = Math.round(Math.sqrt(0.5 * Math.pow(f, 2)));
                switch (a) {
                  case "top":
                    return new d.Point(0, f);
                  case "top-left":
                    return new d.Point(u, u);
                  case "top-right":
                    return new d.Point(-u, u);
                  case "bottom":
                    return new d.Point(0, -f);
                  case "bottom-left":
                    return new d.Point(u, -u);
                  case "bottom-right":
                    return new d.Point(-u, -u);
                  case "left":
                    return new d.Point(f, 0);
                  case "right":
                    return new d.Point(-f, 0);
                }
                return new d.Point(0, 0);
              }
              return f instanceof d.Point || Array.isArray(f)
                ? d.Point.convert(f)
                : d.Point.convert(f[a] || [0, 0]);
            }
            class Cc {
              constructor(a) {
                this.jumpTo(a);
              }
              getValue(a) {
                if (a <= this._startTime) return this._start;
                if (a >= this._endTime) return this._end;
                const u = d.easeCubicInOut(
                  (a - this._startTime) / (this._endTime - this._startTime)
                );
                return this._start * (1 - u) + this._end * u;
              }
              isEasing(a) {
                return a >= this._startTime && a <= this._endTime;
              }
              jumpTo(a) {
                (this._startTime = -1 / 0),
                  (this._endTime = -1 / 0),
                  (this._start = a),
                  (this._end = a);
              }
              easeTo(a, u, g) {
                (this._start = this.getValue(u)),
                  (this._end = a),
                  (this._startTime = u),
                  (this._endTime = u + g);
              }
            }
            const Jh = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "AttributionControl.MapFeedback": "Map feedback",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable":
                  "Location not available",
                "LogoControl.Title": "Mapbox logo",
                "Map.Title": "Map",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScrollZoomBlocker.CtrlMessage":
                  "Use ctrl + scroll to zoom the map",
                "ScrollZoomBlocker.CmdMessage":
                  "Use \u2318 + scroll to zoom the map",
                "TouchPanBlocker.Message": "Use two fingers to move the map",
              },
              ku = {
                center: [0, 0],
                zoom: 0,
                bearing: 0,
                pitch: 0,
                minZoom: -2,
                maxZoom: 22,
                minPitch: 0,
                maxPitch: 85,
                interactive: !0,
                scrollZoom: !0,
                boxZoom: !0,
                dragRotate: !0,
                dragPan: !0,
                keyboard: !0,
                doubleClickZoom: !0,
                touchZoomRotate: !0,
                touchPitch: !0,
                cooperativeGestures: !1,
                performanceMetricsCollection: !0,
                bearingSnap: 7,
                clickTolerance: 3,
                pitchWithRotate: !0,
                hash: !1,
                attributionControl: !0,
                failIfMajorPerformanceCaveat: !1,
                preserveDrawingBuffer: !1,
                trackResize: !0,
                optimizeForTerrain: !0,
                renderWorldCopies: !0,
                refreshExpiredTiles: !0,
                minTileCacheSize: null,
                maxTileCacheSize: null,
                localIdeographFontFamily: "sans-serif",
                localFontFamily: null,
                transformRequest: null,
                accessToken: null,
                fadeDuration: 300,
                respectPrefersReducedMotion: !0,
                crossSourceCollisions: !0,
              },
              Hf = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
            class vp {
              constructor(a, u, g = !1) {
                (this._clickTolerance = 10),
                  (this.element = u),
                  (this.mouseRotate = new Nl({
                    clickTolerance: a.dragRotate._mouseRotate._clickTolerance,
                  })),
                  (this.map = a),
                  g &&
                    (this.mousePitch = new Zh({
                      clickTolerance: a.dragRotate._mousePitch._clickTolerance,
                    })),
                  d.bindAll(
                    [
                      "mousedown",
                      "mousemove",
                      "mouseup",
                      "touchstart",
                      "touchmove",
                      "touchend",
                      "reset",
                    ],
                    this
                  ),
                  u.addEventListener("mousedown", this.mousedown),
                  u.addEventListener("touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  u.addEventListener("touchmove", this.touchmove),
                  u.addEventListener("touchend", this.touchend),
                  u.addEventListener("touchcancel", this.reset);
              }
              down(a, u) {
                this.mouseRotate.mousedown(a, u),
                  this.mousePitch && this.mousePitch.mousedown(a, u),
                  oc();
              }
              move(a, u) {
                const g = this.map,
                  v = this.mouseRotate.mousemoveWindow(a, u),
                  b = v && v.bearingDelta;
                if ((b && g.setBearing(g.getBearing() + b), this.mousePitch)) {
                  const D = this.mousePitch.mousemoveWindow(a, u),
                    I = D && D.pitchDelta;
                  I && g.setPitch(g.getPitch() + I);
                }
              }
              off() {
                const a = this.element;
                a.removeEventListener("mousedown", this.mousedown),
                  a.removeEventListener("touchstart", this.touchstart, {
                    passive: !1,
                  }),
                  a.removeEventListener("touchmove", this.touchmove),
                  a.removeEventListener("touchend", this.touchend),
                  a.removeEventListener("touchcancel", this.reset),
                  this.offTemp();
              }
              offTemp() {
                vl(),
                  d.window.removeEventListener("mousemove", this.mousemove),
                  d.window.removeEventListener("mouseup", this.mouseup);
              }
              mousedown(a) {
                this.down(
                  d.extend({}, a, {
                    ctrlKey: !0,
                    preventDefault: () => a.preventDefault(),
                  }),
                  Ir(this.element, a)
                ),
                  d.window.addEventListener("mousemove", this.mousemove),
                  d.window.addEventListener("mouseup", this.mouseup);
              }
              mousemove(a) {
                this.move(a, Ir(this.element, a));
              }
              mouseup(a) {
                this.mouseRotate.mouseupWindow(a),
                  this.mousePitch && this.mousePitch.mouseupWindow(a),
                  this.offTemp();
              }
              touchstart(a) {
                1 !== a.targetTouches.length
                  ? this.reset()
                  : ((this._startPos = this._lastPos =
                      Sa(this.element, a.targetTouches)[0]),
                    this.down(
                      {
                        type: "mousedown",
                        button: 0,
                        ctrlKey: !0,
                        preventDefault: () => a.preventDefault(),
                      },
                      this._startPos
                    ));
              }
              touchmove(a) {
                1 !== a.targetTouches.length
                  ? this.reset()
                  : ((this._lastPos = Sa(this.element, a.targetTouches)[0]),
                    this.move(
                      { preventDefault: () => a.preventDefault() },
                      this._lastPos
                    ));
              }
              touchend(a) {
                0 === a.targetTouches.length &&
                  this._startPos &&
                  this._lastPos &&
                  this._startPos.dist(this._lastPos) < this._clickTolerance &&
                  this.element.click(),
                  this.reset();
              }
              reset() {
                this.mouseRotate.reset(),
                  this.mousePitch && this.mousePitch.reset(),
                  delete this._startPos,
                  delete this._lastPos,
                  this.offTemp();
              }
            }
            const Mc = {
                positionOptions: {
                  enableHighAccuracy: !1,
                  maximumAge: 0,
                  timeout: 6e3,
                },
                fitBoundsOptions: { maxZoom: 15 },
                trackUserLocation: !1,
                showAccuracyCircle: !0,
                showUserLocation: !0,
                showUserHeading: !1,
              },
              Ru = { maxWidth: 100, unit: "metric" },
              Ou = {
                kilometer: "km",
                meter: "m",
                mile: "mi",
                foot: "ft",
                "nautical-mile": "nm",
              },
              qa = {
                version: d.version,
                supported: Oo,
                setRTLTextPlugin: d.setRTLTextPlugin,
                getRTLTextPluginStatus: d.getRTLTextPluginStatus,
                Map: class extends Vi {
                  constructor(f) {
                    if (
                      (d.LivePerformanceUtils.mark(d.PerformanceMarkers.create),
                      null != (f = d.extend({}, ku, f)).minZoom &&
                        null != f.maxZoom &&
                        f.minZoom > f.maxZoom)
                    )
                      throw new Error(
                        "maxZoom must be greater than or equal to minZoom"
                      );
                    if (
                      null != f.minPitch &&
                      null != f.maxPitch &&
                      f.minPitch > f.maxPitch
                    )
                      throw new Error(
                        "maxPitch must be greater than or equal to minPitch"
                      );
                    if (null != f.minPitch && f.minPitch < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0"
                      );
                    if (null != f.maxPitch && f.maxPitch > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85"
                      );
                    if (
                      (f.antialias &&
                        d.isSafariWithAntialiasingBug(d.window) &&
                        ((f.antialias = !1),
                        d.warnOnce(
                          "Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609"
                        )),
                      super(
                        new Zo(
                          f.minZoom,
                          f.maxZoom,
                          f.minPitch,
                          f.maxPitch,
                          f.renderWorldCopies
                        ),
                        f
                      ),
                      (this._interactive = f.interactive),
                      (this._minTileCacheSize = f.minTileCacheSize),
                      (this._maxTileCacheSize = f.maxTileCacheSize),
                      (this._failIfMajorPerformanceCaveat =
                        f.failIfMajorPerformanceCaveat),
                      (this._preserveDrawingBuffer = f.preserveDrawingBuffer),
                      (this._antialias = f.antialias),
                      (this._useWebGL2 = f.useWebGL2),
                      (this._trackResize = f.trackResize),
                      (this._bearingSnap = f.bearingSnap),
                      (this._refreshExpiredTiles = f.refreshExpiredTiles),
                      (this._fadeDuration = f.fadeDuration),
                      (this._isInitialLoad = !0),
                      (this._crossSourceCollisions = f.crossSourceCollisions),
                      (this._collectResourceTiming = f.collectResourceTiming),
                      (this._optimizeForTerrain = f.optimizeForTerrain),
                      (this._language = this._parseLanguage(f.language)),
                      (this._worldview = f.worldview),
                      (this._renderTaskQueue = new ea()),
                      (this._domRenderTaskQueue = new ea()),
                      (this._controls = []),
                      (this._markers = []),
                      (this._popups = []),
                      (this._mapId = d.uniqueId()),
                      (this._locale = d.extend({}, Jh, f.locale)),
                      (this._clickTolerance = f.clickTolerance),
                      (this._cooperativeGestures = f.cooperativeGestures),
                      (this._performanceMetricsCollection =
                        f.performanceMetricsCollection),
                      (this._containerWidth = 0),
                      (this._containerHeight = 0),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      (this._averageElevationExaggeration = 0),
                      (this._averageElevation = new Cc(0)),
                      (this._interactionRange = [1 / 0, -1 / 0]),
                      (this._visibilityHidden = 0),
                      (this._useExplicitProjection = !1),
                      (this._requestManager = new d.RequestManager(
                        f.transformRequest,
                        f.accessToken,
                        f.testMode
                      )),
                      (this._silenceAuthErrors = !!f.testMode),
                      "string" == typeof f.container)
                    ) {
                      if (
                        ((this._container = d.window.document.getElementById(
                          f.container
                        )),
                        !this._container)
                      )
                        throw new Error(
                          `Container '${f.container}' not found.`
                        );
                    } else {
                      if (!(f.container instanceof d.window.HTMLElement))
                        throw new Error(
                          "Invalid type: 'container' must be a String or HTMLElement."
                        );
                      this._container = f.container;
                    }
                    if (
                      (this._container.childNodes.length > 0 &&
                        d.warnOnce(
                          "The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."
                        ),
                      f.maxBounds && this.setMaxBounds(f.maxBounds),
                      d.bindAll(
                        [
                          "_onWindowOnline",
                          "_onWindowResize",
                          "_onVisibilityChange",
                          "_onMapScroll",
                          "_contextLost",
                          "_contextRestored",
                        ],
                        this
                      ),
                      this._setupContainer(),
                      this._setupPainter(),
                      void 0 === this.painter)
                    )
                      throw new Error("Failed to initialize WebGL.");
                    this.on("move", () => this._update(!1)),
                      this.on("moveend", () => this._update(!1)),
                      this.on("zoom", () => this._update(!0)),
                      void 0 !== d.window &&
                        (d.window.addEventListener(
                          "online",
                          this._onWindowOnline,
                          !1
                        ),
                        d.window.addEventListener(
                          "resize",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.addEventListener(
                          "orientationchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.addEventListener(
                          "webkitfullscreenchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.addEventListener(
                          "visibilitychange",
                          this._onVisibilityChange,
                          !1
                        )),
                      (this.handlers = new ms(this, f)),
                      (this._localFontFamily = f.localFontFamily),
                      (this._localIdeographFontFamily =
                        f.localIdeographFontFamily),
                      f.style &&
                        this.setStyle(f.style, {
                          localFontFamily: this._localFontFamily,
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                        }),
                      f.projection && this.setProjection(f.projection),
                      (this._hash =
                        f.hash &&
                        new $h(
                          ("string" == typeof f.hash && f.hash) || void 0
                        ).addTo(this)),
                      (this._hash && this._hash._onHashChange()) ||
                        (this.jumpTo({
                          center: f.center,
                          zoom: f.zoom,
                          bearing: f.bearing,
                          pitch: f.pitch,
                        }),
                        f.bounds &&
                          (this.resize(),
                          this.fitBounds(
                            f.bounds,
                            d.extend({}, f.fitBoundsOptions, { duration: 0 })
                          ))),
                      this.resize(),
                      f.attributionControl &&
                        this.addControl(
                          new st({ customAttribution: f.customAttribution })
                        ),
                      (this._logoControl = new Pu()),
                      this.addControl(this._logoControl, f.logoPosition),
                      this.on("style.load", () => {
                        this.transform.unmodified &&
                          this.jumpTo(this.style.stylesheet);
                      }),
                      this.on("data", (a) => {
                        this._update("style" === a.dataType),
                          this.fire(new d.Event(`${a.dataType}data`, a));
                      }),
                      this.on("dataloading", (a) => {
                        this.fire(new d.Event(`${a.dataType}dataloading`, a));
                      });
                  }
                  _getMapId() {
                    return this._mapId;
                  }
                  addControl(f, a) {
                    if (
                      (void 0 === a &&
                        (a = f.getDefaultPosition
                          ? f.getDefaultPosition()
                          : "top-right"),
                      !f || !f.onAdd)
                    )
                      return this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."
                          )
                        )
                      );
                    const u = f.onAdd(this);
                    this._controls.push(f);
                    const g = this._controlPositions[a];
                    return (
                      -1 !== a.indexOf("bottom")
                        ? g.insertBefore(u, g.firstChild)
                        : g.appendChild(u),
                      this
                    );
                  }
                  removeControl(f) {
                    if (!f || !f.onRemove)
                      return this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."
                          )
                        )
                      );
                    const a = this._controls.indexOf(f);
                    return (
                      a > -1 && this._controls.splice(a, 1),
                      f.onRemove(this),
                      this
                    );
                  }
                  hasControl(f) {
                    return this._controls.indexOf(f) > -1;
                  }
                  getContainer() {
                    return this._container;
                  }
                  getCanvasContainer() {
                    return this._canvasContainer;
                  }
                  getCanvas() {
                    return this._canvas;
                  }
                  resize(f) {
                    if (
                      (this._updateContainerDimensions(),
                      this._containerWidth === this.transform.width &&
                        this._containerHeight === this.transform.height)
                    )
                      return this;
                    this._resizeCanvas(
                      this._containerWidth,
                      this._containerHeight
                    ),
                      this.transform.resize(
                        this._containerWidth,
                        this._containerHeight
                      ),
                      this.painter.resize(
                        Math.ceil(this._containerWidth),
                        Math.ceil(this._containerHeight)
                      );
                    const a = !this._moving;
                    return (
                      a &&
                        this.fire(new d.Event("movestart", f)).fire(
                          new d.Event("move", f)
                        ),
                      this.fire(new d.Event("resize", f)),
                      a && this.fire(new d.Event("moveend", f)),
                      this
                    );
                  }
                  getBounds() {
                    return this.transform.getBounds();
                  }
                  getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                  }
                  setMaxBounds(f) {
                    return (
                      this.transform.setMaxBounds(d.LngLatBounds.convert(f)),
                      this._update()
                    );
                  }
                  setMinZoom(f) {
                    if ((f = f ?? -2) >= -2 && f <= this.transform.maxZoom)
                      return (
                        (this.transform.minZoom = f),
                        this._update(),
                        this.getZoom() < f
                          ? this.setZoom(f)
                          : this.fire(new d.Event("zoomstart"))
                              .fire(new d.Event("zoom"))
                              .fire(new d.Event("zoomend")),
                        this
                      );
                    throw new Error(
                      "minZoom must be between -2 and the current maxZoom, inclusive"
                    );
                  }
                  getMinZoom() {
                    return this.transform.minZoom;
                  }
                  setMaxZoom(f) {
                    if ((f = f ?? 22) >= this.transform.minZoom)
                      return (
                        (this.transform.maxZoom = f),
                        this._update(),
                        this.getZoom() > f
                          ? this.setZoom(f)
                          : this.fire(new d.Event("zoomstart"))
                              .fire(new d.Event("zoom"))
                              .fire(new d.Event("zoomend")),
                        this
                      );
                    throw new Error(
                      "maxZoom must be greater than the current minZoom"
                    );
                  }
                  getMaxZoom() {
                    return this.transform.maxZoom;
                  }
                  setMinPitch(f) {
                    if ((f = f ?? 0) < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0"
                      );
                    if (f >= 0 && f <= this.transform.maxPitch)
                      return (
                        (this.transform.minPitch = f),
                        this._update(),
                        this.getPitch() < f
                          ? this.setPitch(f)
                          : this.fire(new d.Event("pitchstart"))
                              .fire(new d.Event("pitch"))
                              .fire(new d.Event("pitchend")),
                        this
                      );
                    throw new Error(
                      "minPitch must be between 0 and the current maxPitch, inclusive"
                    );
                  }
                  getMinPitch() {
                    return this.transform.minPitch;
                  }
                  setMaxPitch(f) {
                    if ((f = f ?? 85) > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85"
                      );
                    if (f >= this.transform.minPitch)
                      return (
                        (this.transform.maxPitch = f),
                        this._update(),
                        this.getPitch() > f
                          ? this.setPitch(f)
                          : this.fire(new d.Event("pitchstart"))
                              .fire(new d.Event("pitch"))
                              .fire(new d.Event("pitchend")),
                        this
                      );
                    throw new Error(
                      "maxPitch must be greater than or equal to minPitch"
                    );
                  }
                  getMaxPitch() {
                    return this.transform.maxPitch;
                  }
                  getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                  }
                  setRenderWorldCopies(f) {
                    return (
                      (this.transform.renderWorldCopies = f),
                      this.transform.renderWorldCopies ||
                        this._forceMarkerAndPopupUpdate(!0),
                      this._update()
                    );
                  }
                  getLanguage() {
                    return this._language;
                  }
                  _parseLanguage(f) {
                    return "auto" === f
                      ? d.window.navigator.language
                      : Array.isArray(f)
                      ? 0 === f.length
                        ? void 0
                        : f.map((a) =>
                            "auto" === a ? d.window.navigator.language : a
                          )
                      : f;
                  }
                  setLanguage(f) {
                    const a = this._parseLanguage(f);
                    if (!this.style || a === this._language) return this;
                    (this._language = a), this.style._reloadSources();
                    for (const u of this._controls)
                      u._setLanguage && u._setLanguage(this._language);
                    return this;
                  }
                  getWorldview() {
                    return this._worldview;
                  }
                  setWorldview(f) {
                    return this.style && f !== this._worldview
                      ? ((this._worldview = f),
                        this.style._reloadSources(),
                        this)
                      : this;
                  }
                  getProjection() {
                    return this.transform.mercatorFromTransition
                      ? { name: "globe", center: [0, 0] }
                      : this.transform.getProjection();
                  }
                  _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                  }
                  setProjection(f) {
                    return (
                      this._lazyInitEmptyStyle(),
                      f
                        ? "string" == typeof f && (f = { name: f })
                        : (f = null),
                      (this._useExplicitProjection = !!f),
                      this._prioritizeAndUpdateProjection(
                        f,
                        this.style.stylesheet
                          ? this.style.stylesheet.projection
                          : null
                      )
                    );
                  }
                  _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const f = this.transform,
                      a = f.projection.name;
                    let u;
                    "globe" === a && f.zoom >= d.GLOBE_ZOOM_THRESHOLD_MAX
                      ? (f.setMercatorFromTransition(), (u = !0))
                      : "mercator" === a &&
                        f.zoom < d.GLOBE_ZOOM_THRESHOLD_MAX &&
                        (f.setProjection({ name: "globe" }), (u = !0)),
                      u &&
                        (this.style.applyProjectionUpdate(),
                        this.style._forceSymbolLayerUpdate());
                  }
                  _prioritizeAndUpdateProjection(f, a) {
                    return this._updateProjection(
                      f || a || { name: "mercator" }
                    );
                  }
                  _updateProjection(f) {
                    let a;
                    if (
                      ((a =
                        "globe" === f.name &&
                        this.transform.zoom >= d.GLOBE_ZOOM_THRESHOLD_MAX
                          ? this.transform.setMercatorFromTransition()
                          : this.transform.setProjection(f)),
                      this.style.applyProjectionUpdate(),
                      a)
                    ) {
                      this.painter.clearBackgroundTiles();
                      for (const u in this.style._sourceCaches)
                        this.style._sourceCaches[u].clearTiles();
                      this._update(!0), this._forceMarkerAndPopupUpdate(!0);
                    }
                    return this;
                  }
                  project(f) {
                    return this.transform.locationPoint3D(d.LngLat.convert(f));
                  }
                  unproject(f) {
                    return this.transform.pointLocation3D(d.Point.convert(f));
                  }
                  isMoving() {
                    return (
                      this._moving ||
                      (this.handlers && this.handlers.isMoving()) ||
                      !1
                    );
                  }
                  isZooming() {
                    return (
                      this._zooming ||
                      (this.handlers && this.handlers.isZooming()) ||
                      !1
                    );
                  }
                  isRotating() {
                    return (
                      this._rotating ||
                      (this.handlers && this.handlers.isRotating()) ||
                      !1
                    );
                  }
                  _isDragging() {
                    return (this.handlers && this.handlers._isDragging()) || !1;
                  }
                  _createDelegatedListener(f, a, u) {
                    if ("mouseenter" === f || "mouseover" === f) {
                      let g = !1;
                      const v = (D) => {
                          const I = a.filter((R) => this.getLayer(R)),
                            M = I.length
                              ? this.queryRenderedFeatures(D.point, {
                                  layers: I,
                                })
                              : [];
                          M.length
                            ? g ||
                              ((g = !0),
                              u.call(
                                this,
                                new Ei(f, this, D.originalEvent, {
                                  features: M,
                                })
                              ))
                            : (g = !1);
                        },
                        b = () => {
                          g = !1;
                        };
                      return {
                        layers: new Set(a),
                        listener: u,
                        delegates: { mousemove: v, mouseout: b },
                      };
                    }
                    if ("mouseleave" === f || "mouseout" === f) {
                      let g = !1;
                      const v = (D) => {
                          const I = a.filter((M) => this.getLayer(M));
                          (I.length
                            ? this.queryRenderedFeatures(D.point, { layers: I })
                            : []
                          ).length
                            ? (g = !0)
                            : g &&
                              ((g = !1),
                              u.call(this, new Ei(f, this, D.originalEvent)));
                        },
                        b = (D) => {
                          g &&
                            ((g = !1),
                            u.call(this, new Ei(f, this, D.originalEvent)));
                        };
                      return {
                        layers: new Set(a),
                        listener: u,
                        delegates: { mousemove: v, mouseout: b },
                      };
                    }
                    {
                      const g = (v) => {
                        const b = a.filter((I) => this.getLayer(I)),
                          D = b.length
                            ? this.queryRenderedFeatures(v.point, { layers: b })
                            : [];
                        D.length &&
                          ((v.features = D),
                          u.call(this, v),
                          delete v.features);
                      };
                      return {
                        layers: new Set(a),
                        listener: u,
                        delegates: { [f]: g },
                      };
                    }
                  }
                  on(f, a, u) {
                    if (void 0 === u) return super.on(f, a);
                    Array.isArray(a) || (a = [a]);
                    const g = this._createDelegatedListener(f, a, u);
                    (this._delegatedListeners = this._delegatedListeners || {}),
                      (this._delegatedListeners[f] =
                        this._delegatedListeners[f] || []),
                      this._delegatedListeners[f].push(g);
                    for (const v in g.delegates) this.on(v, g.delegates[v]);
                    return this;
                  }
                  once(f, a, u) {
                    if (void 0 === u) return super.once(f, a);
                    Array.isArray(a) || (a = [a]);
                    const g = this._createDelegatedListener(f, a, u);
                    for (const v in g.delegates) this.once(v, g.delegates[v]);
                    return this;
                  }
                  off(f, a, u) {
                    if (void 0 === u) return super.off(f, a);
                    a = new Set(Array.isArray(a) ? a : [a]);
                    const g = (b, D) => {
                        if (b.size !== D.size) return !1;
                        for (const I of b) if (!D.has(I)) return !1;
                        return !0;
                      },
                      v = this._delegatedListeners
                        ? this._delegatedListeners[f]
                        : void 0;
                    return (
                      v &&
                        ((b) => {
                          for (let D = 0; D < b.length; D++) {
                            const I = b[D];
                            if (I.listener === u && g(I.layers, a)) {
                              for (const M in I.delegates)
                                this.off(M, I.delegates[M]);
                              return b.splice(D, 1), this;
                            }
                          }
                        })(v),
                      this
                    );
                  }
                  queryRenderedFeatures(f, a) {
                    return this.style
                      ? (void 0 !== a ||
                          void 0 === f ||
                          f instanceof d.Point ||
                          Array.isArray(f) ||
                          ((a = f), (f = void 0)),
                        this.style.queryRenderedFeatures(
                          (f = f || [
                            [0, 0],
                            [this.transform.width, this.transform.height],
                          ]),
                          (a = a || {}),
                          this.transform
                        ))
                      : [];
                  }
                  querySourceFeatures(f, a) {
                    return this.style.querySourceFeatures(f, a);
                  }
                  isPointOnSurface(f) {
                    const { name: a } = this.transform.projection;
                    return (
                      "globe" !== a &&
                        "mercator" !== a &&
                        d.warnOnce(
                          `${a} projection does not support isPointOnSurface, this API may behave unexpectedly.`
                        ),
                      this.transform.isPointOnSurface(d.Point.convert(f))
                    );
                  }
                  setStyle(f, a) {
                    return !1 !==
                      (a = d.extend(
                        {},
                        {
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                          localFontFamily: this._localFontFamily,
                        },
                        a
                      )).diff &&
                      a.localIdeographFontFamily ===
                        this._localIdeographFontFamily &&
                      a.localFontFamily === this._localFontFamily &&
                      this.style &&
                      f
                      ? (this._diffStyle(f, a), this)
                      : ((this._localIdeographFontFamily =
                          a.localIdeographFontFamily),
                        (this._localFontFamily = a.localFontFamily),
                        this._updateStyle(f, a));
                  }
                  _getUIString(f) {
                    const a = this._locale[f];
                    if (null == a) throw new Error(`Missing UI string '${f}'`);
                    return a;
                  }
                  _updateStyle(f, a) {
                    return (
                      this.style &&
                        (this.style.setEventedParent(null),
                        this.style._remove(),
                        (this.style = void 0)),
                      f &&
                        ((this.style = new yo(this, a || {})),
                        this.style.setEventedParent(this, {
                          style: this.style,
                        }),
                        "string" == typeof f
                          ? this.style.loadURL(f)
                          : this.style.loadJSON(f)),
                      this._updateTerrain(),
                      this
                    );
                  }
                  _lazyInitEmptyStyle() {
                    this.style ||
                      ((this.style = new yo(this, {})),
                      this.style.setEventedParent(this, { style: this.style }),
                      this.style.loadEmpty());
                  }
                  _diffStyle(f, a) {
                    if ("string" == typeof f) {
                      const u = this._requestManager.normalizeStyleURL(f),
                        g = this._requestManager.transformRequest(
                          u,
                          d.ResourceType.Style
                        );
                      d.getJSON(g, (v, b) => {
                        v
                          ? this.fire(new d.ErrorEvent(v))
                          : b && this._updateDiff(b, a);
                      });
                    } else "object" == typeof f && this._updateDiff(f, a);
                  }
                  _updateDiff(f, a) {
                    try {
                      this.style.setState(f) && this._update(!0);
                    } catch (u) {
                      d.warnOnce(
                        `Unable to perform style diff: ${
                          u.message || u.error || u
                        }.  Rebuilding the style from scratch.`
                      ),
                        this._updateStyle(f, a);
                    }
                  }
                  getStyle() {
                    if (this.style) return this.style.serialize();
                  }
                  isStyleLoaded() {
                    return this.style
                      ? this.style.loaded()
                      : (d.warnOnce("There is no style added to the map."), !1);
                  }
                  addSource(f, a) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.addSource(f, a),
                      this._update(!0)
                    );
                  }
                  isSourceLoaded(f) {
                    return !!this.style && this.style._isSourceCacheLoaded(f);
                  }
                  areTilesLoaded() {
                    const f = this.style && this.style._sourceCaches;
                    for (const a in f) {
                      const u = f[a]._tiles;
                      for (const g in u) {
                        const v = u[g];
                        if ("loaded" !== v.state && "errored" !== v.state)
                          return !1;
                      }
                    }
                    return !0;
                  }
                  addSourceType(f, a, u) {
                    this._lazyInitEmptyStyle(),
                      this.style.addSourceType(f, a, u);
                  }
                  removeSource(f) {
                    return (
                      this.style.removeSource(f),
                      this._updateTerrain(),
                      this._update(!0)
                    );
                  }
                  getSource(f) {
                    return this.style.getSource(f);
                  }
                  addImage(
                    f,
                    a,
                    {
                      pixelRatio: u = 1,
                      sdf: g = !1,
                      stretchX: v,
                      stretchY: b,
                      content: D,
                    } = {}
                  ) {
                    if (
                      (this._lazyInitEmptyStyle(),
                      a instanceof d.window.HTMLImageElement ||
                        (d.window.ImageBitmap &&
                          a instanceof d.window.ImageBitmap))
                    ) {
                      const {
                        width: I,
                        height: M,
                        data: R,
                      } = d.exported.getImageData(a);
                      this.style.addImage(f, {
                        data: new d.RGBAImage({ width: I, height: M }, R),
                        pixelRatio: u,
                        stretchX: v,
                        stretchY: b,
                        content: D,
                        sdf: g,
                        version: 0,
                      });
                    } else if (void 0 === a.width || void 0 === a.height)
                      this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                          )
                        )
                      );
                    else {
                      const { width: I, height: M } = a,
                        R = a;
                      this.style.addImage(f, {
                        data: new d.RGBAImage(
                          { width: I, height: M },
                          new Uint8Array(R.data)
                        ),
                        pixelRatio: u,
                        stretchX: v,
                        stretchY: b,
                        content: D,
                        sdf: g,
                        version: 0,
                        userImage: R,
                      }),
                        R.onAdd && R.onAdd(this, f);
                    }
                  }
                  updateImage(f, a) {
                    const u = this.style.getImage(f);
                    if (!u)
                      return void this.fire(
                        new d.ErrorEvent(
                          new Error(
                            "The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."
                          )
                        )
                      );
                    const g =
                        a instanceof d.window.HTMLImageElement ||
                        (d.window.ImageBitmap &&
                          a instanceof d.window.ImageBitmap)
                          ? d.exported.getImageData(a)
                          : a,
                      { width: v, height: b } = g;
                    void 0 !== v && void 0 !== b
                      ? v === u.data.width && b === u.data.height
                        ? (u.data.replace(
                            g.data,
                            !(
                              a instanceof d.window.HTMLImageElement ||
                              (d.window.ImageBitmap &&
                                a instanceof d.window.ImageBitmap)
                            )
                          ),
                          this.style.updateImage(f, u))
                        : this.fire(
                            new d.ErrorEvent(
                              new Error(
                                `The width and height of the updated image (${v}, ${b})\n                must be that same as the previous version of the image\n                (${u.data.width}, ${u.data.height})`
                              )
                            )
                          )
                      : this.fire(
                          new d.ErrorEvent(
                            new Error(
                              "Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"
                            )
                          )
                        );
                  }
                  hasImage(f) {
                    return f
                      ? !!this.style.getImage(f)
                      : (this.fire(
                          new d.ErrorEvent(
                            new Error("Missing required image id")
                          )
                        ),
                        !1);
                  }
                  removeImage(f) {
                    this.style.removeImage(f);
                  }
                  loadImage(f, a) {
                    d.getImage(
                      this._requestManager.transformRequest(
                        f,
                        d.ResourceType.Image
                      ),
                      (u, g) => {
                        a(
                          u,
                          g instanceof d.window.HTMLImageElement
                            ? d.exported.getImageData(g)
                            : g
                        );
                      }
                    );
                  }
                  listImages() {
                    return this.style.listImages();
                  }
                  addLayer(f, a) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.addLayer(f, a),
                      this._update(!0)
                    );
                  }
                  moveLayer(f, a) {
                    return this.style.moveLayer(f, a), this._update(!0);
                  }
                  removeLayer(f) {
                    return this.style.removeLayer(f), this._update(!0);
                  }
                  getLayer(f) {
                    return this.style.getLayer(f);
                  }
                  setLayerZoomRange(f, a, u) {
                    return (
                      this.style.setLayerZoomRange(f, a, u), this._update(!0)
                    );
                  }
                  setFilter(f, a, u = {}) {
                    return this.style.setFilter(f, a, u), this._update(!0);
                  }
                  getFilter(f) {
                    return this.style.getFilter(f);
                  }
                  setPaintProperty(f, a, u, g = {}) {
                    return (
                      this.style.setPaintProperty(f, a, u, g), this._update(!0)
                    );
                  }
                  getPaintProperty(f, a) {
                    return this.style.getPaintProperty(f, a);
                  }
                  setLayoutProperty(f, a, u, g = {}) {
                    return (
                      this.style.setLayoutProperty(f, a, u, g), this._update(!0)
                    );
                  }
                  getLayoutProperty(f, a) {
                    return this.style.getLayoutProperty(f, a);
                  }
                  setLight(f, a = {}) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setLight(f, a),
                      this._update(!0)
                    );
                  }
                  getLight() {
                    return this.style.getLight();
                  }
                  setTerrain(f) {
                    return (
                      this._lazyInitEmptyStyle(),
                      !f && this.transform.projection.requiresDraping
                        ? this.style.setTerrainForDraping()
                        : this.style.setTerrain(f),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      this._update(!0)
                    );
                  }
                  getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                  }
                  setFog(f) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setFog(f),
                      this._update(!0)
                    );
                  }
                  getFog() {
                    return this.style ? this.style.getFog() : null;
                  }
                  _queryFogOpacity(f) {
                    return this.style && this.style.fog
                      ? this.style.fog.getOpacityAtLatLng(
                          d.LngLat.convert(f),
                          this.transform
                        )
                      : 0;
                  }
                  setFeatureState(f, a) {
                    return this.style.setFeatureState(f, a), this._update();
                  }
                  removeFeatureState(f, a) {
                    return this.style.removeFeatureState(f, a), this._update();
                  }
                  getFeatureState(f) {
                    return this.style.getFeatureState(f);
                  }
                  _updateContainerDimensions() {
                    if (!this._container) return;
                    const f =
                        this._container.getBoundingClientRect().width || 400,
                      a = this._container.getBoundingClientRect().height || 300;
                    let u,
                      g,
                      v,
                      b = this._container;
                    for (; b && (!g || !v); ) {
                      const D = d.window.getComputedStyle(b).transform;
                      D &&
                        "none" !== D &&
                        ((u = D.match(/matrix.*\((.+)\)/)[1].split(", ")),
                        u[0] && "0" !== u[0] && "1" !== u[0] && (g = u[0]),
                        u[3] && "0" !== u[3] && "1" !== u[3] && (v = u[3])),
                        (b = b.parentElement);
                    }
                    (this._containerWidth = g ? Math.abs(f / g) : f),
                      (this._containerHeight = v ? Math.abs(a / v) : a);
                  }
                  _detectMissingCSS() {
                    "rgb(250, 128, 114)" !==
                      d.window
                        .getComputedStyle(this._missingCSSCanary)
                        .getPropertyValue("background-color") &&
                      d.warnOnce(
                        "This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/."
                      );
                  }
                  _setupContainer() {
                    const f = this._container;
                    f.classList.add("mapboxgl-map"),
                      ((this._missingCSSCanary = Ot(
                        "div",
                        "mapboxgl-canary",
                        f
                      )).style.visibility = "hidden"),
                      this._detectMissingCSS();
                    const a = (this._canvasContainer = Ot(
                      "div",
                      "mapboxgl-canvas-container",
                      f
                    ));
                    this._interactive &&
                      a.classList.add("mapboxgl-interactive"),
                      (this._canvas = Ot("canvas", "mapboxgl-canvas", a)),
                      this._canvas.addEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1
                      ),
                      this._canvas.addEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1
                      ),
                      this._canvas.setAttribute("tabindex", "0"),
                      this._canvas.setAttribute(
                        "aria-label",
                        this._getUIString("Map.Title")
                      ),
                      this._canvas.setAttribute("role", "region"),
                      this._updateContainerDimensions(),
                      this._resizeCanvas(
                        this._containerWidth,
                        this._containerHeight
                      );
                    const u = (this._controlContainer = Ot(
                        "div",
                        "mapboxgl-control-container",
                        f
                      )),
                      g = (this._controlPositions = {});
                    [
                      "top-left",
                      "top-right",
                      "bottom-left",
                      "bottom-right",
                    ].forEach((v) => {
                      g[v] = Ot("div", `mapboxgl-ctrl-${v}`, u);
                    }),
                      this._container.addEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1
                      );
                  }
                  _resizeCanvas(f, a) {
                    const u = d.exported.devicePixelRatio || 1;
                    (this._canvas.width = u * Math.ceil(f)),
                      (this._canvas.height = u * Math.ceil(a)),
                      (this._canvas.style.width = `${f}px`),
                      (this._canvas.style.height = `${a}px`);
                  }
                  _addMarker(f) {
                    this._markers.push(f);
                  }
                  _removeMarker(f) {
                    const a = this._markers.indexOf(f);
                    -1 !== a && this._markers.splice(a, 1);
                  }
                  _addPopup(f) {
                    this._popups.push(f);
                  }
                  _removePopup(f) {
                    const a = this._popups.indexOf(f);
                    -1 !== a && this._popups.splice(a, 1);
                  }
                  _setupPainter() {
                    const f = d.extend({}, Oo.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat:
                          this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1,
                      }),
                      a =
                        this._useWebGL2 && this._canvas.getContext("webgl2", f),
                      u =
                        a ||
                        this._canvas.getContext("webgl", f) ||
                        this._canvas.getContext("experimental-webgl", f);
                    u
                      ? (this._useWebGL2 &&
                          !a &&
                          d.warnOnce(
                            "Failed to create WebGL 2 context. Using WebGL 1."
                          ),
                        d.storeAuthState(u, !0),
                        (this.painter = new bc(u, this.transform, !!a)),
                        this.on("data", (g) => {
                          "source" === g.dataType &&
                            this.painter.setTileLoadedFlag(!0);
                        }),
                        d.exported$1.testSupport(u))
                      : this.fire(
                          new d.ErrorEvent(
                            new Error("Failed to initialize WebGL")
                          )
                        );
                  }
                  _contextLost(f) {
                    f.preventDefault(),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this.fire(
                        new d.Event("webglcontextlost", { originalEvent: f })
                      );
                  }
                  _contextRestored(f) {
                    this._setupPainter(),
                      this.resize(),
                      this._update(),
                      this.fire(
                        new d.Event("webglcontextrestored", {
                          originalEvent: f,
                        })
                      );
                  }
                  _onMapScroll(f) {
                    if (f.target === this._container)
                      return (
                        (this._container.scrollTop = 0),
                        (this._container.scrollLeft = 0),
                        !1
                      );
                  }
                  loaded() {
                    return (
                      !this._styleDirty &&
                      !this._sourcesDirty &&
                      !!this.style &&
                      this.style.loaded()
                    );
                  }
                  _update(f) {
                    return this.style
                      ? ((this._styleDirty = this._styleDirty || f),
                        (this._sourcesDirty = !0),
                        this.triggerRepaint(),
                        this)
                      : this;
                  }
                  _requestRenderFrame(f) {
                    return this._update(), this._renderTaskQueue.add(f);
                  }
                  _cancelRenderFrame(f) {
                    this._renderTaskQueue.remove(f);
                  }
                  _requestDomTask(f) {
                    !this.loaded() || (this.loaded() && !this.isMoving())
                      ? f()
                      : this._domRenderTaskQueue.add(f);
                  }
                  _render(f) {
                    let a;
                    const u = this.painter.context.extTimerQuery,
                      g = d.exported.now();
                    if (
                      (this.listens("gpu-timing-frame") &&
                        ((a = u.createQueryEXT()),
                        u.beginQueryEXT(u.TIME_ELAPSED_EXT, a)),
                      this.painter.context.setDirty(),
                      this.painter.setBaseState(),
                      (this.isMoving() ||
                        this.isRotating() ||
                        this.isZooming()) &&
                        ((this._interactionRange[0] = Math.min(
                          this._interactionRange[0],
                          d.window.performance.now()
                        )),
                        (this._interactionRange[1] = Math.max(
                          this._interactionRange[1],
                          d.window.performance.now()
                        ))),
                      this._renderTaskQueue.run(f),
                      this._domRenderTaskQueue.run(f),
                      this._removed)
                    )
                      return;
                    this._updateProjectionTransition();
                    const v = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                      this._styleDirty = !1;
                      const I = this.transform.zoom,
                        M = this.transform.pitch,
                        R = d.exported.now(),
                        k = new d.EvaluationParameters(I, {
                          now: R,
                          fadeDuration: v,
                          pitch: M,
                          transition: this.style.getTransition(),
                        });
                      this.style.update(k);
                    }
                    this.style &&
                      this.style.fog &&
                      this.style.fog.hasTransition() &&
                      ((this.style._markersNeedUpdate = !0),
                      (this._sourcesDirty = !0));
                    let b = !1;
                    if (
                      (this.style && this._sourcesDirty
                        ? ((this._sourcesDirty = !1),
                          this.painter._updateFog(this.style),
                          this._updateTerrain(),
                          (b = this._updateAverageElevation(g)),
                          this.style._updateSources(this.transform),
                          this._forceMarkerAndPopupUpdate())
                        : (b = this._updateAverageElevation(g)),
                      (this._placementDirty =
                        this.style &&
                        this.style._updatePlacement(
                          this.painter.transform,
                          this.showCollisionBoxes,
                          v,
                          this._crossSourceCollisions
                        )),
                      this.style &&
                        this.painter.render(this.style, {
                          showTileBoundaries: this.showTileBoundaries,
                          showTerrainWireframe: this.showTerrainWireframe,
                          showOverdrawInspector: this._showOverdrawInspector,
                          showQueryGeometry: !!this._showQueryGeometry,
                          showTileAABBs: this.showTileAABBs,
                          rotating: this.isRotating(),
                          zooming: this.isZooming(),
                          moving: this.isMoving(),
                          fadeDuration: v,
                          isInitialLoad: this._isInitialLoad,
                          showPadding: this.showPadding,
                          gpuTiming: !!this.listens("gpu-timing-layer"),
                          gpuTimingDeferredRender: !!this.listens(
                            "gpu-timing-deferred-render"
                          ),
                          speedIndexTiming: this.speedIndexTiming,
                        }),
                      this.fire(new d.Event("render")),
                      this.loaded() &&
                        !this._loaded &&
                        ((this._loaded = !0), this.fire(new d.Event("load"))),
                      this.style &&
                        this.style.hasTransitions() &&
                        (this._styleDirty = !0),
                      this.style &&
                        !this._placementDirty &&
                        this.style._releaseSymbolFadeTiles(),
                      a)
                    ) {
                      const I = d.exported.now() - g;
                      u.endQueryEXT(u.TIME_ELAPSED_EXT, a),
                        setTimeout(() => {
                          const M =
                            u.getQueryObjectEXT(a, u.QUERY_RESULT_EXT) / 1e6;
                          u.deleteQueryEXT(a),
                            this.fire(
                              new d.Event("gpu-timing-frame", {
                                cpuTime: I,
                                gpuTime: M,
                              })
                            ),
                            d.window.performance.mark("frame-gpu", {
                              startTime: g,
                              detail: { gpuTime: M },
                            });
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                      const I = this.painter.collectGpuTimers();
                      setTimeout(() => {
                        const M = this.painter.queryGpuTimers(I);
                        this.fire(
                          new d.Event("gpu-timing-layer", { layerTimes: M })
                        );
                      }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                      const I = this.painter.collectDeferredRenderGpuQueries();
                      setTimeout(() => {
                        const M = this.painter.queryGpuTimeDeferredRender(I);
                        this.fire(
                          new d.Event("gpu-timing-deferred-render", {
                            gpuTime: M,
                          })
                        );
                      }, 50);
                    }
                    const D =
                      this._sourcesDirty ||
                      this._styleDirty ||
                      this._placementDirty ||
                      b;
                    if (D || this._repaint) this.triggerRepaint();
                    else {
                      const I = !this.isMoving() && this.loaded();
                      if ((I && (b = this._updateAverageElevation(g, !0)), b))
                        this.triggerRepaint();
                      else if (
                        (this._triggerFrame(!1),
                        I &&
                          (this.fire(new d.Event("idle")),
                          (this._isInitialLoad = !1),
                          this.speedIndexTiming))
                      ) {
                        const M = this._calculateSpeedIndex();
                        this.fire(
                          new d.Event("speedindexcompleted", { speedIndex: M })
                        ),
                          (this.speedIndexTiming = !1);
                      }
                    }
                    !this._loaded ||
                      this._fullyLoaded ||
                      D ||
                      ((this._fullyLoaded = !0),
                      d.LivePerformanceUtils.mark(
                        d.PerformanceMarkers.fullLoad
                      ),
                      this._performanceMetricsCollection &&
                        d.postPerformanceEvent(
                          this._requestManager._customAccessToken,
                          {
                            width: this.painter.width,
                            height: this.painter.height,
                            interactionRange: this._interactionRange,
                            visibilityHidden: this._visibilityHidden,
                            terrainEnabled: !!this.painter.style.getTerrain(),
                            fogEnabled: !!this.painter.style.getFog(),
                            projection: this.getProjection().name,
                            zoom: this.transform.zoom,
                            renderer: this.painter.context.renderer,
                            vendor: this.painter.context.vendor,
                          }
                        ),
                      this._authenticate());
                  }
                  _forceMarkerAndPopupUpdate(f) {
                    for (const a of this._markers)
                      f &&
                        !this.getRenderWorldCopies() &&
                        (a._lngLat = a._lngLat.wrap()),
                        a._update();
                    for (const a of this._popups)
                      !f ||
                        this.getRenderWorldCopies() ||
                        a._trackPointer ||
                        (a._lngLat = a._lngLat.wrap()),
                        a._update();
                  }
                  _updateAverageElevation(f, a = !1) {
                    const u = (g) => (
                      (this.transform.averageElevation = g),
                      this._update(!1),
                      !0
                    );
                    if (!this.painter.averageElevationNeedsEasing())
                      return 0 !== this.transform.averageElevation && u(0);
                    if (
                      (a || f - this._averageElevationLastSampledAt > 500) &&
                      !this._averageElevation.isEasing(f)
                    ) {
                      const g = this.transform.averageElevation;
                      let v = this.transform.sampleAverageElevation(),
                        b = !1;
                      this.transform.elevation &&
                        ((b =
                          this.transform.elevation.exaggeration() !==
                          this._averageElevationExaggeration),
                        (this._averageElevationExaggeration =
                          this.transform.elevation.exaggeration())),
                        isNaN(v)
                          ? (v = 0)
                          : (this._averageElevationLastSampledAt = f);
                      const D = Math.abs(g - v);
                      if (D > 1) {
                        if (this._isInitialLoad || b)
                          return this._averageElevation.jumpTo(v), u(v);
                        this._averageElevation.easeTo(v, f, 300);
                      } else if (D > 1e-4)
                        return this._averageElevation.jumpTo(v), u(v);
                    }
                    return (
                      !!this._averageElevation.isEasing(f) &&
                      u(this._averageElevation.getValue(f))
                    );
                  }
                  _authenticate() {
                    d.getMapSessionAPI(
                      this._getMapId(),
                      this._requestManager._skuToken,
                      this._requestManager._customAccessToken,
                      (f) => {
                        if (
                          f &&
                          (f.message === d.AUTH_ERR_MSG || 401 === f.status)
                        ) {
                          const a = this.painter.context.gl;
                          d.storeAuthState(a, !1),
                            this._logoControl instanceof Pu &&
                              this._logoControl._updateLogo(),
                            a &&
                              a.clear(
                                a.DEPTH_BUFFER_BIT |
                                  a.COLOR_BUFFER_BIT |
                                  a.STENCIL_BUFFER_BIT
                              ),
                            this._silenceAuthErrors ||
                              this.fire(
                                new d.ErrorEvent(
                                  new Error(
                                    "A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/"
                                  )
                                )
                              );
                        }
                      }
                    ),
                      d.postMapLoadEvent(
                        this._getMapId(),
                        this._requestManager._skuToken,
                        this._requestManager._customAccessToken,
                        () => {}
                      );
                  }
                  _updateTerrain() {
                    const f = this._isDragging();
                    this.painter.updateTerrain(this.style, f);
                  }
                  _calculateSpeedIndex() {
                    const f = this.painter.canvasCopy(),
                      a = this.painter.getCanvasCopiesAndTimestamps();
                    a.timeStamps.push(performance.now());
                    const u = this.painter.context.gl,
                      g = u.createFramebuffer();
                    function v(b) {
                      u.framebufferTexture2D(
                        u.FRAMEBUFFER,
                        u.COLOR_ATTACHMENT0,
                        u.TEXTURE_2D,
                        b,
                        0
                      );
                      const D = new Uint8Array(
                        u.drawingBufferWidth * u.drawingBufferHeight * 4
                      );
                      return (
                        u.readPixels(
                          0,
                          0,
                          u.drawingBufferWidth,
                          u.drawingBufferHeight,
                          u.RGBA,
                          u.UNSIGNED_BYTE,
                          D
                        ),
                        D
                      );
                    }
                    return (
                      u.bindFramebuffer(u.FRAMEBUFFER, g),
                      this._canvasPixelComparison(
                        v(f),
                        a.canvasCopies.map(v),
                        a.timeStamps
                      )
                    );
                  }
                  _canvasPixelComparison(f, a, u) {
                    let g = u[1] - u[0];
                    const v = f.length / 4;
                    for (let b = 0; b < a.length; b++) {
                      const D = a[b];
                      let I = 0;
                      for (let M = 0; M < D.length; M += 4)
                        D[M] === f[M] &&
                          D[M + 1] === f[M + 1] &&
                          D[M + 2] === f[M + 2] &&
                          D[M + 3] === f[M + 3] &&
                          (I += 1);
                      g += (u[b + 2] - u[b + 1]) * (1 - I / v);
                    }
                    return g;
                  }
                  remove() {
                    this._hash && this._hash.remove();
                    for (const a of this._controls) a.onRemove(this);
                    (this._controls = []),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this._renderTaskQueue.clear(),
                      this._domRenderTaskQueue.clear(),
                      this.style && this.style.destroy(),
                      this.painter.destroy(),
                      this.handlers && this.handlers.destroy(),
                      (this.handlers = void 0),
                      this.setStyle(null),
                      void 0 !== d.window &&
                        (d.window.removeEventListener(
                          "resize",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.removeEventListener(
                          "orientationchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.removeEventListener(
                          "webkitfullscreenchange",
                          this._onWindowResize,
                          !1
                        ),
                        d.window.removeEventListener(
                          "online",
                          this._onWindowOnline,
                          !1
                        ),
                        d.window.removeEventListener(
                          "visibilitychange",
                          this._onVisibilityChange,
                          !1
                        ));
                    const f =
                      this.painter.context.gl.getExtension(
                        "WEBGL_lose_context"
                      );
                    f && f.loseContext(),
                      this._canvas.removeEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1
                      ),
                      this._canvas.removeEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1
                      ),
                      this._canvasContainer.remove(),
                      this._controlContainer.remove(),
                      this._missingCSSCanary.remove(),
                      (this._canvas = void 0),
                      (this._canvasContainer = void 0),
                      (this._controlContainer = void 0),
                      (this._missingCSSCanary = void 0),
                      this._container.classList.remove("mapboxgl-map"),
                      this._container.removeEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1
                      ),
                      d.removeAuthState(this.painter.context.gl),
                      (this._removed = !0),
                      this.fire(new d.Event("remove"));
                  }
                  triggerRepaint() {
                    this._triggerFrame(!0);
                  }
                  _triggerFrame(f) {
                    (this._renderNextFrame = this._renderNextFrame || f),
                      this.style &&
                        !this._frame &&
                        (this._frame = d.exported.frame((a) => {
                          const u = !!this._renderNextFrame;
                          (this._frame = null),
                            (this._renderNextFrame = null),
                            u && this._render(a);
                        }));
                  }
                  _preloadTiles(f) {
                    const a = this.style
                      ? Object.values(this.style._sourceCaches)
                      : [];
                    return (
                      d.asyncAll(
                        a,
                        (u, g) => u._preloadTiles(f, g),
                        () => {
                          this.triggerRepaint();
                        }
                      ),
                      this
                    );
                  }
                  _onWindowOnline() {
                    this._update();
                  }
                  _onWindowResize(f) {
                    this._trackResize &&
                      this.resize({ originalEvent: f })._update();
                  }
                  _onVisibilityChange() {
                    "hidden" === d.window.document.visibilityState &&
                      this._visibilityHidden++;
                  }
                  get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                  }
                  set showTileBoundaries(f) {
                    this._showTileBoundaries !== f &&
                      ((this._showTileBoundaries = f), this._update());
                  }
                  get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                  }
                  set showTerrainWireframe(f) {
                    this._showTerrainWireframe !== f &&
                      ((this._showTerrainWireframe = f), this._update());
                  }
                  get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                  }
                  set speedIndexTiming(f) {
                    this._speedIndexTiming !== f &&
                      ((this._speedIndexTiming = f), this._update());
                  }
                  get showPadding() {
                    return !!this._showPadding;
                  }
                  set showPadding(f) {
                    this._showPadding !== f &&
                      ((this._showPadding = f), this._update());
                  }
                  get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                  }
                  set showCollisionBoxes(f) {
                    this._showCollisionBoxes !== f &&
                      ((this._showCollisionBoxes = f),
                      f
                        ? this.style._generateCollisionBoxes()
                        : this._update());
                  }
                  get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                  }
                  set showOverdrawInspector(f) {
                    this._showOverdrawInspector !== f &&
                      ((this._showOverdrawInspector = f), this._update());
                  }
                  get repaint() {
                    return !!this._repaint;
                  }
                  set repaint(f) {
                    this._repaint !== f &&
                      ((this._repaint = f), this.triggerRepaint());
                  }
                  get vertices() {
                    return !!this._vertices;
                  }
                  set vertices(f) {
                    (this._vertices = f), this._update();
                  }
                  get showTileAABBs() {
                    return !!this._showTileAABBs;
                  }
                  set showTileAABBs(f) {
                    this._showTileAABBs !== f &&
                      ((this._showTileAABBs = f), f && this._update());
                  }
                  _setCacheLimits(f, a) {
                    d.setCacheLimits(f, a);
                  }
                  get version() {
                    return d.version;
                  }
                },
                NavigationControl: class {
                  constructor(f) {
                    (this.options = d.extend({}, Hf, f)),
                      (this._container = Ot(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group"
                      )),
                      this._container.addEventListener("contextmenu", (a) =>
                        a.preventDefault()
                      ),
                      this.options.showZoom &&
                        (d.bindAll(
                          ["_setButtonTitle", "_updateZoomButtons"],
                          this
                        ),
                        (this._zoomInButton = this._createButton(
                          "mapboxgl-ctrl-zoom-in",
                          (a) => {
                            this._map &&
                              this._map.zoomIn({}, { originalEvent: a });
                          }
                        )),
                        Ot(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomInButton
                        ).setAttribute("aria-hidden", "true"),
                        (this._zoomOutButton = this._createButton(
                          "mapboxgl-ctrl-zoom-out",
                          (a) => {
                            this._map &&
                              this._map.zoomOut({}, { originalEvent: a });
                          }
                        )),
                        Ot(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomOutButton
                        ).setAttribute("aria-hidden", "true")),
                      this.options.showCompass &&
                        (d.bindAll(["_rotateCompassArrow"], this),
                        (this._compass = this._createButton(
                          "mapboxgl-ctrl-compass",
                          (a) => {
                            const u = this._map;
                            u &&
                              (this.options.visualizePitch
                                ? u.resetNorthPitch({}, { originalEvent: a })
                                : u.resetNorth({}, { originalEvent: a }));
                          }
                        )),
                        (this._compassIcon = Ot(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._compass
                        )),
                        this._compassIcon.setAttribute("aria-hidden", "true"));
                  }
                  _updateZoomButtons() {
                    const f = this._map;
                    if (!f) return;
                    const a = f.getZoom(),
                      u = a === f.getMaxZoom(),
                      g = a === f.getMinZoom();
                    (this._zoomInButton.disabled = u),
                      (this._zoomOutButton.disabled = g),
                      this._zoomInButton.setAttribute(
                        "aria-disabled",
                        u.toString()
                      ),
                      this._zoomOutButton.setAttribute(
                        "aria-disabled",
                        g.toString()
                      );
                  }
                  _rotateCompassArrow() {
                    const f = this._map;
                    if (!f) return;
                    const a = this.options.visualizePitch
                      ? `scale(${
                          1 /
                          Math.pow(
                            Math.cos(f.transform.pitch * (Math.PI / 180)),
                            0.5
                          )
                        }) rotateX(${f.transform.pitch}deg) rotateZ(${
                          f.transform.angle * (180 / Math.PI)
                        }deg)`
                      : `rotate(${f.transform.angle * (180 / Math.PI)}deg)`;
                    f._requestDomTask(() => {
                      this._compassIcon &&
                        (this._compassIcon.style.transform = a);
                    });
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      this.options.showZoom &&
                        (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        f.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                      this.options.showCompass &&
                        (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch &&
                          f.on("pitch", this._rotateCompassArrow),
                        f.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        (this._handler = new vp(
                          f,
                          this._compass,
                          this.options.visualizePitch
                        ))),
                      this._container
                    );
                  }
                  onRemove() {
                    const f = this._map;
                    f &&
                      (this._container.remove(),
                      this.options.showZoom &&
                        f.off("zoom", this._updateZoomButtons),
                      this.options.showCompass &&
                        (this.options.visualizePitch &&
                          f.off("pitch", this._rotateCompassArrow),
                        f.off("rotate", this._rotateCompassArrow),
                        this._handler && this._handler.off(),
                        (this._handler = void 0)),
                      (this._map = void 0));
                  }
                  _createButton(f, a) {
                    const u = Ot("button", f, this._container);
                    return (
                      (u.type = "button"), u.addEventListener("click", a), u
                    );
                  }
                  _setButtonTitle(f, a) {
                    if (!this._map) return;
                    const u = this._map._getUIString(`NavigationControl.${a}`);
                    f.setAttribute("aria-label", u),
                      f.firstElementChild &&
                        f.firstElementChild.setAttribute("title", u);
                  }
                },
                GeolocateControl: class extends d.Evented {
                  constructor(f) {
                    super(),
                      (this.options = d.extend(
                        { geolocation: d.window.navigator.geolocation },
                        Mc,
                        f
                      )),
                      d.bindAll(
                        [
                          "_onSuccess",
                          "_onError",
                          "_onZoom",
                          "_finish",
                          "_setupUI",
                          "_updateCamera",
                          "_updateMarker",
                          "_updateMarkerRotation",
                          "_onDeviceOrientation",
                        ],
                        this
                      ),
                      (this._updateMarkerRotationThrottled = Ba(
                        this._updateMarkerRotation,
                        20
                      )),
                      (this._numberOfWatches = 0);
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      (this._container = Ot(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group"
                      )),
                      this._checkGeolocationSupport(this._setupUI),
                      this._container
                    );
                  }
                  onRemove() {
                    void 0 !== this._geolocationWatchID &&
                      (this.options.geolocation.clearWatch(
                        this._geolocationWatchID
                      ),
                      (this._geolocationWatchID = void 0)),
                      this.options.showUserLocation &&
                        this._userLocationDotMarker &&
                        this._userLocationDotMarker.remove(),
                      this.options.showAccuracyCircle &&
                        this._accuracyCircleMarker &&
                        this._accuracyCircleMarker.remove(),
                      this._container.remove(),
                      this._map.off("zoom", this._onZoom),
                      (this._map = void 0),
                      (this._numberOfWatches = 0),
                      (this._noTimeout = !1);
                  }
                  _checkGeolocationSupport(f) {
                    const a = (u = !!this.options.geolocation) => {
                      (this._supportsGeolocation = u), f(u);
                    };
                    void 0 !== this._supportsGeolocation
                      ? f(this._supportsGeolocation)
                      : void 0 !== d.window.navigator.permissions
                      ? d.window.navigator.permissions
                          .query({ name: "geolocation" })
                          .then((u) => a("denied" !== u.state))
                          .catch(() => a())
                      : a();
                  }
                  _isOutOfMapMaxBounds(f) {
                    const a = this._map.getMaxBounds(),
                      u = f.coords;
                    return (
                      !!a &&
                      (u.longitude < a.getWest() ||
                        u.longitude > a.getEast() ||
                        u.latitude < a.getSouth() ||
                        u.latitude > a.getNorth())
                    );
                  }
                  _setErrorState() {
                    switch (this._watchState) {
                      case "WAITING_ACTIVE":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error"
                          );
                        break;
                      case "ACTIVE_LOCK":
                        (this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          );
                        break;
                      case "BACKGROUND":
                        (this._watchState = "BACKGROUND_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background-error"
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          );
                    }
                  }
                  _onSuccess(f) {
                    if (this._map) {
                      if (this._isOutOfMapMaxBounds(f))
                        return (
                          this._setErrorState(),
                          this.fire(new d.Event("outofmaxbounds", f)),
                          this._updateMarker(),
                          void this._finish()
                        );
                      if (this.options.trackUserLocation)
                        switch (
                          ((this._lastKnownPosition = f), this._watchState)
                        ) {
                          case "WAITING_ACTIVE":
                          case "ACTIVE_LOCK":
                          case "ACTIVE_ERROR":
                            (this._watchState = "ACTIVE_LOCK"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting"
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active-error"
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-active"
                              );
                            break;
                          case "BACKGROUND":
                          case "BACKGROUND_ERROR":
                            (this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting"
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-background-error"
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background"
                              );
                        }
                      this.options.showUserLocation &&
                        "OFF" !== this._watchState &&
                        this._updateMarker(f),
                        (this.options.trackUserLocation &&
                          "ACTIVE_LOCK" !== this._watchState) ||
                          this._updateCamera(f),
                        this.options.showUserLocation &&
                          this._dotElement.classList.remove(
                            "mapboxgl-user-location-dot-stale"
                          ),
                        this.fire(new d.Event("geolocate", f)),
                        this._finish();
                    }
                  }
                  _updateCamera(f) {
                    const a = new d.LngLat(
                        f.coords.longitude,
                        f.coords.latitude
                      ),
                      u = f.coords.accuracy,
                      g = this._map.getBearing(),
                      v = d.extend(
                        { bearing: g },
                        this.options.fitBoundsOptions
                      );
                    this._map.fitBounds(a.toBounds(u), v, {
                      geolocateSource: !0,
                    });
                  }
                  _updateMarker(f) {
                    if (f) {
                      const a = new d.LngLat(
                        f.coords.longitude,
                        f.coords.latitude
                      );
                      this._accuracyCircleMarker.setLngLat(a).addTo(this._map),
                        this._userLocationDotMarker
                          .setLngLat(a)
                          .addTo(this._map),
                        (this._accuracy = f.coords.accuracy),
                        this.options.showUserLocation &&
                          this.options.showAccuracyCircle &&
                          this._updateCircleRadius();
                    } else
                      this._userLocationDotMarker.remove(),
                        this._accuracyCircleMarker.remove();
                  }
                  _updateCircleRadius() {
                    const f = this._map.transform,
                      a =
                        d.mercatorZfromAltitude(1, f._center.lat) * f.worldSize,
                      u = Math.ceil(2 * this._accuracy * a);
                    (this._circleElement.style.width = `${u}px`),
                      (this._circleElement.style.height = `${u}px`);
                  }
                  _onZoom() {
                    this.options.showUserLocation &&
                      this.options.showAccuracyCircle &&
                      this._updateCircleRadius();
                  }
                  _updateMarkerRotation() {
                    this._userLocationDotMarker &&
                    "number" == typeof this._heading
                      ? (this._userLocationDotMarker.setRotation(this._heading),
                        this._dotElement.classList.add(
                          "mapboxgl-user-location-show-heading"
                        ))
                      : (this._dotElement.classList.remove(
                          "mapboxgl-user-location-show-heading"
                        ),
                        this._userLocationDotMarker.setRotation(0));
                  }
                  _onError(f) {
                    if (this._map) {
                      if (this.options.trackUserLocation)
                        if (1 === f.code) {
                          (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error"
                            ),
                            (this._geolocateButton.disabled = !0);
                          const a = this._map._getUIString(
                            "GeolocateControl.LocationNotAvailable"
                          );
                          this._geolocateButton.setAttribute("aria-label", a),
                            this._geolocateButton.firstElementChild &&
                              this._geolocateButton.firstElementChild.setAttribute(
                                "title",
                                a
                              ),
                            void 0 !== this._geolocationWatchID &&
                              this._clearWatch();
                        } else {
                          if (3 === f.code && this._noTimeout) return;
                          this._setErrorState();
                        }
                      "OFF" !== this._watchState &&
                        this.options.showUserLocation &&
                        this._dotElement.classList.add(
                          "mapboxgl-user-location-dot-stale"
                        ),
                        this.fire(new d.Event("error", f)),
                        this._finish();
                    }
                  }
                  _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId),
                      (this._timeoutId = void 0);
                  }
                  _setupUI(f) {
                    if (void 0 !== this._map) {
                      if (
                        (this._container.addEventListener("contextmenu", (a) =>
                          a.preventDefault()
                        ),
                        (this._geolocateButton = Ot(
                          "button",
                          "mapboxgl-ctrl-geolocate",
                          this._container
                        )),
                        Ot(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._geolocateButton
                        ).setAttribute("aria-hidden", "true"),
                        (this._geolocateButton.type = "button"),
                        !1 === f)
                      ) {
                        d.warnOnce(
                          "Geolocation support is not available so the GeolocateControl will be disabled."
                        );
                        const a = this._map._getUIString(
                          "GeolocateControl.LocationNotAvailable"
                        );
                        (this._geolocateButton.disabled = !0),
                          this._geolocateButton.setAttribute("aria-label", a),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              a
                            );
                      } else {
                        const a = this._map._getUIString(
                          "GeolocateControl.FindMyLocation"
                        );
                        this._geolocateButton.setAttribute("aria-label", a),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              a
                            );
                      }
                      this.options.trackUserLocation &&
                        (this._geolocateButton.setAttribute(
                          "aria-pressed",
                          "false"
                        ),
                        (this._watchState = "OFF")),
                        this.options.showUserLocation &&
                          ((this._dotElement = Ot(
                            "div",
                            "mapboxgl-user-location"
                          )),
                          this._dotElement.appendChild(
                            Ot("div", "mapboxgl-user-location-dot")
                          ),
                          this._dotElement.appendChild(
                            Ot("div", "mapboxgl-user-location-heading")
                          ),
                          (this._userLocationDotMarker = new ot({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map",
                          })),
                          (this._circleElement = Ot(
                            "div",
                            "mapboxgl-user-location-accuracy-circle"
                          )),
                          (this._accuracyCircleMarker = new ot({
                            element: this._circleElement,
                            pitchAlignment: "map",
                          })),
                          this.options.trackUserLocation &&
                            (this._watchState = "OFF"),
                          this._map.on("zoom", this._onZoom)),
                        this._geolocateButton.addEventListener(
                          "click",
                          this.trigger.bind(this)
                        ),
                        (this._setup = !0),
                        this.options.trackUserLocation &&
                          this._map.on("movestart", (a) => {
                            a.geolocateSource ||
                              "ACTIVE_LOCK" !== this._watchState ||
                              (a.originalEvent &&
                                "resize" === a.originalEvent.type) ||
                              ((this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background"
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active"
                              ),
                              this.fire(new d.Event("trackuserlocationend")));
                          });
                    }
                  }
                  _onDeviceOrientation(f) {
                    this._userLocationDotMarker &&
                      (f.webkitCompassHeading
                        ? (this._heading = f.webkitCompassHeading)
                        : !0 === f.absolute && (this._heading = -1 * f.alpha),
                      this._updateMarkerRotationThrottled());
                  }
                  trigger() {
                    if (!this._setup)
                      return (
                        d.warnOnce(
                          "Geolocate control triggered before added to a map"
                        ),
                        !1
                      );
                    if (this.options.trackUserLocation) {
                      switch (this._watchState) {
                        case "OFF":
                          (this._watchState = "WAITING_ACTIVE"),
                            this.fire(new d.Event("trackuserlocationstart"));
                          break;
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                        case "BACKGROUND_ERROR":
                          this._numberOfWatches--,
                            (this._noTimeout = !1),
                            (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background"
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error"
                            ),
                            this.fire(new d.Event("trackuserlocationend"));
                          break;
                        case "BACKGROUND":
                          (this._watchState = "ACTIVE_LOCK"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background"
                            ),
                            this._lastKnownPosition &&
                              this._updateCamera(this._lastKnownPosition),
                            this.fire(new d.Event("trackuserlocationstart"));
                      }
                      switch (this._watchState) {
                        case "WAITING_ACTIVE":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active"
                            );
                          break;
                        case "ACTIVE_LOCK":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active"
                          );
                          break;
                        case "ACTIVE_ERROR":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active-error"
                            );
                          break;
                        case "BACKGROUND":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background"
                          );
                          break;
                        case "BACKGROUND_ERROR":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting"
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-background-error"
                            );
                      }
                      if (
                        "OFF" === this._watchState &&
                        void 0 !== this._geolocationWatchID
                      )
                        this._clearWatch();
                      else if (void 0 === this._geolocationWatchID) {
                        let f;
                        this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting"
                        ),
                          this._geolocateButton.setAttribute(
                            "aria-pressed",
                            "true"
                          ),
                          this._numberOfWatches++,
                          this._numberOfWatches > 1
                            ? ((f = { maximumAge: 6e5, timeout: 0 }),
                              (this._noTimeout = !0))
                            : ((f = this.options.positionOptions),
                              (this._noTimeout = !1)),
                          (this._geolocationWatchID =
                            this.options.geolocation.watchPosition(
                              this._onSuccess,
                              this._onError,
                              f
                            )),
                          this.options.showUserHeading &&
                            this._addDeviceOrientationListener();
                      }
                    } else
                      this.options.geolocation.getCurrentPosition(
                        this._onSuccess,
                        this._onError,
                        this.options.positionOptions
                      ),
                        (this._timeoutId = setTimeout(this._finish, 1e4));
                    return !0;
                  }
                  _addDeviceOrientationListener() {
                    const f = () => {
                      d.window.addEventListener(
                        "ondeviceorientationabsolute" in d.window
                          ? "deviceorientationabsolute"
                          : "deviceorientation",
                        this._onDeviceOrientation
                      );
                    };
                    void 0 !== d.window.DeviceMotionEvent &&
                    "function" ==
                      typeof d.window.DeviceMotionEvent.requestPermission
                      ? DeviceOrientationEvent.requestPermission()
                          .then((a) => {
                            "granted" === a && f();
                          })
                          .catch(console.error)
                      : f();
                  }
                  _clearWatch() {
                    this.options.geolocation.clearWatch(
                      this._geolocationWatchID
                    ),
                      d.window.removeEventListener(
                        "deviceorientation",
                        this._onDeviceOrientation
                      ),
                      d.window.removeEventListener(
                        "deviceorientationabsolute",
                        this._onDeviceOrientation
                      ),
                      (this._geolocationWatchID = void 0),
                      this._geolocateButton.classList.remove(
                        "mapboxgl-ctrl-geolocate-waiting"
                      ),
                      this._geolocateButton.setAttribute(
                        "aria-pressed",
                        "false"
                      ),
                      this.options.showUserLocation && this._updateMarker(null);
                  }
                },
                AttributionControl: st,
                ScaleControl: class {
                  constructor(f) {
                    (this.options = d.extend({}, Ru, f)),
                      (this._isNumberFormatSupported = (function () {
                        try {
                          return (
                            new Intl.NumberFormat("en", {
                              style: "unit",
                              unitDisplay: "short",
                              unit: "meter",
                            }),
                            !0
                          );
                        } catch {
                          return !1;
                        }
                      })()),
                      d.bindAll(["_update", "_setScale", "setUnit"], this);
                  }
                  getDefaultPosition() {
                    return "bottom-left";
                  }
                  _update() {
                    const f = this.options.maxWidth || 100,
                      a = this._map,
                      u = a._containerHeight / 2,
                      g = a._containerWidth / 2 - f / 2,
                      v = a.unproject([g, u]),
                      b = a.unproject([g + f, u]),
                      D = v.distanceTo(b);
                    if ("imperial" === this.options.unit) {
                      const I = 3.2808 * D;
                      I > 5280
                        ? this._setScale(f, I / 5280, "mile")
                        : this._setScale(f, I, "foot");
                    } else
                      "nautical" === this.options.unit
                        ? this._setScale(f, D / 1852, "nautical-mile")
                        : D >= 1e3
                        ? this._setScale(f, D / 1e3, "kilometer")
                        : this._setScale(f, D, "meter");
                  }
                  _setScale(f, a, u) {
                    this._map._requestDomTask(() => {
                      const g = (function (b) {
                          const D = Math.pow(10, `${Math.floor(b)}`.length - 1);
                          let I = b / D;
                          return (
                            (I =
                              I >= 10
                                ? 10
                                : I >= 5
                                ? 5
                                : I >= 3
                                ? 3
                                : I >= 2
                                ? 2
                                : I >= 1
                                ? 1
                                : (function (M) {
                                    const R = Math.pow(
                                      10,
                                      Math.ceil(-Math.log(M) / Math.LN10)
                                    );
                                    return Math.round(M * R) / R;
                                  })(I)),
                            D * I
                          );
                        })(a),
                        v = g / a;
                      (this._container.innerHTML =
                        this._isNumberFormatSupported && "nautical-mile" !== u
                          ? new Intl.NumberFormat(this._language, {
                              style: "unit",
                              unitDisplay: "short",
                              unit: u,
                            }).format(g)
                          : `${g}&nbsp;${Ou[u]}`),
                        (this._container.style.width = f * v + "px");
                    });
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      (this._language = f.getLanguage()),
                      (this._container = Ot(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-scale",
                        f.getContainer()
                      )),
                      (this._container.dir = "auto"),
                      this._map.on("move", this._update),
                      this._update(),
                      this._container
                    );
                  }
                  onRemove() {
                    this._container.remove(),
                      this._map.off("move", this._update),
                      (this._map = void 0);
                  }
                  _setLanguage(f) {
                    (this._language = f), this._update();
                  }
                  setUnit(f) {
                    (this.options.unit = f), this._update();
                  }
                },
                FullscreenControl: class {
                  constructor(f) {
                    (this._fullscreen = !1),
                      f &&
                        f.container &&
                        (f.container instanceof d.window.HTMLElement
                          ? (this._container = f.container)
                          : d.warnOnce(
                              "Full screen control 'container' must be a DOM element."
                            )),
                      d.bindAll(["_onClickFullscreen", "_changeIcon"], this),
                      "onfullscreenchange" in d.window.document
                        ? (this._fullscreenchange = "fullscreenchange")
                        : "onwebkitfullscreenchange" in d.window.document &&
                          (this._fullscreenchange = "webkitfullscreenchange");
                  }
                  onAdd(f) {
                    return (
                      (this._map = f),
                      this._container ||
                        (this._container = this._map.getContainer()),
                      (this._controlContainer = Ot(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group"
                      )),
                      this._checkFullscreenSupport()
                        ? this._setupUI()
                        : ((this._controlContainer.style.display = "none"),
                          d.warnOnce(
                            "This device does not support fullscreen mode."
                          )),
                      this._controlContainer
                    );
                  }
                  onRemove() {
                    this._controlContainer.remove(),
                      (this._map = null),
                      d.window.document.removeEventListener(
                        this._fullscreenchange,
                        this._changeIcon
                      );
                  }
                  _checkFullscreenSupport() {
                    return !(
                      !d.window.document.fullscreenEnabled &&
                      !d.window.document.webkitFullscreenEnabled
                    );
                  }
                  _setupUI() {
                    const f = (this._fullscreenButton = Ot(
                      "button",
                      "mapboxgl-ctrl-fullscreen",
                      this._controlContainer
                    ));
                    Ot("span", "mapboxgl-ctrl-icon", f).setAttribute(
                      "aria-hidden",
                      "true"
                    ),
                      (f.type = "button"),
                      this._updateTitle(),
                      this._fullscreenButton.addEventListener(
                        "click",
                        this._onClickFullscreen
                      ),
                      d.window.document.addEventListener(
                        this._fullscreenchange,
                        this._changeIcon
                      );
                  }
                  _updateTitle() {
                    const f = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", f),
                      this._fullscreenButton.firstElementChild &&
                        this._fullscreenButton.firstElementChild.setAttribute(
                          "title",
                          f
                        );
                  }
                  _getTitle() {
                    return this._map._getUIString(
                      this._isFullscreen()
                        ? "FullscreenControl.Exit"
                        : "FullscreenControl.Enter"
                    );
                  }
                  _isFullscreen() {
                    return this._fullscreen;
                  }
                  _changeIcon() {
                    ((d.window.document.fullscreenElement ||
                      d.window.document.webkitFullscreenElement) ===
                      this._container) !==
                      this._fullscreen &&
                      ((this._fullscreen = !this._fullscreen),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-shrink"
                      ),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-fullscreen"
                      ),
                      this._updateTitle());
                  }
                  _onClickFullscreen() {
                    this._isFullscreen()
                      ? d.window.document.exitFullscreen
                        ? d.window.document.exitFullscreen()
                        : d.window.document.webkitCancelFullScreen &&
                          d.window.document.webkitCancelFullScreen()
                      : this._container.requestFullscreen
                      ? this._container.requestFullscreen()
                      : this._container.webkitRequestFullscreen &&
                        this._container.webkitRequestFullscreen();
                  }
                },
                Popup: class extends d.Evented {
                  constructor(f) {
                    super(),
                      (this.options = d.extend(Object.create(Qh), f)),
                      d.bindAll(
                        ["_update", "_onClose", "remove", "_onMouseEvent"],
                        this
                      ),
                      (this._classList = new Set(
                        f && f.className ? f.className.trim().split(/\s+/) : []
                      ));
                  }
                  addTo(f) {
                    return (
                      this._map && this.remove(),
                      (this._map = f),
                      this.options.closeOnClick &&
                        f.on("preclick", this._onClose),
                      this.options.closeOnMove && f.on("move", this._onClose),
                      f.on("remove", this.remove),
                      this._update(),
                      f._addPopup(this),
                      this._focusFirstElement(),
                      this._trackPointer
                        ? (f.on("mousemove", this._onMouseEvent),
                          f.on("mouseup", this._onMouseEvent),
                          f._canvasContainer.classList.add(
                            "mapboxgl-track-pointer"
                          ))
                        : f.on("move", this._update),
                      this.fire(new d.Event("open")),
                      this
                    );
                  }
                  isOpen() {
                    return !!this._map;
                  }
                  remove() {
                    this._content && this._content.remove(),
                      this._container &&
                        (this._container.remove(), (this._container = void 0));
                    const f = this._map;
                    return (
                      f &&
                        (f.off("move", this._update),
                        f.off("move", this._onClose),
                        f.off("preclick", this._onClose),
                        f.off("click", this._onClose),
                        f.off("remove", this.remove),
                        f.off("mousemove", this._onMouseEvent),
                        f.off("mouseup", this._onMouseEvent),
                        f.off("drag", this._onMouseEvent),
                        f._canvasContainer &&
                          f._canvasContainer.classList.remove(
                            "mapboxgl-track-pointer"
                          ),
                        f._removePopup(this),
                        (this._map = void 0)),
                      this.fire(new d.Event("close")),
                      this
                    );
                  }
                  getLngLat() {
                    return this._lngLat;
                  }
                  setLngLat(f) {
                    (this._lngLat = d.LngLat.convert(f)),
                      (this._pos = null),
                      (this._trackPointer = !1),
                      this._update();
                    const a = this._map;
                    return (
                      a &&
                        (a.on("move", this._update),
                        a.off("mousemove", this._onMouseEvent),
                        a._canvasContainer.classList.remove(
                          "mapboxgl-track-pointer"
                        )),
                      this
                    );
                  }
                  trackPointer() {
                    (this._trackPointer = !0),
                      (this._pos = null),
                      this._update();
                    const f = this._map;
                    return (
                      f &&
                        (f.off("move", this._update),
                        f.on("mousemove", this._onMouseEvent),
                        f.on("drag", this._onMouseEvent),
                        f._canvasContainer.classList.add(
                          "mapboxgl-track-pointer"
                        )),
                      this
                    );
                  }
                  getElement() {
                    return this._container;
                  }
                  setText(f) {
                    return this.setDOMContent(
                      d.window.document.createTextNode(f)
                    );
                  }
                  setHTML(f) {
                    const a = d.window.document.createDocumentFragment(),
                      u = d.window.document.createElement("body");
                    let g;
                    for (u.innerHTML = f; (g = u.firstChild), g; )
                      a.appendChild(g);
                    return this.setDOMContent(a);
                  }
                  getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                  }
                  setMaxWidth(f) {
                    return (this.options.maxWidth = f), this._update(), this;
                  }
                  setDOMContent(f) {
                    let a = this._content;
                    if (a)
                      for (; a.hasChildNodes(); )
                        a.firstChild && a.removeChild(a.firstChild);
                    else
                      a = this._content = Ot(
                        "div",
                        "mapboxgl-popup-content",
                        this._container || void 0
                      );
                    if ((a.appendChild(f), this.options.closeButton)) {
                      const u = (this._closeButton = Ot(
                        "button",
                        "mapboxgl-popup-close-button",
                        a
                      ));
                      (u.type = "button"),
                        u.setAttribute("aria-label", "Close popup"),
                        u.setAttribute("aria-hidden", "true"),
                        (u.innerHTML = "&#215;"),
                        u.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                  }
                  addClassName(f) {
                    return (
                      this._classList.add(f), this._updateClassList(), this
                    );
                  }
                  removeClassName(f) {
                    return (
                      this._classList.delete(f), this._updateClassList(), this
                    );
                  }
                  setOffset(f) {
                    return (this.options.offset = f), this._update(), this;
                  }
                  toggleClassName(f) {
                    let a;
                    return (
                      this._classList.delete(f)
                        ? (a = !1)
                        : (this._classList.add(f), (a = !0)),
                      this._updateClassList(),
                      a
                    );
                  }
                  _onMouseEvent(f) {
                    this._update(f.point);
                  }
                  _getAnchor(f) {
                    if (this.options.anchor) return this.options.anchor;
                    const a = this._map,
                      u = this._container,
                      g = this._pos;
                    if (!a || !u || !g) return "bottom";
                    const v = u.offsetWidth,
                      b = u.offsetHeight,
                      D = g.x < v / 2,
                      I = g.x > a.transform.width - v / 2;
                    if (g.y + f < b)
                      return D ? "top-left" : I ? "top-right" : "top";
                    if (g.y > a.transform.height - b) {
                      if (D) return "bottom-left";
                      if (I) return "bottom-right";
                    }
                    return D ? "left" : I ? "right" : "bottom";
                  }
                  _updateClassList() {
                    const f = this._container;
                    if (!f) return;
                    const a = [...this._classList];
                    a.push("mapboxgl-popup"),
                      this._anchor &&
                        a.push(`mapboxgl-popup-anchor-${this._anchor}`),
                      this._trackPointer &&
                        a.push("mapboxgl-popup-track-pointer"),
                      (f.className = a.join(" "));
                  }
                  _update(f) {
                    const a = this._map,
                      u = this._content;
                    if (!a || (!this._lngLat && !this._trackPointer) || !u)
                      return;
                    let g = this._container;
                    if (
                      (g ||
                        ((g = this._container =
                          Ot("div", "mapboxgl-popup", a.getContainer())),
                        (this._tip = Ot("div", "mapboxgl-popup-tip", g)),
                        g.appendChild(u)),
                      this.options.maxWidth &&
                        g.style.maxWidth !== this.options.maxWidth &&
                        (g.style.maxWidth = this.options.maxWidth),
                      a.transform.renderWorldCopies &&
                        !this._trackPointer &&
                        (this._lngLat = Rr(
                          this._lngLat,
                          this._pos,
                          a.transform
                        )),
                      !this._trackPointer || f)
                    ) {
                      const v = (this._pos =
                          this._trackPointer && f
                            ? f
                            : a.project(this._lngLat)),
                        b = Lu(this.options.offset),
                        D = (this._anchor = this._getAnchor(b.y)),
                        I = Lu(this.options.offset, D),
                        M = v.add(I).round();
                      a._requestDomTask(() => {
                        this._container &&
                          D &&
                          (this._container.style.transform = `${Ga[D]} translate(${M.x}px,${M.y}px)`);
                      });
                    }
                    if (!this._marker && a._showingGlobe()) {
                      const v = d.isLngLatBehindGlobe(a.transform, this._lngLat)
                        ? 0
                        : 1;
                      this._setOpacity(v);
                    }
                    this._updateClassList();
                  }
                  _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container)
                      return;
                    const f = this._container.querySelector($f);
                    f && f.focus();
                  }
                  _onClose() {
                    this.remove();
                  }
                  _setOpacity(f) {
                    this._container && (this._container.style.opacity = `${f}`),
                      this._content &&
                        (this._content.style.pointerEvents = f
                          ? "auto"
                          : "none");
                  }
                },
                Marker: ot,
                Style: yo,
                LngLat: d.LngLat,
                LngLatBounds: d.LngLatBounds,
                Point: d.Point,
                MercatorCoordinate: d.MercatorCoordinate,
                FreeCameraOptions: Bf,
                Evented: d.Evented,
                config: d.config,
                prewarm: function () {
                  ka().acquire(zo);
                },
                clearPrewarmedResources: function () {
                  const f = fr;
                  f &&
                    (f.isPreloaded() && 1 === f.numActive()
                      ? (f.release(zo), (fr = null))
                      : console.warn(
                          "Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"
                        ));
                },
                get accessToken() {
                  return d.config.ACCESS_TOKEN;
                },
                set accessToken(f) {
                  d.config.ACCESS_TOKEN = f;
                },
                get baseApiUrl() {
                  return d.config.API_URL;
                },
                set baseApiUrl(f) {
                  d.config.API_URL = f;
                },
                get workerCount() {
                  return qn.workerCount;
                },
                set workerCount(f) {
                  qn.workerCount = f;
                },
                get maxParallelImageRequests() {
                  return d.config.MAX_PARALLEL_IMAGE_REQUESTS;
                },
                set maxParallelImageRequests(f) {
                  d.config.MAX_PARALLEL_IMAGE_REQUESTS = f;
                },
                clearStorage(f) {
                  d.clearTileCache(f);
                },
                workerUrl: "",
                workerClass: null,
                setNow: d.exported.setNow,
                restoreNow: d.exported.restoreNow,
              };
            return qa;
          }),
          li
        );
      })();
    },
  },
  (Af) => {
    Af((Af.s = 196));
  },
]);
